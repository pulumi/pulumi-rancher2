# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CloudCredentialAmazonec2CredentialConfigArgs',
    'CloudCredentialAmazonec2CredentialConfigArgsDict',
    'CloudCredentialAzureCredentialConfigArgs',
    'CloudCredentialAzureCredentialConfigArgsDict',
    'CloudCredentialDigitaloceanCredentialConfigArgs',
    'CloudCredentialDigitaloceanCredentialConfigArgsDict',
    'CloudCredentialGoogleCredentialConfigArgs',
    'CloudCredentialGoogleCredentialConfigArgsDict',
    'CloudCredentialHarvesterCredentialConfigArgs',
    'CloudCredentialHarvesterCredentialConfigArgsDict',
    'CloudCredentialLinodeCredentialConfigArgs',
    'CloudCredentialLinodeCredentialConfigArgsDict',
    'CloudCredentialOpenstackCredentialConfigArgs',
    'CloudCredentialOpenstackCredentialConfigArgsDict',
    'CloudCredentialS3CredentialConfigArgs',
    'CloudCredentialS3CredentialConfigArgsDict',
    'CloudCredentialVsphereCredentialConfigArgs',
    'CloudCredentialVsphereCredentialConfigArgsDict',
    'ClusterAgentEnvVarArgs',
    'ClusterAgentEnvVarArgsDict',
    'ClusterAksConfigArgs',
    'ClusterAksConfigArgsDict',
    'ClusterAksConfigV2Args',
    'ClusterAksConfigV2ArgsDict',
    'ClusterAksConfigV2NodePoolArgs',
    'ClusterAksConfigV2NodePoolArgsDict',
    'ClusterClusterAgentDeploymentCustomizationArgs',
    'ClusterClusterAgentDeploymentCustomizationArgsDict',
    'ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs',
    'ClusterClusterAgentDeploymentCustomizationAppendTolerationArgsDict',
    'ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs',
    'ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict',
    'ClusterClusterAuthEndpointArgs',
    'ClusterClusterAuthEndpointArgsDict',
    'ClusterClusterRegistrationTokenArgs',
    'ClusterClusterRegistrationTokenArgsDict',
    'ClusterClusterTemplateAnswersArgs',
    'ClusterClusterTemplateAnswersArgsDict',
    'ClusterClusterTemplateQuestionArgs',
    'ClusterClusterTemplateQuestionArgsDict',
    'ClusterEksConfigArgs',
    'ClusterEksConfigArgsDict',
    'ClusterEksConfigV2Args',
    'ClusterEksConfigV2ArgsDict',
    'ClusterEksConfigV2NodeGroupArgs',
    'ClusterEksConfigV2NodeGroupArgsDict',
    'ClusterEksConfigV2NodeGroupLaunchTemplateArgs',
    'ClusterEksConfigV2NodeGroupLaunchTemplateArgsDict',
    'ClusterFleetAgentDeploymentCustomizationArgs',
    'ClusterFleetAgentDeploymentCustomizationArgsDict',
    'ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs',
    'ClusterFleetAgentDeploymentCustomizationAppendTolerationArgsDict',
    'ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs',
    'ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict',
    'ClusterGkeConfigArgs',
    'ClusterGkeConfigArgsDict',
    'ClusterGkeConfigV2Args',
    'ClusterGkeConfigV2ArgsDict',
    'ClusterGkeConfigV2ClusterAddonsArgs',
    'ClusterGkeConfigV2ClusterAddonsArgsDict',
    'ClusterGkeConfigV2IpAllocationPolicyArgs',
    'ClusterGkeConfigV2IpAllocationPolicyArgsDict',
    'ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs',
    'ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgsDict',
    'ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs',
    'ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgsDict',
    'ClusterGkeConfigV2NodePoolArgs',
    'ClusterGkeConfigV2NodePoolArgsDict',
    'ClusterGkeConfigV2NodePoolAutoscalingArgs',
    'ClusterGkeConfigV2NodePoolAutoscalingArgsDict',
    'ClusterGkeConfigV2NodePoolConfigArgs',
    'ClusterGkeConfigV2NodePoolConfigArgsDict',
    'ClusterGkeConfigV2NodePoolConfigTaintArgs',
    'ClusterGkeConfigV2NodePoolConfigTaintArgsDict',
    'ClusterGkeConfigV2NodePoolManagementArgs',
    'ClusterGkeConfigV2NodePoolManagementArgsDict',
    'ClusterGkeConfigV2PrivateClusterConfigArgs',
    'ClusterGkeConfigV2PrivateClusterConfigArgsDict',
    'ClusterK3sConfigArgs',
    'ClusterK3sConfigArgsDict',
    'ClusterK3sConfigUpgradeStrategyArgs',
    'ClusterK3sConfigUpgradeStrategyArgsDict',
    'ClusterOkeConfigArgs',
    'ClusterOkeConfigArgsDict',
    'ClusterRke2ConfigArgs',
    'ClusterRke2ConfigArgsDict',
    'ClusterRke2ConfigUpgradeStrategyArgs',
    'ClusterRke2ConfigUpgradeStrategyArgsDict',
    'ClusterRkeConfigArgs',
    'ClusterRkeConfigArgsDict',
    'ClusterRkeConfigAuthenticationArgs',
    'ClusterRkeConfigAuthenticationArgsDict',
    'ClusterRkeConfigAuthorizationArgs',
    'ClusterRkeConfigAuthorizationArgsDict',
    'ClusterRkeConfigBastionHostArgs',
    'ClusterRkeConfigBastionHostArgsDict',
    'ClusterRkeConfigCloudProviderArgs',
    'ClusterRkeConfigCloudProviderArgsDict',
    'ClusterRkeConfigCloudProviderAwsCloudProviderArgs',
    'ClusterRkeConfigCloudProviderAwsCloudProviderArgsDict',
    'ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs',
    'ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict',
    'ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs',
    'ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict',
    'ClusterRkeConfigCloudProviderAzureCloudProviderArgs',
    'ClusterRkeConfigCloudProviderAzureCloudProviderArgsDict',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderArgsDict',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderArgs',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderArgsDict',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict',
    'ClusterRkeConfigDnsArgs',
    'ClusterRkeConfigDnsArgsDict',
    'ClusterRkeConfigDnsLinearAutoscalerParamsArgs',
    'ClusterRkeConfigDnsLinearAutoscalerParamsArgsDict',
    'ClusterRkeConfigDnsNodelocalArgs',
    'ClusterRkeConfigDnsNodelocalArgsDict',
    'ClusterRkeConfigDnsTolerationArgs',
    'ClusterRkeConfigDnsTolerationArgsDict',
    'ClusterRkeConfigDnsUpdateStrategyArgs',
    'ClusterRkeConfigDnsUpdateStrategyArgsDict',
    'ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs',
    'ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgsDict',
    'ClusterRkeConfigIngressArgs',
    'ClusterRkeConfigIngressArgsDict',
    'ClusterRkeConfigIngressTolerationArgs',
    'ClusterRkeConfigIngressTolerationArgsDict',
    'ClusterRkeConfigIngressUpdateStrategyArgs',
    'ClusterRkeConfigIngressUpdateStrategyArgsDict',
    'ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs',
    'ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgsDict',
    'ClusterRkeConfigMonitoringArgs',
    'ClusterRkeConfigMonitoringArgsDict',
    'ClusterRkeConfigMonitoringTolerationArgs',
    'ClusterRkeConfigMonitoringTolerationArgsDict',
    'ClusterRkeConfigMonitoringUpdateStrategyArgs',
    'ClusterRkeConfigMonitoringUpdateStrategyArgsDict',
    'ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs',
    'ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict',
    'ClusterRkeConfigNetworkArgs',
    'ClusterRkeConfigNetworkArgsDict',
    'ClusterRkeConfigNetworkAciNetworkProviderArgs',
    'ClusterRkeConfigNetworkAciNetworkProviderArgsDict',
    'ClusterRkeConfigNetworkCalicoNetworkProviderArgs',
    'ClusterRkeConfigNetworkCalicoNetworkProviderArgsDict',
    'ClusterRkeConfigNetworkCanalNetworkProviderArgs',
    'ClusterRkeConfigNetworkCanalNetworkProviderArgsDict',
    'ClusterRkeConfigNetworkFlannelNetworkProviderArgs',
    'ClusterRkeConfigNetworkFlannelNetworkProviderArgsDict',
    'ClusterRkeConfigNetworkTolerationArgs',
    'ClusterRkeConfigNetworkTolerationArgsDict',
    'ClusterRkeConfigNetworkWeaveNetworkProviderArgs',
    'ClusterRkeConfigNetworkWeaveNetworkProviderArgsDict',
    'ClusterRkeConfigNodeArgs',
    'ClusterRkeConfigNodeArgsDict',
    'ClusterRkeConfigPrivateRegistryArgs',
    'ClusterRkeConfigPrivateRegistryArgsDict',
    'ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs',
    'ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgsDict',
    'ClusterRkeConfigServicesArgs',
    'ClusterRkeConfigServicesArgsDict',
    'ClusterRkeConfigServicesEtcdArgs',
    'ClusterRkeConfigServicesEtcdArgsDict',
    'ClusterRkeConfigServicesEtcdBackupConfigArgs',
    'ClusterRkeConfigServicesEtcdBackupConfigArgsDict',
    'ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs',
    'ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict',
    'ClusterRkeConfigServicesKubeApiArgs',
    'ClusterRkeConfigServicesKubeApiArgsDict',
    'ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs',
    'ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgsDict',
    'ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs',
    'ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict',
    'ClusterRkeConfigServicesKubeApiAuditLogArgs',
    'ClusterRkeConfigServicesKubeApiAuditLogArgsDict',
    'ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs',
    'ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgsDict',
    'ClusterRkeConfigServicesKubeApiEventRateLimitArgs',
    'ClusterRkeConfigServicesKubeApiEventRateLimitArgsDict',
    'ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs',
    'ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict',
    'ClusterRkeConfigServicesKubeControllerArgs',
    'ClusterRkeConfigServicesKubeControllerArgsDict',
    'ClusterRkeConfigServicesKubeletArgs',
    'ClusterRkeConfigServicesKubeletArgsDict',
    'ClusterRkeConfigServicesKubeproxyArgs',
    'ClusterRkeConfigServicesKubeproxyArgsDict',
    'ClusterRkeConfigServicesSchedulerArgs',
    'ClusterRkeConfigServicesSchedulerArgsDict',
    'ClusterRkeConfigUpgradeStrategyArgs',
    'ClusterRkeConfigUpgradeStrategyArgsDict',
    'ClusterRkeConfigUpgradeStrategyDrainInputArgs',
    'ClusterRkeConfigUpgradeStrategyDrainInputArgsDict',
    'ClusterSyncNodeArgs',
    'ClusterSyncNodeArgsDict',
    'ClusterTemplateMemberArgs',
    'ClusterTemplateMemberArgsDict',
    'ClusterTemplateTemplateRevisionArgs',
    'ClusterTemplateTemplateRevisionArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigArgs',
    'ClusterTemplateTemplateRevisionClusterConfigArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs',
    'ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgsDict',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgs',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgsDict',
    'ClusterTemplateTemplateRevisionQuestionArgs',
    'ClusterTemplateTemplateRevisionQuestionArgsDict',
    'ClusterV2AgentEnvVarArgs',
    'ClusterV2AgentEnvVarArgsDict',
    'ClusterV2ClusterAgentDeploymentCustomizationArgs',
    'ClusterV2ClusterAgentDeploymentCustomizationArgsDict',
    'ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs',
    'ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgsDict',
    'ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs',
    'ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict',
    'ClusterV2ClusterRegistrationTokenArgs',
    'ClusterV2ClusterRegistrationTokenArgsDict',
    'ClusterV2FleetAgentDeploymentCustomizationArgs',
    'ClusterV2FleetAgentDeploymentCustomizationArgsDict',
    'ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs',
    'ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgsDict',
    'ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs',
    'ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict',
    'ClusterV2LocalAuthEndpointArgs',
    'ClusterV2LocalAuthEndpointArgsDict',
    'ClusterV2RkeConfigArgs',
    'ClusterV2RkeConfigArgsDict',
    'ClusterV2RkeConfigEtcdArgs',
    'ClusterV2RkeConfigEtcdArgsDict',
    'ClusterV2RkeConfigEtcdS3ConfigArgs',
    'ClusterV2RkeConfigEtcdS3ConfigArgsDict',
    'ClusterV2RkeConfigEtcdSnapshotCreateArgs',
    'ClusterV2RkeConfigEtcdSnapshotCreateArgsDict',
    'ClusterV2RkeConfigEtcdSnapshotRestoreArgs',
    'ClusterV2RkeConfigEtcdSnapshotRestoreArgsDict',
    'ClusterV2RkeConfigLocalAuthEndpointArgs',
    'ClusterV2RkeConfigLocalAuthEndpointArgsDict',
    'ClusterV2RkeConfigMachinePoolArgs',
    'ClusterV2RkeConfigMachinePoolArgsDict',
    'ClusterV2RkeConfigMachinePoolDefaultArgs',
    'ClusterV2RkeConfigMachinePoolDefaultArgsDict',
    'ClusterV2RkeConfigMachinePoolMachineConfigArgs',
    'ClusterV2RkeConfigMachinePoolMachineConfigArgsDict',
    'ClusterV2RkeConfigMachinePoolRollingUpdateArgs',
    'ClusterV2RkeConfigMachinePoolRollingUpdateArgsDict',
    'ClusterV2RkeConfigMachinePoolTaintArgs',
    'ClusterV2RkeConfigMachinePoolTaintArgsDict',
    'ClusterV2RkeConfigMachineSelectorConfigArgs',
    'ClusterV2RkeConfigMachineSelectorConfigArgsDict',
    'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs',
    'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgsDict',
    'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs',
    'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileArgs',
    'ClusterV2RkeConfigMachineSelectorFileArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceArgs',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs',
    'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgsDict',
    'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs',
    'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgsDict',
    'ClusterV2RkeConfigRegistriesArgs',
    'ClusterV2RkeConfigRegistriesArgsDict',
    'ClusterV2RkeConfigRegistriesConfigArgs',
    'ClusterV2RkeConfigRegistriesConfigArgsDict',
    'ClusterV2RkeConfigRegistriesMirrorArgs',
    'ClusterV2RkeConfigRegistriesMirrorArgsDict',
    'ClusterV2RkeConfigRotateCertificatesArgs',
    'ClusterV2RkeConfigRotateCertificatesArgsDict',
    'ClusterV2RkeConfigUpgradeStrategyArgs',
    'ClusterV2RkeConfigUpgradeStrategyArgsDict',
    'ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs',
    'ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgsDict',
    'ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs',
    'ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgsDict',
    'EtcdBackupBackupConfigArgs',
    'EtcdBackupBackupConfigArgsDict',
    'EtcdBackupBackupConfigS3BackupConfigArgs',
    'EtcdBackupBackupConfigS3BackupConfigArgsDict',
    'GlobalRoleRuleArgs',
    'GlobalRoleRuleArgsDict',
    'MachineConfigV2Amazonec2ConfigArgs',
    'MachineConfigV2Amazonec2ConfigArgsDict',
    'MachineConfigV2AzureConfigArgs',
    'MachineConfigV2AzureConfigArgsDict',
    'MachineConfigV2DigitaloceanConfigArgs',
    'MachineConfigV2DigitaloceanConfigArgsDict',
    'MachineConfigV2HarvesterConfigArgs',
    'MachineConfigV2HarvesterConfigArgsDict',
    'MachineConfigV2LinodeConfigArgs',
    'MachineConfigV2LinodeConfigArgsDict',
    'MachineConfigV2OpenstackConfigArgs',
    'MachineConfigV2OpenstackConfigArgsDict',
    'MachineConfigV2VsphereConfigArgs',
    'MachineConfigV2VsphereConfigArgsDict',
    'MultiClusterAppAnswerArgs',
    'MultiClusterAppAnswerArgsDict',
    'MultiClusterAppMemberArgs',
    'MultiClusterAppMemberArgsDict',
    'MultiClusterAppTargetArgs',
    'MultiClusterAppTargetArgsDict',
    'MultiClusterAppUpgradeStrategyArgs',
    'MultiClusterAppUpgradeStrategyArgsDict',
    'MultiClusterAppUpgradeStrategyRollingUpdateArgs',
    'MultiClusterAppUpgradeStrategyRollingUpdateArgsDict',
    'NamespaceContainerResourceLimitArgs',
    'NamespaceContainerResourceLimitArgsDict',
    'NamespaceResourceQuotaArgs',
    'NamespaceResourceQuotaArgsDict',
    'NamespaceResourceQuotaLimitArgs',
    'NamespaceResourceQuotaLimitArgsDict',
    'NodePoolNodeTaintArgs',
    'NodePoolNodeTaintArgsDict',
    'NodeTemplateAmazonec2ConfigArgs',
    'NodeTemplateAmazonec2ConfigArgsDict',
    'NodeTemplateAzureConfigArgs',
    'NodeTemplateAzureConfigArgsDict',
    'NodeTemplateDigitaloceanConfigArgs',
    'NodeTemplateDigitaloceanConfigArgsDict',
    'NodeTemplateHarvesterConfigArgs',
    'NodeTemplateHarvesterConfigArgsDict',
    'NodeTemplateHetznerConfigArgs',
    'NodeTemplateHetznerConfigArgsDict',
    'NodeTemplateLinodeConfigArgs',
    'NodeTemplateLinodeConfigArgsDict',
    'NodeTemplateNodeTaintArgs',
    'NodeTemplateNodeTaintArgsDict',
    'NodeTemplateOpennebulaConfigArgs',
    'NodeTemplateOpennebulaConfigArgsDict',
    'NodeTemplateOpenstackConfigArgs',
    'NodeTemplateOpenstackConfigArgsDict',
    'NodeTemplateOutscaleConfigArgs',
    'NodeTemplateOutscaleConfigArgsDict',
    'NodeTemplateVsphereConfigArgs',
    'NodeTemplateVsphereConfigArgsDict',
    'PodSecurityAdmissionConfigurationTemplateDefaultsArgs',
    'PodSecurityAdmissionConfigurationTemplateDefaultsArgsDict',
    'PodSecurityAdmissionConfigurationTemplateExemptionsArgs',
    'PodSecurityAdmissionConfigurationTemplateExemptionsArgsDict',
    'ProjectContainerResourceLimitArgs',
    'ProjectContainerResourceLimitArgsDict',
    'ProjectResourceQuotaArgs',
    'ProjectResourceQuotaArgsDict',
    'ProjectResourceQuotaNamespaceDefaultLimitArgs',
    'ProjectResourceQuotaNamespaceDefaultLimitArgsDict',
    'ProjectResourceQuotaProjectLimitArgs',
    'ProjectResourceQuotaProjectLimitArgsDict',
    'RegistryRegistryArgs',
    'RegistryRegistryArgsDict',
    'RoleTemplateExternalRuleArgs',
    'RoleTemplateExternalRuleArgsDict',
    'RoleTemplateRuleArgs',
    'RoleTemplateRuleArgsDict',
    'GetRoleTemplateExternalRuleArgs',
    'GetRoleTemplateExternalRuleArgsDict',
]

MYPY = False

if not MYPY:
    class CloudCredentialAmazonec2CredentialConfigArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        AWS Access Key
        """
        secret_key: pulumi.Input[str]
        """
        AWS Secret Key
        """
        default_region: NotRequired[pulumi.Input[str]]
        """
        AWS default region
        """
elif False:
    CloudCredentialAmazonec2CredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialAmazonec2CredentialConfigArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 default_region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: AWS Access Key
        :param pulumi.Input[str] secret_key: AWS Secret Key
        :param pulumi.Input[str] default_region: AWS default region
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if default_region is not None:
            pulumi.set(__self__, "default_region", default_region)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="defaultRegion")
    def default_region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS default region
        """
        return pulumi.get(self, "default_region")

    @default_region.setter
    def default_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_region", value)


if not MYPY:
    class CloudCredentialAzureCredentialConfigArgsDict(TypedDict):
        client_id: pulumi.Input[str]
        """
        Azure Service Principal Account ID
        """
        client_secret: pulumi.Input[str]
        """
        Azure Service Principal Account password
        """
        subscription_id: pulumi.Input[str]
        """
        Azure Subscription ID
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        Azure Tenant ID
        """
elif False:
    CloudCredentialAzureCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialAzureCredentialConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 environment: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: Azure Service Principal Account ID
        :param pulumi.Input[str] client_secret: Azure Service Principal Account password
        :param pulumi.Input[str] subscription_id: Azure Subscription ID
        :param pulumi.Input[str] environment: Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        :param pulumi.Input[str] tenant_id: Azure Tenant ID
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Azure Service Principal Account ID
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Azure Service Principal Account password
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        Azure Subscription ID
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class CloudCredentialDigitaloceanCredentialConfigArgsDict(TypedDict):
        access_token: pulumi.Input[str]
        """
        Digital Ocean access token
        """
elif False:
    CloudCredentialDigitaloceanCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialDigitaloceanCredentialConfigArgs:
    def __init__(__self__, *,
                 access_token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] access_token: Digital Ocean access token
        """
        pulumi.set(__self__, "access_token", access_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> pulumi.Input[str]:
        """
        Digital Ocean access token
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_token", value)


if not MYPY:
    class CloudCredentialGoogleCredentialConfigArgsDict(TypedDict):
        auth_encoded_json: pulumi.Input[str]
        """
        Google auth encoded json
        """
elif False:
    CloudCredentialGoogleCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialGoogleCredentialConfigArgs:
    def __init__(__self__, *,
                 auth_encoded_json: pulumi.Input[str]):
        """
        :param pulumi.Input[str] auth_encoded_json: Google auth encoded json
        """
        pulumi.set(__self__, "auth_encoded_json", auth_encoded_json)

    @property
    @pulumi.getter(name="authEncodedJson")
    def auth_encoded_json(self) -> pulumi.Input[str]:
        """
        Google auth encoded json
        """
        return pulumi.get(self, "auth_encoded_json")

    @auth_encoded_json.setter
    def auth_encoded_json(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_encoded_json", value)


if not MYPY:
    class CloudCredentialHarvesterCredentialConfigArgsDict(TypedDict):
        cluster_type: pulumi.Input[str]
        """
        Harvester cluster type. must be imported or external
        """
        kubeconfig_content: pulumi.Input[str]
        """
        Harvester cluster kubeconfig content
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        The cluster id of imported Harvester cluster
        """
elif False:
    CloudCredentialHarvesterCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialHarvesterCredentialConfigArgs:
    def __init__(__self__, *,
                 cluster_type: pulumi.Input[str],
                 kubeconfig_content: pulumi.Input[str],
                 cluster_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_type: Harvester cluster type. must be imported or external
        :param pulumi.Input[str] kubeconfig_content: Harvester cluster kubeconfig content
        :param pulumi.Input[str] cluster_id: The cluster id of imported Harvester cluster
        """
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "kubeconfig_content", kubeconfig_content)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)

    @property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> pulumi.Input[str]:
        """
        Harvester cluster type. must be imported or external
        """
        return pulumi.get(self, "cluster_type")

    @cluster_type.setter
    def cluster_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_type", value)

    @property
    @pulumi.getter(name="kubeconfigContent")
    def kubeconfig_content(self) -> pulumi.Input[str]:
        """
        Harvester cluster kubeconfig content
        """
        return pulumi.get(self, "kubeconfig_content")

    @kubeconfig_content.setter
    def kubeconfig_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "kubeconfig_content", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster id of imported Harvester cluster
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)


if not MYPY:
    class CloudCredentialLinodeCredentialConfigArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Linode API token
        """
elif False:
    CloudCredentialLinodeCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialLinodeCredentialConfigArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Linode API token
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Linode API token
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class CloudCredentialOpenstackCredentialConfigArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        OpenStack password
        """
elif False:
    CloudCredentialOpenstackCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialOpenstackCredentialConfigArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: OpenStack password
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        OpenStack password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class CloudCredentialS3CredentialConfigArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        AWS Access Key
        """
        secret_key: pulumi.Input[str]
        """
        AWS Secret Key
        """
        default_bucket: NotRequired[pulumi.Input[str]]
        """
        AWS default bucket
        """
        default_endpoint: NotRequired[pulumi.Input[str]]
        """
        AWS default endpoint
        """
        default_endpoint_ca: NotRequired[pulumi.Input[str]]
        """
        AWS default endpoint CA
        """
        default_folder: NotRequired[pulumi.Input[str]]
        """
        AWS default folder
        """
        default_region: NotRequired[pulumi.Input[str]]
        """
        AWS default region
        """
        default_skip_ssl_verify: NotRequired[pulumi.Input[bool]]
        """
        AWS default skip ssl verify
        """
elif False:
    CloudCredentialS3CredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialS3CredentialConfigArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 default_bucket: Optional[pulumi.Input[str]] = None,
                 default_endpoint: Optional[pulumi.Input[str]] = None,
                 default_endpoint_ca: Optional[pulumi.Input[str]] = None,
                 default_folder: Optional[pulumi.Input[str]] = None,
                 default_region: Optional[pulumi.Input[str]] = None,
                 default_skip_ssl_verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] access_key: AWS Access Key
        :param pulumi.Input[str] secret_key: AWS Secret Key
        :param pulumi.Input[str] default_bucket: AWS default bucket
        :param pulumi.Input[str] default_endpoint: AWS default endpoint
        :param pulumi.Input[str] default_endpoint_ca: AWS default endpoint CA
        :param pulumi.Input[str] default_folder: AWS default folder
        :param pulumi.Input[str] default_region: AWS default region
        :param pulumi.Input[bool] default_skip_ssl_verify: AWS default skip ssl verify
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if default_bucket is not None:
            pulumi.set(__self__, "default_bucket", default_bucket)
        if default_endpoint is not None:
            pulumi.set(__self__, "default_endpoint", default_endpoint)
        if default_endpoint_ca is not None:
            pulumi.set(__self__, "default_endpoint_ca", default_endpoint_ca)
        if default_folder is not None:
            pulumi.set(__self__, "default_folder", default_folder)
        if default_region is not None:
            pulumi.set(__self__, "default_region", default_region)
        if default_skip_ssl_verify is not None:
            pulumi.set(__self__, "default_skip_ssl_verify", default_skip_ssl_verify)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="defaultBucket")
    def default_bucket(self) -> Optional[pulumi.Input[str]]:
        """
        AWS default bucket
        """
        return pulumi.get(self, "default_bucket")

    @default_bucket.setter
    def default_bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_bucket", value)

    @property
    @pulumi.getter(name="defaultEndpoint")
    def default_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        AWS default endpoint
        """
        return pulumi.get(self, "default_endpoint")

    @default_endpoint.setter
    def default_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_endpoint", value)

    @property
    @pulumi.getter(name="defaultEndpointCa")
    def default_endpoint_ca(self) -> Optional[pulumi.Input[str]]:
        """
        AWS default endpoint CA
        """
        return pulumi.get(self, "default_endpoint_ca")

    @default_endpoint_ca.setter
    def default_endpoint_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_endpoint_ca", value)

    @property
    @pulumi.getter(name="defaultFolder")
    def default_folder(self) -> Optional[pulumi.Input[str]]:
        """
        AWS default folder
        """
        return pulumi.get(self, "default_folder")

    @default_folder.setter
    def default_folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_folder", value)

    @property
    @pulumi.getter(name="defaultRegion")
    def default_region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS default region
        """
        return pulumi.get(self, "default_region")

    @default_region.setter
    def default_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_region", value)

    @property
    @pulumi.getter(name="defaultSkipSslVerify")
    def default_skip_ssl_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        AWS default skip ssl verify
        """
        return pulumi.get(self, "default_skip_ssl_verify")

    @default_skip_ssl_verify.setter
    def default_skip_ssl_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default_skip_ssl_verify", value)


if not MYPY:
    class CloudCredentialVsphereCredentialConfigArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        vSphere password
        """
        username: pulumi.Input[str]
        """
        vSphere username
        """
        vcenter: pulumi.Input[str]
        """
        vSphere IP/hostname for vCenter
        """
        vcenter_port: NotRequired[pulumi.Input[str]]
        """
        vSphere Port for vCenter
        """
elif False:
    CloudCredentialVsphereCredentialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudCredentialVsphereCredentialConfigArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 vcenter: pulumi.Input[str],
                 vcenter_port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: vSphere password
        :param pulumi.Input[str] username: vSphere username
        :param pulumi.Input[str] vcenter: vSphere IP/hostname for vCenter
        :param pulumi.Input[str] vcenter_port: vSphere Port for vCenter
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "vcenter", vcenter)
        if vcenter_port is not None:
            pulumi.set(__self__, "vcenter_port", vcenter_port)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        vSphere password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        vSphere username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def vcenter(self) -> pulumi.Input[str]:
        """
        vSphere IP/hostname for vCenter
        """
        return pulumi.get(self, "vcenter")

    @vcenter.setter
    def vcenter(self, value: pulumi.Input[str]):
        pulumi.set(self, "vcenter", value)

    @property
    @pulumi.getter(name="vcenterPort")
    def vcenter_port(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere Port for vCenter
        """
        return pulumi.get(self, "vcenter_port")

    @vcenter_port.setter
    def vcenter_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter_port", value)


if not MYPY:
    class ClusterAgentEnvVarArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Cluster (string)
        """
        value: pulumi.Input[str]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterAgentEnvVarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAgentEnvVarArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterAksConfigArgsDict(TypedDict):
        agent_dns_prefix: pulumi.Input[str]
        """
        DNS prefix to be used to create the FQDN for the agent pool
        """
        client_id: pulumi.Input[str]
        """
        Azure client ID to use
        """
        client_secret: pulumi.Input[str]
        """
        Azure client secret associated with the "client id"
        """
        kubernetes_version: pulumi.Input[str]
        """
        Specify the version of Kubernetes
        """
        master_dns_prefix: pulumi.Input[str]
        """
        DNS prefix to use the Kubernetes cluster control pane
        """
        resource_group: pulumi.Input[str]
        """
        The name of the Cluster resource group
        """
        ssh_public_key_contents: pulumi.Input[str]
        """
        Contents of the SSH public key used to authenticate with Linux hosts
        """
        subnet: pulumi.Input[str]
        """
        The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
        """
        subscription_id: pulumi.Input[str]
        """
        Subscription credentials which uniquely identify Microsoft Azure subscription
        """
        tenant_id: pulumi.Input[str]
        """
        Azure tenant ID to use
        """
        virtual_network: pulumi.Input[str]
        """
        The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
        """
        virtual_network_resource_group: pulumi.Input[str]
        """
        The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
        """
        aad_server_app_secret: NotRequired[pulumi.Input[str]]
        """
        The secret of an Azure Active Directory server application
        """
        aad_tenant_id: NotRequired[pulumi.Input[str]]
        """
        The ID of an Azure Active Directory tenant
        """
        add_client_app_id: NotRequired[pulumi.Input[str]]
        """
        The ID of an Azure Active Directory client application of type "Native". This application is for user login via kubectl
        """
        add_server_app_id: NotRequired[pulumi.Input[str]]
        """
        The ID of an Azure Active Directory server application of type "Web app/API". This application represents the managed cluster's apiserver (Server application)
        """
        admin_username: NotRequired[pulumi.Input[str]]
        """
        The administrator username to use for Linux hosts
        """
        agent_os_disk_size: NotRequired[pulumi.Input[int]]
        """
        GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
        """
        agent_pool_name: NotRequired[pulumi.Input[str]]
        """
        Name for the agent pool, upto 12 alphanumeric characters
        """
        agent_storage_profile: NotRequired[pulumi.Input[str]]
        """
        Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
        """
        agent_vm_size: NotRequired[pulumi.Input[str]]
        """
        Size of machine in the agent pool
        """
        auth_base_url: NotRequired[pulumi.Input[str]]
        """
        Different authentication API url to use
        """
        base_url: NotRequired[pulumi.Input[str]]
        """
        Different resource management API url to use
        """
        count: NotRequired[pulumi.Input[int]]
        """
        Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
        """
        dns_service_ip: NotRequired[pulumi.Input[str]]
        """
        An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
        """
        docker_bridge_cidr: NotRequired[pulumi.Input[str]]
        """
        A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
        """
        enable_http_application_routing: NotRequired[pulumi.Input[bool]]
        """
        Enable the Kubernetes ingress with automatic public DNS name creation
        """
        enable_monitoring: NotRequired[pulumi.Input[bool]]
        """
        Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
        """
        load_balancer_sku: NotRequired[pulumi.Input[str]]
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Azure Kubernetes cluster location
        """
        log_analytics_workspace: NotRequired[pulumi.Input[str]]
        """
        The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
        """
        log_analytics_workspace_resource_group: NotRequired[pulumi.Input[str]]
        """
        The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
        """
        max_pods: NotRequired[pulumi.Input[int]]
        """
        Maximum number of pods that can run on a node
        """
        network_plugin: NotRequired[pulumi.Input[str]]
        """
        Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
        """
        network_policy: NotRequired[pulumi.Input[str]]
        """
        Network policy used for building Kubernetes network. Chooses from [calico]
        """
        pod_cidr: NotRequired[pulumi.Input[str]]
        """
        A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
        """
        service_cidr: NotRequired[pulumi.Input[str]]
        """
        A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
        """
        tag: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Tags for Kubernetes cluster. For example, foo=bar
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
        """
elif False:
    ClusterAksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAksConfigArgs:
    def __init__(__self__, *,
                 agent_dns_prefix: pulumi.Input[str],
                 client_id: pulumi.Input[str],
                 client_secret: pulumi.Input[str],
                 kubernetes_version: pulumi.Input[str],
                 master_dns_prefix: pulumi.Input[str],
                 resource_group: pulumi.Input[str],
                 ssh_public_key_contents: pulumi.Input[str],
                 subnet: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 virtual_network: pulumi.Input[str],
                 virtual_network_resource_group: pulumi.Input[str],
                 aad_server_app_secret: Optional[pulumi.Input[str]] = None,
                 aad_tenant_id: Optional[pulumi.Input[str]] = None,
                 add_client_app_id: Optional[pulumi.Input[str]] = None,
                 add_server_app_id: Optional[pulumi.Input[str]] = None,
                 admin_username: Optional[pulumi.Input[str]] = None,
                 agent_os_disk_size: Optional[pulumi.Input[int]] = None,
                 agent_pool_name: Optional[pulumi.Input[str]] = None,
                 agent_storage_profile: Optional[pulumi.Input[str]] = None,
                 agent_vm_size: Optional[pulumi.Input[str]] = None,
                 auth_base_url: Optional[pulumi.Input[str]] = None,
                 base_url: Optional[pulumi.Input[str]] = None,
                 count: Optional[pulumi.Input[int]] = None,
                 dns_service_ip: Optional[pulumi.Input[str]] = None,
                 docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
                 enable_http_application_routing: Optional[pulumi.Input[bool]] = None,
                 enable_monitoring: Optional[pulumi.Input[bool]] = None,
                 load_balancer_sku: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_resource_group: Optional[pulumi.Input[str]] = None,
                 max_pods: Optional[pulumi.Input[int]] = None,
                 network_plugin: Optional[pulumi.Input[str]] = None,
                 network_policy: Optional[pulumi.Input[str]] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 service_cidr: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] agent_dns_prefix: DNS prefix to be used to create the FQDN for the agent pool
        :param pulumi.Input[str] client_id: Azure client ID to use
        :param pulumi.Input[str] client_secret: Azure client secret associated with the "client id"
        :param pulumi.Input[str] kubernetes_version: Specify the version of Kubernetes
        :param pulumi.Input[str] master_dns_prefix: DNS prefix to use the Kubernetes cluster control pane
        :param pulumi.Input[str] resource_group: The name of the Cluster resource group
        :param pulumi.Input[str] ssh_public_key_contents: Contents of the SSH public key used to authenticate with Linux hosts
        :param pulumi.Input[str] subnet: The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
        :param pulumi.Input[str] subscription_id: Subscription credentials which uniquely identify Microsoft Azure subscription
        :param pulumi.Input[str] tenant_id: Azure tenant ID to use
        :param pulumi.Input[str] virtual_network: The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
        :param pulumi.Input[str] virtual_network_resource_group: The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
        :param pulumi.Input[str] aad_server_app_secret: The secret of an Azure Active Directory server application
        :param pulumi.Input[str] aad_tenant_id: The ID of an Azure Active Directory tenant
        :param pulumi.Input[str] add_client_app_id: The ID of an Azure Active Directory client application of type "Native". This application is for user login via kubectl
        :param pulumi.Input[str] add_server_app_id: The ID of an Azure Active Directory server application of type "Web app/API". This application represents the managed cluster's apiserver (Server application)
        :param pulumi.Input[str] admin_username: The administrator username to use for Linux hosts
        :param pulumi.Input[int] agent_os_disk_size: GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
        :param pulumi.Input[str] agent_pool_name: Name for the agent pool, upto 12 alphanumeric characters
        :param pulumi.Input[str] agent_storage_profile: Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
        :param pulumi.Input[str] agent_vm_size: Size of machine in the agent pool
        :param pulumi.Input[str] auth_base_url: Different authentication API url to use
        :param pulumi.Input[str] base_url: Different resource management API url to use
        :param pulumi.Input[int] count: Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
        :param pulumi.Input[str] dns_service_ip: An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
        :param pulumi.Input[str] docker_bridge_cidr: A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
        :param pulumi.Input[bool] enable_http_application_routing: Enable the Kubernetes ingress with automatic public DNS name creation
        :param pulumi.Input[bool] enable_monitoring: Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
        :param pulumi.Input[str] load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        :param pulumi.Input[str] location: Azure Kubernetes cluster location
        :param pulumi.Input[str] log_analytics_workspace: The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
        :param pulumi.Input[str] log_analytics_workspace_resource_group: The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
        :param pulumi.Input[int] max_pods: Maximum number of pods that can run on a node
        :param pulumi.Input[str] network_plugin: Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
        :param pulumi.Input[str] network_policy: Network policy used for building Kubernetes network. Chooses from [calico]
        :param pulumi.Input[str] pod_cidr: A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
        :param pulumi.Input[str] service_cidr: A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tag: Tags for Kubernetes cluster. For example, foo=bar
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
        """
        pulumi.set(__self__, "agent_dns_prefix", agent_dns_prefix)
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "master_dns_prefix", master_dns_prefix)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "ssh_public_key_contents", ssh_public_key_contents)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "virtual_network", virtual_network)
        pulumi.set(__self__, "virtual_network_resource_group", virtual_network_resource_group)
        if aad_server_app_secret is not None:
            pulumi.set(__self__, "aad_server_app_secret", aad_server_app_secret)
        if aad_tenant_id is not None:
            pulumi.set(__self__, "aad_tenant_id", aad_tenant_id)
        if add_client_app_id is not None:
            pulumi.set(__self__, "add_client_app_id", add_client_app_id)
        if add_server_app_id is not None:
            pulumi.set(__self__, "add_server_app_id", add_server_app_id)
        if admin_username is not None:
            pulumi.set(__self__, "admin_username", admin_username)
        if agent_os_disk_size is not None:
            pulumi.set(__self__, "agent_os_disk_size", agent_os_disk_size)
        if agent_pool_name is not None:
            pulumi.set(__self__, "agent_pool_name", agent_pool_name)
        if agent_storage_profile is not None:
            pulumi.set(__self__, "agent_storage_profile", agent_storage_profile)
        if agent_vm_size is not None:
            pulumi.set(__self__, "agent_vm_size", agent_vm_size)
        if auth_base_url is not None:
            pulumi.set(__self__, "auth_base_url", auth_base_url)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if dns_service_ip is not None:
            pulumi.set(__self__, "dns_service_ip", dns_service_ip)
        if docker_bridge_cidr is not None:
            pulumi.set(__self__, "docker_bridge_cidr", docker_bridge_cidr)
        if enable_http_application_routing is not None:
            pulumi.set(__self__, "enable_http_application_routing", enable_http_application_routing)
        if enable_monitoring is not None:
            pulumi.set(__self__, "enable_monitoring", enable_monitoring)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if log_analytics_workspace is not None:
            pulumi.set(__self__, "log_analytics_workspace", log_analytics_workspace)
        if log_analytics_workspace_resource_group is not None:
            pulumi.set(__self__, "log_analytics_workspace_resource_group", log_analytics_workspace_resource_group)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if tag is not None:
            warnings.warn("""Use tags argument instead as []string""", DeprecationWarning)
            pulumi.log.warn("""tag is deprecated: Use tags argument instead as []string""")
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="agentDnsPrefix")
    def agent_dns_prefix(self) -> pulumi.Input[str]:
        """
        DNS prefix to be used to create the FQDN for the agent pool
        """
        return pulumi.get(self, "agent_dns_prefix")

    @agent_dns_prefix.setter
    def agent_dns_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "agent_dns_prefix", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        Azure client ID to use
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> pulumi.Input[str]:
        """
        Azure client secret associated with the "client id"
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> pulumi.Input[str]:
        """
        Specify the version of Kubernetes
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter(name="masterDnsPrefix")
    def master_dns_prefix(self) -> pulumi.Input[str]:
        """
        DNS prefix to use the Kubernetes cluster control pane
        """
        return pulumi.get(self, "master_dns_prefix")

    @master_dns_prefix.setter
    def master_dns_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_dns_prefix", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> pulumi.Input[str]:
        """
        The name of the Cluster resource group
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="sshPublicKeyContents")
    def ssh_public_key_contents(self) -> pulumi.Input[str]:
        """
        Contents of the SSH public key used to authenticate with Linux hosts
        """
        return pulumi.get(self, "ssh_public_key_contents")

    @ssh_public_key_contents.setter
    def ssh_public_key_contents(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_public_key_contents", value)

    @property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[str]:
        """
        The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        Subscription credentials which uniquely identify Microsoft Azure subscription
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Azure tenant ID to use
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="virtualNetwork")
    def virtual_network(self) -> pulumi.Input[str]:
        """
        The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
        """
        return pulumi.get(self, "virtual_network")

    @virtual_network.setter
    def virtual_network(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network", value)

    @property
    @pulumi.getter(name="virtualNetworkResourceGroup")
    def virtual_network_resource_group(self) -> pulumi.Input[str]:
        """
        The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID
        """
        return pulumi.get(self, "virtual_network_resource_group")

    @virtual_network_resource_group.setter
    def virtual_network_resource_group(self, value: pulumi.Input[str]):
        pulumi.set(self, "virtual_network_resource_group", value)

    @property
    @pulumi.getter(name="aadServerAppSecret")
    def aad_server_app_secret(self) -> Optional[pulumi.Input[str]]:
        """
        The secret of an Azure Active Directory server application
        """
        return pulumi.get(self, "aad_server_app_secret")

    @aad_server_app_secret.setter
    def aad_server_app_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aad_server_app_secret", value)

    @property
    @pulumi.getter(name="aadTenantId")
    def aad_tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an Azure Active Directory tenant
        """
        return pulumi.get(self, "aad_tenant_id")

    @aad_tenant_id.setter
    def aad_tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aad_tenant_id", value)

    @property
    @pulumi.getter(name="addClientAppId")
    def add_client_app_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an Azure Active Directory client application of type "Native". This application is for user login via kubectl
        """
        return pulumi.get(self, "add_client_app_id")

    @add_client_app_id.setter
    def add_client_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "add_client_app_id", value)

    @property
    @pulumi.getter(name="addServerAppId")
    def add_server_app_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an Azure Active Directory server application of type "Web app/API". This application represents the managed cluster's apiserver (Server application)
        """
        return pulumi.get(self, "add_server_app_id")

    @add_server_app_id.setter
    def add_server_app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "add_server_app_id", value)

    @property
    @pulumi.getter(name="adminUsername")
    def admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        The administrator username to use for Linux hosts
        """
        return pulumi.get(self, "admin_username")

    @admin_username.setter
    def admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "admin_username", value)

    @property
    @pulumi.getter(name="agentOsDiskSize")
    def agent_os_disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the "agent vm size" specified
        """
        return pulumi.get(self, "agent_os_disk_size")

    @agent_os_disk_size.setter
    def agent_os_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "agent_os_disk_size", value)

    @property
    @pulumi.getter(name="agentPoolName")
    def agent_pool_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for the agent pool, upto 12 alphanumeric characters
        """
        return pulumi.get(self, "agent_pool_name")

    @agent_pool_name.setter
    def agent_pool_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_pool_name", value)

    @property
    @pulumi.getter(name="agentStorageProfile")
    def agent_storage_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]
        """
        return pulumi.get(self, "agent_storage_profile")

    @agent_storage_profile.setter
    def agent_storage_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_storage_profile", value)

    @property
    @pulumi.getter(name="agentVmSize")
    def agent_vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        Size of machine in the agent pool
        """
        return pulumi.get(self, "agent_vm_size")

    @agent_vm_size.setter
    def agent_vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "agent_vm_size", value)

    @property
    @pulumi.getter(name="authBaseUrl")
    def auth_base_url(self) -> Optional[pulumi.Input[str]]:
        """
        Different authentication API url to use
        """
        return pulumi.get(self, "auth_base_url")

    @auth_base_url.setter
    def auth_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_base_url", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        Different resource management API url to use
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive)
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="dnsServiceIp")
    def dns_service_ip(self) -> Optional[pulumi.Input[str]]:
        """
        An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in "service cidr"
        """
        return pulumi.get(self, "dns_service_ip")

    @dns_service_ip.setter
    def dns_service_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_service_ip", value)

    @property
    @pulumi.getter(name="dockerBridgeCidr")
    def docker_bridge_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in "service cidr"
        """
        return pulumi.get(self, "docker_bridge_cidr")

    @docker_bridge_cidr.setter
    def docker_bridge_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="enableHttpApplicationRouting")
    def enable_http_application_routing(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the Kubernetes ingress with automatic public DNS name creation
        """
        return pulumi.get(self, "enable_http_application_routing")

    @enable_http_application_routing.setter
    def enable_http_application_routing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_http_application_routing", value)

    @property
    @pulumi.getter(name="enableMonitoring")
    def enable_monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn on Azure Log Analytics monitoring. Uses the Log Analytics "Default" workspace if it exists, else creates one. if using an existing workspace, specifies "log analytics workspace resource id"
        """
        return pulumi.get(self, "enable_monitoring")

    @enable_monitoring.setter
    def enable_monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_monitoring", value)

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")

    @load_balancer_sku.setter
    def load_balancer_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_sku", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Kubernetes cluster location
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspace")
    def log_analytics_workspace(self) -> Optional[pulumi.Input[str]]:
        """
        The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}'
        """
        return pulumi.get(self, "log_analytics_workspace")

    @log_analytics_workspace.setter
    def log_analytics_workspace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceResourceGroup")
    def log_analytics_workspace_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group
        """
        return pulumi.get(self, "log_analytics_workspace_resource_group")

    @log_analytics_workspace_resource_group.setter
    def log_analytics_workspace_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_resource_group", value)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of pods that can run on a node
        """
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pods", value)

    @property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[pulumi.Input[str]]:
        """
        Network plugin used for building Kubernetes network. Chooses from [azure kubenet]
        """
        return pulumi.get(self, "network_plugin")

    @network_plugin.setter
    def network_plugin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_plugin", value)

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Network policy used for building Kubernetes network. Chooses from [calico]
        """
        return pulumi.get(self, "network_policy")

    @network_policy.setter
    def network_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_policy", value)

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        A CIDR notation IP range from which to assign Kubernetes Pod IPs when "network plugin" is specified in "kubenet".
        """
        return pulumi.get(self, "pod_cidr")

    @pod_cidr.setter
    def pod_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_cidr", value)

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges
        """
        return pulumi.get(self, "service_cidr")

    @service_cidr.setter
    def service_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cidr", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use tags argument instead as []string""")
    def tag(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Tags for Kubernetes cluster. For example, foo=bar
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tag", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]`
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ClusterAksConfigV2ArgsDict(TypedDict):
        cloud_credential_id: pulumi.Input[str]
        """
        The AKS Cloud Credential ID to use
        """
        resource_group: pulumi.Input[str]
        """
        The AKS resource group
        """
        resource_location: pulumi.Input[str]
        """
        The AKS resource location
        """
        auth_base_url: NotRequired[pulumi.Input[str]]
        """
        The AKS auth base url
        """
        authorized_ip_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The AKS authorized ip ranges
        """
        base_url: NotRequired[pulumi.Input[str]]
        """
        The AKS base url
        """
        dns_prefix: NotRequired[pulumi.Input[str]]
        """
        The AKS dns prefix. Required if `import=false`
        """
        http_application_routing: NotRequired[pulumi.Input[bool]]
        """
        Enable AKS http application routing?
        """
        imported: NotRequired[pulumi.Input[bool]]
        """
        Is AKS cluster imported?
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        The kubernetes master version. Required if `import=false`
        """
        linux_admin_username: NotRequired[pulumi.Input[str]]
        """
        The AKS linux admin username
        """
        linux_ssh_public_key: NotRequired[pulumi.Input[str]]
        """
        The AKS linux ssh public key
        """
        load_balancer_sku: NotRequired[pulumi.Input[str]]
        """
        The AKS load balancer sku
        """
        log_analytics_workspace_group: NotRequired[pulumi.Input[str]]
        """
        The AKS log analytics workspace group
        """
        log_analytics_workspace_name: NotRequired[pulumi.Input[str]]
        """
        The AKS log analytics workspace name
        """
        monitoring: NotRequired[pulumi.Input[bool]]
        """
        Is AKS cluster monitoring enabled?
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Cluster (string)
        """
        network_dns_service_ip: NotRequired[pulumi.Input[str]]
        """
        The AKS network dns service ip
        """
        network_docker_bridge_cidr: NotRequired[pulumi.Input[str]]
        """
        The AKS network docker bridge cidr
        """
        network_plugin: NotRequired[pulumi.Input[str]]
        """
        The AKS network plugin. Required if `import=false`
        """
        network_pod_cidr: NotRequired[pulumi.Input[str]]
        """
        The AKS network pod cidr
        """
        network_policy: NotRequired[pulumi.Input[str]]
        """
        The AKS network policy
        """
        network_service_cidr: NotRequired[pulumi.Input[str]]
        """
        The AKS network service cidr
        """
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterAksConfigV2NodePoolArgsDict']]]]
        """
        The AKS node pools to use. Required if `import=false`
        """
        node_resource_group: NotRequired[pulumi.Input[str]]
        """
        The AKS node resource group name
        """
        outbound_type: NotRequired[pulumi.Input[str]]
        """
        The AKS outbound type for the egress traffic
        """
        private_cluster: NotRequired[pulumi.Input[bool]]
        """
        Is AKS cluster private?
        """
        subnet: NotRequired[pulumi.Input[str]]
        """
        The AKS subnet
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The AKS cluster tags
        """
        virtual_network: NotRequired[pulumi.Input[str]]
        """
        The AKS virtual network
        """
        virtual_network_resource_group: NotRequired[pulumi.Input[str]]
        """
        The AKS virtual network resource group
        """
elif False:
    ClusterAksConfigV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAksConfigV2Args:
    def __init__(__self__, *,
                 cloud_credential_id: pulumi.Input[str],
                 resource_group: pulumi.Input[str],
                 resource_location: pulumi.Input[str],
                 auth_base_url: Optional[pulumi.Input[str]] = None,
                 authorized_ip_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 base_url: Optional[pulumi.Input[str]] = None,
                 dns_prefix: Optional[pulumi.Input[str]] = None,
                 http_application_routing: Optional[pulumi.Input[bool]] = None,
                 imported: Optional[pulumi.Input[bool]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 linux_admin_username: Optional[pulumi.Input[str]] = None,
                 linux_ssh_public_key: Optional[pulumi.Input[str]] = None,
                 load_balancer_sku: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_group: Optional[pulumi.Input[str]] = None,
                 log_analytics_workspace_name: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 network_dns_service_ip: Optional[pulumi.Input[str]] = None,
                 network_docker_bridge_cidr: Optional[pulumi.Input[str]] = None,
                 network_plugin: Optional[pulumi.Input[str]] = None,
                 network_pod_cidr: Optional[pulumi.Input[str]] = None,
                 network_policy: Optional[pulumi.Input[str]] = None,
                 network_service_cidr: Optional[pulumi.Input[str]] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAksConfigV2NodePoolArgs']]]] = None,
                 node_resource_group: Optional[pulumi.Input[str]] = None,
                 outbound_type: Optional[pulumi.Input[str]] = None,
                 private_cluster: Optional[pulumi.Input[bool]] = None,
                 subnet: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 virtual_network: Optional[pulumi.Input[str]] = None,
                 virtual_network_resource_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_credential_id: The AKS Cloud Credential ID to use
        :param pulumi.Input[str] resource_group: The AKS resource group
        :param pulumi.Input[str] resource_location: The AKS resource location
        :param pulumi.Input[str] auth_base_url: The AKS auth base url
        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_ip_ranges: The AKS authorized ip ranges
        :param pulumi.Input[str] base_url: The AKS base url
        :param pulumi.Input[str] dns_prefix: The AKS dns prefix. Required if `import=false`
        :param pulumi.Input[bool] http_application_routing: Enable AKS http application routing?
        :param pulumi.Input[bool] imported: Is AKS cluster imported?
        :param pulumi.Input[str] kubernetes_version: The kubernetes master version. Required if `import=false`
        :param pulumi.Input[str] linux_admin_username: The AKS linux admin username
        :param pulumi.Input[str] linux_ssh_public_key: The AKS linux ssh public key
        :param pulumi.Input[str] load_balancer_sku: The AKS load balancer sku
        :param pulumi.Input[str] log_analytics_workspace_group: The AKS log analytics workspace group
        :param pulumi.Input[str] log_analytics_workspace_name: The AKS log analytics workspace name
        :param pulumi.Input[bool] monitoring: Is AKS cluster monitoring enabled?
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] network_dns_service_ip: The AKS network dns service ip
        :param pulumi.Input[str] network_docker_bridge_cidr: The AKS network docker bridge cidr
        :param pulumi.Input[str] network_plugin: The AKS network plugin. Required if `import=false`
        :param pulumi.Input[str] network_pod_cidr: The AKS network pod cidr
        :param pulumi.Input[str] network_policy: The AKS network policy
        :param pulumi.Input[str] network_service_cidr: The AKS network service cidr
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAksConfigV2NodePoolArgs']]] node_pools: The AKS node pools to use. Required if `import=false`
        :param pulumi.Input[str] node_resource_group: The AKS node resource group name
        :param pulumi.Input[str] outbound_type: The AKS outbound type for the egress traffic
        :param pulumi.Input[bool] private_cluster: Is AKS cluster private?
        :param pulumi.Input[str] subnet: The AKS subnet
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The AKS cluster tags
        :param pulumi.Input[str] virtual_network: The AKS virtual network
        :param pulumi.Input[str] virtual_network_resource_group: The AKS virtual network resource group
        """
        pulumi.set(__self__, "cloud_credential_id", cloud_credential_id)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "resource_location", resource_location)
        if auth_base_url is not None:
            pulumi.set(__self__, "auth_base_url", auth_base_url)
        if authorized_ip_ranges is not None:
            pulumi.set(__self__, "authorized_ip_ranges", authorized_ip_ranges)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)
        if http_application_routing is not None:
            pulumi.set(__self__, "http_application_routing", http_application_routing)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if linux_admin_username is not None:
            pulumi.set(__self__, "linux_admin_username", linux_admin_username)
        if linux_ssh_public_key is not None:
            pulumi.set(__self__, "linux_ssh_public_key", linux_ssh_public_key)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if log_analytics_workspace_group is not None:
            pulumi.set(__self__, "log_analytics_workspace_group", log_analytics_workspace_group)
        if log_analytics_workspace_name is not None:
            pulumi.set(__self__, "log_analytics_workspace_name", log_analytics_workspace_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_dns_service_ip is not None:
            pulumi.set(__self__, "network_dns_service_ip", network_dns_service_ip)
        if network_docker_bridge_cidr is not None:
            pulumi.set(__self__, "network_docker_bridge_cidr", network_docker_bridge_cidr)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if network_pod_cidr is not None:
            pulumi.set(__self__, "network_pod_cidr", network_pod_cidr)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if network_service_cidr is not None:
            pulumi.set(__self__, "network_service_cidr", network_service_cidr)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if node_resource_group is not None:
            pulumi.set(__self__, "node_resource_group", node_resource_group)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if private_cluster is not None:
            pulumi.set(__self__, "private_cluster", private_cluster)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if virtual_network is not None:
            pulumi.set(__self__, "virtual_network", virtual_network)
        if virtual_network_resource_group is not None:
            pulumi.set(__self__, "virtual_network_resource_group", virtual_network_resource_group)

    @property
    @pulumi.getter(name="cloudCredentialId")
    def cloud_credential_id(self) -> pulumi.Input[str]:
        """
        The AKS Cloud Credential ID to use
        """
        return pulumi.get(self, "cloud_credential_id")

    @cloud_credential_id.setter
    def cloud_credential_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_credential_id", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> pulumi.Input[str]:
        """
        The AKS resource group
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> pulumi.Input[str]:
        """
        The AKS resource location
        """
        return pulumi.get(self, "resource_location")

    @resource_location.setter
    def resource_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_location", value)

    @property
    @pulumi.getter(name="authBaseUrl")
    def auth_base_url(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS auth base url
        """
        return pulumi.get(self, "auth_base_url")

    @auth_base_url.setter
    def auth_base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_base_url", value)

    @property
    @pulumi.getter(name="authorizedIpRanges")
    def authorized_ip_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AKS authorized ip ranges
        """
        return pulumi.get(self, "authorized_ip_ranges")

    @authorized_ip_ranges.setter
    def authorized_ip_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "authorized_ip_ranges", value)

    @property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS base url
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_url", value)

    @property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS dns prefix. Required if `import=false`
        """
        return pulumi.get(self, "dns_prefix")

    @dns_prefix.setter
    def dns_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_prefix", value)

    @property
    @pulumi.getter(name="httpApplicationRouting")
    def http_application_routing(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable AKS http application routing?
        """
        return pulumi.get(self, "http_application_routing")

    @http_application_routing.setter
    def http_application_routing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_application_routing", value)

    @property
    @pulumi.getter
    def imported(self) -> Optional[pulumi.Input[bool]]:
        """
        Is AKS cluster imported?
        """
        return pulumi.get(self, "imported")

    @imported.setter
    def imported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "imported", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The kubernetes master version. Required if `import=false`
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter(name="linuxAdminUsername")
    def linux_admin_username(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS linux admin username
        """
        return pulumi.get(self, "linux_admin_username")

    @linux_admin_username.setter
    def linux_admin_username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_admin_username", value)

    @property
    @pulumi.getter(name="linuxSshPublicKey")
    def linux_ssh_public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS linux ssh public key
        """
        return pulumi.get(self, "linux_ssh_public_key")

    @linux_ssh_public_key.setter
    def linux_ssh_public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_ssh_public_key", value)

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS load balancer sku
        """
        return pulumi.get(self, "load_balancer_sku")

    @load_balancer_sku.setter
    def load_balancer_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_sku", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceGroup")
    def log_analytics_workspace_group(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS log analytics workspace group
        """
        return pulumi.get(self, "log_analytics_workspace_group")

    @log_analytics_workspace_group.setter
    def log_analytics_workspace_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_group", value)

    @property
    @pulumi.getter(name="logAnalyticsWorkspaceName")
    def log_analytics_workspace_name(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS log analytics workspace name
        """
        return pulumi.get(self, "log_analytics_workspace_name")

    @log_analytics_workspace_name.setter
    def log_analytics_workspace_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_analytics_workspace_name", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Is AKS cluster monitoring enabled?
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="networkDnsServiceIp")
    def network_dns_service_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS network dns service ip
        """
        return pulumi.get(self, "network_dns_service_ip")

    @network_dns_service_ip.setter
    def network_dns_service_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_dns_service_ip", value)

    @property
    @pulumi.getter(name="networkDockerBridgeCidr")
    def network_docker_bridge_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS network docker bridge cidr
        """
        return pulumi.get(self, "network_docker_bridge_cidr")

    @network_docker_bridge_cidr.setter
    def network_docker_bridge_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_docker_bridge_cidr", value)

    @property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS network plugin. Required if `import=false`
        """
        return pulumi.get(self, "network_plugin")

    @network_plugin.setter
    def network_plugin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_plugin", value)

    @property
    @pulumi.getter(name="networkPodCidr")
    def network_pod_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS network pod cidr
        """
        return pulumi.get(self, "network_pod_cidr")

    @network_pod_cidr.setter
    def network_pod_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_pod_cidr", value)

    @property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS network policy
        """
        return pulumi.get(self, "network_policy")

    @network_policy.setter
    def network_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_policy", value)

    @property
    @pulumi.getter(name="networkServiceCidr")
    def network_service_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS network service cidr
        """
        return pulumi.get(self, "network_service_cidr")

    @network_service_cidr.setter
    def network_service_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_service_cidr", value)

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAksConfigV2NodePoolArgs']]]]:
        """
        The AKS node pools to use. Required if `import=false`
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterAksConfigV2NodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @property
    @pulumi.getter(name="nodeResourceGroup")
    def node_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node resource group name
        """
        return pulumi.get(self, "node_resource_group")

    @node_resource_group.setter
    def node_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_resource_group", value)

    @property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS outbound type for the egress traffic
        """
        return pulumi.get(self, "outbound_type")

    @outbound_type.setter
    def outbound_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outbound_type", value)

    @property
    @pulumi.getter(name="privateCluster")
    def private_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        Is AKS cluster private?
        """
        return pulumi.get(self, "private_cluster")

    @private_cluster.setter
    def private_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_cluster", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS subnet
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The AKS cluster tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="virtualNetwork")
    def virtual_network(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS virtual network
        """
        return pulumi.get(self, "virtual_network")

    @virtual_network.setter
    def virtual_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network", value)

    @property
    @pulumi.getter(name="virtualNetworkResourceGroup")
    def virtual_network_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS virtual network resource group
        """
        return pulumi.get(self, "virtual_network_resource_group")

    @virtual_network_resource_group.setter
    def virtual_network_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network_resource_group", value)


if not MYPY:
    class ClusterAksConfigV2NodePoolArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Cluster (string)
        """
        availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The AKS node pool availability zones
        """
        count: NotRequired[pulumi.Input[int]]
        """
        The AKS node pool count
        """
        enable_auto_scaling: NotRequired[pulumi.Input[bool]]
        """
        Is AKS node pool auto scaling enabled?
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        max_count: NotRequired[pulumi.Input[int]]
        """
        The AKS node pool max count
        """
        max_pods: NotRequired[pulumi.Input[int]]
        """
        The AKS node pool max pods
        """
        max_surge: NotRequired[pulumi.Input[str]]
        """
        The AKS node pool max surge
        """
        min_count: NotRequired[pulumi.Input[int]]
        """
        The AKS node pool min count
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        The AKS node pool mode
        """
        orchestrator_version: NotRequired[pulumi.Input[str]]
        """
        The AKS node pool orchestrator version
        """
        os_disk_size_gb: NotRequired[pulumi.Input[int]]
        """
        The AKS node pool os disk size gb
        """
        os_disk_type: NotRequired[pulumi.Input[str]]
        """
        The AKS node pool os disk type
        """
        os_type: NotRequired[pulumi.Input[str]]
        """
        Enable AKS node pool os type
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The AKS node pool taints
        """
        vm_size: NotRequired[pulumi.Input[str]]
        """
        The AKS node pool vm size
        """
elif False:
    ClusterAksConfigV2NodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAksConfigV2NodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 count: Optional[pulumi.Input[int]] = None,
                 enable_auto_scaling: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 max_count: Optional[pulumi.Input[int]] = None,
                 max_pods: Optional[pulumi.Input[int]] = None,
                 max_surge: Optional[pulumi.Input[str]] = None,
                 min_count: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 orchestrator_version: Optional[pulumi.Input[str]] = None,
                 os_disk_size_gb: Optional[pulumi.Input[int]] = None,
                 os_disk_type: Optional[pulumi.Input[str]] = None,
                 os_type: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vm_size: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] availability_zones: The AKS node pool availability zones
        :param pulumi.Input[int] count: The AKS node pool count
        :param pulumi.Input[bool] enable_auto_scaling: Is AKS node pool auto scaling enabled?
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[int] max_count: The AKS node pool max count
        :param pulumi.Input[int] max_pods: The AKS node pool max pods
        :param pulumi.Input[str] max_surge: The AKS node pool max surge
        :param pulumi.Input[int] min_count: The AKS node pool min count
        :param pulumi.Input[str] mode: The AKS node pool mode
        :param pulumi.Input[str] orchestrator_version: The AKS node pool orchestrator version
        :param pulumi.Input[int] os_disk_size_gb: The AKS node pool os disk size gb
        :param pulumi.Input[str] os_disk_type: The AKS node pool os disk type
        :param pulumi.Input[str] os_type: Enable AKS node pool os type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] taints: The AKS node pool taints
        :param pulumi.Input[str] vm_size: The AKS node pool vm size
        """
        pulumi.set(__self__, "name", name)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enable_auto_scaling is not None:
            pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AKS node pool availability zones
        """
        return pulumi.get(self, "availability_zones")

    @availability_zones.setter
    def availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "availability_zones", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The AKS node pool count
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> Optional[pulumi.Input[bool]]:
        """
        Is AKS node pool auto scaling enabled?
        """
        return pulumi.get(self, "enable_auto_scaling")

    @enable_auto_scaling.setter
    def enable_auto_scaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_auto_scaling", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[pulumi.Input[int]]:
        """
        The AKS node pool max count
        """
        return pulumi.get(self, "max_count")

    @max_count.setter
    def max_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_count", value)

    @property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[pulumi.Input[int]]:
        """
        The AKS node pool max pods
        """
        return pulumi.get(self, "max_pods")

    @max_pods.setter
    def max_pods(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pods", value)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node pool max surge
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[pulumi.Input[int]]:
        """
        The AKS node pool min count
        """
        return pulumi.get(self, "min_count")

    @min_count.setter
    def min_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_count", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node pool mode
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node pool orchestrator version
        """
        return pulumi.get(self, "orchestrator_version")

    @orchestrator_version.setter
    def orchestrator_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "orchestrator_version", value)

    @property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The AKS node pool os disk size gb
        """
        return pulumi.get(self, "os_disk_size_gb")

    @os_disk_size_gb.setter
    def os_disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "os_disk_size_gb", value)

    @property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node pool os disk type
        """
        return pulumi.get(self, "os_disk_type")

    @os_disk_type.setter
    def os_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_disk_type", value)

    @property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[pulumi.Input[str]]:
        """
        Enable AKS node pool os type
        """
        return pulumi.get(self, "os_type")

    @os_type.setter
    def os_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "os_type", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AKS node pool taints
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "taints", value)

    @property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node pool vm size
        """
        return pulumi.get(self, "vm_size")

    @vm_size.setter
    def vm_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_size", value)


if not MYPY:
    class ClusterClusterAgentDeploymentCustomizationArgsDict(TypedDict):
        append_tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationAppendTolerationArgsDict']]]]
        """
        User defined tolerations to append to agent
        """
        override_affinity: NotRequired[pulumi.Input[str]]
        """
        User defined affinity to override default agent affinity
        """
        override_resource_requirements: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict']]]]
        """
        User defined resource requirements to set on the agent
        """
elif False:
    ClusterClusterAgentDeploymentCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterAgentDeploymentCustomizationArgs:
    def __init__(__self__, *,
                 append_tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs']]]] = None,
                 override_affinity: Optional[pulumi.Input[str]] = None,
                 override_resource_requirements: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs']]] append_tolerations: User defined tolerations to append to agent
        :param pulumi.Input[str] override_affinity: User defined affinity to override default agent affinity
        :param pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]] override_resource_requirements: User defined resource requirements to set on the agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)

    @property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs']]]]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @append_tolerations.setter
    def append_tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs']]]]):
        pulumi.set(self, "append_tolerations", value)

    @property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @override_affinity.setter
    def override_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_affinity", value)

    @property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")

    @override_resource_requirements.setter
    def override_resource_requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]):
        pulumi.set(self, "override_resource_requirements", value)


if not MYPY:
    class ClusterClusterAgentDeploymentCustomizationAppendTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The GKE taint effect (string)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The toleration seconds (int)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterClusterAgentDeploymentCustomizationAppendTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param pulumi.Input[int] seconds: The toleration seconds (int)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict(TypedDict):
        cpu_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum CPU limit for agent
        """
        cpu_request: NotRequired[pulumi.Input[str]]
        """
        The minimum CPU required for agent
        """
        memory_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum memory limit for agent
        """
        memory_request: NotRequired[pulumi.Input[str]]
        """
        The minimum memory required for agent
        """
elif False:
    ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs:
    def __init__(__self__, *,
                 cpu_limit: Optional[pulumi.Input[str]] = None,
                 cpu_request: Optional[pulumi.Input[str]] = None,
                 memory_limit: Optional[pulumi.Input[str]] = None,
                 memory_request: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_limit: The maximum CPU limit for agent
        :param pulumi.Input[str] cpu_request: The minimum CPU required for agent
        :param pulumi.Input[str] memory_limit: The maximum memory limit for agent
        :param pulumi.Input[str] memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @cpu_request.setter
    def cpu_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_request", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_limit", value)

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")

    @memory_request.setter
    def memory_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_request", value)


if not MYPY:
    class ClusterClusterAuthEndpointArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[str]]
        """
        CA certs for the authorized cluster endpoint (string)
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        FQDN for the authorized cluster endpoint (string)
        """
elif False:
    ClusterClusterAuthEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterAuthEndpointArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certs: CA certs for the authorized cluster endpoint (string)
        :param pulumi.Input[bool] enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        :param pulumi.Input[str] fqdn: FQDN for the authorized cluster endpoint (string)
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[str]]:
        """
        CA certs for the authorized cluster endpoint (string)
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        FQDN for the authorized cluster endpoint (string)
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class ClusterClusterRegistrationTokenArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations for the Cluster (map)
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        command: NotRequired[pulumi.Input[str]]
        """
        Command to execute in a imported k8s cluster (string)
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) The ID of the resource (string)
        """
        insecure_command: NotRequired[pulumi.Input[str]]
        """
        Insecure command to execute in a imported k8s cluster (string)
        """
        insecure_node_command: NotRequired[pulumi.Input[str]]
        """
        Insecure node command to execute in a imported k8s cluster (string)
        """
        insecure_windows_node_command: NotRequired[pulumi.Input[str]]
        """
        Insecure windows command to execute in a imported k8s cluster (string)
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        manifest_url: NotRequired[pulumi.Input[str]]
        """
        K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Cluster (string)
        """
        node_command: NotRequired[pulumi.Input[str]]
        """
        Node command to execute in linux nodes for custom k8s cluster (string)
        """
        token: NotRequired[pulumi.Input[str]]
        windows_node_command: NotRequired[pulumi.Input[str]]
        """
        Node command to execute in windows nodes for custom k8s cluster (string)
        """
elif False:
    ClusterClusterRegistrationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterRegistrationTokenArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 command: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 insecure_command: Optional[pulumi.Input[str]] = None,
                 insecure_node_command: Optional[pulumi.Input[str]] = None,
                 insecure_windows_node_command: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 manifest_url: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_command: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 windows_node_command: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations for the Cluster (map)
        :param pulumi.Input[str] command: Command to execute in a imported k8s cluster (string)
        :param pulumi.Input[str] id: (Computed) The ID of the resource (string)
        :param pulumi.Input[str] insecure_command: Insecure command to execute in a imported k8s cluster (string)
        :param pulumi.Input[str] insecure_node_command: Insecure node command to execute in a imported k8s cluster (string)
        :param pulumi.Input[str] insecure_windows_node_command: Insecure windows command to execute in a imported k8s cluster (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[str] manifest_url: K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] node_command: Node command to execute in linux nodes for custom k8s cluster (string)
        :param pulumi.Input[str] windows_node_command: Node command to execute in windows nodes for custom k8s cluster (string)
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure_command is not None:
            pulumi.set(__self__, "insecure_command", insecure_command)
        if insecure_node_command is not None:
            pulumi.set(__self__, "insecure_node_command", insecure_node_command)
        if insecure_windows_node_command is not None:
            pulumi.set(__self__, "insecure_windows_node_command", insecure_windows_node_command)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if manifest_url is not None:
            pulumi.set(__self__, "manifest_url", manifest_url)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_command is not None:
            pulumi.set(__self__, "node_command", node_command)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if windows_node_command is not None:
            pulumi.set(__self__, "windows_node_command", windows_node_command)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations for the Cluster (map)
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        Command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="insecureCommand")
    def insecure_command(self) -> Optional[pulumi.Input[str]]:
        """
        Insecure command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "insecure_command")

    @insecure_command.setter
    def insecure_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insecure_command", value)

    @property
    @pulumi.getter(name="insecureNodeCommand")
    def insecure_node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Insecure node command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "insecure_node_command")

    @insecure_node_command.setter
    def insecure_node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insecure_node_command", value)

    @property
    @pulumi.getter(name="insecureWindowsNodeCommand")
    def insecure_windows_node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Insecure windows command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "insecure_windows_node_command")

    @insecure_windows_node_command.setter
    def insecure_windows_node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insecure_windows_node_command", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="manifestUrl")
    def manifest_url(self) -> Optional[pulumi.Input[str]]:
        """
        K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
        """
        return pulumi.get(self, "manifest_url")

    @manifest_url.setter
    def manifest_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manifest_url", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodeCommand")
    def node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Node command to execute in linux nodes for custom k8s cluster (string)
        """
        return pulumi.get(self, "node_command")

    @node_command.setter
    def node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_command", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="windowsNodeCommand")
    def windows_node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Node command to execute in windows nodes for custom k8s cluster (string)
        """
        return pulumi.get(self, "windows_node_command")

    @windows_node_command.setter
    def windows_node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_node_command", value)


if not MYPY:
    class ClusterClusterTemplateAnswersArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        Cluster ID for answer
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        Project ID for answer
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key/values for answer
        """
elif False:
    ClusterClusterTemplateAnswersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterTemplateAnswersArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cluster_id: Cluster ID for answer
        :param pulumi.Input[str] project_id: Project ID for answer
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: Key/values for answer
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster ID for answer
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Project ID for answer
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key/values for answer
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterClusterTemplateQuestionArgsDict(TypedDict):
        default: pulumi.Input[str]
        """
        Default variable value
        """
        variable: pulumi.Input[str]
        """
        Variable name
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Required variable
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Variable type
        """
elif False:
    ClusterClusterTemplateQuestionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterClusterTemplateQuestionArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[str],
                 variable: pulumi.Input[str],
                 required: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default: Default variable value
        :param pulumi.Input[str] variable: Variable name
        :param pulumi.Input[bool] required: Required variable
        :param pulumi.Input[str] type: Variable type
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "variable", variable)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def default(self) -> pulumi.Input[str]:
        """
        Default variable value
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[str]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def variable(self) -> pulumi.Input[str]:
        """
        Variable name
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "variable", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Required variable
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Variable type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterEksConfigArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        The AWS Client ID to use
        """
        kubernetes_version: pulumi.Input[str]
        """
        The kubernetes master version
        """
        secret_key: pulumi.Input[str]
        """
        The AWS Client Secret associated with the Client ID
        """
        ami: NotRequired[pulumi.Input[str]]
        """
        A custom AMI ID to use for the worker nodes instead of the default
        """
        associate_worker_node_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Associate public ip EKS worker nodes
        """
        desired_nodes: NotRequired[pulumi.Input[int]]
        """
        The desired number of worker nodes
        """
        ebs_encryption: NotRequired[pulumi.Input[bool]]
        """
        Enables EBS encryption of worker nodes
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        The type of machine to use for worker nodes
        """
        key_pair_name: NotRequired[pulumi.Input[str]]
        """
        Allow user to specify key name to use
        """
        maximum_nodes: NotRequired[pulumi.Input[int]]
        """
        The maximum number of worker nodes
        """
        minimum_nodes: NotRequired[pulumi.Input[int]]
        """
        The minimum number of worker nodes
        """
        node_volume_size: NotRequired[pulumi.Input[int]]
        """
        The volume size for each node
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The AWS Region to create the EKS cluster in
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups to use for the cluster
        """
        service_role: NotRequired[pulumi.Input[str]]
        """
        The service role to use to perform the cluster operations in AWS
        """
        session_token: NotRequired[pulumi.Input[str]]
        """
        A session token to use with the client key and secret if applicable
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of subnets in the virtual network to use
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        Pass user-data to the nodes to perform automated configuration tasks
        """
        virtual_network: NotRequired[pulumi.Input[str]]
        """
        The name of the virtual network to use
        """
elif False:
    ClusterEksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEksConfigArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 kubernetes_version: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 ami: Optional[pulumi.Input[str]] = None,
                 associate_worker_node_public_ip: Optional[pulumi.Input[bool]] = None,
                 desired_nodes: Optional[pulumi.Input[int]] = None,
                 ebs_encryption: Optional[pulumi.Input[bool]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 key_pair_name: Optional[pulumi.Input[str]] = None,
                 maximum_nodes: Optional[pulumi.Input[int]] = None,
                 minimum_nodes: Optional[pulumi.Input[int]] = None,
                 node_volume_size: Optional[pulumi.Input[int]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_role: Optional[pulumi.Input[str]] = None,
                 session_token: Optional[pulumi.Input[str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 virtual_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The AWS Client ID to use
        :param pulumi.Input[str] kubernetes_version: The kubernetes master version
        :param pulumi.Input[str] secret_key: The AWS Client Secret associated with the Client ID
        :param pulumi.Input[str] ami: A custom AMI ID to use for the worker nodes instead of the default
        :param pulumi.Input[bool] associate_worker_node_public_ip: Associate public ip EKS worker nodes
        :param pulumi.Input[int] desired_nodes: The desired number of worker nodes
        :param pulumi.Input[bool] ebs_encryption: Enables EBS encryption of worker nodes
        :param pulumi.Input[str] instance_type: The type of machine to use for worker nodes
        :param pulumi.Input[str] key_pair_name: Allow user to specify key name to use
        :param pulumi.Input[int] maximum_nodes: The maximum number of worker nodes
        :param pulumi.Input[int] minimum_nodes: The minimum number of worker nodes
        :param pulumi.Input[int] node_volume_size: The volume size for each node
        :param pulumi.Input[str] region: The AWS Region to create the EKS cluster in
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups to use for the cluster
        :param pulumi.Input[str] service_role: The service role to use to perform the cluster operations in AWS
        :param pulumi.Input[str] session_token: A session token to use with the client key and secret if applicable
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: List of subnets in the virtual network to use
        :param pulumi.Input[str] user_data: Pass user-data to the nodes to perform automated configuration tasks
        :param pulumi.Input[str] virtual_network: The name of the virtual network to use
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "secret_key", secret_key)
        if ami is not None:
            pulumi.set(__self__, "ami", ami)
        if associate_worker_node_public_ip is not None:
            pulumi.set(__self__, "associate_worker_node_public_ip", associate_worker_node_public_ip)
        if desired_nodes is not None:
            pulumi.set(__self__, "desired_nodes", desired_nodes)
        if ebs_encryption is not None:
            pulumi.set(__self__, "ebs_encryption", ebs_encryption)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if key_pair_name is not None:
            pulumi.set(__self__, "key_pair_name", key_pair_name)
        if maximum_nodes is not None:
            pulumi.set(__self__, "maximum_nodes", maximum_nodes)
        if minimum_nodes is not None:
            pulumi.set(__self__, "minimum_nodes", minimum_nodes)
        if node_volume_size is not None:
            pulumi.set(__self__, "node_volume_size", node_volume_size)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if virtual_network is not None:
            pulumi.set(__self__, "virtual_network", virtual_network)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        The AWS Client ID to use
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> pulumi.Input[str]:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        The AWS Client Secret associated with the Client ID
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def ami(self) -> Optional[pulumi.Input[str]]:
        """
        A custom AMI ID to use for the worker nodes instead of the default
        """
        return pulumi.get(self, "ami")

    @ami.setter
    def ami(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ami", value)

    @property
    @pulumi.getter(name="associateWorkerNodePublicIp")
    def associate_worker_node_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Associate public ip EKS worker nodes
        """
        return pulumi.get(self, "associate_worker_node_public_ip")

    @associate_worker_node_public_ip.setter
    def associate_worker_node_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "associate_worker_node_public_ip", value)

    @property
    @pulumi.getter(name="desiredNodes")
    def desired_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The desired number of worker nodes
        """
        return pulumi.get(self, "desired_nodes")

    @desired_nodes.setter
    def desired_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "desired_nodes", value)

    @property
    @pulumi.getter(name="ebsEncryption")
    def ebs_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables EBS encryption of worker nodes
        """
        return pulumi.get(self, "ebs_encryption")

    @ebs_encryption.setter
    def ebs_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ebs_encryption", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of machine to use for worker nodes
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="keyPairName")
    def key_pair_name(self) -> Optional[pulumi.Input[str]]:
        """
        Allow user to specify key name to use
        """
        return pulumi.get(self, "key_pair_name")

    @key_pair_name.setter
    def key_pair_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_pair_name", value)

    @property
    @pulumi.getter(name="maximumNodes")
    def maximum_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of worker nodes
        """
        return pulumi.get(self, "maximum_nodes")

    @maximum_nodes.setter
    def maximum_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_nodes", value)

    @property
    @pulumi.getter(name="minimumNodes")
    def minimum_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of worker nodes
        """
        return pulumi.get(self, "minimum_nodes")

    @minimum_nodes.setter
    def minimum_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minimum_nodes", value)

    @property
    @pulumi.getter(name="nodeVolumeSize")
    def node_volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The volume size for each node
        """
        return pulumi.get(self, "node_volume_size")

    @node_volume_size.setter
    def node_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_volume_size", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Region to create the EKS cluster in
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups to use for the cluster
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[pulumi.Input[str]]:
        """
        The service role to use to perform the cluster operations in AWS
        """
        return pulumi.get(self, "service_role")

    @service_role.setter
    def service_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_role", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[str]]:
        """
        A session token to use with the client key and secret if applicable
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_token", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of subnets in the virtual network to use
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        Pass user-data to the nodes to perform automated configuration tasks
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="virtualNetwork")
    def virtual_network(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the virtual network to use
        """
        return pulumi.get(self, "virtual_network")

    @virtual_network.setter
    def virtual_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "virtual_network", value)


if not MYPY:
    class ClusterEksConfigV2ArgsDict(TypedDict):
        cloud_credential_id: pulumi.Input[str]
        """
        The AWS Cloud Credential ID to use
        """
        imported: NotRequired[pulumi.Input[bool]]
        """
        Is EKS cluster imported?
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        The AWS kms key to use
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        The kubernetes master version
        """
        logging_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The AWS logging types
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Cluster (string)
        """
        node_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupArgsDict']]]]
        """
        The AWS node groups to use
        """
        private_access: NotRequired[pulumi.Input[bool]]
        """
        The EKS cluster has private access
        """
        public_access: NotRequired[pulumi.Input[bool]]
        """
        The EKS cluster has public access
        """
        public_access_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The EKS cluster public access sources
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The AWS Region to create the EKS cluster in
        """
        secrets_encryption: NotRequired[pulumi.Input[bool]]
        """
        Enable EKS cluster secret encryption
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of security groups to use for the cluster
        """
        service_role: NotRequired[pulumi.Input[str]]
        """
        The AWS service role to use
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of subnets in the virtual network to use
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The EKS cluster tags
        """
elif False:
    ClusterEksConfigV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEksConfigV2Args:
    def __init__(__self__, *,
                 cloud_credential_id: pulumi.Input[str],
                 imported: Optional[pulumi.Input[bool]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 logging_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupArgs']]]] = None,
                 private_access: Optional[pulumi.Input[bool]] = None,
                 public_access: Optional[pulumi.Input[bool]] = None,
                 public_access_sources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secrets_encryption: Optional[pulumi.Input[bool]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_role: Optional[pulumi.Input[str]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cloud_credential_id: The AWS Cloud Credential ID to use
        :param pulumi.Input[bool] imported: Is EKS cluster imported?
        :param pulumi.Input[str] kms_key: The AWS kms key to use
        :param pulumi.Input[str] kubernetes_version: The kubernetes master version
        :param pulumi.Input[Sequence[pulumi.Input[str]]] logging_types: The AWS logging types
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupArgs']]] node_groups: The AWS node groups to use
        :param pulumi.Input[bool] private_access: The EKS cluster has private access
        :param pulumi.Input[bool] public_access: The EKS cluster has public access
        :param pulumi.Input[Sequence[pulumi.Input[str]]] public_access_sources: The EKS cluster public access sources
        :param pulumi.Input[str] region: The AWS Region to create the EKS cluster in
        :param pulumi.Input[bool] secrets_encryption: Enable EKS cluster secret encryption
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: List of security groups to use for the cluster
        :param pulumi.Input[str] service_role: The AWS service role to use
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: List of subnets in the virtual network to use
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The EKS cluster tags
        """
        pulumi.set(__self__, "cloud_credential_id", cloud_credential_id)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if logging_types is not None:
            pulumi.set(__self__, "logging_types", logging_types)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_groups is not None:
            pulumi.set(__self__, "node_groups", node_groups)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if public_access_sources is not None:
            pulumi.set(__self__, "public_access_sources", public_access_sources)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secrets_encryption is not None:
            pulumi.set(__self__, "secrets_encryption", secrets_encryption)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="cloudCredentialId")
    def cloud_credential_id(self) -> pulumi.Input[str]:
        """
        The AWS Cloud Credential ID to use
        """
        return pulumi.get(self, "cloud_credential_id")

    @cloud_credential_id.setter
    def cloud_credential_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_credential_id", value)

    @property
    @pulumi.getter
    def imported(self) -> Optional[pulumi.Input[bool]]:
        """
        Is EKS cluster imported?
        """
        return pulumi.get(self, "imported")

    @imported.setter
    def imported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "imported", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS kms key to use
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter(name="loggingTypes")
    def logging_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AWS logging types
        """
        return pulumi.get(self, "logging_types")

    @logging_types.setter
    def logging_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "logging_types", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodeGroups")
    def node_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupArgs']]]]:
        """
        The AWS node groups to use
        """
        return pulumi.get(self, "node_groups")

    @node_groups.setter
    def node_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupArgs']]]]):
        pulumi.set(self, "node_groups", value)

    @property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional[pulumi.Input[bool]]:
        """
        The EKS cluster has private access
        """
        return pulumi.get(self, "private_access")

    @private_access.setter
    def private_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_access", value)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input[bool]]:
        """
        The EKS cluster has public access
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="publicAccessSources")
    def public_access_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The EKS cluster public access sources
        """
        return pulumi.get(self, "public_access_sources")

    @public_access_sources.setter
    def public_access_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "public_access_sources", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Region to create the EKS cluster in
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretsEncryption")
    def secrets_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable EKS cluster secret encryption
        """
        return pulumi.get(self, "secrets_encryption")

    @secrets_encryption.setter
    def secrets_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "secrets_encryption", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of security groups to use for the cluster
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS service role to use
        """
        return pulumi.get(self, "service_role")

    @service_role.setter
    def service_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_role", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of subnets in the virtual network to use
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The EKS cluster tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class ClusterEksConfigV2NodeGroupArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Cluster (string)
        """
        desired_size: NotRequired[pulumi.Input[int]]
        """
        The EKS node group desired size
        """
        disk_size: NotRequired[pulumi.Input[int]]
        """
        The EKS node group disk size
        """
        ec2_ssh_key: NotRequired[pulumi.Input[str]]
        """
        The EKS node group ssh key
        """
        gpu: NotRequired[pulumi.Input[bool]]
        """
        Is EKS cluster using gpu?
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        The EKS node group image ID
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        The EKS node group instance type
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        launch_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupLaunchTemplateArgsDict']]]]
        """
        The EKS node groups launch template
        """
        max_size: NotRequired[pulumi.Input[int]]
        """
        The EKS node group maximum size
        """
        min_size: NotRequired[pulumi.Input[int]]
        """
        The EKS node group minimum size
        """
        node_role: NotRequired[pulumi.Input[str]]
        """
        The EKS node group node role ARN
        """
        request_spot_instances: NotRequired[pulumi.Input[bool]]
        """
        Enable EKS node group request spot instances
        """
        resource_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The EKS node group resource tags
        """
        spot_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The EKS node group spot instance types
        """
        subnets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The EKS node group subnets
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The EKS node group tags
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        The EKS node group user data
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The EKS node group k8s version
        """
elif False:
    ClusterEksConfigV2NodeGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEksConfigV2NodeGroupArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 desired_size: Optional[pulumi.Input[int]] = None,
                 disk_size: Optional[pulumi.Input[int]] = None,
                 ec2_ssh_key: Optional[pulumi.Input[str]] = None,
                 gpu: Optional[pulumi.Input[bool]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 launch_templates: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupLaunchTemplateArgs']]]] = None,
                 max_size: Optional[pulumi.Input[int]] = None,
                 min_size: Optional[pulumi.Input[int]] = None,
                 node_role: Optional[pulumi.Input[str]] = None,
                 request_spot_instances: Optional[pulumi.Input[bool]] = None,
                 resource_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 spot_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[int] desired_size: The EKS node group desired size
        :param pulumi.Input[int] disk_size: The EKS node group disk size
        :param pulumi.Input[str] ec2_ssh_key: The EKS node group ssh key
        :param pulumi.Input[bool] gpu: Is EKS cluster using gpu?
        :param pulumi.Input[str] image_id: The EKS node group image ID
        :param pulumi.Input[str] instance_type: The EKS node group instance type
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupLaunchTemplateArgs']]] launch_templates: The EKS node groups launch template
        :param pulumi.Input[int] max_size: The EKS node group maximum size
        :param pulumi.Input[int] min_size: The EKS node group minimum size
        :param pulumi.Input[str] node_role: The EKS node group node role ARN
        :param pulumi.Input[bool] request_spot_instances: Enable EKS node group request spot instances
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resource_tags: The EKS node group resource tags
        :param pulumi.Input[Sequence[pulumi.Input[str]]] spot_instance_types: The EKS node group spot instance types
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The EKS node group subnets
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: The EKS node group tags
        :param pulumi.Input[str] user_data: The EKS node group user data
        :param pulumi.Input[str] version: The EKS node group k8s version
        """
        pulumi.set(__self__, "name", name)
        if desired_size is not None:
            pulumi.set(__self__, "desired_size", desired_size)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if ec2_ssh_key is not None:
            pulumi.set(__self__, "ec2_ssh_key", ec2_ssh_key)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if launch_templates is not None:
            pulumi.set(__self__, "launch_templates", launch_templates)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if node_role is not None:
            pulumi.set(__self__, "node_role", node_role)
        if request_spot_instances is not None:
            pulumi.set(__self__, "request_spot_instances", request_spot_instances)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)
        if spot_instance_types is not None:
            pulumi.set(__self__, "spot_instance_types", spot_instance_types)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="desiredSize")
    def desired_size(self) -> Optional[pulumi.Input[int]]:
        """
        The EKS node group desired size
        """
        return pulumi.get(self, "desired_size")

    @desired_size.setter
    def desired_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "desired_size", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        The EKS node group disk size
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="ec2SshKey")
    def ec2_ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        The EKS node group ssh key
        """
        return pulumi.get(self, "ec2_ssh_key")

    @ec2_ssh_key.setter
    def ec2_ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ec2_ssh_key", value)

    @property
    @pulumi.getter
    def gpu(self) -> Optional[pulumi.Input[bool]]:
        """
        Is EKS cluster using gpu?
        """
        return pulumi.get(self, "gpu")

    @gpu.setter
    def gpu(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "gpu", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        The EKS node group image ID
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        The EKS node group instance type
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="launchTemplates")
    def launch_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupLaunchTemplateArgs']]]]:
        """
        The EKS node groups launch template
        """
        return pulumi.get(self, "launch_templates")

    @launch_templates.setter
    def launch_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterEksConfigV2NodeGroupLaunchTemplateArgs']]]]):
        pulumi.set(self, "launch_templates", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The EKS node group maximum size
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[int]]:
        """
        The EKS node group minimum size
        """
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_size", value)

    @property
    @pulumi.getter(name="nodeRole")
    def node_role(self) -> Optional[pulumi.Input[str]]:
        """
        The EKS node group node role ARN
        """
        return pulumi.get(self, "node_role")

    @node_role.setter
    def node_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_role", value)

    @property
    @pulumi.getter(name="requestSpotInstances")
    def request_spot_instances(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable EKS node group request spot instances
        """
        return pulumi.get(self, "request_spot_instances")

    @request_spot_instances.setter
    def request_spot_instances(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "request_spot_instances", value)

    @property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The EKS node group resource tags
        """
        return pulumi.get(self, "resource_tags")

    @resource_tags.setter
    def resource_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "resource_tags", value)

    @property
    @pulumi.getter(name="spotInstanceTypes")
    def spot_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The EKS node group spot instance types
        """
        return pulumi.get(self, "spot_instance_types")

    @spot_instance_types.setter
    def spot_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "spot_instance_types", value)

    @property
    @pulumi.getter
    def subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The EKS node group subnets
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnets", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The EKS node group tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        The EKS node group user data
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The EKS node group k8s version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterEksConfigV2NodeGroupLaunchTemplateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        (Computed) The ID of the resource (string)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Cluster (string)
        """
        version: NotRequired[pulumi.Input[int]]
        """
        The EKS node group launch template version
        """
elif False:
    ClusterEksConfigV2NodeGroupLaunchTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterEksConfigV2NodeGroupLaunchTemplateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: (Computed) The ID of the resource (string)
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[int] version: The EKS node group launch template version
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[int]]:
        """
        The EKS node group launch template version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterFleetAgentDeploymentCustomizationArgsDict(TypedDict):
        append_tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationAppendTolerationArgsDict']]]]
        """
        User defined tolerations to append to agent
        """
        override_affinity: NotRequired[pulumi.Input[str]]
        """
        User defined affinity to override default agent affinity
        """
        override_resource_requirements: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict']]]]
        """
        User defined resource requirements to set on the agent
        """
elif False:
    ClusterFleetAgentDeploymentCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterFleetAgentDeploymentCustomizationArgs:
    def __init__(__self__, *,
                 append_tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs']]]] = None,
                 override_affinity: Optional[pulumi.Input[str]] = None,
                 override_resource_requirements: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs']]] append_tolerations: User defined tolerations to append to agent
        :param pulumi.Input[str] override_affinity: User defined affinity to override default agent affinity
        :param pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]] override_resource_requirements: User defined resource requirements to set on the agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)

    @property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs']]]]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @append_tolerations.setter
    def append_tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs']]]]):
        pulumi.set(self, "append_tolerations", value)

    @property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @override_affinity.setter
    def override_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_affinity", value)

    @property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")

    @override_resource_requirements.setter
    def override_resource_requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]):
        pulumi.set(self, "override_resource_requirements", value)


if not MYPY:
    class ClusterFleetAgentDeploymentCustomizationAppendTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The GKE taint effect (string)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The toleration seconds (int)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterFleetAgentDeploymentCustomizationAppendTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param pulumi.Input[int] seconds: The toleration seconds (int)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict(TypedDict):
        cpu_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum CPU limit for agent
        """
        cpu_request: NotRequired[pulumi.Input[str]]
        """
        The minimum CPU required for agent
        """
        memory_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum memory limit for agent
        """
        memory_request: NotRequired[pulumi.Input[str]]
        """
        The minimum memory required for agent
        """
elif False:
    ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs:
    def __init__(__self__, *,
                 cpu_limit: Optional[pulumi.Input[str]] = None,
                 cpu_request: Optional[pulumi.Input[str]] = None,
                 memory_limit: Optional[pulumi.Input[str]] = None,
                 memory_request: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_limit: The maximum CPU limit for agent
        :param pulumi.Input[str] cpu_request: The minimum CPU required for agent
        :param pulumi.Input[str] memory_limit: The maximum memory limit for agent
        :param pulumi.Input[str] memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @cpu_request.setter
    def cpu_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_request", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_limit", value)

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")

    @memory_request.setter
    def memory_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_request", value)


if not MYPY:
    class ClusterGkeConfigArgsDict(TypedDict):
        cluster_ipv4_cidr: pulumi.Input[str]
        """
        The IP address range of the container pods
        """
        credential: pulumi.Input[str]
        """
        The contents of the GC credential file
        """
        disk_type: pulumi.Input[str]
        """
        Type of the disk attached to each node
        """
        image_type: pulumi.Input[str]
        """
        The image to use for the worker nodes
        """
        ip_policy_cluster_ipv4_cidr_block: pulumi.Input[str]
        """
        The IP address range for the cluster pod IPs
        """
        ip_policy_cluster_secondary_range_name: pulumi.Input[str]
        """
        The name of the secondary range to be used for the cluster CIDR block
        """
        ip_policy_node_ipv4_cidr_block: pulumi.Input[str]
        """
        The IP address range of the instance IPs in this cluster
        """
        ip_policy_services_ipv4_cidr_block: pulumi.Input[str]
        """
        The IP address range of the services IPs in this cluster
        """
        ip_policy_services_secondary_range_name: pulumi.Input[str]
        """
        The name of the secondary range to be used for the services CIDR block
        """
        ip_policy_subnetwork_name: pulumi.Input[str]
        """
        A custom subnetwork name to be used if createSubnetwork is true
        """
        locations: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Locations to use for the cluster
        """
        machine_type: pulumi.Input[str]
        """
        The machine type to use for the worker nodes
        """
        maintenance_window: pulumi.Input[str]
        """
        When to performance updates on the nodes, in 24-hour time
        """
        master_ipv4_cidr_block: pulumi.Input[str]
        """
        The IP range in CIDR notation to use for the hosted master network
        """
        master_version: pulumi.Input[str]
        """
        The kubernetes master version
        """
        network: pulumi.Input[str]
        """
        The network to use for the cluster
        """
        node_pool: pulumi.Input[str]
        """
        The ID of the cluster node pool
        """
        node_version: pulumi.Input[str]
        """
        The version of kubernetes to use on the nodes
        """
        oauth_scopes: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The set of Google API scopes to be made available on all of the node VMs under the default service account
        """
        project_id: pulumi.Input[str]
        """
        The ID of your project to use when creating a cluster
        """
        service_account: pulumi.Input[str]
        """
        The Google Cloud Platform Service Account to be used by the node VMs
        """
        sub_network: pulumi.Input[str]
        """
        The sub-network to use for the cluster
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for Cluster (string)
        """
        disk_size_gb: NotRequired[pulumi.Input[int]]
        """
        Size of the disk attached to each node
        """
        enable_alpha_feature: NotRequired[pulumi.Input[bool]]
        """
        To enable kubernetes alpha feature
        """
        enable_auto_repair: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the node auto-repair is enabled for the node pool
        """
        enable_auto_upgrade: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether node auto-upgrade is enabled for the node pool
        """
        enable_horizontal_pod_autoscaling: NotRequired[pulumi.Input[bool]]
        """
        Enable horizontal pod autoscaling for the cluster
        """
        enable_http_load_balancing: NotRequired[pulumi.Input[bool]]
        """
        Enable http load balancing for the cluster
        """
        enable_kubernetes_dashboard: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable the kubernetes dashboard
        """
        enable_legacy_abac: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable legacy abac on the cluster
        """
        enable_master_authorized_network: NotRequired[pulumi.Input[bool]]
        """
        Whether or not master authorized network is enabled
        """
        enable_network_policy_config: NotRequired[pulumi.Input[bool]]
        """
        Enable network policy config for the cluster
        """
        enable_nodepool_autoscaling: NotRequired[pulumi.Input[bool]]
        """
        Enable nodepool autoscaling
        """
        enable_private_endpoint: NotRequired[pulumi.Input[bool]]
        """
        Whether the master's internal IP address is used as the cluster endpoint
        """
        enable_private_nodes: NotRequired[pulumi.Input[bool]]
        """
        Whether nodes have internal IP address only
        """
        enable_stackdriver_logging: NotRequired[pulumi.Input[bool]]
        """
        Enable stackdriver logging
        """
        enable_stackdriver_monitoring: NotRequired[pulumi.Input[bool]]
        """
        Enable stackdriver monitoring
        """
        ip_policy_create_subnetwork: NotRequired[pulumi.Input[bool]]
        """
        Whether a new subnetwork will be created automatically for the cluster
        """
        issue_client_certificate: NotRequired[pulumi.Input[bool]]
        """
        Issue a client certificate
        """
        kubernetes_dashboard: NotRequired[pulumi.Input[bool]]
        """
        Enable the kubernetes dashboard
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        local_ssd_count: NotRequired[pulumi.Input[int]]
        """
        The number of local SSD disks to be attached to the node
        """
        master_authorized_network_cidr_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Define up to 10 external networks that could access Kubernetes master through HTTPS
        """
        max_node_count: NotRequired[pulumi.Input[int]]
        """
        Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
        """
        min_node_count: NotRequired[pulumi.Input[int]]
        """
        Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        The number of nodes to create in this cluster
        """
        preemptible: NotRequired[pulumi.Input[bool]]
        """
        Whether the nodes are created as preemptible VM instances
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The region to launch the cluster. Region or zone should be used
        """
        resource_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each cluster
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of kubernetes taints to be applied to each node
        """
        use_ip_aliases: NotRequired[pulumi.Input[bool]]
        """
        Whether alias IPs will be used for pod IPs in the cluster
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        The zone to launch the cluster. Zone or region should be used
        """
elif False:
    ClusterGkeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigArgs:
    def __init__(__self__, *,
                 cluster_ipv4_cidr: pulumi.Input[str],
                 credential: pulumi.Input[str],
                 disk_type: pulumi.Input[str],
                 image_type: pulumi.Input[str],
                 ip_policy_cluster_ipv4_cidr_block: pulumi.Input[str],
                 ip_policy_cluster_secondary_range_name: pulumi.Input[str],
                 ip_policy_node_ipv4_cidr_block: pulumi.Input[str],
                 ip_policy_services_ipv4_cidr_block: pulumi.Input[str],
                 ip_policy_services_secondary_range_name: pulumi.Input[str],
                 ip_policy_subnetwork_name: pulumi.Input[str],
                 locations: pulumi.Input[Sequence[pulumi.Input[str]]],
                 machine_type: pulumi.Input[str],
                 maintenance_window: pulumi.Input[str],
                 master_ipv4_cidr_block: pulumi.Input[str],
                 master_version: pulumi.Input[str],
                 network: pulumi.Input[str],
                 node_pool: pulumi.Input[str],
                 node_version: pulumi.Input[str],
                 oauth_scopes: pulumi.Input[Sequence[pulumi.Input[str]]],
                 project_id: pulumi.Input[str],
                 service_account: pulumi.Input[str],
                 sub_network: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 enable_alpha_feature: Optional[pulumi.Input[bool]] = None,
                 enable_auto_repair: Optional[pulumi.Input[bool]] = None,
                 enable_auto_upgrade: Optional[pulumi.Input[bool]] = None,
                 enable_horizontal_pod_autoscaling: Optional[pulumi.Input[bool]] = None,
                 enable_http_load_balancing: Optional[pulumi.Input[bool]] = None,
                 enable_kubernetes_dashboard: Optional[pulumi.Input[bool]] = None,
                 enable_legacy_abac: Optional[pulumi.Input[bool]] = None,
                 enable_master_authorized_network: Optional[pulumi.Input[bool]] = None,
                 enable_network_policy_config: Optional[pulumi.Input[bool]] = None,
                 enable_nodepool_autoscaling: Optional[pulumi.Input[bool]] = None,
                 enable_private_endpoint: Optional[pulumi.Input[bool]] = None,
                 enable_private_nodes: Optional[pulumi.Input[bool]] = None,
                 enable_stackdriver_logging: Optional[pulumi.Input[bool]] = None,
                 enable_stackdriver_monitoring: Optional[pulumi.Input[bool]] = None,
                 ip_policy_create_subnetwork: Optional[pulumi.Input[bool]] = None,
                 issue_client_certificate: Optional[pulumi.Input[bool]] = None,
                 kubernetes_dashboard: Optional[pulumi.Input[bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 master_authorized_network_cidr_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_node_count: Optional[pulumi.Input[int]] = None,
                 min_node_count: Optional[pulumi.Input[int]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 preemptible: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 resource_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 use_ip_aliases: Optional[pulumi.Input[bool]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_ipv4_cidr: The IP address range of the container pods
        :param pulumi.Input[str] credential: The contents of the GC credential file
        :param pulumi.Input[str] disk_type: Type of the disk attached to each node
        :param pulumi.Input[str] image_type: The image to use for the worker nodes
        :param pulumi.Input[str] ip_policy_cluster_ipv4_cidr_block: The IP address range for the cluster pod IPs
        :param pulumi.Input[str] ip_policy_cluster_secondary_range_name: The name of the secondary range to be used for the cluster CIDR block
        :param pulumi.Input[str] ip_policy_node_ipv4_cidr_block: The IP address range of the instance IPs in this cluster
        :param pulumi.Input[str] ip_policy_services_ipv4_cidr_block: The IP address range of the services IPs in this cluster
        :param pulumi.Input[str] ip_policy_services_secondary_range_name: The name of the secondary range to be used for the services CIDR block
        :param pulumi.Input[str] ip_policy_subnetwork_name: A custom subnetwork name to be used if createSubnetwork is true
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: Locations to use for the cluster
        :param pulumi.Input[str] machine_type: The machine type to use for the worker nodes
        :param pulumi.Input[str] maintenance_window: When to performance updates on the nodes, in 24-hour time
        :param pulumi.Input[str] master_ipv4_cidr_block: The IP range in CIDR notation to use for the hosted master network
        :param pulumi.Input[str] master_version: The kubernetes master version
        :param pulumi.Input[str] network: The network to use for the cluster
        :param pulumi.Input[str] node_pool: The ID of the cluster node pool
        :param pulumi.Input[str] node_version: The version of kubernetes to use on the nodes
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The set of Google API scopes to be made available on all of the node VMs under the default service account
        :param pulumi.Input[str] project_id: The ID of your project to use when creating a cluster
        :param pulumi.Input[str] service_account: The Google Cloud Platform Service Account to be used by the node VMs
        :param pulumi.Input[str] sub_network: The sub-network to use for the cluster
        :param pulumi.Input[str] description: The description for Cluster (string)
        :param pulumi.Input[int] disk_size_gb: Size of the disk attached to each node
        :param pulumi.Input[bool] enable_alpha_feature: To enable kubernetes alpha feature
        :param pulumi.Input[bool] enable_auto_repair: Specifies whether the node auto-repair is enabled for the node pool
        :param pulumi.Input[bool] enable_auto_upgrade: Specifies whether node auto-upgrade is enabled for the node pool
        :param pulumi.Input[bool] enable_horizontal_pod_autoscaling: Enable horizontal pod autoscaling for the cluster
        :param pulumi.Input[bool] enable_http_load_balancing: Enable http load balancing for the cluster
        :param pulumi.Input[bool] enable_kubernetes_dashboard: Whether to enable the kubernetes dashboard
        :param pulumi.Input[bool] enable_legacy_abac: Whether to enable legacy abac on the cluster
        :param pulumi.Input[bool] enable_master_authorized_network: Whether or not master authorized network is enabled
        :param pulumi.Input[bool] enable_network_policy_config: Enable network policy config for the cluster
        :param pulumi.Input[bool] enable_nodepool_autoscaling: Enable nodepool autoscaling
        :param pulumi.Input[bool] enable_private_endpoint: Whether the master's internal IP address is used as the cluster endpoint
        :param pulumi.Input[bool] enable_private_nodes: Whether nodes have internal IP address only
        :param pulumi.Input[bool] enable_stackdriver_logging: Enable stackdriver logging
        :param pulumi.Input[bool] enable_stackdriver_monitoring: Enable stackdriver monitoring
        :param pulumi.Input[bool] ip_policy_create_subnetwork: Whether a new subnetwork will be created automatically for the cluster
        :param pulumi.Input[bool] issue_client_certificate: Issue a client certificate
        :param pulumi.Input[bool] kubernetes_dashboard: Enable the kubernetes dashboard
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[int] local_ssd_count: The number of local SSD disks to be attached to the node
        :param pulumi.Input[Sequence[pulumi.Input[str]]] master_authorized_network_cidr_blocks: Define up to 10 external networks that could access Kubernetes master through HTTPS
        :param pulumi.Input[int] max_node_count: Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
        :param pulumi.Input[int] min_node_count: Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
        :param pulumi.Input[int] node_count: The number of nodes to create in this cluster
        :param pulumi.Input[bool] preemptible: Whether the nodes are created as preemptible VM instances
        :param pulumi.Input[str] region: The region to launch the cluster. Region or zone should be used
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] resource_labels: The map of Kubernetes labels (key/value pairs) to be applied to each cluster
        :param pulumi.Input[Sequence[pulumi.Input[str]]] taints: List of kubernetes taints to be applied to each node
        :param pulumi.Input[bool] use_ip_aliases: Whether alias IPs will be used for pod IPs in the cluster
        :param pulumi.Input[str] zone: The zone to launch the cluster. Zone or region should be used
        """
        pulumi.set(__self__, "cluster_ipv4_cidr", cluster_ipv4_cidr)
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "image_type", image_type)
        pulumi.set(__self__, "ip_policy_cluster_ipv4_cidr_block", ip_policy_cluster_ipv4_cidr_block)
        pulumi.set(__self__, "ip_policy_cluster_secondary_range_name", ip_policy_cluster_secondary_range_name)
        pulumi.set(__self__, "ip_policy_node_ipv4_cidr_block", ip_policy_node_ipv4_cidr_block)
        pulumi.set(__self__, "ip_policy_services_ipv4_cidr_block", ip_policy_services_ipv4_cidr_block)
        pulumi.set(__self__, "ip_policy_services_secondary_range_name", ip_policy_services_secondary_range_name)
        pulumi.set(__self__, "ip_policy_subnetwork_name", ip_policy_subnetwork_name)
        pulumi.set(__self__, "locations", locations)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "maintenance_window", maintenance_window)
        pulumi.set(__self__, "master_ipv4_cidr_block", master_ipv4_cidr_block)
        pulumi.set(__self__, "master_version", master_version)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "node_pool", node_pool)
        pulumi.set(__self__, "node_version", node_version)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "service_account", service_account)
        pulumi.set(__self__, "sub_network", sub_network)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if enable_alpha_feature is not None:
            pulumi.set(__self__, "enable_alpha_feature", enable_alpha_feature)
        if enable_auto_repair is not None:
            pulumi.set(__self__, "enable_auto_repair", enable_auto_repair)
        if enable_auto_upgrade is not None:
            pulumi.set(__self__, "enable_auto_upgrade", enable_auto_upgrade)
        if enable_horizontal_pod_autoscaling is not None:
            pulumi.set(__self__, "enable_horizontal_pod_autoscaling", enable_horizontal_pod_autoscaling)
        if enable_http_load_balancing is not None:
            pulumi.set(__self__, "enable_http_load_balancing", enable_http_load_balancing)
        if enable_kubernetes_dashboard is not None:
            pulumi.set(__self__, "enable_kubernetes_dashboard", enable_kubernetes_dashboard)
        if enable_legacy_abac is not None:
            pulumi.set(__self__, "enable_legacy_abac", enable_legacy_abac)
        if enable_master_authorized_network is not None:
            pulumi.set(__self__, "enable_master_authorized_network", enable_master_authorized_network)
        if enable_network_policy_config is not None:
            pulumi.set(__self__, "enable_network_policy_config", enable_network_policy_config)
        if enable_nodepool_autoscaling is not None:
            pulumi.set(__self__, "enable_nodepool_autoscaling", enable_nodepool_autoscaling)
        if enable_private_endpoint is not None:
            pulumi.set(__self__, "enable_private_endpoint", enable_private_endpoint)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)
        if enable_stackdriver_logging is not None:
            pulumi.set(__self__, "enable_stackdriver_logging", enable_stackdriver_logging)
        if enable_stackdriver_monitoring is not None:
            pulumi.set(__self__, "enable_stackdriver_monitoring", enable_stackdriver_monitoring)
        if ip_policy_create_subnetwork is not None:
            pulumi.set(__self__, "ip_policy_create_subnetwork", ip_policy_create_subnetwork)
        if issue_client_certificate is not None:
            pulumi.set(__self__, "issue_client_certificate", issue_client_certificate)
        if kubernetes_dashboard is not None:
            pulumi.set(__self__, "kubernetes_dashboard", kubernetes_dashboard)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if master_authorized_network_cidr_blocks is not None:
            pulumi.set(__self__, "master_authorized_network_cidr_blocks", master_authorized_network_cidr_blocks)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_labels is not None:
            pulumi.set(__self__, "resource_labels", resource_labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if use_ip_aliases is not None:
            pulumi.set(__self__, "use_ip_aliases", use_ip_aliases)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="clusterIpv4Cidr")
    def cluster_ipv4_cidr(self) -> pulumi.Input[str]:
        """
        The IP address range of the container pods
        """
        return pulumi.get(self, "cluster_ipv4_cidr")

    @cluster_ipv4_cidr.setter
    def cluster_ipv4_cidr(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_ipv4_cidr", value)

    @property
    @pulumi.getter
    def credential(self) -> pulumi.Input[str]:
        """
        The contents of the GC credential file
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input[str]):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> pulumi.Input[str]:
        """
        Type of the disk attached to each node
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> pulumi.Input[str]:
        """
        The image to use for the worker nodes
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_type", value)

    @property
    @pulumi.getter(name="ipPolicyClusterIpv4CidrBlock")
    def ip_policy_cluster_ipv4_cidr_block(self) -> pulumi.Input[str]:
        """
        The IP address range for the cluster pod IPs
        """
        return pulumi.get(self, "ip_policy_cluster_ipv4_cidr_block")

    @ip_policy_cluster_ipv4_cidr_block.setter
    def ip_policy_cluster_ipv4_cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_policy_cluster_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="ipPolicyClusterSecondaryRangeName")
    def ip_policy_cluster_secondary_range_name(self) -> pulumi.Input[str]:
        """
        The name of the secondary range to be used for the cluster CIDR block
        """
        return pulumi.get(self, "ip_policy_cluster_secondary_range_name")

    @ip_policy_cluster_secondary_range_name.setter
    def ip_policy_cluster_secondary_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_policy_cluster_secondary_range_name", value)

    @property
    @pulumi.getter(name="ipPolicyNodeIpv4CidrBlock")
    def ip_policy_node_ipv4_cidr_block(self) -> pulumi.Input[str]:
        """
        The IP address range of the instance IPs in this cluster
        """
        return pulumi.get(self, "ip_policy_node_ipv4_cidr_block")

    @ip_policy_node_ipv4_cidr_block.setter
    def ip_policy_node_ipv4_cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_policy_node_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="ipPolicyServicesIpv4CidrBlock")
    def ip_policy_services_ipv4_cidr_block(self) -> pulumi.Input[str]:
        """
        The IP address range of the services IPs in this cluster
        """
        return pulumi.get(self, "ip_policy_services_ipv4_cidr_block")

    @ip_policy_services_ipv4_cidr_block.setter
    def ip_policy_services_ipv4_cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_policy_services_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="ipPolicyServicesSecondaryRangeName")
    def ip_policy_services_secondary_range_name(self) -> pulumi.Input[str]:
        """
        The name of the secondary range to be used for the services CIDR block
        """
        return pulumi.get(self, "ip_policy_services_secondary_range_name")

    @ip_policy_services_secondary_range_name.setter
    def ip_policy_services_secondary_range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_policy_services_secondary_range_name", value)

    @property
    @pulumi.getter(name="ipPolicySubnetworkName")
    def ip_policy_subnetwork_name(self) -> pulumi.Input[str]:
        """
        A custom subnetwork name to be used if createSubnetwork is true
        """
        return pulumi.get(self, "ip_policy_subnetwork_name")

    @ip_policy_subnetwork_name.setter
    def ip_policy_subnetwork_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_policy_subnetwork_name", value)

    @property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Locations to use for the cluster
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> pulumi.Input[str]:
        """
        The machine type to use for the worker nodes
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> pulumi.Input[str]:
        """
        When to performance updates on the nodes, in 24-hour time
        """
        return pulumi.get(self, "maintenance_window")

    @maintenance_window.setter
    def maintenance_window(self, value: pulumi.Input[str]):
        pulumi.set(self, "maintenance_window", value)

    @property
    @pulumi.getter(name="masterIpv4CidrBlock")
    def master_ipv4_cidr_block(self) -> pulumi.Input[str]:
        """
        The IP range in CIDR notation to use for the hosted master network
        """
        return pulumi.get(self, "master_ipv4_cidr_block")

    @master_ipv4_cidr_block.setter
    def master_ipv4_cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="masterVersion")
    def master_version(self) -> pulumi.Input[str]:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "master_version")

    @master_version.setter
    def master_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_version", value)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[str]:
        """
        The network to use for the cluster
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="nodePool")
    def node_pool(self) -> pulumi.Input[str]:
        """
        The ID of the cluster node pool
        """
        return pulumi.get(self, "node_pool")

    @node_pool.setter
    def node_pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_pool", value)

    @property
    @pulumi.getter(name="nodeVersion")
    def node_version(self) -> pulumi.Input[str]:
        """
        The version of kubernetes to use on the nodes
        """
        return pulumi.get(self, "node_version")

    @node_version.setter
    def node_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_version", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The set of Google API scopes to be made available on all of the node VMs under the default service account
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "oauth_scopes", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of your project to use when creating a cluster
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[str]:
        """
        The Google Cloud Platform Service Account to be used by the node VMs
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> pulumi.Input[str]:
        """
        The sub-network to use for the cluster
        """
        return pulumi.get(self, "sub_network")

    @sub_network.setter
    def sub_network(self, value: pulumi.Input[str]):
        pulumi.set(self, "sub_network", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the disk attached to each node
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="enableAlphaFeature")
    def enable_alpha_feature(self) -> Optional[pulumi.Input[bool]]:
        """
        To enable kubernetes alpha feature
        """
        return pulumi.get(self, "enable_alpha_feature")

    @enable_alpha_feature.setter
    def enable_alpha_feature(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_alpha_feature", value)

    @property
    @pulumi.getter(name="enableAutoRepair")
    def enable_auto_repair(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the node auto-repair is enabled for the node pool
        """
        return pulumi.get(self, "enable_auto_repair")

    @enable_auto_repair.setter
    def enable_auto_repair(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_auto_repair", value)

    @property
    @pulumi.getter(name="enableAutoUpgrade")
    def enable_auto_upgrade(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether node auto-upgrade is enabled for the node pool
        """
        return pulumi.get(self, "enable_auto_upgrade")

    @enable_auto_upgrade.setter
    def enable_auto_upgrade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_auto_upgrade", value)

    @property
    @pulumi.getter(name="enableHorizontalPodAutoscaling")
    def enable_horizontal_pod_autoscaling(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable horizontal pod autoscaling for the cluster
        """
        return pulumi.get(self, "enable_horizontal_pod_autoscaling")

    @enable_horizontal_pod_autoscaling.setter
    def enable_horizontal_pod_autoscaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_horizontal_pod_autoscaling", value)

    @property
    @pulumi.getter(name="enableHttpLoadBalancing")
    def enable_http_load_balancing(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable http load balancing for the cluster
        """
        return pulumi.get(self, "enable_http_load_balancing")

    @enable_http_load_balancing.setter
    def enable_http_load_balancing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_http_load_balancing", value)

    @property
    @pulumi.getter(name="enableKubernetesDashboard")
    def enable_kubernetes_dashboard(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable the kubernetes dashboard
        """
        return pulumi.get(self, "enable_kubernetes_dashboard")

    @enable_kubernetes_dashboard.setter
    def enable_kubernetes_dashboard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kubernetes_dashboard", value)

    @property
    @pulumi.getter(name="enableLegacyAbac")
    def enable_legacy_abac(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable legacy abac on the cluster
        """
        return pulumi.get(self, "enable_legacy_abac")

    @enable_legacy_abac.setter
    def enable_legacy_abac(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_legacy_abac", value)

    @property
    @pulumi.getter(name="enableMasterAuthorizedNetwork")
    def enable_master_authorized_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not master authorized network is enabled
        """
        return pulumi.get(self, "enable_master_authorized_network")

    @enable_master_authorized_network.setter
    def enable_master_authorized_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_master_authorized_network", value)

    @property
    @pulumi.getter(name="enableNetworkPolicyConfig")
    def enable_network_policy_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable network policy config for the cluster
        """
        return pulumi.get(self, "enable_network_policy_config")

    @enable_network_policy_config.setter
    def enable_network_policy_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_policy_config", value)

    @property
    @pulumi.getter(name="enableNodepoolAutoscaling")
    def enable_nodepool_autoscaling(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable nodepool autoscaling
        """
        return pulumi.get(self, "enable_nodepool_autoscaling")

    @enable_nodepool_autoscaling.setter
    def enable_nodepool_autoscaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_nodepool_autoscaling", value)

    @property
    @pulumi.getter(name="enablePrivateEndpoint")
    def enable_private_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the master's internal IP address is used as the cluster endpoint
        """
        return pulumi.get(self, "enable_private_endpoint")

    @enable_private_endpoint.setter
    def enable_private_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_endpoint", value)

    @property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether nodes have internal IP address only
        """
        return pulumi.get(self, "enable_private_nodes")

    @enable_private_nodes.setter
    def enable_private_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_nodes", value)

    @property
    @pulumi.getter(name="enableStackdriverLogging")
    def enable_stackdriver_logging(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable stackdriver logging
        """
        return pulumi.get(self, "enable_stackdriver_logging")

    @enable_stackdriver_logging.setter
    def enable_stackdriver_logging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_stackdriver_logging", value)

    @property
    @pulumi.getter(name="enableStackdriverMonitoring")
    def enable_stackdriver_monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable stackdriver monitoring
        """
        return pulumi.get(self, "enable_stackdriver_monitoring")

    @enable_stackdriver_monitoring.setter
    def enable_stackdriver_monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_stackdriver_monitoring", value)

    @property
    @pulumi.getter(name="ipPolicyCreateSubnetwork")
    def ip_policy_create_subnetwork(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a new subnetwork will be created automatically for the cluster
        """
        return pulumi.get(self, "ip_policy_create_subnetwork")

    @ip_policy_create_subnetwork.setter
    def ip_policy_create_subnetwork(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ip_policy_create_subnetwork", value)

    @property
    @pulumi.getter(name="issueClientCertificate")
    def issue_client_certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        Issue a client certificate
        """
        return pulumi.get(self, "issue_client_certificate")

    @issue_client_certificate.setter
    def issue_client_certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "issue_client_certificate", value)

    @property
    @pulumi.getter(name="kubernetesDashboard")
    def kubernetes_dashboard(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the kubernetes dashboard
        """
        return pulumi.get(self, "kubernetes_dashboard")

    @kubernetes_dashboard.setter
    def kubernetes_dashboard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "kubernetes_dashboard", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of local SSD disks to be attached to the node
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="masterAuthorizedNetworkCidrBlocks")
    def master_authorized_network_cidr_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Define up to 10 external networks that could access Kubernetes master through HTTPS
        """
        return pulumi.get(self, "master_authorized_network_cidr_blocks")

    @master_authorized_network_cidr_blocks.setter
    def master_authorized_network_cidr_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "master_authorized_network_cidr_blocks", value)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster
        """
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount
        """
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_node_count", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of nodes to create in this cluster
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the nodes are created as preemptible VM instances
        """
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preemptible", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region to launch the cluster. Region or zone should be used
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="resourceLabels")
    def resource_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each cluster
        """
        return pulumi.get(self, "resource_labels")

    @resource_labels.setter
    def resource_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "resource_labels", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of kubernetes taints to be applied to each node
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "taints", value)

    @property
    @pulumi.getter(name="useIpAliases")
    def use_ip_aliases(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether alias IPs will be used for pod IPs in the cluster
        """
        return pulumi.get(self, "use_ip_aliases")

    @use_ip_aliases.setter
    def use_ip_aliases(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ip_aliases", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        The zone to launch the cluster. Zone or region should be used
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ClusterGkeConfigV2ArgsDict(TypedDict):
        google_credential_secret: pulumi.Input[str]
        """
        Google credential secret
        """
        name: pulumi.Input[str]
        """
        The name of the Cluster (string)
        """
        project_id: pulumi.Input[str]
        """
        The GKE project id
        """
        cluster_addons: NotRequired[pulumi.Input['ClusterGkeConfigV2ClusterAddonsArgsDict']]
        """
        The GKE cluster addons
        """
        cluster_ipv4_cidr_block: NotRequired[pulumi.Input[str]]
        """
        The GKE ip v4 cidr block
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for Cluster (string)
        """
        enable_kubernetes_alpha: NotRequired[pulumi.Input[bool]]
        """
        Enable Kubernetes alpha
        """
        imported: NotRequired[pulumi.Input[bool]]
        """
        Is GKE cluster imported?
        """
        ip_allocation_policy: NotRequired[pulumi.Input['ClusterGkeConfigV2IpAllocationPolicyArgsDict']]
        """
        The GKE ip allocation policy
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        The kubernetes master version
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The GKE cluster locations
        """
        logging_service: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster logging service
        """
        maintenance_window: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster maintenance window
        """
        master_authorized_networks_config: NotRequired[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgsDict']]
        """
        The GKE cluster master authorized networks config
        """
        monitoring_service: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster monitoring service
        """
        network: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster network
        """
        network_policy_enabled: NotRequired[pulumi.Input[bool]]
        """
        Is GKE cluster network policy enabled?
        """
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolArgsDict']]]]
        """
        The GKE cluster node pools
        """
        private_cluster_config: NotRequired[pulumi.Input['ClusterGkeConfigV2PrivateClusterConfigArgsDict']]
        """
        The GKE private cluster config
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster region. Required if `zone` is empty
        """
        subnetwork: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster subnetwork
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster zone. Required if `region` is empty
        """
elif False:
    ClusterGkeConfigV2ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2Args:
    def __init__(__self__, *,
                 google_credential_secret: pulumi.Input[str],
                 name: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 cluster_addons: Optional[pulumi.Input['ClusterGkeConfigV2ClusterAddonsArgs']] = None,
                 cluster_ipv4_cidr_block: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_kubernetes_alpha: Optional[pulumi.Input[bool]] = None,
                 imported: Optional[pulumi.Input[bool]] = None,
                 ip_allocation_policy: Optional[pulumi.Input['ClusterGkeConfigV2IpAllocationPolicyArgs']] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 logging_service: Optional[pulumi.Input[str]] = None,
                 maintenance_window: Optional[pulumi.Input[str]] = None,
                 master_authorized_networks_config: Optional[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs']] = None,
                 monitoring_service: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 network_policy_enabled: Optional[pulumi.Input[bool]] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolArgs']]]] = None,
                 private_cluster_config: Optional[pulumi.Input['ClusterGkeConfigV2PrivateClusterConfigArgs']] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 subnetwork: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] google_credential_secret: Google credential secret
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] project_id: The GKE project id
        :param pulumi.Input['ClusterGkeConfigV2ClusterAddonsArgs'] cluster_addons: The GKE cluster addons
        :param pulumi.Input[str] cluster_ipv4_cidr_block: The GKE ip v4 cidr block
        :param pulumi.Input[str] description: The description for Cluster (string)
        :param pulumi.Input[bool] enable_kubernetes_alpha: Enable Kubernetes alpha
        :param pulumi.Input[bool] imported: Is GKE cluster imported?
        :param pulumi.Input['ClusterGkeConfigV2IpAllocationPolicyArgs'] ip_allocation_policy: The GKE ip allocation policy
        :param pulumi.Input[str] kubernetes_version: The kubernetes master version
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] locations: The GKE cluster locations
        :param pulumi.Input[str] logging_service: The GKE cluster logging service
        :param pulumi.Input[str] maintenance_window: The GKE cluster maintenance window
        :param pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs'] master_authorized_networks_config: The GKE cluster master authorized networks config
        :param pulumi.Input[str] monitoring_service: The GKE cluster monitoring service
        :param pulumi.Input[str] network: The GKE cluster network
        :param pulumi.Input[bool] network_policy_enabled: Is GKE cluster network policy enabled?
        :param pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolArgs']]] node_pools: The GKE cluster node pools
        :param pulumi.Input['ClusterGkeConfigV2PrivateClusterConfigArgs'] private_cluster_config: The GKE private cluster config
        :param pulumi.Input[str] region: The GKE cluster region. Required if `zone` is empty
        :param pulumi.Input[str] subnetwork: The GKE cluster subnetwork
        :param pulumi.Input[str] zone: The GKE cluster zone. Required if `region` is empty
        """
        pulumi.set(__self__, "google_credential_secret", google_credential_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if cluster_addons is not None:
            pulumi.set(__self__, "cluster_addons", cluster_addons)
        if cluster_ipv4_cidr_block is not None:
            pulumi.set(__self__, "cluster_ipv4_cidr_block", cluster_ipv4_cidr_block)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_kubernetes_alpha is not None:
            pulumi.set(__self__, "enable_kubernetes_alpha", enable_kubernetes_alpha)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if ip_allocation_policy is not None:
            pulumi.set(__self__, "ip_allocation_policy", ip_allocation_policy)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if logging_service is not None:
            pulumi.set(__self__, "logging_service", logging_service)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if master_authorized_networks_config is not None:
            pulumi.set(__self__, "master_authorized_networks_config", master_authorized_networks_config)
        if monitoring_service is not None:
            pulumi.set(__self__, "monitoring_service", monitoring_service)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_policy_enabled is not None:
            pulumi.set(__self__, "network_policy_enabled", network_policy_enabled)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if private_cluster_config is not None:
            pulumi.set(__self__, "private_cluster_config", private_cluster_config)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="googleCredentialSecret")
    def google_credential_secret(self) -> pulumi.Input[str]:
        """
        Google credential secret
        """
        return pulumi.get(self, "google_credential_secret")

    @google_credential_secret.setter
    def google_credential_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "google_credential_secret", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The GKE project id
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="clusterAddons")
    def cluster_addons(self) -> Optional[pulumi.Input['ClusterGkeConfigV2ClusterAddonsArgs']]:
        """
        The GKE cluster addons
        """
        return pulumi.get(self, "cluster_addons")

    @cluster_addons.setter
    def cluster_addons(self, value: Optional[pulumi.Input['ClusterGkeConfigV2ClusterAddonsArgs']]):
        pulumi.set(self, "cluster_addons", value)

    @property
    @pulumi.getter(name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE ip v4 cidr block
        """
        return pulumi.get(self, "cluster_ipv4_cidr_block")

    @cluster_ipv4_cidr_block.setter
    def cluster_ipv4_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ipv4_cidr_block", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableKubernetesAlpha")
    def enable_kubernetes_alpha(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Kubernetes alpha
        """
        return pulumi.get(self, "enable_kubernetes_alpha")

    @enable_kubernetes_alpha.setter
    def enable_kubernetes_alpha(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kubernetes_alpha", value)

    @property
    @pulumi.getter
    def imported(self) -> Optional[pulumi.Input[bool]]:
        """
        Is GKE cluster imported?
        """
        return pulumi.get(self, "imported")

    @imported.setter
    def imported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "imported", value)

    @property
    @pulumi.getter(name="ipAllocationPolicy")
    def ip_allocation_policy(self) -> Optional[pulumi.Input['ClusterGkeConfigV2IpAllocationPolicyArgs']]:
        """
        The GKE ip allocation policy
        """
        return pulumi.get(self, "ip_allocation_policy")

    @ip_allocation_policy.setter
    def ip_allocation_policy(self, value: Optional[pulumi.Input['ClusterGkeConfigV2IpAllocationPolicyArgs']]):
        pulumi.set(self, "ip_allocation_policy", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The GKE cluster locations
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "locations", value)

    @property
    @pulumi.getter(name="loggingService")
    def logging_service(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster logging service
        """
        return pulumi.get(self, "logging_service")

    @logging_service.setter
    def logging_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logging_service", value)

    @property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster maintenance window
        """
        return pulumi.get(self, "maintenance_window")

    @maintenance_window.setter
    def maintenance_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maintenance_window", value)

    @property
    @pulumi.getter(name="masterAuthorizedNetworksConfig")
    def master_authorized_networks_config(self) -> Optional[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs']]:
        """
        The GKE cluster master authorized networks config
        """
        return pulumi.get(self, "master_authorized_networks_config")

    @master_authorized_networks_config.setter
    def master_authorized_networks_config(self, value: Optional[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs']]):
        pulumi.set(self, "master_authorized_networks_config", value)

    @property
    @pulumi.getter(name="monitoringService")
    def monitoring_service(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster monitoring service
        """
        return pulumi.get(self, "monitoring_service")

    @monitoring_service.setter
    def monitoring_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitoring_service", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster network
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="networkPolicyEnabled")
    def network_policy_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Is GKE cluster network policy enabled?
        """
        return pulumi.get(self, "network_policy_enabled")

    @network_policy_enabled.setter
    def network_policy_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "network_policy_enabled", value)

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolArgs']]]]:
        """
        The GKE cluster node pools
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @property
    @pulumi.getter(name="privateClusterConfig")
    def private_cluster_config(self) -> Optional[pulumi.Input['ClusterGkeConfigV2PrivateClusterConfigArgs']]:
        """
        The GKE private cluster config
        """
        return pulumi.get(self, "private_cluster_config")

    @private_cluster_config.setter
    def private_cluster_config(self, value: Optional[pulumi.Input['ClusterGkeConfigV2PrivateClusterConfigArgs']]):
        pulumi.set(self, "private_cluster_config", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster region. Required if `zone` is empty
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def subnetwork(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster subnetwork
        """
        return pulumi.get(self, "subnetwork")

    @subnetwork.setter
    def subnetwork(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnetwork", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster zone. Required if `region` is empty
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ClusterGkeConfigV2ClusterAddonsArgsDict(TypedDict):
        horizontal_pod_autoscaling: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE horizontal pod autoscaling
        """
        http_load_balancing: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE HTTP load balancing
        """
        network_policy_config: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE network policy config
        """
elif False:
    ClusterGkeConfigV2ClusterAddonsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2ClusterAddonsArgs:
    def __init__(__self__, *,
                 horizontal_pod_autoscaling: Optional[pulumi.Input[bool]] = None,
                 http_load_balancing: Optional[pulumi.Input[bool]] = None,
                 network_policy_config: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] horizontal_pod_autoscaling: Enable GKE horizontal pod autoscaling
        :param pulumi.Input[bool] http_load_balancing: Enable GKE HTTP load balancing
        :param pulumi.Input[bool] network_policy_config: Enable GKE network policy config
        """
        if horizontal_pod_autoscaling is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaling", horizontal_pod_autoscaling)
        if http_load_balancing is not None:
            pulumi.set(__self__, "http_load_balancing", http_load_balancing)
        if network_policy_config is not None:
            pulumi.set(__self__, "network_policy_config", network_policy_config)

    @property
    @pulumi.getter(name="horizontalPodAutoscaling")
    def horizontal_pod_autoscaling(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE horizontal pod autoscaling
        """
        return pulumi.get(self, "horizontal_pod_autoscaling")

    @horizontal_pod_autoscaling.setter
    def horizontal_pod_autoscaling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "horizontal_pod_autoscaling", value)

    @property
    @pulumi.getter(name="httpLoadBalancing")
    def http_load_balancing(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE HTTP load balancing
        """
        return pulumi.get(self, "http_load_balancing")

    @http_load_balancing.setter
    def http_load_balancing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "http_load_balancing", value)

    @property
    @pulumi.getter(name="networkPolicyConfig")
    def network_policy_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE network policy config
        """
        return pulumi.get(self, "network_policy_config")

    @network_policy_config.setter
    def network_policy_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "network_policy_config", value)


if not MYPY:
    class ClusterGkeConfigV2IpAllocationPolicyArgsDict(TypedDict):
        cluster_ipv4_cidr_block: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster ip v4 allocation cidr block
        """
        cluster_secondary_range_name: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster ip v4 allocation secondary range name
        """
        create_subnetwork: NotRequired[pulumi.Input[bool]]
        """
        Create GKE subnetwork?
        """
        node_ipv4_cidr_block: NotRequired[pulumi.Input[str]]
        """
        The GKE node ip v4 allocation cidr block
        """
        services_ipv4_cidr_block: NotRequired[pulumi.Input[str]]
        """
        The GKE services ip v4 allocation cidr block
        """
        services_secondary_range_name: NotRequired[pulumi.Input[str]]
        """
        The GKE services ip v4 allocation secondary range name
        """
        subnetwork_name: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster subnetwork name
        """
        use_ip_aliases: NotRequired[pulumi.Input[bool]]
        """
        Use GKE ip aliases?
        """
elif False:
    ClusterGkeConfigV2IpAllocationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2IpAllocationPolicyArgs:
    def __init__(__self__, *,
                 cluster_ipv4_cidr_block: Optional[pulumi.Input[str]] = None,
                 cluster_secondary_range_name: Optional[pulumi.Input[str]] = None,
                 create_subnetwork: Optional[pulumi.Input[bool]] = None,
                 node_ipv4_cidr_block: Optional[pulumi.Input[str]] = None,
                 services_ipv4_cidr_block: Optional[pulumi.Input[str]] = None,
                 services_secondary_range_name: Optional[pulumi.Input[str]] = None,
                 subnetwork_name: Optional[pulumi.Input[str]] = None,
                 use_ip_aliases: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_ipv4_cidr_block: The GKE cluster ip v4 allocation cidr block
        :param pulumi.Input[str] cluster_secondary_range_name: The GKE cluster ip v4 allocation secondary range name
        :param pulumi.Input[bool] create_subnetwork: Create GKE subnetwork?
        :param pulumi.Input[str] node_ipv4_cidr_block: The GKE node ip v4 allocation cidr block
        :param pulumi.Input[str] services_ipv4_cidr_block: The GKE services ip v4 allocation cidr block
        :param pulumi.Input[str] services_secondary_range_name: The GKE services ip v4 allocation secondary range name
        :param pulumi.Input[str] subnetwork_name: The GKE cluster subnetwork name
        :param pulumi.Input[bool] use_ip_aliases: Use GKE ip aliases?
        """
        if cluster_ipv4_cidr_block is not None:
            pulumi.set(__self__, "cluster_ipv4_cidr_block", cluster_ipv4_cidr_block)
        if cluster_secondary_range_name is not None:
            pulumi.set(__self__, "cluster_secondary_range_name", cluster_secondary_range_name)
        if create_subnetwork is not None:
            pulumi.set(__self__, "create_subnetwork", create_subnetwork)
        if node_ipv4_cidr_block is not None:
            pulumi.set(__self__, "node_ipv4_cidr_block", node_ipv4_cidr_block)
        if services_ipv4_cidr_block is not None:
            pulumi.set(__self__, "services_ipv4_cidr_block", services_ipv4_cidr_block)
        if services_secondary_range_name is not None:
            pulumi.set(__self__, "services_secondary_range_name", services_secondary_range_name)
        if subnetwork_name is not None:
            pulumi.set(__self__, "subnetwork_name", subnetwork_name)
        if use_ip_aliases is not None:
            pulumi.set(__self__, "use_ip_aliases", use_ip_aliases)

    @property
    @pulumi.getter(name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster ip v4 allocation cidr block
        """
        return pulumi.get(self, "cluster_ipv4_cidr_block")

    @cluster_ipv4_cidr_block.setter
    def cluster_ipv4_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="clusterSecondaryRangeName")
    def cluster_secondary_range_name(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster ip v4 allocation secondary range name
        """
        return pulumi.get(self, "cluster_secondary_range_name")

    @cluster_secondary_range_name.setter
    def cluster_secondary_range_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_secondary_range_name", value)

    @property
    @pulumi.getter(name="createSubnetwork")
    def create_subnetwork(self) -> Optional[pulumi.Input[bool]]:
        """
        Create GKE subnetwork?
        """
        return pulumi.get(self, "create_subnetwork")

    @create_subnetwork.setter
    def create_subnetwork(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_subnetwork", value)

    @property
    @pulumi.getter(name="nodeIpv4CidrBlock")
    def node_ipv4_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE node ip v4 allocation cidr block
        """
        return pulumi.get(self, "node_ipv4_cidr_block")

    @node_ipv4_cidr_block.setter
    def node_ipv4_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="servicesIpv4CidrBlock")
    def services_ipv4_cidr_block(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE services ip v4 allocation cidr block
        """
        return pulumi.get(self, "services_ipv4_cidr_block")

    @services_ipv4_cidr_block.setter
    def services_ipv4_cidr_block(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="servicesSecondaryRangeName")
    def services_secondary_range_name(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE services ip v4 allocation secondary range name
        """
        return pulumi.get(self, "services_secondary_range_name")

    @services_secondary_range_name.setter
    def services_secondary_range_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_secondary_range_name", value)

    @property
    @pulumi.getter(name="subnetworkName")
    def subnetwork_name(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster subnetwork name
        """
        return pulumi.get(self, "subnetwork_name")

    @subnetwork_name.setter
    def subnetwork_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnetwork_name", value)

    @property
    @pulumi.getter(name="useIpAliases")
    def use_ip_aliases(self) -> Optional[pulumi.Input[bool]]:
        """
        Use GKE ip aliases?
        """
        return pulumi.get(self, "use_ip_aliases")

    @use_ip_aliases.setter
    def use_ip_aliases(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ip_aliases", value)


if not MYPY:
    class ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgsDict(TypedDict):
        cidr_blocks: pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgsDict']]]
        """
        The GKE master authorized network config cidr blocks
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE master authorized network config
        """
elif False:
    ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs:
    def __init__(__self__, *,
                 cidr_blocks: pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs']]],
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs']]] cidr_blocks: The GKE master authorized network config cidr blocks
        :param pulumi.Input[bool] enabled: Enable GKE master authorized network config
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs']]]:
        """
        The GKE master authorized network config cidr blocks
        """
        return pulumi.get(self, "cidr_blocks")

    @cidr_blocks.setter
    def cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs']]]):
        pulumi.set(self, "cidr_blocks", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE master authorized network config
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgsDict(TypedDict):
        cidr_block: pulumi.Input[str]
        """
        The GKE master authorized network config cidr block
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        The GKE master authorized network config cidr block dispaly name
        """
elif False:
    ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs:
    def __init__(__self__, *,
                 cidr_block: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cidr_block: The GKE master authorized network config cidr block
        :param pulumi.Input[str] display_name: The GKE master authorized network config cidr block dispaly name
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> pulumi.Input[str]:
        """
        The GKE master authorized network config cidr block
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "cidr_block", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE master authorized network config cidr block dispaly name
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ClusterGkeConfigV2NodePoolArgsDict(TypedDict):
        initial_node_count: pulumi.Input[int]
        """
        The GKE node pool config initial node count
        """
        name: pulumi.Input[str]
        """
        The name of the Cluster (string)
        """
        version: pulumi.Input[str]
        """
        The GKE node pool config version
        """
        autoscaling: NotRequired[pulumi.Input['ClusterGkeConfigV2NodePoolAutoscalingArgsDict']]
        """
        The GKE node pool config autoscaling
        """
        config: NotRequired[pulumi.Input['ClusterGkeConfigV2NodePoolConfigArgsDict']]
        """
        The GKE node pool node config
        """
        management: NotRequired[pulumi.Input['ClusterGkeConfigV2NodePoolManagementArgsDict']]
        """
        The GKE node pool config management
        """
        max_pods_constraint: NotRequired[pulumi.Input[int]]
        """
        The GKE node pool config max pods constraint
        """
elif False:
    ClusterGkeConfigV2NodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2NodePoolArgs:
    def __init__(__self__, *,
                 initial_node_count: pulumi.Input[int],
                 name: pulumi.Input[str],
                 version: pulumi.Input[str],
                 autoscaling: Optional[pulumi.Input['ClusterGkeConfigV2NodePoolAutoscalingArgs']] = None,
                 config: Optional[pulumi.Input['ClusterGkeConfigV2NodePoolConfigArgs']] = None,
                 management: Optional[pulumi.Input['ClusterGkeConfigV2NodePoolManagementArgs']] = None,
                 max_pods_constraint: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] initial_node_count: The GKE node pool config initial node count
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] version: The GKE node pool config version
        :param pulumi.Input['ClusterGkeConfigV2NodePoolAutoscalingArgs'] autoscaling: The GKE node pool config autoscaling
        :param pulumi.Input['ClusterGkeConfigV2NodePoolConfigArgs'] config: The GKE node pool node config
        :param pulumi.Input['ClusterGkeConfigV2NodePoolManagementArgs'] management: The GKE node pool config management
        :param pulumi.Input[int] max_pods_constraint: The GKE node pool config max pods constraint
        """
        pulumi.set(__self__, "initial_node_count", initial_node_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if max_pods_constraint is not None:
            pulumi.set(__self__, "max_pods_constraint", max_pods_constraint)

    @property
    @pulumi.getter(name="initialNodeCount")
    def initial_node_count(self) -> pulumi.Input[int]:
        """
        The GKE node pool config initial node count
        """
        return pulumi.get(self, "initial_node_count")

    @initial_node_count.setter
    def initial_node_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "initial_node_count", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[str]:
        """
        The GKE node pool config version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['ClusterGkeConfigV2NodePoolAutoscalingArgs']]:
        """
        The GKE node pool config autoscaling
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['ClusterGkeConfigV2NodePoolAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['ClusterGkeConfigV2NodePoolConfigArgs']]:
        """
        The GKE node pool node config
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['ClusterGkeConfigV2NodePoolConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def management(self) -> Optional[pulumi.Input['ClusterGkeConfigV2NodePoolManagementArgs']]:
        """
        The GKE node pool config management
        """
        return pulumi.get(self, "management")

    @management.setter
    def management(self, value: Optional[pulumi.Input['ClusterGkeConfigV2NodePoolManagementArgs']]):
        pulumi.set(self, "management", value)

    @property
    @pulumi.getter(name="maxPodsConstraint")
    def max_pods_constraint(self) -> Optional[pulumi.Input[int]]:
        """
        The GKE node pool config max pods constraint
        """
        return pulumi.get(self, "max_pods_constraint")

    @max_pods_constraint.setter
    def max_pods_constraint(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pods_constraint", value)


if not MYPY:
    class ClusterGkeConfigV2NodePoolAutoscalingArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE node pool config autoscaling
        """
        max_node_count: NotRequired[pulumi.Input[int]]
        """
        The GKE node pool config max node count
        """
        min_node_count: NotRequired[pulumi.Input[int]]
        """
        The GKE node pool config min node count
        """
elif False:
    ClusterGkeConfigV2NodePoolAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2NodePoolAutoscalingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 max_node_count: Optional[pulumi.Input[int]] = None,
                 min_node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable GKE node pool config autoscaling
        :param pulumi.Input[int] max_node_count: The GKE node pool config max node count
        :param pulumi.Input[int] min_node_count: The GKE node pool config min node count
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE node pool config autoscaling
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        The GKE node pool config max node count
        """
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_node_count", value)

    @property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        The GKE node pool config min node count
        """
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_node_count", value)


if not MYPY:
    class ClusterGkeConfigV2NodePoolConfigArgsDict(TypedDict):
        disk_size_gb: NotRequired[pulumi.Input[int]]
        """
        The GKE node config disk size (Gb)
        """
        disk_type: NotRequired[pulumi.Input[str]]
        """
        The GKE node config disk type
        """
        image_type: NotRequired[pulumi.Input[str]]
        """
        The GKE node config image type
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        local_ssd_count: NotRequired[pulumi.Input[int]]
        """
        The GKE node config local ssd count
        """
        machine_type: NotRequired[pulumi.Input[str]]
        """
        The GKE node config machine type
        """
        oauth_scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The GKE node config oauth scopes
        """
        preemptible: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE node config preemptible
        """
        service_account: NotRequired[pulumi.Input[str]]
        """
        The GKE node config service account
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The GKE node config tags
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolConfigTaintArgsDict']]]]
        """
        The GKE node config taints
        """
elif False:
    ClusterGkeConfigV2NodePoolConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2NodePoolConfigArgs:
    def __init__(__self__, *,
                 disk_size_gb: Optional[pulumi.Input[int]] = None,
                 disk_type: Optional[pulumi.Input[str]] = None,
                 image_type: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 local_ssd_count: Optional[pulumi.Input[int]] = None,
                 machine_type: Optional[pulumi.Input[str]] = None,
                 oauth_scopes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 preemptible: Optional[pulumi.Input[bool]] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolConfigTaintArgs']]]] = None):
        """
        :param pulumi.Input[int] disk_size_gb: The GKE node config disk size (Gb)
        :param pulumi.Input[str] disk_type: The GKE node config disk type
        :param pulumi.Input[str] image_type: The GKE node config image type
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[int] local_ssd_count: The GKE node config local ssd count
        :param pulumi.Input[str] machine_type: The GKE node config machine type
        :param pulumi.Input[Sequence[pulumi.Input[str]]] oauth_scopes: The GKE node config oauth scopes
        :param pulumi.Input[bool] preemptible: Enable GKE node config preemptible
        :param pulumi.Input[str] service_account: The GKE node config service account
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: The GKE node config tags
        :param pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolConfigTaintArgs']]] taints: The GKE node config taints
        """
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        The GKE node config disk size (Gb)
        """
        return pulumi.get(self, "disk_size_gb")

    @disk_size_gb.setter
    def disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "disk_size_gb", value)

    @property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE node config disk type
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_type", value)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE node config image type
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_type", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[pulumi.Input[int]]:
        """
        The GKE node config local ssd count
        """
        return pulumi.get(self, "local_ssd_count")

    @local_ssd_count.setter
    def local_ssd_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "local_ssd_count", value)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE node config machine type
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_type", value)

    @property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The GKE node config oauth scopes
        """
        return pulumi.get(self, "oauth_scopes")

    @oauth_scopes.setter
    def oauth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "oauth_scopes", value)

    @property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE node config preemptible
        """
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preemptible", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE node config service account
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The GKE node config tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolConfigTaintArgs']]]]:
        """
        The GKE node config taints
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterGkeConfigV2NodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class ClusterGkeConfigV2NodePoolConfigTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        The GKE taint effect (string)
        """
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        value: pulumi.Input[str]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterGkeConfigV2NodePoolConfigTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2NodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterGkeConfigV2NodePoolManagementArgsDict(TypedDict):
        auto_repair: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE node pool config management auto repair
        """
        auto_upgrade: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE node pool config management auto upgrade
        """
elif False:
    ClusterGkeConfigV2NodePoolManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2NodePoolManagementArgs:
    def __init__(__self__, *,
                 auto_repair: Optional[pulumi.Input[bool]] = None,
                 auto_upgrade: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] auto_repair: Enable GKE node pool config management auto repair
        :param pulumi.Input[bool] auto_upgrade: Enable GKE node pool config management auto upgrade
        """
        if auto_repair is not None:
            pulumi.set(__self__, "auto_repair", auto_repair)
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)

    @property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE node pool config management auto repair
        """
        return pulumi.get(self, "auto_repair")

    @auto_repair.setter
    def auto_repair(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_repair", value)

    @property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE node pool config management auto upgrade
        """
        return pulumi.get(self, "auto_upgrade")

    @auto_upgrade.setter
    def auto_upgrade(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_upgrade", value)


if not MYPY:
    class ClusterGkeConfigV2PrivateClusterConfigArgsDict(TypedDict):
        master_ipv4_cidr_block: pulumi.Input[str]
        """
        The GKE cluster private master ip v4 cidr block
        """
        enable_private_endpoint: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE cluster private endpoint
        """
        enable_private_nodes: NotRequired[pulumi.Input[bool]]
        """
        Enable GKE cluster private nodes
        """
elif False:
    ClusterGkeConfigV2PrivateClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterGkeConfigV2PrivateClusterConfigArgs:
    def __init__(__self__, *,
                 master_ipv4_cidr_block: pulumi.Input[str],
                 enable_private_endpoint: Optional[pulumi.Input[bool]] = None,
                 enable_private_nodes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] master_ipv4_cidr_block: The GKE cluster private master ip v4 cidr block
        :param pulumi.Input[bool] enable_private_endpoint: Enable GKE cluster private endpoint
        :param pulumi.Input[bool] enable_private_nodes: Enable GKE cluster private nodes
        """
        pulumi.set(__self__, "master_ipv4_cidr_block", master_ipv4_cidr_block)
        if enable_private_endpoint is not None:
            pulumi.set(__self__, "enable_private_endpoint", enable_private_endpoint)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)

    @property
    @pulumi.getter(name="masterIpv4CidrBlock")
    def master_ipv4_cidr_block(self) -> pulumi.Input[str]:
        """
        The GKE cluster private master ip v4 cidr block
        """
        return pulumi.get(self, "master_ipv4_cidr_block")

    @master_ipv4_cidr_block.setter
    def master_ipv4_cidr_block(self, value: pulumi.Input[str]):
        pulumi.set(self, "master_ipv4_cidr_block", value)

    @property
    @pulumi.getter(name="enablePrivateEndpoint")
    def enable_private_endpoint(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE cluster private endpoint
        """
        return pulumi.get(self, "enable_private_endpoint")

    @enable_private_endpoint.setter
    def enable_private_endpoint(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_endpoint", value)

    @property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable GKE cluster private nodes
        """
        return pulumi.get(self, "enable_private_nodes")

    @enable_private_nodes.setter
    def enable_private_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_nodes", value)


if not MYPY:
    class ClusterK3sConfigArgsDict(TypedDict):
        upgrade_strategy: NotRequired[pulumi.Input['ClusterK3sConfigUpgradeStrategyArgsDict']]
        """
        The K3S upgrade strategy
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The K3S kubernetes version
        """
elif False:
    ClusterK3sConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterK3sConfigArgs:
    def __init__(__self__, *,
                 upgrade_strategy: Optional[pulumi.Input['ClusterK3sConfigUpgradeStrategyArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterK3sConfigUpgradeStrategyArgs'] upgrade_strategy: The K3S upgrade strategy
        :param pulumi.Input[str] version: The K3S kubernetes version
        """
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional[pulumi.Input['ClusterK3sConfigUpgradeStrategyArgs']]:
        """
        The K3S upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @upgrade_strategy.setter
    def upgrade_strategy(self, value: Optional[pulumi.Input['ClusterK3sConfigUpgradeStrategyArgs']]):
        pulumi.set(self, "upgrade_strategy", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The K3S kubernetes version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterK3sConfigUpgradeStrategyArgsDict(TypedDict):
        drain_server_nodes: NotRequired[pulumi.Input[bool]]
        """
        Drain server nodes
        """
        drain_worker_nodes: NotRequired[pulumi.Input[bool]]
        """
        Drain worker nodes
        """
        server_concurrency: NotRequired[pulumi.Input[int]]
        """
        Server concurrency
        """
        worker_concurrency: NotRequired[pulumi.Input[int]]
        """
        Worker concurrency
        """
elif False:
    ClusterK3sConfigUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterK3sConfigUpgradeStrategyArgs:
    def __init__(__self__, *,
                 drain_server_nodes: Optional[pulumi.Input[bool]] = None,
                 drain_worker_nodes: Optional[pulumi.Input[bool]] = None,
                 server_concurrency: Optional[pulumi.Input[int]] = None,
                 worker_concurrency: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] drain_server_nodes: Drain server nodes
        :param pulumi.Input[bool] drain_worker_nodes: Drain worker nodes
        :param pulumi.Input[int] server_concurrency: Server concurrency
        :param pulumi.Input[int] worker_concurrency: Worker concurrency
        """
        if drain_server_nodes is not None:
            pulumi.set(__self__, "drain_server_nodes", drain_server_nodes)
        if drain_worker_nodes is not None:
            pulumi.set(__self__, "drain_worker_nodes", drain_worker_nodes)
        if server_concurrency is not None:
            pulumi.set(__self__, "server_concurrency", server_concurrency)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)

    @property
    @pulumi.getter(name="drainServerNodes")
    def drain_server_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain server nodes
        """
        return pulumi.get(self, "drain_server_nodes")

    @drain_server_nodes.setter
    def drain_server_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain_server_nodes", value)

    @property
    @pulumi.getter(name="drainWorkerNodes")
    def drain_worker_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain worker nodes
        """
        return pulumi.get(self, "drain_worker_nodes")

    @drain_worker_nodes.setter
    def drain_worker_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain_worker_nodes", value)

    @property
    @pulumi.getter(name="serverConcurrency")
    def server_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Server concurrency
        """
        return pulumi.get(self, "server_concurrency")

    @server_concurrency.setter
    def server_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "server_concurrency", value)

    @property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Worker concurrency
        """
        return pulumi.get(self, "worker_concurrency")

    @worker_concurrency.setter
    def worker_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_concurrency", value)


if not MYPY:
    class ClusterOkeConfigArgsDict(TypedDict):
        compartment_id: pulumi.Input[str]
        """
        The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        """
        fingerprint: pulumi.Input[str]
        """
        The fingerprint corresponding to the specified user's private API Key
        """
        kubernetes_version: pulumi.Input[str]
        """
        The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
        """
        node_image: pulumi.Input[str]
        """
        The OS for the node image
        """
        node_shape: pulumi.Input[str]
        """
        The shape of the node (determines number of CPUs and  amount of memory on each node)
        """
        private_key_contents: pulumi.Input[str]
        """
        The private API key file contents for the specified user, in PEM format
        """
        region: pulumi.Input[str]
        """
        The availability domain within the region to host the OKE cluster
        """
        tenancy_id: pulumi.Input[str]
        """
        The OCID of the tenancy in which to create resources
        """
        user_ocid: pulumi.Input[str]
        """
        The OCID of a user who has access to the tenancy/compartment
        """
        custom_boot_volume_size: NotRequired[pulumi.Input[int]]
        """
        An optional custom boot volume size (in GB) for the nodes
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description for Cluster (string)
        """
        enable_kubernetes_dashboard: NotRequired[pulumi.Input[bool]]
        """
        Enable the kubernetes dashboard
        """
        enable_private_control_plane: NotRequired[pulumi.Input[bool]]
        """
        Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        """
        enable_private_nodes: NotRequired[pulumi.Input[bool]]
        """
        Whether worker nodes are deployed into a new private subnet
        """
        flex_ocpus: NotRequired[pulumi.Input[int]]
        """
        Optional number of OCPUs for nodes (requires flexible node_shape)
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        Optional specify the OCID of the KMS Vault master key
        """
        limit_node_count: NotRequired[pulumi.Input[int]]
        """
        Optional limit on the total number of nodes in the pool
        """
        load_balancer_subnet_name1: NotRequired[pulumi.Input[str]]
        """
        The name of the first existing subnet to use for Kubernetes services / LB
        """
        load_balancer_subnet_name2: NotRequired[pulumi.Input[str]]
        """
        The (optional) name of a second existing subnet to use for Kubernetes services / LB
        """
        node_pool_dns_domain_name: NotRequired[pulumi.Input[str]]
        """
        Optional name for DNS domain of node pool subnet
        """
        node_pool_subnet_name: NotRequired[pulumi.Input[str]]
        """
        Optional name for node pool subnet
        """
        node_public_key_contents: NotRequired[pulumi.Input[str]]
        """
        The contents of the SSH public key file to use for the nodes
        """
        pod_cidr: NotRequired[pulumi.Input[str]]
        """
        Optional specify the pod CIDR, defaults to 10.244.0.0/16
        """
        private_key_passphrase: NotRequired[pulumi.Input[str]]
        """
        The passphrase of the private key for the OKE cluster
        """
        quantity_of_node_subnets: NotRequired[pulumi.Input[int]]
        """
        Number of node subnets (defaults to creating 1 regional subnet)
        """
        quantity_per_subnet: NotRequired[pulumi.Input[int]]
        """
        Number of worker nodes in each subnet / availability domain
        """
        service_cidr: NotRequired[pulumi.Input[str]]
        """
        Optional specify the service CIDR, defaults to 10.96.0.0/16
        """
        service_dns_domain_name: NotRequired[pulumi.Input[str]]
        """
        Optional name for DNS domain of service subnet
        """
        skip_vcn_delete: NotRequired[pulumi.Input[bool]]
        """
        Whether to skip deleting VCN
        """
        vcn_compartment_id: NotRequired[pulumi.Input[str]]
        """
        The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        """
        vcn_name: NotRequired[pulumi.Input[str]]
        """
        The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        """
        worker_node_ingress_cidr: NotRequired[pulumi.Input[str]]
        """
        Additional CIDR from which to allow ingress to worker nodes
        """
elif False:
    ClusterOkeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOkeConfigArgs:
    def __init__(__self__, *,
                 compartment_id: pulumi.Input[str],
                 fingerprint: pulumi.Input[str],
                 kubernetes_version: pulumi.Input[str],
                 node_image: pulumi.Input[str],
                 node_shape: pulumi.Input[str],
                 private_key_contents: pulumi.Input[str],
                 region: pulumi.Input[str],
                 tenancy_id: pulumi.Input[str],
                 user_ocid: pulumi.Input[str],
                 custom_boot_volume_size: Optional[pulumi.Input[int]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 enable_kubernetes_dashboard: Optional[pulumi.Input[bool]] = None,
                 enable_private_control_plane: Optional[pulumi.Input[bool]] = None,
                 enable_private_nodes: Optional[pulumi.Input[bool]] = None,
                 flex_ocpus: Optional[pulumi.Input[int]] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 limit_node_count: Optional[pulumi.Input[int]] = None,
                 load_balancer_subnet_name1: Optional[pulumi.Input[str]] = None,
                 load_balancer_subnet_name2: Optional[pulumi.Input[str]] = None,
                 node_pool_dns_domain_name: Optional[pulumi.Input[str]] = None,
                 node_pool_subnet_name: Optional[pulumi.Input[str]] = None,
                 node_public_key_contents: Optional[pulumi.Input[str]] = None,
                 pod_cidr: Optional[pulumi.Input[str]] = None,
                 private_key_passphrase: Optional[pulumi.Input[str]] = None,
                 quantity_of_node_subnets: Optional[pulumi.Input[int]] = None,
                 quantity_per_subnet: Optional[pulumi.Input[int]] = None,
                 service_cidr: Optional[pulumi.Input[str]] = None,
                 service_dns_domain_name: Optional[pulumi.Input[str]] = None,
                 skip_vcn_delete: Optional[pulumi.Input[bool]] = None,
                 vcn_compartment_id: Optional[pulumi.Input[str]] = None,
                 vcn_name: Optional[pulumi.Input[str]] = None,
                 worker_node_ingress_cidr: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compartment_id: The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        :param pulumi.Input[str] fingerprint: The fingerprint corresponding to the specified user's private API Key
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
        :param pulumi.Input[str] node_image: The OS for the node image
        :param pulumi.Input[str] node_shape: The shape of the node (determines number of CPUs and  amount of memory on each node)
        :param pulumi.Input[str] private_key_contents: The private API key file contents for the specified user, in PEM format
        :param pulumi.Input[str] region: The availability domain within the region to host the OKE cluster
        :param pulumi.Input[str] tenancy_id: The OCID of the tenancy in which to create resources
        :param pulumi.Input[str] user_ocid: The OCID of a user who has access to the tenancy/compartment
        :param pulumi.Input[int] custom_boot_volume_size: An optional custom boot volume size (in GB) for the nodes
        :param pulumi.Input[str] description: The description for Cluster (string)
        :param pulumi.Input[bool] enable_kubernetes_dashboard: Enable the kubernetes dashboard
        :param pulumi.Input[bool] enable_private_control_plane: Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        :param pulumi.Input[bool] enable_private_nodes: Whether worker nodes are deployed into a new private subnet
        :param pulumi.Input[int] flex_ocpus: Optional number of OCPUs for nodes (requires flexible node_shape)
        :param pulumi.Input[str] kms_key_id: Optional specify the OCID of the KMS Vault master key
        :param pulumi.Input[int] limit_node_count: Optional limit on the total number of nodes in the pool
        :param pulumi.Input[str] load_balancer_subnet_name1: The name of the first existing subnet to use for Kubernetes services / LB
        :param pulumi.Input[str] load_balancer_subnet_name2: The (optional) name of a second existing subnet to use for Kubernetes services / LB
        :param pulumi.Input[str] node_pool_dns_domain_name: Optional name for DNS domain of node pool subnet
        :param pulumi.Input[str] node_pool_subnet_name: Optional name for node pool subnet
        :param pulumi.Input[str] node_public_key_contents: The contents of the SSH public key file to use for the nodes
        :param pulumi.Input[str] pod_cidr: Optional specify the pod CIDR, defaults to 10.244.0.0/16
        :param pulumi.Input[str] private_key_passphrase: The passphrase of the private key for the OKE cluster
        :param pulumi.Input[int] quantity_of_node_subnets: Number of node subnets (defaults to creating 1 regional subnet)
        :param pulumi.Input[int] quantity_per_subnet: Number of worker nodes in each subnet / availability domain
        :param pulumi.Input[str] service_cidr: Optional specify the service CIDR, defaults to 10.96.0.0/16
        :param pulumi.Input[str] service_dns_domain_name: Optional name for DNS domain of service subnet
        :param pulumi.Input[bool] skip_vcn_delete: Whether to skip deleting VCN
        :param pulumi.Input[str] vcn_compartment_id: The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        :param pulumi.Input[str] vcn_name: The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        :param pulumi.Input[str] worker_node_ingress_cidr: Additional CIDR from which to allow ingress to worker nodes
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "node_image", node_image)
        pulumi.set(__self__, "node_shape", node_shape)
        pulumi.set(__self__, "private_key_contents", private_key_contents)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tenancy_id", tenancy_id)
        pulumi.set(__self__, "user_ocid", user_ocid)
        if custom_boot_volume_size is not None:
            pulumi.set(__self__, "custom_boot_volume_size", custom_boot_volume_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_kubernetes_dashboard is not None:
            pulumi.set(__self__, "enable_kubernetes_dashboard", enable_kubernetes_dashboard)
        if enable_private_control_plane is not None:
            pulumi.set(__self__, "enable_private_control_plane", enable_private_control_plane)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)
        if flex_ocpus is not None:
            pulumi.set(__self__, "flex_ocpus", flex_ocpus)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if limit_node_count is not None:
            pulumi.set(__self__, "limit_node_count", limit_node_count)
        if load_balancer_subnet_name1 is not None:
            pulumi.set(__self__, "load_balancer_subnet_name1", load_balancer_subnet_name1)
        if load_balancer_subnet_name2 is not None:
            pulumi.set(__self__, "load_balancer_subnet_name2", load_balancer_subnet_name2)
        if node_pool_dns_domain_name is not None:
            pulumi.set(__self__, "node_pool_dns_domain_name", node_pool_dns_domain_name)
        if node_pool_subnet_name is not None:
            pulumi.set(__self__, "node_pool_subnet_name", node_pool_subnet_name)
        if node_public_key_contents is not None:
            pulumi.set(__self__, "node_public_key_contents", node_public_key_contents)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if private_key_passphrase is not None:
            pulumi.set(__self__, "private_key_passphrase", private_key_passphrase)
        if quantity_of_node_subnets is not None:
            pulumi.set(__self__, "quantity_of_node_subnets", quantity_of_node_subnets)
        if quantity_per_subnet is not None:
            pulumi.set(__self__, "quantity_per_subnet", quantity_per_subnet)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_dns_domain_name is not None:
            pulumi.set(__self__, "service_dns_domain_name", service_dns_domain_name)
        if skip_vcn_delete is not None:
            pulumi.set(__self__, "skip_vcn_delete", skip_vcn_delete)
        if vcn_compartment_id is not None:
            pulumi.set(__self__, "vcn_compartment_id", vcn_compartment_id)
        if vcn_name is not None:
            pulumi.set(__self__, "vcn_name", vcn_name)
        if worker_node_ingress_cidr is not None:
            pulumi.set(__self__, "worker_node_ingress_cidr", worker_node_ingress_cidr)

    @property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> pulumi.Input[str]:
        """
        The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        """
        return pulumi.get(self, "compartment_id")

    @compartment_id.setter
    def compartment_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "compartment_id", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> pulumi.Input[str]:
        """
        The fingerprint corresponding to the specified user's private API Key
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: pulumi.Input[str]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> pulumi.Input[str]:
        """
        The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter(name="nodeImage")
    def node_image(self) -> pulumi.Input[str]:
        """
        The OS for the node image
        """
        return pulumi.get(self, "node_image")

    @node_image.setter
    def node_image(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_image", value)

    @property
    @pulumi.getter(name="nodeShape")
    def node_shape(self) -> pulumi.Input[str]:
        """
        The shape of the node (determines number of CPUs and  amount of memory on each node)
        """
        return pulumi.get(self, "node_shape")

    @node_shape.setter
    def node_shape(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_shape", value)

    @property
    @pulumi.getter(name="privateKeyContents")
    def private_key_contents(self) -> pulumi.Input[str]:
        """
        The private API key file contents for the specified user, in PEM format
        """
        return pulumi.get(self, "private_key_contents")

    @private_key_contents.setter
    def private_key_contents(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_key_contents", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        The availability domain within the region to host the OKE cluster
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="tenancyId")
    def tenancy_id(self) -> pulumi.Input[str]:
        """
        The OCID of the tenancy in which to create resources
        """
        return pulumi.get(self, "tenancy_id")

    @tenancy_id.setter
    def tenancy_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenancy_id", value)

    @property
    @pulumi.getter(name="userOcid")
    def user_ocid(self) -> pulumi.Input[str]:
        """
        The OCID of a user who has access to the tenancy/compartment
        """
        return pulumi.get(self, "user_ocid")

    @user_ocid.setter
    def user_ocid(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_ocid", value)

    @property
    @pulumi.getter(name="customBootVolumeSize")
    def custom_boot_volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        An optional custom boot volume size (in GB) for the nodes
        """
        return pulumi.get(self, "custom_boot_volume_size")

    @custom_boot_volume_size.setter
    def custom_boot_volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "custom_boot_volume_size", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="enableKubernetesDashboard")
    def enable_kubernetes_dashboard(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the kubernetes dashboard
        """
        return pulumi.get(self, "enable_kubernetes_dashboard")

    @enable_kubernetes_dashboard.setter
    def enable_kubernetes_dashboard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_kubernetes_dashboard", value)

    @property
    @pulumi.getter(name="enablePrivateControlPlane")
    def enable_private_control_plane(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        """
        return pulumi.get(self, "enable_private_control_plane")

    @enable_private_control_plane.setter
    def enable_private_control_plane(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_control_plane", value)

    @property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether worker nodes are deployed into a new private subnet
        """
        return pulumi.get(self, "enable_private_nodes")

    @enable_private_nodes.setter
    def enable_private_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_private_nodes", value)

    @property
    @pulumi.getter(name="flexOcpus")
    def flex_ocpus(self) -> Optional[pulumi.Input[int]]:
        """
        Optional number of OCPUs for nodes (requires flexible node_shape)
        """
        return pulumi.get(self, "flex_ocpus")

    @flex_ocpus.setter
    def flex_ocpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flex_ocpus", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional specify the OCID of the KMS Vault master key
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="limitNodeCount")
    def limit_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Optional limit on the total number of nodes in the pool
        """
        return pulumi.get(self, "limit_node_count")

    @limit_node_count.setter
    def limit_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "limit_node_count", value)

    @property
    @pulumi.getter(name="loadBalancerSubnetName1")
    def load_balancer_subnet_name1(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the first existing subnet to use for Kubernetes services / LB
        """
        return pulumi.get(self, "load_balancer_subnet_name1")

    @load_balancer_subnet_name1.setter
    def load_balancer_subnet_name1(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_subnet_name1", value)

    @property
    @pulumi.getter(name="loadBalancerSubnetName2")
    def load_balancer_subnet_name2(self) -> Optional[pulumi.Input[str]]:
        """
        The (optional) name of a second existing subnet to use for Kubernetes services / LB
        """
        return pulumi.get(self, "load_balancer_subnet_name2")

    @load_balancer_subnet_name2.setter
    def load_balancer_subnet_name2(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_subnet_name2", value)

    @property
    @pulumi.getter(name="nodePoolDnsDomainName")
    def node_pool_dns_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional name for DNS domain of node pool subnet
        """
        return pulumi.get(self, "node_pool_dns_domain_name")

    @node_pool_dns_domain_name.setter
    def node_pool_dns_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pool_dns_domain_name", value)

    @property
    @pulumi.getter(name="nodePoolSubnetName")
    def node_pool_subnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional name for node pool subnet
        """
        return pulumi.get(self, "node_pool_subnet_name")

    @node_pool_subnet_name.setter
    def node_pool_subnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pool_subnet_name", value)

    @property
    @pulumi.getter(name="nodePublicKeyContents")
    def node_public_key_contents(self) -> Optional[pulumi.Input[str]]:
        """
        The contents of the SSH public key file to use for the nodes
        """
        return pulumi.get(self, "node_public_key_contents")

    @node_public_key_contents.setter
    def node_public_key_contents(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_public_key_contents", value)

    @property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional specify the pod CIDR, defaults to 10.244.0.0/16
        """
        return pulumi.get(self, "pod_cidr")

    @pod_cidr.setter
    def pod_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_cidr", value)

    @property
    @pulumi.getter(name="privateKeyPassphrase")
    def private_key_passphrase(self) -> Optional[pulumi.Input[str]]:
        """
        The passphrase of the private key for the OKE cluster
        """
        return pulumi.get(self, "private_key_passphrase")

    @private_key_passphrase.setter
    def private_key_passphrase(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_passphrase", value)

    @property
    @pulumi.getter(name="quantityOfNodeSubnets")
    def quantity_of_node_subnets(self) -> Optional[pulumi.Input[int]]:
        """
        Number of node subnets (defaults to creating 1 regional subnet)
        """
        return pulumi.get(self, "quantity_of_node_subnets")

    @quantity_of_node_subnets.setter
    def quantity_of_node_subnets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quantity_of_node_subnets", value)

    @property
    @pulumi.getter(name="quantityPerSubnet")
    def quantity_per_subnet(self) -> Optional[pulumi.Input[int]]:
        """
        Number of worker nodes in each subnet / availability domain
        """
        return pulumi.get(self, "quantity_per_subnet")

    @quantity_per_subnet.setter
    def quantity_per_subnet(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quantity_per_subnet", value)

    @property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Optional specify the service CIDR, defaults to 10.96.0.0/16
        """
        return pulumi.get(self, "service_cidr")

    @service_cidr.setter
    def service_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cidr", value)

    @property
    @pulumi.getter(name="serviceDnsDomainName")
    def service_dns_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Optional name for DNS domain of service subnet
        """
        return pulumi.get(self, "service_dns_domain_name")

    @service_dns_domain_name.setter
    def service_dns_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_dns_domain_name", value)

    @property
    @pulumi.getter(name="skipVcnDelete")
    def skip_vcn_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to skip deleting VCN
        """
        return pulumi.get(self, "skip_vcn_delete")

    @skip_vcn_delete.setter
    def skip_vcn_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_vcn_delete", value)

    @property
    @pulumi.getter(name="vcnCompartmentId")
    def vcn_compartment_id(self) -> Optional[pulumi.Input[str]]:
        """
        The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        """
        return pulumi.get(self, "vcn_compartment_id")

    @vcn_compartment_id.setter
    def vcn_compartment_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn_compartment_id", value)

    @property
    @pulumi.getter(name="vcnName")
    def vcn_name(self) -> Optional[pulumi.Input[str]]:
        """
        The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        """
        return pulumi.get(self, "vcn_name")

    @vcn_name.setter
    def vcn_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcn_name", value)

    @property
    @pulumi.getter(name="workerNodeIngressCidr")
    def worker_node_ingress_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Additional CIDR from which to allow ingress to worker nodes
        """
        return pulumi.get(self, "worker_node_ingress_cidr")

    @worker_node_ingress_cidr.setter
    def worker_node_ingress_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "worker_node_ingress_cidr", value)


if not MYPY:
    class ClusterRke2ConfigArgsDict(TypedDict):
        upgrade_strategy: NotRequired[pulumi.Input['ClusterRke2ConfigUpgradeStrategyArgsDict']]
        """
        The RKE2 upgrade strategy
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The RKE2 kubernetes version
        """
elif False:
    ClusterRke2ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRke2ConfigArgs:
    def __init__(__self__, *,
                 upgrade_strategy: Optional[pulumi.Input['ClusterRke2ConfigUpgradeStrategyArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterRke2ConfigUpgradeStrategyArgs'] upgrade_strategy: The RKE2 upgrade strategy
        :param pulumi.Input[str] version: The RKE2 kubernetes version
        """
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional[pulumi.Input['ClusterRke2ConfigUpgradeStrategyArgs']]:
        """
        The RKE2 upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @upgrade_strategy.setter
    def upgrade_strategy(self, value: Optional[pulumi.Input['ClusterRke2ConfigUpgradeStrategyArgs']]):
        pulumi.set(self, "upgrade_strategy", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The RKE2 kubernetes version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ClusterRke2ConfigUpgradeStrategyArgsDict(TypedDict):
        drain_server_nodes: NotRequired[pulumi.Input[bool]]
        """
        Drain server nodes
        """
        drain_worker_nodes: NotRequired[pulumi.Input[bool]]
        """
        Drain worker nodes
        """
        server_concurrency: NotRequired[pulumi.Input[int]]
        """
        Server concurrency
        """
        worker_concurrency: NotRequired[pulumi.Input[int]]
        """
        Worker concurrency
        """
elif False:
    ClusterRke2ConfigUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRke2ConfigUpgradeStrategyArgs:
    def __init__(__self__, *,
                 drain_server_nodes: Optional[pulumi.Input[bool]] = None,
                 drain_worker_nodes: Optional[pulumi.Input[bool]] = None,
                 server_concurrency: Optional[pulumi.Input[int]] = None,
                 worker_concurrency: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] drain_server_nodes: Drain server nodes
        :param pulumi.Input[bool] drain_worker_nodes: Drain worker nodes
        :param pulumi.Input[int] server_concurrency: Server concurrency
        :param pulumi.Input[int] worker_concurrency: Worker concurrency
        """
        if drain_server_nodes is not None:
            pulumi.set(__self__, "drain_server_nodes", drain_server_nodes)
        if drain_worker_nodes is not None:
            pulumi.set(__self__, "drain_worker_nodes", drain_worker_nodes)
        if server_concurrency is not None:
            pulumi.set(__self__, "server_concurrency", server_concurrency)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)

    @property
    @pulumi.getter(name="drainServerNodes")
    def drain_server_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain server nodes
        """
        return pulumi.get(self, "drain_server_nodes")

    @drain_server_nodes.setter
    def drain_server_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain_server_nodes", value)

    @property
    @pulumi.getter(name="drainWorkerNodes")
    def drain_worker_nodes(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain worker nodes
        """
        return pulumi.get(self, "drain_worker_nodes")

    @drain_worker_nodes.setter
    def drain_worker_nodes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain_worker_nodes", value)

    @property
    @pulumi.getter(name="serverConcurrency")
    def server_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Server concurrency
        """
        return pulumi.get(self, "server_concurrency")

    @server_concurrency.setter
    def server_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "server_concurrency", value)

    @property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        Worker concurrency
        """
        return pulumi.get(self, "worker_concurrency")

    @worker_concurrency.setter
    def worker_concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "worker_concurrency", value)


if not MYPY:
    class ClusterRkeConfigArgsDict(TypedDict):
        addon_job_timeout: NotRequired[pulumi.Input[int]]
        """
        Optional duration in seconds of addon job.
        """
        addons: NotRequired[pulumi.Input[str]]
        """
        Optional addons descripton to deploy on rke cluster.
        """
        addons_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        authentication: NotRequired[pulumi.Input['ClusterRkeConfigAuthenticationArgsDict']]
        """
        Kubernetes cluster authentication
        """
        authorization: NotRequired[pulumi.Input['ClusterRkeConfigAuthorizationArgsDict']]
        """
        Kubernetes cluster authorization
        """
        bastion_host: NotRequired[pulumi.Input['ClusterRkeConfigBastionHostArgsDict']]
        """
        RKE bastion host
        """
        cloud_provider: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderArgsDict']]
        """
        RKE options for Calico network provider (string)
        """
        dns: NotRequired[pulumi.Input['ClusterRkeConfigDnsArgsDict']]
        """
        RKE dns add-on. For Rancher v2.2.x (list maxitems:1)
        """
        enable_cri_dockerd: NotRequired[pulumi.Input[bool]]
        """
        Enable/disable using cri-dockerd
        """
        ignore_docker_version: NotRequired[pulumi.Input[bool]]
        """
        Optional ignore docker version on nodes
        """
        ingress: NotRequired[pulumi.Input['ClusterRkeConfigIngressArgsDict']]
        """
        Kubernetes ingress configuration
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        Optional kubernetes version to deploy
        """
        monitoring: NotRequired[pulumi.Input['ClusterRkeConfigMonitoringArgsDict']]
        """
        Kubernetes cluster monitoring
        """
        network: NotRequired[pulumi.Input['ClusterRkeConfigNetworkArgsDict']]
        """
        Kubernetes cluster networking
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNodeArgsDict']]]]
        """
        Optional RKE cluster nodes
        """
        prefix_path: NotRequired[pulumi.Input[str]]
        """
        Optional prefix to customize kubernetes path
        """
        private_registries: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigPrivateRegistryArgsDict']]]]
        """
        Optional private registries for docker images
        """
        services: NotRequired[pulumi.Input['ClusterRkeConfigServicesArgsDict']]
        """
        Kubernetes cluster services
        """
        ssh_agent_auth: NotRequired[pulumi.Input[bool]]
        """
        Optional use ssh agent auth
        """
        ssh_cert_path: NotRequired[pulumi.Input[str]]
        """
        Optional cluster level SSH certificate path
        """
        ssh_key_path: NotRequired[pulumi.Input[str]]
        """
        Optional cluster level SSH private key path
        """
        upgrade_strategy: NotRequired[pulumi.Input['ClusterRkeConfigUpgradeStrategyArgsDict']]
        """
        RKE upgrade strategy
        """
        win_prefix_path: NotRequired[pulumi.Input[str]]
        """
        Optional prefix to customize kubernetes path for windows
        """
elif False:
    ClusterRkeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigArgs:
    def __init__(__self__, *,
                 addon_job_timeout: Optional[pulumi.Input[int]] = None,
                 addons: Optional[pulumi.Input[str]] = None,
                 addons_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 authentication: Optional[pulumi.Input['ClusterRkeConfigAuthenticationArgs']] = None,
                 authorization: Optional[pulumi.Input['ClusterRkeConfigAuthorizationArgs']] = None,
                 bastion_host: Optional[pulumi.Input['ClusterRkeConfigBastionHostArgs']] = None,
                 cloud_provider: Optional[pulumi.Input['ClusterRkeConfigCloudProviderArgs']] = None,
                 dns: Optional[pulumi.Input['ClusterRkeConfigDnsArgs']] = None,
                 enable_cri_dockerd: Optional[pulumi.Input[bool]] = None,
                 ignore_docker_version: Optional[pulumi.Input[bool]] = None,
                 ingress: Optional[pulumi.Input['ClusterRkeConfigIngressArgs']] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input['ClusterRkeConfigMonitoringArgs']] = None,
                 network: Optional[pulumi.Input['ClusterRkeConfigNetworkArgs']] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNodeArgs']]]] = None,
                 prefix_path: Optional[pulumi.Input[str]] = None,
                 private_registries: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigPrivateRegistryArgs']]]] = None,
                 services: Optional[pulumi.Input['ClusterRkeConfigServicesArgs']] = None,
                 ssh_agent_auth: Optional[pulumi.Input[bool]] = None,
                 ssh_cert_path: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None,
                 upgrade_strategy: Optional[pulumi.Input['ClusterRkeConfigUpgradeStrategyArgs']] = None,
                 win_prefix_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] addon_job_timeout: Optional duration in seconds of addon job.
        :param pulumi.Input[str] addons: Optional addons descripton to deploy on rke cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addons_includes: Optional addons yaml manisfest to deploy on rke cluster.
        :param pulumi.Input['ClusterRkeConfigAuthenticationArgs'] authentication: Kubernetes cluster authentication
        :param pulumi.Input['ClusterRkeConfigAuthorizationArgs'] authorization: Kubernetes cluster authorization
        :param pulumi.Input['ClusterRkeConfigBastionHostArgs'] bastion_host: RKE bastion host
        :param pulumi.Input['ClusterRkeConfigCloudProviderArgs'] cloud_provider: RKE options for Calico network provider (string)
        :param pulumi.Input['ClusterRkeConfigDnsArgs'] dns: RKE dns add-on. For Rancher v2.2.x (list maxitems:1)
        :param pulumi.Input[bool] enable_cri_dockerd: Enable/disable using cri-dockerd
        :param pulumi.Input[bool] ignore_docker_version: Optional ignore docker version on nodes
        :param pulumi.Input['ClusterRkeConfigIngressArgs'] ingress: Kubernetes ingress configuration
        :param pulumi.Input[str] kubernetes_version: Optional kubernetes version to deploy
        :param pulumi.Input['ClusterRkeConfigMonitoringArgs'] monitoring: Kubernetes cluster monitoring
        :param pulumi.Input['ClusterRkeConfigNetworkArgs'] network: Kubernetes cluster networking
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNodeArgs']]] nodes: Optional RKE cluster nodes
        :param pulumi.Input[str] prefix_path: Optional prefix to customize kubernetes path
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigPrivateRegistryArgs']]] private_registries: Optional private registries for docker images
        :param pulumi.Input['ClusterRkeConfigServicesArgs'] services: Kubernetes cluster services
        :param pulumi.Input[bool] ssh_agent_auth: Optional use ssh agent auth
        :param pulumi.Input[str] ssh_cert_path: Optional cluster level SSH certificate path
        :param pulumi.Input[str] ssh_key_path: Optional cluster level SSH private key path
        :param pulumi.Input['ClusterRkeConfigUpgradeStrategyArgs'] upgrade_strategy: RKE upgrade strategy
        :param pulumi.Input[str] win_prefix_path: Optional prefix to customize kubernetes path for windows
        """
        if addon_job_timeout is not None:
            pulumi.set(__self__, "addon_job_timeout", addon_job_timeout)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if addons_includes is not None:
            pulumi.set(__self__, "addons_includes", addons_includes)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if bastion_host is not None:
            pulumi.set(__self__, "bastion_host", bastion_host)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if enable_cri_dockerd is not None:
            pulumi.set(__self__, "enable_cri_dockerd", enable_cri_dockerd)
        if ignore_docker_version is not None:
            pulumi.set(__self__, "ignore_docker_version", ignore_docker_version)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if private_registries is not None:
            pulumi.set(__self__, "private_registries", private_registries)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_cert_path is not None:
            pulumi.set(__self__, "ssh_cert_path", ssh_cert_path)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if win_prefix_path is not None:
            pulumi.set(__self__, "win_prefix_path", win_prefix_path)

    @property
    @pulumi.getter(name="addonJobTimeout")
    def addon_job_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Optional duration in seconds of addon job.
        """
        return pulumi.get(self, "addon_job_timeout")

    @addon_job_timeout.setter
    def addon_job_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "addon_job_timeout", value)

    @property
    @pulumi.getter
    def addons(self) -> Optional[pulumi.Input[str]]:
        """
        Optional addons descripton to deploy on rke cluster.
        """
        return pulumi.get(self, "addons")

    @addons.setter
    def addons(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "addons", value)

    @property
    @pulumi.getter(name="addonsIncludes")
    def addons_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        return pulumi.get(self, "addons_includes")

    @addons_includes.setter
    def addons_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addons_includes", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ClusterRkeConfigAuthenticationArgs']]:
        """
        Kubernetes cluster authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ClusterRkeConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ClusterRkeConfigAuthorizationArgs']]:
        """
        Kubernetes cluster authorization
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ClusterRkeConfigAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="bastionHost")
    def bastion_host(self) -> Optional[pulumi.Input['ClusterRkeConfigBastionHostArgs']]:
        """
        RKE bastion host
        """
        return pulumi.get(self, "bastion_host")

    @bastion_host.setter
    def bastion_host(self, value: Optional[pulumi.Input['ClusterRkeConfigBastionHostArgs']]):
        pulumi.set(self, "bastion_host", value)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderArgs']]:
        """
        RKE options for Calico network provider (string)
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderArgs']]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['ClusterRkeConfigDnsArgs']]:
        """
        RKE dns add-on. For Rancher v2.2.x (list maxitems:1)
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['ClusterRkeConfigDnsArgs']]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="enableCriDockerd")
    def enable_cri_dockerd(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/disable using cri-dockerd
        """
        return pulumi.get(self, "enable_cri_dockerd")

    @enable_cri_dockerd.setter
    def enable_cri_dockerd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cri_dockerd", value)

    @property
    @pulumi.getter(name="ignoreDockerVersion")
    def ignore_docker_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional ignore docker version on nodes
        """
        return pulumi.get(self, "ignore_docker_version")

    @ignore_docker_version.setter
    def ignore_docker_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_docker_version", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['ClusterRkeConfigIngressArgs']]:
        """
        Kubernetes ingress configuration
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['ClusterRkeConfigIngressArgs']]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional kubernetes version to deploy
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['ClusterRkeConfigMonitoringArgs']]:
        """
        Kubernetes cluster monitoring
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['ClusterRkeConfigMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ClusterRkeConfigNetworkArgs']]:
        """
        Kubernetes cluster networking
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ClusterRkeConfigNetworkArgs']]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNodeArgs']]]]:
        """
        Optional RKE cluster nodes
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional prefix to customize kubernetes path
        """
        return pulumi.get(self, "prefix_path")

    @prefix_path.setter
    def prefix_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_path", value)

    @property
    @pulumi.getter(name="privateRegistries")
    def private_registries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigPrivateRegistryArgs']]]]:
        """
        Optional private registries for docker images
        """
        return pulumi.get(self, "private_registries")

    @private_registries.setter
    def private_registries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigPrivateRegistryArgs']]]]):
        pulumi.set(self, "private_registries", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesArgs']]:
        """
        Kubernetes cluster services
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesArgs']]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional use ssh agent auth
        """
        return pulumi.get(self, "ssh_agent_auth")

    @ssh_agent_auth.setter
    def ssh_agent_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssh_agent_auth", value)

    @property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional cluster level SSH certificate path
        """
        return pulumi.get(self, "ssh_cert_path")

    @ssh_cert_path.setter
    def ssh_cert_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_cert_path", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional cluster level SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)

    @property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional[pulumi.Input['ClusterRkeConfigUpgradeStrategyArgs']]:
        """
        RKE upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @upgrade_strategy.setter
    def upgrade_strategy(self, value: Optional[pulumi.Input['ClusterRkeConfigUpgradeStrategyArgs']]):
        pulumi.set(self, "upgrade_strategy", value)

    @property
    @pulumi.getter(name="winPrefixPath")
    def win_prefix_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional prefix to customize kubernetes path for windows
        """
        return pulumi.get(self, "win_prefix_path")

    @win_prefix_path.setter
    def win_prefix_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "win_prefix_path", value)


if not MYPY:
    class ClusterRkeConfigAuthenticationArgsDict(TypedDict):
        sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        RKE sans for authentication ([]string)
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Monitoring deployment update strategy (string)
        """
elif False:
    ClusterRkeConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigAuthenticationArgs:
    def __init__(__self__, *,
                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sans: RKE sans for authentication ([]string)
        :param pulumi.Input[str] strategy: Monitoring deployment update strategy (string)
        """
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        RKE sans for authentication ([]string)
        """
        return pulumi.get(self, "sans")

    @sans.setter
    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sans", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring deployment update strategy (string)
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterRkeConfigAuthorizationArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        The AKS node group mode. Default: `System` (string)
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE options for network (map)
        """
elif False:
    ClusterRkeConfigAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigAuthorizationArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] mode: The AKS node group mode. Default: `System` (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: RKE options for network (map)
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS node group mode. Default: `System` (string)
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ClusterRkeConfigBastionHostArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        Address ip for node (string)
        """
        user: pulumi.Input[str]
        """
        Registry user (string)
        """
        port: NotRequired[pulumi.Input[str]]
        """
        Port for node. Default `22` (string)
        """
        ssh_agent_auth: NotRequired[pulumi.Input[bool]]
        """
        Use ssh agent auth. Default `false` (bool)
        """
        ssh_key: NotRequired[pulumi.Input[str]]
        """
        Node SSH private key (string)
        """
        ssh_key_path: NotRequired[pulumi.Input[str]]
        """
        Node SSH private key path (string)
        """
elif False:
    ClusterRkeConfigBastionHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigBastionHostArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 user: pulumi.Input[str],
                 port: Optional[pulumi.Input[str]] = None,
                 ssh_agent_auth: Optional[pulumi.Input[bool]] = None,
                 ssh_key: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Address ip for node (string)
        :param pulumi.Input[str] user: Registry user (string)
        :param pulumi.Input[str] port: Port for node. Default `22` (string)
        :param pulumi.Input[bool] ssh_agent_auth: Use ssh agent auth. Default `false` (bool)
        :param pulumi.Input[str] ssh_key: Node SSH private key (string)
        :param pulumi.Input[str] ssh_key_path: Node SSH private key path (string)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Use ssh agent auth. Default `false` (bool)
        """
        return pulumi.get(self, "ssh_agent_auth")

    @ssh_agent_auth.setter
    def ssh_agent_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssh_agent_auth", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        Node SSH private key (string)
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        """
        Node SSH private key path (string)
        """
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderArgsDict(TypedDict):
        aws_cloud_provider: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderArgsDict']]
        """
        RKE AWS Cloud Provider config for Cloud Provider [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        """
        azure_cloud_provider: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderAzureCloudProviderArgsDict']]
        """
        RKE Azure Cloud Provider config for Cloud Provider [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        """
        custom_cloud_provider: NotRequired[pulumi.Input[str]]
        """
        RKE Custom Cloud Provider config for Cloud Provider (string)
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Cluster (string)
        """
        openstack_cloud_provider: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderArgsDict']]
        """
        RKE Openstack Cloud Provider config for Cloud Provider [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        """
        vsphere_cloud_provider: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderArgsDict']]
        """
        RKE Vsphere Cloud Provider config for Cloud Provider [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
elif False:
    ClusterRkeConfigCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderArgs:
    def __init__(__self__, *,
                 aws_cloud_provider: Optional[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderArgs']] = None,
                 azure_cloud_provider: Optional[pulumi.Input['ClusterRkeConfigCloudProviderAzureCloudProviderArgs']] = None,
                 custom_cloud_provider: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 openstack_cloud_provider: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs']] = None,
                 vsphere_cloud_provider: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderArgs']] = None):
        """
        :param pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderArgs'] aws_cloud_provider: RKE AWS Cloud Provider config for Cloud Provider [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderAzureCloudProviderArgs'] azure_cloud_provider: RKE Azure Cloud Provider config for Cloud Provider [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        :param pulumi.Input[str] custom_cloud_provider: RKE Custom Cloud Provider config for Cloud Provider (string)
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs'] openstack_cloud_provider: RKE Openstack Cloud Provider config for Cloud Provider [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderArgs'] vsphere_cloud_provider: RKE Vsphere Cloud Provider config for Cloud Provider [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
        if aws_cloud_provider is not None:
            pulumi.set(__self__, "aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_provider is not None:
            pulumi.set(__self__, "azure_cloud_provider", azure_cloud_provider)
        if custom_cloud_provider is not None:
            pulumi.set(__self__, "custom_cloud_provider", custom_cloud_provider)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if openstack_cloud_provider is not None:
            pulumi.set(__self__, "openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_provider is not None:
            pulumi.set(__self__, "vsphere_cloud_provider", vsphere_cloud_provider)

    @property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderArgs']]:
        """
        RKE AWS Cloud Provider config for Cloud Provider [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        """
        return pulumi.get(self, "aws_cloud_provider")

    @aws_cloud_provider.setter
    def aws_cloud_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderArgs']]):
        pulumi.set(self, "aws_cloud_provider", value)

    @property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderAzureCloudProviderArgs']]:
        """
        RKE Azure Cloud Provider config for Cloud Provider [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        """
        return pulumi.get(self, "azure_cloud_provider")

    @azure_cloud_provider.setter
    def azure_cloud_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderAzureCloudProviderArgs']]):
        pulumi.set(self, "azure_cloud_provider", value)

    @property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        RKE Custom Cloud Provider config for Cloud Provider (string)
        """
        return pulumi.get(self, "custom_cloud_provider")

    @custom_cloud_provider.setter
    def custom_cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_cloud_provider", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs']]:
        """
        RKE Openstack Cloud Provider config for Cloud Provider [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        """
        return pulumi.get(self, "openstack_cloud_provider")

    @openstack_cloud_provider.setter
    def openstack_cloud_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs']]):
        pulumi.set(self, "openstack_cloud_provider", value)

    @property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderArgs']]:
        """
        RKE Vsphere Cloud Provider config for Cloud Provider [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
        return pulumi.get(self, "vsphere_cloud_provider")

    @vsphere_cloud_provider.setter
    def vsphere_cloud_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderArgs']]):
        pulumi.set(self, "vsphere_cloud_provider", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderAwsCloudProviderArgsDict(TypedDict):
        global_: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict']]
        """
        (list maxitems:1)
        """
        service_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict']]]]
        """
        (list)
        """
elif False:
    ClusterRkeConfigCloudProviderAwsCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderAwsCloudProviderArgs:
    def __init__(__self__, *,
                 global_: Optional[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs']] = None,
                 service_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs'] global_: (list maxitems:1)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]] service_overrides: (list)
        """
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if service_overrides is not None:
            pulumi.set(__self__, "service_overrides", service_overrides)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs']]):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]]]:
        """
        (list)
        """
        return pulumi.get(self, "service_overrides")

    @service_overrides.setter
    def service_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]]]):
        pulumi.set(self, "service_overrides", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict(TypedDict):
        disable_security_group_ingress: NotRequired[pulumi.Input[bool]]
        """
        Default `false` (bool)
        """
        disable_strict_zone_check: NotRequired[pulumi.Input[bool]]
        """
        Default `false` (bool)
        """
        elb_security_group: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        kubernetes_cluster_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        kubernetes_cluster_tag: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        route_table_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        vpc: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        The GKE cluster zone. Required if `region` not set (string)
        """
elif False:
    ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs:
    def __init__(__self__, *,
                 disable_security_group_ingress: Optional[pulumi.Input[bool]] = None,
                 disable_strict_zone_check: Optional[pulumi.Input[bool]] = None,
                 elb_security_group: Optional[pulumi.Input[str]] = None,
                 kubernetes_cluster_id: Optional[pulumi.Input[str]] = None,
                 kubernetes_cluster_tag: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 route_table_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vpc: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_security_group_ingress: Default `false` (bool)
        :param pulumi.Input[bool] disable_strict_zone_check: Default `false` (bool)
        :param pulumi.Input[str] elb_security_group: (string)
        :param pulumi.Input[str] kubernetes_cluster_id: (string)
        :param pulumi.Input[str] kubernetes_cluster_tag: (string)
        :param pulumi.Input[str] role_arn: (string)
        :param pulumi.Input[str] route_table_id: (string)
        :param pulumi.Input[str] subnet_id: (string)
        :param pulumi.Input[str] vpc: (string)
        :param pulumi.Input[str] zone: The GKE cluster zone. Required if `region` not set (string)
        """
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            pulumi.set(__self__, "disable_strict_zone_check", disable_strict_zone_check)
        if elb_security_group is not None:
            pulumi.set(__self__, "elb_security_group", elb_security_group)
        if kubernetes_cluster_id is not None:
            pulumi.set(__self__, "kubernetes_cluster_id", kubernetes_cluster_id)
        if kubernetes_cluster_tag is not None:
            pulumi.set(__self__, "kubernetes_cluster_tag", kubernetes_cluster_tag)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[pulumi.Input[bool]]:
        """
        Default `false` (bool)
        """
        return pulumi.get(self, "disable_security_group_ingress")

    @disable_security_group_ingress.setter
    def disable_security_group_ingress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_security_group_ingress", value)

    @property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[pulumi.Input[bool]]:
        """
        Default `false` (bool)
        """
        return pulumi.get(self, "disable_strict_zone_check")

    @disable_strict_zone_check.setter
    def disable_strict_zone_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_strict_zone_check", value)

    @property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "elb_security_group")

    @elb_security_group.setter
    def elb_security_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "elb_security_group", value)

    @property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "kubernetes_cluster_id")

    @kubernetes_cluster_id.setter
    def kubernetes_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_cluster_id", value)

    @property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "kubernetes_cluster_tag")

    @kubernetes_cluster_tag.setter
    def kubernetes_cluster_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_cluster_tag", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def vpc(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE cluster zone. Required if `region` not set (string)
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict(TypedDict):
        service: pulumi.Input[str]
        """
        (string)
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        signing_method: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        signing_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        signing_region: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        url: NotRequired[pulumi.Input[str]]
        """
        Registry URL (string)
        """
elif False:
    ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 region: Optional[pulumi.Input[str]] = None,
                 signing_method: Optional[pulumi.Input[str]] = None,
                 signing_name: Optional[pulumi.Input[str]] = None,
                 signing_region: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service: (string)
        :param pulumi.Input[str] region: The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        :param pulumi.Input[str] signing_method: (string)
        :param pulumi.Input[str] signing_name: (string)
        :param pulumi.Input[str] signing_region: (string)
        :param pulumi.Input[str] url: Registry URL (string)
        """
        pulumi.set(__self__, "service", service)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if signing_method is not None:
            pulumi.set(__self__, "signing_method", signing_method)
        if signing_name is not None:
            pulumi.set(__self__, "signing_name", signing_name)
        if signing_region is not None:
            pulumi.set(__self__, "signing_region", signing_region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "signing_method")

    @signing_method.setter
    def signing_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_method", value)

    @property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "signing_name")

    @signing_name.setter
    def signing_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_name", value)

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "signing_region")

    @signing_region.setter
    def signing_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_region", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderAzureCloudProviderArgsDict(TypedDict):
        aad_client_id: pulumi.Input[str]
        """
        (string)
        """
        aad_client_secret: pulumi.Input[str]
        """
        (string)
        """
        subscription_id: pulumi.Input[str]
        """
        Subscription credentials which uniquely identify Microsoft Azure subscription (string)
        """
        tenant_id: pulumi.Input[str]
        """
        Azure tenant ID to use (string)
        """
        aad_client_cert_password: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        aad_client_cert_path: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        cloud: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        cloud_provider_backoff: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        cloud_provider_backoff_duration: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        cloud_provider_backoff_exponent: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        cloud_provider_backoff_jitter: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        cloud_provider_backoff_retries: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        cloud_provider_rate_limit: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        cloud_provider_rate_limit_bucket: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        cloud_provider_rate_limit_qps: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        load_balancer_sku: NotRequired[pulumi.Input[str]]
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Azure Kubernetes cluster location. Default `eastus` (string)
        """
        maximum_load_balancer_rule_count: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        primary_availability_set_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        primary_scale_set_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        resource_group: NotRequired[pulumi.Input[str]]
        """
        The AKS resource group (string)
        """
        route_table_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        security_group_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        subnet_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        use_instance_metadata: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        use_managed_identity_extension: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        vm_type: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        vnet_name: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        vnet_resource_group: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderAzureCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderAzureCloudProviderArgs:
    def __init__(__self__, *,
                 aad_client_id: pulumi.Input[str],
                 aad_client_secret: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 aad_client_cert_password: Optional[pulumi.Input[str]] = None,
                 aad_client_cert_path: Optional[pulumi.Input[str]] = None,
                 cloud: Optional[pulumi.Input[str]] = None,
                 cloud_provider_backoff: Optional[pulumi.Input[bool]] = None,
                 cloud_provider_backoff_duration: Optional[pulumi.Input[int]] = None,
                 cloud_provider_backoff_exponent: Optional[pulumi.Input[int]] = None,
                 cloud_provider_backoff_jitter: Optional[pulumi.Input[int]] = None,
                 cloud_provider_backoff_retries: Optional[pulumi.Input[int]] = None,
                 cloud_provider_rate_limit: Optional[pulumi.Input[bool]] = None,
                 cloud_provider_rate_limit_bucket: Optional[pulumi.Input[int]] = None,
                 cloud_provider_rate_limit_qps: Optional[pulumi.Input[int]] = None,
                 load_balancer_sku: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 maximum_load_balancer_rule_count: Optional[pulumi.Input[int]] = None,
                 primary_availability_set_name: Optional[pulumi.Input[str]] = None,
                 primary_scale_set_name: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 route_table_name: Optional[pulumi.Input[str]] = None,
                 security_group_name: Optional[pulumi.Input[str]] = None,
                 subnet_name: Optional[pulumi.Input[str]] = None,
                 use_instance_metadata: Optional[pulumi.Input[bool]] = None,
                 use_managed_identity_extension: Optional[pulumi.Input[bool]] = None,
                 vm_type: Optional[pulumi.Input[str]] = None,
                 vnet_name: Optional[pulumi.Input[str]] = None,
                 vnet_resource_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aad_client_id: (string)
        :param pulumi.Input[str] aad_client_secret: (string)
        :param pulumi.Input[str] subscription_id: Subscription credentials which uniquely identify Microsoft Azure subscription (string)
        :param pulumi.Input[str] tenant_id: Azure tenant ID to use (string)
        :param pulumi.Input[str] aad_client_cert_password: (string)
        :param pulumi.Input[str] aad_client_cert_path: (string)
        :param pulumi.Input[str] cloud: (string)
        :param pulumi.Input[bool] cloud_provider_backoff: (bool)
        :param pulumi.Input[int] cloud_provider_backoff_duration: (int)
        :param pulumi.Input[int] cloud_provider_backoff_exponent: (int)
        :param pulumi.Input[int] cloud_provider_backoff_jitter: (int)
        :param pulumi.Input[int] cloud_provider_backoff_retries: (int)
        :param pulumi.Input[bool] cloud_provider_rate_limit: (bool)
        :param pulumi.Input[int] cloud_provider_rate_limit_bucket: (int)
        :param pulumi.Input[int] cloud_provider_rate_limit_qps: (int)
        :param pulumi.Input[str] load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        :param pulumi.Input[str] location: Azure Kubernetes cluster location. Default `eastus` (string)
        :param pulumi.Input[int] maximum_load_balancer_rule_count: (int)
        :param pulumi.Input[str] primary_availability_set_name: (string)
        :param pulumi.Input[str] primary_scale_set_name: (string)
        :param pulumi.Input[str] resource_group: The AKS resource group (string)
        :param pulumi.Input[str] route_table_name: (string)
        :param pulumi.Input[str] security_group_name: (string)
        :param pulumi.Input[str] subnet_name: (string)
        :param pulumi.Input[bool] use_instance_metadata: (bool)
        :param pulumi.Input[bool] use_managed_identity_extension: (bool)
        :param pulumi.Input[str] vm_type: (string)
        :param pulumi.Input[str] vnet_name: (string)
        :param pulumi.Input[str] vnet_resource_group: (string)
        """
        pulumi.set(__self__, "aad_client_id", aad_client_id)
        pulumi.set(__self__, "aad_client_secret", aad_client_secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if aad_client_cert_password is not None:
            pulumi.set(__self__, "aad_client_cert_password", aad_client_cert_password)
        if aad_client_cert_path is not None:
            pulumi.set(__self__, "aad_client_cert_path", aad_client_cert_path)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if cloud_provider_backoff is not None:
            pulumi.set(__self__, "cloud_provider_backoff", cloud_provider_backoff)
        if cloud_provider_backoff_duration is not None:
            pulumi.set(__self__, "cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        if cloud_provider_backoff_exponent is not None:
            pulumi.set(__self__, "cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        if cloud_provider_backoff_jitter is not None:
            pulumi.set(__self__, "cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        if cloud_provider_backoff_retries is not None:
            pulumi.set(__self__, "cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        if cloud_provider_rate_limit is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit", cloud_provider_rate_limit)
        if cloud_provider_rate_limit_bucket is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        if cloud_provider_rate_limit_qps is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_load_balancer_rule_count is not None:
            pulumi.set(__self__, "maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        if primary_availability_set_name is not None:
            pulumi.set(__self__, "primary_availability_set_name", primary_availability_set_name)
        if primary_scale_set_name is not None:
            pulumi.set(__self__, "primary_scale_set_name", primary_scale_set_name)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if route_table_name is not None:
            pulumi.set(__self__, "route_table_name", route_table_name)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if use_instance_metadata is not None:
            pulumi.set(__self__, "use_instance_metadata", use_instance_metadata)
        if use_managed_identity_extension is not None:
            pulumi.set(__self__, "use_managed_identity_extension", use_managed_identity_extension)
        if vm_type is not None:
            pulumi.set(__self__, "vm_type", vm_type)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)
        if vnet_resource_group is not None:
            pulumi.set(__self__, "vnet_resource_group", vnet_resource_group)

    @property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_id")

    @aad_client_id.setter
    def aad_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aad_client_id", value)

    @property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_secret")

    @aad_client_secret.setter
    def aad_client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "aad_client_secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        """
        Subscription credentials which uniquely identify Microsoft Azure subscription (string)
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        """
        Azure tenant ID to use (string)
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_password")

    @aad_client_cert_password.setter
    def aad_client_cert_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aad_client_cert_password", value)

    @property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_path")

    @aad_client_cert_path.setter
    def aad_client_cert_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aad_client_cert_path", value)

    @property
    @pulumi.getter
    def cloud(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud", value)

    @property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_backoff")

    @cloud_provider_backoff.setter
    def cloud_provider_backoff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloud_provider_backoff", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @cloud_provider_backoff_duration.setter
    def cloud_provider_backoff_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_duration", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @cloud_provider_backoff_exponent.setter
    def cloud_provider_backoff_exponent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_exponent", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @cloud_provider_backoff_jitter.setter
    def cloud_provider_backoff_jitter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_jitter", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @cloud_provider_backoff_retries.setter
    def cloud_provider_backoff_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_retries", value)

    @property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_rate_limit")

    @cloud_provider_rate_limit.setter
    def cloud_provider_rate_limit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloud_provider_rate_limit", value)

    @property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @cloud_provider_rate_limit_bucket.setter
    def cloud_provider_rate_limit_bucket(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_rate_limit_bucket", value)

    @property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @cloud_provider_rate_limit_qps.setter
    def cloud_provider_rate_limit_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_rate_limit_qps", value)

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")

    @load_balancer_sku.setter
    def load_balancer_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_sku", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Kubernetes cluster location. Default `eastus` (string)
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @maximum_load_balancer_rule_count.setter
    def maximum_load_balancer_rule_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_load_balancer_rule_count", value)

    @property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "primary_availability_set_name")

    @primary_availability_set_name.setter
    def primary_availability_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_availability_set_name", value)

    @property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "primary_scale_set_name")

    @primary_scale_set_name.setter
    def primary_scale_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_scale_set_name", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        The AKS resource group (string)
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "route_table_name")

    @route_table_name.setter
    def route_table_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_name", value)

    @property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_name", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "use_instance_metadata")

    @use_instance_metadata.setter
    def use_instance_metadata(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_instance_metadata", value)

    @property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "use_managed_identity_extension")

    @use_managed_identity_extension.setter
    def use_managed_identity_extension(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_managed_identity_extension", value)

    @property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "vm_type")

    @vm_type.setter
    def vm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_type", value)

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_name")

    @vnet_name.setter
    def vnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_name", value)

    @property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_resource_group")

    @vnet_resource_group.setter
    def vnet_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_resource_group", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderOpenstackCloudProviderArgsDict(TypedDict):
        global_: pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict']
        """
        (list maxitems:1)
        """
        block_storage: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict']]
        """
        (list maxitems:1)
        """
        load_balancer: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict']]
        """
        (list maxitems:1)
        """
        metadata: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict']]
        """
        (list maxitems:1)
        """
        route: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict']]
        """
        (list maxitems:1)
        """
elif False:
    ClusterRkeConfigCloudProviderOpenstackCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs:
    def __init__(__self__, *,
                 global_: pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs'],
                 block_storage: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs']] = None,
                 load_balancer: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs']] = None,
                 metadata: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs']] = None,
                 route: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs']] = None):
        """
        :param pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs'] global_: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs'] block_storage: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs'] load_balancer: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs'] metadata: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs'] route: (list maxitems:1)
        """
        pulumi.set(__self__, "global_", global_)
        if block_storage is not None:
            pulumi.set(__self__, "block_storage", block_storage)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs']):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "block_storage")

    @block_storage.setter
    def block_storage(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs']]):
        pulumi.set(self, "block_storage", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs']]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs']]):
        pulumi.set(self, "route", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict(TypedDict):
        bs_version: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        ignore_volume_az: NotRequired[pulumi.Input[bool]]
        """
        (string)
        """
        trust_device_path: NotRequired[pulumi.Input[bool]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs:
    def __init__(__self__, *,
                 bs_version: Optional[pulumi.Input[str]] = None,
                 ignore_volume_az: Optional[pulumi.Input[bool]] = None,
                 trust_device_path: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bs_version: (string)
        :param pulumi.Input[bool] ignore_volume_az: (string)
        :param pulumi.Input[bool] trust_device_path: (string)
        """
        if bs_version is not None:
            pulumi.set(__self__, "bs_version", bs_version)
        if ignore_volume_az is not None:
            pulumi.set(__self__, "ignore_volume_az", ignore_volume_az)
        if trust_device_path is not None:
            pulumi.set(__self__, "trust_device_path", trust_device_path)

    @property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "bs_version")

    @bs_version.setter
    def bs_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bs_version", value)

    @property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> Optional[pulumi.Input[bool]]:
        """
        (string)
        """
        return pulumi.get(self, "ignore_volume_az")

    @ignore_volume_az.setter
    def ignore_volume_az(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_volume_az", value)

    @property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> Optional[pulumi.Input[bool]]:
        """
        (string)
        """
        return pulumi.get(self, "trust_device_path")

    @trust_device_path.setter
    def trust_device_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trust_device_path", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict(TypedDict):
        auth_url: pulumi.Input[str]
        """
        (string)
        """
        password: pulumi.Input[str]
        """
        Registry password (string)
        """
        username: pulumi.Input[str]
        """
        (string)
        """
        ca_file: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        domain_id: NotRequired[pulumi.Input[str]]
        """
        Required if `domain_name` not provided. (string)
        """
        domain_name: NotRequired[pulumi.Input[str]]
        """
        Required if `domain_id` not provided. (string)
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        Azure tenant ID to use (string)
        """
        tenant_name: NotRequired[pulumi.Input[str]]
        """
        Required if `tenant_id` not provided. (string)
        """
        trust_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs:
    def __init__(__self__, *,
                 auth_url: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 ca_file: Optional[pulumi.Input[str]] = None,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 tenant_name: Optional[pulumi.Input[str]] = None,
                 trust_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_url: (string)
        :param pulumi.Input[str] password: Registry password (string)
        :param pulumi.Input[str] username: (string)
        :param pulumi.Input[str] ca_file: (string)
        :param pulumi.Input[str] domain_id: Required if `domain_name` not provided. (string)
        :param pulumi.Input[str] domain_name: Required if `domain_id` not provided. (string)
        :param pulumi.Input[str] region: The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        :param pulumi.Input[str] tenant_id: Azure tenant ID to use (string)
        :param pulumi.Input[str] tenant_name: Required if `tenant_id` not provided. (string)
        :param pulumi.Input[str] trust_id: (string)
        """
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if trust_id is not None:
            pulumi.set(__self__, "trust_id", trust_id)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `domain_name` not provided. (string)
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `domain_id` not provided. (string)
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure tenant ID to use (string)
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[str]]:
        """
        Required if `tenant_id` not provided. (string)
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_name", value)

    @property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "trust_id")

    @trust_id.setter
    def trust_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trust_id", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict(TypedDict):
        create_monitor: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        floating_network_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        lb_method: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        lb_provider: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        lb_version: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        manage_security_groups: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        monitor_delay: NotRequired[pulumi.Input[str]]
        """
        Default `60s` (string)
        """
        monitor_max_retries: NotRequired[pulumi.Input[int]]
        """
        Default 5 (int)
        """
        monitor_timeout: NotRequired[pulumi.Input[str]]
        """
        Default `30s` (string)
        """
        subnet_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        use_octavia: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
elif False:
    ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs:
    def __init__(__self__, *,
                 create_monitor: Optional[pulumi.Input[bool]] = None,
                 floating_network_id: Optional[pulumi.Input[str]] = None,
                 lb_method: Optional[pulumi.Input[str]] = None,
                 lb_provider: Optional[pulumi.Input[str]] = None,
                 lb_version: Optional[pulumi.Input[str]] = None,
                 manage_security_groups: Optional[pulumi.Input[bool]] = None,
                 monitor_delay: Optional[pulumi.Input[str]] = None,
                 monitor_max_retries: Optional[pulumi.Input[int]] = None,
                 monitor_timeout: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 use_octavia: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] create_monitor: (bool)
        :param pulumi.Input[str] floating_network_id: (string)
        :param pulumi.Input[str] lb_method: (string)
        :param pulumi.Input[str] lb_provider: (string)
        :param pulumi.Input[str] lb_version: (string)
        :param pulumi.Input[bool] manage_security_groups: (bool)
        :param pulumi.Input[str] monitor_delay: Default `60s` (string)
        :param pulumi.Input[int] monitor_max_retries: Default 5 (int)
        :param pulumi.Input[str] monitor_timeout: Default `30s` (string)
        :param pulumi.Input[str] subnet_id: (string)
        :param pulumi.Input[bool] use_octavia: (bool)
        """
        if create_monitor is not None:
            pulumi.set(__self__, "create_monitor", create_monitor)
        if floating_network_id is not None:
            pulumi.set(__self__, "floating_network_id", floating_network_id)
        if lb_method is not None:
            pulumi.set(__self__, "lb_method", lb_method)
        if lb_provider is not None:
            pulumi.set(__self__, "lb_provider", lb_provider)
        if lb_version is not None:
            pulumi.set(__self__, "lb_version", lb_version)
        if manage_security_groups is not None:
            pulumi.set(__self__, "manage_security_groups", manage_security_groups)
        if monitor_delay is not None:
            pulumi.set(__self__, "monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            pulumi.set(__self__, "monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if use_octavia is not None:
            pulumi.set(__self__, "use_octavia", use_octavia)

    @property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "create_monitor")

    @create_monitor.setter
    def create_monitor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_monitor", value)

    @property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "floating_network_id")

    @floating_network_id.setter
    def floating_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "floating_network_id", value)

    @property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "lb_method")

    @lb_method.setter
    def lb_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_method", value)

    @property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "lb_provider")

    @lb_provider.setter
    def lb_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_provider", value)

    @property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "lb_version")

    @lb_version.setter
    def lb_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_version", value)

    @property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "manage_security_groups")

    @manage_security_groups.setter
    def manage_security_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manage_security_groups", value)

    @property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[pulumi.Input[str]]:
        """
        Default `60s` (string)
        """
        return pulumi.get(self, "monitor_delay")

    @monitor_delay.setter
    def monitor_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor_delay", value)

    @property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Default 5 (int)
        """
        return pulumi.get(self, "monitor_max_retries")

    @monitor_max_retries.setter
    def monitor_max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_max_retries", value)

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Default `30s` (string)
        """
        return pulumi.get(self, "monitor_timeout")

    @monitor_timeout.setter
    def monitor_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor_timeout", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "use_octavia")

    @use_octavia.setter
    def use_octavia(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_octavia", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict(TypedDict):
        request_timeout: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        search_order: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs:
    def __init__(__self__, *,
                 request_timeout: Optional[pulumi.Input[int]] = None,
                 search_order: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] request_timeout: (int)
        :param pulumi.Input[str] search_order: (string)
        """
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if search_order is not None:
            pulumi.set(__self__, "search_order", search_order)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout", value)

    @property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "search_order")

    @search_order.setter
    def search_order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_order", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict(TypedDict):
        router_id: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs:
    def __init__(__self__, *,
                 router_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] router_id: (string)
        """
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "router_id", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderVsphereCloudProviderArgsDict(TypedDict):
        virtual_centers: pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict']]]
        """
        (List)
        """
        workspace: pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict']
        """
        (list maxitems:1)
        """
        disk: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict']]
        """
        (list maxitems:1)
        """
        global_: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict']]
        """
        (list maxitems:1)
        """
        network: NotRequired[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict']]
        """
        The GKE cluster network. Required for create new cluster (string)
        """
elif False:
    ClusterRkeConfigCloudProviderVsphereCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderArgs:
    def __init__(__self__, *,
                 virtual_centers: pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]],
                 workspace: pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs'],
                 disk: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs']] = None,
                 global_: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs']] = None,
                 network: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]] virtual_centers: (List)
        :param pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs'] workspace: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs'] disk: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs'] global_: (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs'] network: The GKE cluster network. Required for create new cluster (string)
        """
        pulumi.set(__self__, "virtual_centers", virtual_centers)
        pulumi.set(__self__, "workspace", workspace)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]]:
        """
        (List)
        """
        return pulumi.get(self, "virtual_centers")

    @virtual_centers.setter
    def virtual_centers(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]]):
        pulumi.set(self, "virtual_centers", value)

    @property
    @pulumi.getter
    def workspace(self) -> pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs']):
        pulumi.set(self, "workspace", value)

    @property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs']]):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs']]:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs']]):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs']]:
        """
        The GKE cluster network. Required for create new cluster (string)
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs']]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict(TypedDict):
        scsi_controller_type: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs:
    def __init__(__self__, *,
                 scsi_controller_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] scsi_controller_type: (string)
        """
        if scsi_controller_type is not None:
            pulumi.set(__self__, "scsi_controller_type", scsi_controller_type)

    @property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "scsi_controller_type")

    @scsi_controller_type.setter
    def scsi_controller_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scsi_controller_type", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict(TypedDict):
        datacenters: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        graceful_shutdown_timeout: NotRequired[pulumi.Input[str]]
        insecure_flag: NotRequired[pulumi.Input[bool]]
        """
        (bool)
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Registry password (string)
        """
        port: NotRequired[pulumi.Input[str]]
        """
        Port for node. Default `22` (string)
        """
        soap_roundtrip_count: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
        user: NotRequired[pulumi.Input[str]]
        """
        Registry user (string)
        """
elif False:
    ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs:
    def __init__(__self__, *,
                 datacenters: Optional[pulumi.Input[str]] = None,
                 graceful_shutdown_timeout: Optional[pulumi.Input[str]] = None,
                 insecure_flag: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 soap_roundtrip_count: Optional[pulumi.Input[int]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datacenters: (string)
        :param pulumi.Input[bool] insecure_flag: (bool)
        :param pulumi.Input[str] password: Registry password (string)
        :param pulumi.Input[str] port: Port for node. Default `22` (string)
        :param pulumi.Input[int] soap_roundtrip_count: (int)
        :param pulumi.Input[str] user: Registry user (string)
        """
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if insecure_flag is not None:
            pulumi.set(__self__, "insecure_flag", insecure_flag)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenters", value)

    @property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "graceful_shutdown_timeout")

    @graceful_shutdown_timeout.setter
    def graceful_shutdown_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graceful_shutdown_timeout", value)

    @property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> Optional[pulumi.Input[bool]]:
        """
        (bool)
        """
        return pulumi.get(self, "insecure_flag")

    @insecure_flag.setter
    def insecure_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_flag", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")

    @soap_roundtrip_count.setter
    def soap_roundtrip_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "soap_roundtrip_count", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict(TypedDict):
        public_network: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs:
    def __init__(__self__, *,
                 public_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] public_network: (string)
        """
        if public_network is not None:
            pulumi.set(__self__, "public_network", public_network)

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "public_network")

    @public_network.setter
    def public_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_network", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict(TypedDict):
        datacenters: pulumi.Input[str]
        """
        (string)
        """
        name: pulumi.Input[str]
        """
        The name of the Cluster (string)
        """
        password: pulumi.Input[str]
        """
        Registry password (string)
        """
        user: pulumi.Input[str]
        """
        Registry user (string)
        """
        port: NotRequired[pulumi.Input[str]]
        """
        Port for node. Default `22` (string)
        """
        soap_roundtrip_count: NotRequired[pulumi.Input[int]]
        """
        (int)
        """
elif False:
    ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs:
    def __init__(__self__, *,
                 datacenters: pulumi.Input[str],
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 user: pulumi.Input[str],
                 port: Optional[pulumi.Input[str]] = None,
                 soap_roundtrip_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] datacenters: (string)
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] password: Registry password (string)
        :param pulumi.Input[str] user: Registry user (string)
        :param pulumi.Input[str] port: Port for node. Default `22` (string)
        :param pulumi.Input[int] soap_roundtrip_count: (int)
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)

    @property
    @pulumi.getter
    def datacenters(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenters", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[pulumi.Input[int]]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")

    @soap_roundtrip_count.setter
    def soap_roundtrip_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "soap_roundtrip_count", value)


if not MYPY:
    class ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict(TypedDict):
        datacenter: pulumi.Input[str]
        """
        (string)
        """
        folder: pulumi.Input[str]
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        server: pulumi.Input[str]
        """
        (string)
        """
        default_datastore: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
        resourcepool_path: NotRequired[pulumi.Input[str]]
        """
        (string)
        """
elif False:
    ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs:
    def __init__(__self__, *,
                 datacenter: pulumi.Input[str],
                 folder: pulumi.Input[str],
                 server: pulumi.Input[str],
                 default_datastore: Optional[pulumi.Input[str]] = None,
                 resourcepool_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datacenter: (string)
        :param pulumi.Input[str] folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param pulumi.Input[str] server: (string)
        :param pulumi.Input[str] default_datastore: (string)
        :param pulumi.Input[str] resourcepool_path: (string)
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "server", server)
        if default_datastore is not None:
            pulumi.set(__self__, "default_datastore", default_datastore)
        if resourcepool_path is not None:
            pulumi.set(__self__, "resourcepool_path", resourcepool_path)

    @property
    @pulumi.getter
    def datacenter(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def folder(self) -> pulumi.Input[str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: pulumi.Input[str]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        """
        (string)
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "default_datastore")

    @default_datastore.setter
    def default_datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_datastore", value)

    @property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> Optional[pulumi.Input[str]]:
        """
        (string)
        """
        return pulumi.get(self, "resourcepool_path")

    @resourcepool_path.setter
    def resourcepool_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resourcepool_path", value)


if not MYPY:
    class ClusterRkeConfigDnsArgsDict(TypedDict):
        linear_autoscaler_params: NotRequired[pulumi.Input['ClusterRkeConfigDnsLinearAutoscalerParamsArgsDict']]
        """
        Linear Autoscaler Params
        """
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE monitoring node selector (map)
        """
        nodelocal: NotRequired[pulumi.Input['ClusterRkeConfigDnsNodelocalArgsDict']]
        """
        Nodelocal dns
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE options for network (map)
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        RKE monitoring provider (string)
        """
        reverse_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        DNS add-on reverse cidr  (list)
        """
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigDnsTolerationArgsDict']]]]
        """
        DNS service tolerations
        """
        update_strategy: NotRequired[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyArgsDict']]
        """
        Update deployment strategy
        """
        upstream_nameservers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        DNS add-on upstream nameservers  (list)
        """
elif False:
    ClusterRkeConfigDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigDnsArgs:
    def __init__(__self__, *,
                 linear_autoscaler_params: Optional[pulumi.Input['ClusterRkeConfigDnsLinearAutoscalerParamsArgs']] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 nodelocal: Optional[pulumi.Input['ClusterRkeConfigDnsNodelocalArgs']] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 reverse_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigDnsTolerationArgs']]]] = None,
                 update_strategy: Optional[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyArgs']] = None,
                 upstream_nameservers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigDnsLinearAutoscalerParamsArgs'] linear_autoscaler_params: Linear Autoscaler Params
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: RKE monitoring node selector (map)
        :param pulumi.Input['ClusterRkeConfigDnsNodelocalArgs'] nodelocal: Nodelocal dns
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: RKE options for network (map)
        :param pulumi.Input[str] provider: RKE monitoring provider (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] reverse_cidrs: DNS add-on reverse cidr  (list)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigDnsTolerationArgs']]] tolerations: DNS service tolerations
        :param pulumi.Input['ClusterRkeConfigDnsUpdateStrategyArgs'] update_strategy: Update deployment strategy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] upstream_nameservers: DNS add-on upstream nameservers  (list)
        """
        if linear_autoscaler_params is not None:
            pulumi.set(__self__, "linear_autoscaler_params", linear_autoscaler_params)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if nodelocal is not None:
            pulumi.set(__self__, "nodelocal", nodelocal)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if reverse_cidrs is not None:
            pulumi.set(__self__, "reverse_cidrs", reverse_cidrs)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)
        if upstream_nameservers is not None:
            pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)

    @property
    @pulumi.getter(name="linearAutoscalerParams")
    def linear_autoscaler_params(self) -> Optional[pulumi.Input['ClusterRkeConfigDnsLinearAutoscalerParamsArgs']]:
        """
        Linear Autoscaler Params
        """
        return pulumi.get(self, "linear_autoscaler_params")

    @linear_autoscaler_params.setter
    def linear_autoscaler_params(self, value: Optional[pulumi.Input['ClusterRkeConfigDnsLinearAutoscalerParamsArgs']]):
        pulumi.set(self, "linear_autoscaler_params", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE monitoring node selector (map)
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def nodelocal(self) -> Optional[pulumi.Input['ClusterRkeConfigDnsNodelocalArgs']]:
        """
        Nodelocal dns
        """
        return pulumi.get(self, "nodelocal")

    @nodelocal.setter
    def nodelocal(self, value: Optional[pulumi.Input['ClusterRkeConfigDnsNodelocalArgs']]):
        pulumi.set(self, "nodelocal", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        RKE monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS add-on reverse cidr  (list)
        """
        return pulumi.get(self, "reverse_cidrs")

    @reverse_cidrs.setter
    def reverse_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "reverse_cidrs", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigDnsTolerationArgs']]]]:
        """
        DNS service tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigDnsTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyArgs']]:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)

    @property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS add-on upstream nameservers  (list)
        """
        return pulumi.get(self, "upstream_nameservers")

    @upstream_nameservers.setter
    def upstream_nameservers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "upstream_nameservers", value)


if not MYPY:
    class ClusterRkeConfigDnsLinearAutoscalerParamsArgsDict(TypedDict):
        cores_per_replica: NotRequired[pulumi.Input[float]]
        """
        number of replicas per cluster cores (float64)
        """
        max: NotRequired[pulumi.Input[int]]
        """
        maximum number of replicas (int64)
        """
        min: NotRequired[pulumi.Input[int]]
        """
        minimum number of replicas (int64)
        """
        nodes_per_replica: NotRequired[pulumi.Input[float]]
        """
        number of replica per cluster nodes (float64)
        """
        prevent_single_point_failure: NotRequired[pulumi.Input[bool]]
        """
        prevent single point of failure
        """
elif False:
    ClusterRkeConfigDnsLinearAutoscalerParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigDnsLinearAutoscalerParamsArgs:
    def __init__(__self__, *,
                 cores_per_replica: Optional[pulumi.Input[float]] = None,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 nodes_per_replica: Optional[pulumi.Input[float]] = None,
                 prevent_single_point_failure: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] cores_per_replica: number of replicas per cluster cores (float64)
        :param pulumi.Input[int] max: maximum number of replicas (int64)
        :param pulumi.Input[int] min: minimum number of replicas (int64)
        :param pulumi.Input[float] nodes_per_replica: number of replica per cluster nodes (float64)
        :param pulumi.Input[bool] prevent_single_point_failure: prevent single point of failure
        """
        if cores_per_replica is not None:
            pulumi.set(__self__, "cores_per_replica", cores_per_replica)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if nodes_per_replica is not None:
            pulumi.set(__self__, "nodes_per_replica", nodes_per_replica)
        if prevent_single_point_failure is not None:
            pulumi.set(__self__, "prevent_single_point_failure", prevent_single_point_failure)

    @property
    @pulumi.getter(name="coresPerReplica")
    def cores_per_replica(self) -> Optional[pulumi.Input[float]]:
        """
        number of replicas per cluster cores (float64)
        """
        return pulumi.get(self, "cores_per_replica")

    @cores_per_replica.setter
    def cores_per_replica(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cores_per_replica", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        """
        maximum number of replicas (int64)
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        """
        minimum number of replicas (int64)
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="nodesPerReplica")
    def nodes_per_replica(self) -> Optional[pulumi.Input[float]]:
        """
        number of replica per cluster nodes (float64)
        """
        return pulumi.get(self, "nodes_per_replica")

    @nodes_per_replica.setter
    def nodes_per_replica(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nodes_per_replica", value)

    @property
    @pulumi.getter(name="preventSinglePointFailure")
    def prevent_single_point_failure(self) -> Optional[pulumi.Input[bool]]:
        """
        prevent single point of failure
        """
        return pulumi.get(self, "prevent_single_point_failure")

    @prevent_single_point_failure.setter
    def prevent_single_point_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prevent_single_point_failure", value)


if not MYPY:
    class ClusterRkeConfigDnsNodelocalArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[str]]
        """
        Nodelocal dns ip address (string)
        """
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Node selector key pair
        """
elif False:
    ClusterRkeConfigDnsNodelocalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigDnsNodelocalArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] ip_address: Nodelocal dns ip address (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: Node selector key pair
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Nodelocal dns ip address (string)
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Node selector key pair
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)


if not MYPY:
    class ClusterRkeConfigDnsTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The GKE taint effect (string)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The toleration seconds (int)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterRkeConfigDnsTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigDnsTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param pulumi.Input[int] seconds: The toleration seconds (int)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterRkeConfigDnsUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgsDict']]
        """
        Rolling update for update strategy
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Strategy
        """
elif False:
    ClusterRkeConfigDnsUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigDnsUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs']] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs'] rolling_update: Rolling update for update strategy
        :param pulumi.Input[str] strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs']]:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgsDict(TypedDict):
        max_surge: NotRequired[pulumi.Input[int]]
        """
        Rolling update max surge
        """
        max_unavailable: NotRequired[pulumi.Input[int]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[int]] = None,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_surge: Rolling update max surge
        :param pulumi.Input[int] max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterRkeConfigIngressArgsDict(TypedDict):
        default_backend: NotRequired[pulumi.Input[bool]]
        """
        Enable ingress default backend. Default: `true` (bool)
        """
        dns_policy: NotRequired[pulumi.Input[str]]
        """
        Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        http_port: NotRequired[pulumi.Input[int]]
        """
        HTTP port for RKE Ingress (int)
        """
        https_port: NotRequired[pulumi.Input[int]]
        """
        HTTPS port for RKE Ingress (int)
        """
        network_mode: NotRequired[pulumi.Input[str]]
        """
        Network mode for RKE Ingress (string)
        """
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE monitoring node selector (map)
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE options for network (map)
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        RKE monitoring provider (string)
        """
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigIngressTolerationArgsDict']]]]
        """
        Ingress add-on tolerations
        """
        update_strategy: NotRequired[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyArgsDict']]
        """
        Update daemon set strategy
        """
elif False:
    ClusterRkeConfigIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigIngressArgs:
    def __init__(__self__, *,
                 default_backend: Optional[pulumi.Input[bool]] = None,
                 dns_policy: Optional[pulumi.Input[str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 http_port: Optional[pulumi.Input[int]] = None,
                 https_port: Optional[pulumi.Input[int]] = None,
                 network_mode: Optional[pulumi.Input[str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigIngressTolerationArgs']]]] = None,
                 update_strategy: Optional[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyArgs']] = None):
        """
        :param pulumi.Input[bool] default_backend: Enable ingress default backend. Default: `true` (bool)
        :param pulumi.Input[str] dns_policy: Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[int] http_port: HTTP port for RKE Ingress (int)
        :param pulumi.Input[int] https_port: HTTPS port for RKE Ingress (int)
        :param pulumi.Input[str] network_mode: Network mode for RKE Ingress (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: RKE monitoring node selector (map)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: RKE options for network (map)
        :param pulumi.Input[str] provider: RKE monitoring provider (string)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigIngressTolerationArgs']]] tolerations: Ingress add-on tolerations
        :param pulumi.Input['ClusterRkeConfigIngressUpdateStrategyArgs'] update_strategy: Update daemon set strategy
        """
        if default_backend is not None:
            pulumi.set(__self__, "default_backend", default_backend)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable ingress default backend. Default: `true` (bool)
        """
        return pulumi.get(self, "default_backend")

    @default_backend.setter
    def default_backend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default_backend", value)

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        """
        return pulumi.get(self, "dns_policy")

    @dns_policy.setter
    def dns_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_policy", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        HTTP port for RKE Ingress (int)
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[int]]:
        """
        HTTPS port for RKE Ingress (int)
        """
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_port", value)

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Network mode for RKE Ingress (string)
        """
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_mode", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE monitoring node selector (map)
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        RKE monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigIngressTolerationArgs']]]]:
        """
        Ingress add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigIngressTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyArgs']]:
        """
        Update daemon set strategy
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)


if not MYPY:
    class ClusterRkeConfigIngressTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The GKE taint effect (string)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The toleration seconds (int)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterRkeConfigIngressTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigIngressTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param pulumi.Input[int] seconds: The toleration seconds (int)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterRkeConfigIngressUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgsDict']]
        """
        Rolling update for update strategy
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Strategy
        """
elif False:
    ClusterRkeConfigIngressUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigIngressUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs']] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs'] rolling_update: Rolling update for update strategy
        :param pulumi.Input[str] strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs']]:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgsDict(TypedDict):
        max_unavailable: NotRequired[pulumi.Input[int]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_unavailable: Rolling update max unavailable
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterRkeConfigMonitoringArgsDict(TypedDict):
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE monitoring node selector (map)
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE options for network (map)
        """
        provider: NotRequired[pulumi.Input[str]]
        """
        RKE monitoring provider (string)
        """
        replicas: NotRequired[pulumi.Input[int]]
        """
        RKE monitoring replicas (int)
        """
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigMonitoringTolerationArgsDict']]]]
        """
        Monitoring add-on tolerations
        """
        update_strategy: NotRequired[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyArgsDict']]
        """
        Update deployment strategy
        """
elif False:
    ClusterRkeConfigMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigMonitoringArgs:
    def __init__(__self__, *,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigMonitoringTolerationArgs']]]] = None,
                 update_strategy: Optional[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyArgs']] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: RKE monitoring node selector (map)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: RKE options for network (map)
        :param pulumi.Input[str] provider: RKE monitoring provider (string)
        :param pulumi.Input[int] replicas: RKE monitoring replicas (int)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigMonitoringTolerationArgs']]] tolerations: Monitoring add-on tolerations
        :param pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyArgs'] update_strategy: Update deployment strategy
        """
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE monitoring node selector (map)
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        """
        RKE monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        RKE monitoring replicas (int)
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigMonitoringTolerationArgs']]]]:
        """
        Monitoring add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigMonitoringTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyArgs']]:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)


if not MYPY:
    class ClusterRkeConfigMonitoringTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The GKE taint effect (string)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The toleration seconds (int)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterRkeConfigMonitoringTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigMonitoringTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param pulumi.Input[int] seconds: The toleration seconds (int)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterRkeConfigMonitoringUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict']]
        """
        Rolling update for update strategy
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Strategy
        """
elif False:
    ClusterRkeConfigMonitoringUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigMonitoringUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs']] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs'] rolling_update: Rolling update for update strategy
        :param pulumi.Input[str] strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs']]:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict(TypedDict):
        max_surge: NotRequired[pulumi.Input[int]]
        """
        Rolling update max surge
        """
        max_unavailable: NotRequired[pulumi.Input[int]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[int]] = None,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_surge: Rolling update max surge
        :param pulumi.Input[int] max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterRkeConfigNetworkArgsDict(TypedDict):
        aci_network_provider: NotRequired[pulumi.Input['ClusterRkeConfigNetworkAciNetworkProviderArgsDict']]
        """
        ACI provider config for RKE network (list maxitems:63)
        """
        calico_network_provider: NotRequired[pulumi.Input['ClusterRkeConfigNetworkCalicoNetworkProviderArgsDict']]
        """
        Calico provider config for RKE network (list maxitems:1)
        """
        canal_network_provider: NotRequired[pulumi.Input['ClusterRkeConfigNetworkCanalNetworkProviderArgsDict']]
        """
        Canal provider config for RKE network (list maxitems:1)
        """
        flannel_network_provider: NotRequired[pulumi.Input['ClusterRkeConfigNetworkFlannelNetworkProviderArgsDict']]
        """
        Flannel provider config for RKE network (list maxitems:1)
        """
        mtu: NotRequired[pulumi.Input[int]]
        """
        Network provider MTU. Default `0` (int)
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        RKE options for network (map)
        """
        plugin: NotRequired[pulumi.Input[str]]
        """
        Plugin for RKE network. `canal` (default), `flannel`, `calico`, `none` and `weave` are supported. (string)
        """
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNetworkTolerationArgsDict']]]]
        """
        Network add-on tolerations
        """
        weave_network_provider: NotRequired[pulumi.Input['ClusterRkeConfigNetworkWeaveNetworkProviderArgsDict']]
        """
        Weave provider config for RKE network (list maxitems:1)
        """
elif False:
    ClusterRkeConfigNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkArgs:
    def __init__(__self__, *,
                 aci_network_provider: Optional[pulumi.Input['ClusterRkeConfigNetworkAciNetworkProviderArgs']] = None,
                 calico_network_provider: Optional[pulumi.Input['ClusterRkeConfigNetworkCalicoNetworkProviderArgs']] = None,
                 canal_network_provider: Optional[pulumi.Input['ClusterRkeConfigNetworkCanalNetworkProviderArgs']] = None,
                 flannel_network_provider: Optional[pulumi.Input['ClusterRkeConfigNetworkFlannelNetworkProviderArgs']] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 plugin: Optional[pulumi.Input[str]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNetworkTolerationArgs']]]] = None,
                 weave_network_provider: Optional[pulumi.Input['ClusterRkeConfigNetworkWeaveNetworkProviderArgs']] = None):
        """
        :param pulumi.Input['ClusterRkeConfigNetworkAciNetworkProviderArgs'] aci_network_provider: ACI provider config for RKE network (list maxitems:63)
        :param pulumi.Input['ClusterRkeConfigNetworkCalicoNetworkProviderArgs'] calico_network_provider: Calico provider config for RKE network (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigNetworkCanalNetworkProviderArgs'] canal_network_provider: Canal provider config for RKE network (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigNetworkFlannelNetworkProviderArgs'] flannel_network_provider: Flannel provider config for RKE network (list maxitems:1)
        :param pulumi.Input[int] mtu: Network provider MTU. Default `0` (int)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] options: RKE options for network (map)
        :param pulumi.Input[str] plugin: Plugin for RKE network. `canal` (default), `flannel`, `calico`, `none` and `weave` are supported. (string)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNetworkTolerationArgs']]] tolerations: Network add-on tolerations
        :param pulumi.Input['ClusterRkeConfigNetworkWeaveNetworkProviderArgs'] weave_network_provider: Weave provider config for RKE network (list maxitems:1)
        """
        if aci_network_provider is not None:
            pulumi.set(__self__, "aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            pulumi.set(__self__, "calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            pulumi.set(__self__, "canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            pulumi.set(__self__, "flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if weave_network_provider is not None:
            pulumi.set(__self__, "weave_network_provider", weave_network_provider)

    @property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigNetworkAciNetworkProviderArgs']]:
        """
        ACI provider config for RKE network (list maxitems:63)
        """
        return pulumi.get(self, "aci_network_provider")

    @aci_network_provider.setter
    def aci_network_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigNetworkAciNetworkProviderArgs']]):
        pulumi.set(self, "aci_network_provider", value)

    @property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigNetworkCalicoNetworkProviderArgs']]:
        """
        Calico provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "calico_network_provider")

    @calico_network_provider.setter
    def calico_network_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigNetworkCalicoNetworkProviderArgs']]):
        pulumi.set(self, "calico_network_provider", value)

    @property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigNetworkCanalNetworkProviderArgs']]:
        """
        Canal provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "canal_network_provider")

    @canal_network_provider.setter
    def canal_network_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigNetworkCanalNetworkProviderArgs']]):
        pulumi.set(self, "canal_network_provider", value)

    @property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigNetworkFlannelNetworkProviderArgs']]:
        """
        Flannel provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "flannel_network_provider")

    @flannel_network_provider.setter
    def flannel_network_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigNetworkFlannelNetworkProviderArgs']]):
        pulumi.set(self, "flannel_network_provider", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Network provider MTU. Default `0` (int)
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def plugin(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin for RKE network. `canal` (default), `flannel`, `calico`, `none` and `weave` are supported. (string)
        """
        return pulumi.get(self, "plugin")

    @plugin.setter
    def plugin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNetworkTolerationArgs']]]]:
        """
        Network add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigNetworkTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional[pulumi.Input['ClusterRkeConfigNetworkWeaveNetworkProviderArgs']]:
        """
        Weave provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "weave_network_provider")

    @weave_network_provider.setter
    def weave_network_provider(self, value: Optional[pulumi.Input['ClusterRkeConfigNetworkWeaveNetworkProviderArgs']]):
        pulumi.set(self, "weave_network_provider", value)


if not MYPY:
    class ClusterRkeConfigNetworkAciNetworkProviderArgsDict(TypedDict):
        aep: pulumi.Input[str]
        """
        Attachable entity profile (string)
        """
        apic_hosts: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of APIC hosts to connect for APIC API (list)
        """
        apic_user_crt: pulumi.Input[str]
        """
        APIC user certificate (string)
        """
        apic_user_key: pulumi.Input[str]
        """
        APIC user key (string)
        """
        apic_user_name: pulumi.Input[str]
        """
        APIC user name (string)
        """
        encap_type: pulumi.Input[str]
        """
        Encap type: vxlan or vlan (string)
        """
        extern_dynamic: pulumi.Input[str]
        """
        Subnet to use for dynamic external IPs (string)
        """
        extern_static: pulumi.Input[str]
        """
        Subnet to use for static external IPs (string)
        """
        kube_api_vlan: pulumi.Input[str]
        """
        The VLAN used by the physdom for nodes (string)
        """
        l3out: pulumi.Input[str]
        """
        L3out (string)
        """
        l3out_external_networks: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        L3out external networks (list)
        """
        mcast_range_end: pulumi.Input[str]
        """
        End of mcast range (string)
        """
        mcast_range_start: pulumi.Input[str]
        """
        Start of mcast range (string)
        """
        node_subnet: pulumi.Input[str]
        """
        Subnet to use for nodes (string)
        """
        node_svc_subnet: pulumi.Input[str]
        """
        Subnet to use for service graph (string)
        """
        service_vlan: pulumi.Input[str]
        """
        The VLAN used by LoadBalancer services (string)
        """
        system_id: pulumi.Input[str]
        """
        ACI system ID (string)
        """
        token: pulumi.Input[str]
        vrf_name: pulumi.Input[str]
        """
        VRF name (string)
        """
        vrf_tenant: pulumi.Input[str]
        """
        VRF tenant (string)
        """
        apic_refresh_ticker_adjust: NotRequired[pulumi.Input[str]]
        """
        APIC refresh ticker adjust amount (string)
        """
        apic_refresh_time: NotRequired[pulumi.Input[str]]
        """
        APIC refresh time in seconds (string)
        """
        apic_subscription_delay: NotRequired[pulumi.Input[str]]
        """
        APIC subscription delay amount (string)
        """
        capic: NotRequired[pulumi.Input[str]]
        """
        cAPIC cloud (string)
        """
        controller_log_level: NotRequired[pulumi.Input[str]]
        """
        Log level for ACI controller (string)
        """
        disable_periodic_snat_global_info_sync: NotRequired[pulumi.Input[str]]
        """
        Whether to disable periodic SNAT global info sync (string)
        """
        disable_wait_for_network: NotRequired[pulumi.Input[str]]
        """
        Whether to disable waiting for network (string)
        """
        drop_log_enable: NotRequired[pulumi.Input[str]]
        """
        Whether to enable drop log (string)
        """
        duration_wait_for_network: NotRequired[pulumi.Input[str]]
        """
        The duration to wait for network (string)
        """
        enable_endpoint_slice: NotRequired[pulumi.Input[str]]
        """
        Whether to enable endpoint slices (string)
        """
        ep_registry: NotRequired[pulumi.Input[str]]
        """
        EP registry (string)
        """
        gbp_pod_subnet: NotRequired[pulumi.Input[str]]
        """
        GBH pod subnet (string)
        """
        host_agent_log_level: NotRequired[pulumi.Input[str]]
        """
        Log level for ACI host agent (string)
        """
        image_pull_policy: NotRequired[pulumi.Input[str]]
        """
        Image pull policy (string)
        """
        image_pull_secret: NotRequired[pulumi.Input[str]]
        """
        Image pull policy (string)
        """
        infra_vlan: NotRequired[pulumi.Input[str]]
        """
        The VLAN used by ACI infra (string)
        """
        install_istio: NotRequired[pulumi.Input[str]]
        """
        Whether to install Istio (string)
        """
        istio_profile: NotRequired[pulumi.Input[str]]
        """
        Istio profile name (string)
        """
        kafka_brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Kafka broker hosts (list)
        """
        kafka_client_crt: NotRequired[pulumi.Input[str]]
        """
        Kafka client certificate (string)
        """
        kafka_client_key: NotRequired[pulumi.Input[str]]
        """
        Kafka client key (string)
        """
        max_nodes_svc_graph: NotRequired[pulumi.Input[str]]
        """
        Max nodes in service graph (string)
        """
        mtu_head_room: NotRequired[pulumi.Input[str]]
        """
        MTU head room amount (string)
        """
        multus_disable: NotRequired[pulumi.Input[str]]
        """
        Whether to disable Multus (string)
        """
        no_priority_class: NotRequired[pulumi.Input[str]]
        """
        Whether to use priority class (string)
        """
        node_pod_if_enable: NotRequired[pulumi.Input[str]]
        """
        Whether to enable node pod interface (string)
        """
        opflex_client_ssl: NotRequired[pulumi.Input[str]]
        """
        Whether to use client SSL for Opflex (string)
        """
        opflex_device_delete_timeout: NotRequired[pulumi.Input[str]]
        """
        Opflex device delete timeout (string)
        """
        opflex_log_level: NotRequired[pulumi.Input[str]]
        """
        Log level for ACI opflex (string)
        """
        opflex_mode: NotRequired[pulumi.Input[str]]
        """
        Opflex mode (string)
        """
        opflex_server_port: NotRequired[pulumi.Input[str]]
        """
        Opflex server port (string)
        """
        overlay_vrf_name: NotRequired[pulumi.Input[str]]
        """
        Overlay VRF name (string)
        """
        ovs_memory_limit: NotRequired[pulumi.Input[str]]
        """
        OVS memory limit (string)
        """
        pbr_tracking_non_snat: NotRequired[pulumi.Input[str]]
        """
        Policy-based routing tracking non snat (string)
        """
        pod_subnet_chunk_size: NotRequired[pulumi.Input[str]]
        """
        Pod subnet chunk size (string)
        """
        run_gbp_container: NotRequired[pulumi.Input[str]]
        """
        Whether to run GBP container (string)
        """
        run_opflex_server_container: NotRequired[pulumi.Input[str]]
        """
        Whether to run Opflex server container (string)
        """
        service_monitor_interval: NotRequired[pulumi.Input[str]]
        """
        Service monitor interval (string)
        """
        snat_contract_scope: NotRequired[pulumi.Input[str]]
        """
        Snat contract scope (string)
        """
        snat_namespace: NotRequired[pulumi.Input[str]]
        """
        Snat namespace (string)
        """
        snat_port_range_end: NotRequired[pulumi.Input[str]]
        """
        End of snat port range (string)
        """
        snat_port_range_start: NotRequired[pulumi.Input[str]]
        """
        End of snat port range (string)
        """
        snat_ports_per_node: NotRequired[pulumi.Input[str]]
        """
        Snat ports per node (string)
        """
        sriov_enable: NotRequired[pulumi.Input[str]]
        """
        Whether to enable SR-IOV (string)
        """
        subnet_domain_name: NotRequired[pulumi.Input[str]]
        """
        Subnet domain name (string)
        """
        tenant: NotRequired[pulumi.Input[str]]
        """
        ACI tenant (string)
        """
        use_aci_anywhere_crd: NotRequired[pulumi.Input[str]]
        """
        Whether to use ACI anywhere CRD (string)
        """
        use_aci_cni_priority_class: NotRequired[pulumi.Input[str]]
        """
        Whether to use ACI CNI priority class (string)
        """
        use_cluster_role: NotRequired[pulumi.Input[str]]
        """
        Whether to use cluster role (string)
        """
        use_host_netns_volume: NotRequired[pulumi.Input[str]]
        """
        Whether to use host netns volume (string)
        """
        use_opflex_server_volume: NotRequired[pulumi.Input[str]]
        """
        Whether use Opflex server volume (string)
        """
        use_privileged_container: NotRequired[pulumi.Input[str]]
        """
        Whether ACI containers should run as privileged (string)
        """
        vmm_controller: NotRequired[pulumi.Input[str]]
        """
        VMM controller configuration (string)
        """
        vmm_domain: NotRequired[pulumi.Input[str]]
        """
        VMM domain configuration (string)
        """
elif False:
    ClusterRkeConfigNetworkAciNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkAciNetworkProviderArgs:
    def __init__(__self__, *,
                 aep: pulumi.Input[str],
                 apic_hosts: pulumi.Input[Sequence[pulumi.Input[str]]],
                 apic_user_crt: pulumi.Input[str],
                 apic_user_key: pulumi.Input[str],
                 apic_user_name: pulumi.Input[str],
                 encap_type: pulumi.Input[str],
                 extern_dynamic: pulumi.Input[str],
                 extern_static: pulumi.Input[str],
                 kube_api_vlan: pulumi.Input[str],
                 l3out: pulumi.Input[str],
                 l3out_external_networks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 mcast_range_end: pulumi.Input[str],
                 mcast_range_start: pulumi.Input[str],
                 node_subnet: pulumi.Input[str],
                 node_svc_subnet: pulumi.Input[str],
                 service_vlan: pulumi.Input[str],
                 system_id: pulumi.Input[str],
                 token: pulumi.Input[str],
                 vrf_name: pulumi.Input[str],
                 vrf_tenant: pulumi.Input[str],
                 apic_refresh_ticker_adjust: Optional[pulumi.Input[str]] = None,
                 apic_refresh_time: Optional[pulumi.Input[str]] = None,
                 apic_subscription_delay: Optional[pulumi.Input[str]] = None,
                 capic: Optional[pulumi.Input[str]] = None,
                 controller_log_level: Optional[pulumi.Input[str]] = None,
                 disable_periodic_snat_global_info_sync: Optional[pulumi.Input[str]] = None,
                 disable_wait_for_network: Optional[pulumi.Input[str]] = None,
                 drop_log_enable: Optional[pulumi.Input[str]] = None,
                 duration_wait_for_network: Optional[pulumi.Input[str]] = None,
                 enable_endpoint_slice: Optional[pulumi.Input[str]] = None,
                 ep_registry: Optional[pulumi.Input[str]] = None,
                 gbp_pod_subnet: Optional[pulumi.Input[str]] = None,
                 host_agent_log_level: Optional[pulumi.Input[str]] = None,
                 image_pull_policy: Optional[pulumi.Input[str]] = None,
                 image_pull_secret: Optional[pulumi.Input[str]] = None,
                 infra_vlan: Optional[pulumi.Input[str]] = None,
                 install_istio: Optional[pulumi.Input[str]] = None,
                 istio_profile: Optional[pulumi.Input[str]] = None,
                 kafka_brokers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kafka_client_crt: Optional[pulumi.Input[str]] = None,
                 kafka_client_key: Optional[pulumi.Input[str]] = None,
                 max_nodes_svc_graph: Optional[pulumi.Input[str]] = None,
                 mtu_head_room: Optional[pulumi.Input[str]] = None,
                 multus_disable: Optional[pulumi.Input[str]] = None,
                 no_priority_class: Optional[pulumi.Input[str]] = None,
                 node_pod_if_enable: Optional[pulumi.Input[str]] = None,
                 opflex_client_ssl: Optional[pulumi.Input[str]] = None,
                 opflex_device_delete_timeout: Optional[pulumi.Input[str]] = None,
                 opflex_log_level: Optional[pulumi.Input[str]] = None,
                 opflex_mode: Optional[pulumi.Input[str]] = None,
                 opflex_server_port: Optional[pulumi.Input[str]] = None,
                 overlay_vrf_name: Optional[pulumi.Input[str]] = None,
                 ovs_memory_limit: Optional[pulumi.Input[str]] = None,
                 pbr_tracking_non_snat: Optional[pulumi.Input[str]] = None,
                 pod_subnet_chunk_size: Optional[pulumi.Input[str]] = None,
                 run_gbp_container: Optional[pulumi.Input[str]] = None,
                 run_opflex_server_container: Optional[pulumi.Input[str]] = None,
                 service_monitor_interval: Optional[pulumi.Input[str]] = None,
                 snat_contract_scope: Optional[pulumi.Input[str]] = None,
                 snat_namespace: Optional[pulumi.Input[str]] = None,
                 snat_port_range_end: Optional[pulumi.Input[str]] = None,
                 snat_port_range_start: Optional[pulumi.Input[str]] = None,
                 snat_ports_per_node: Optional[pulumi.Input[str]] = None,
                 sriov_enable: Optional[pulumi.Input[str]] = None,
                 subnet_domain_name: Optional[pulumi.Input[str]] = None,
                 tenant: Optional[pulumi.Input[str]] = None,
                 use_aci_anywhere_crd: Optional[pulumi.Input[str]] = None,
                 use_aci_cni_priority_class: Optional[pulumi.Input[str]] = None,
                 use_cluster_role: Optional[pulumi.Input[str]] = None,
                 use_host_netns_volume: Optional[pulumi.Input[str]] = None,
                 use_opflex_server_volume: Optional[pulumi.Input[str]] = None,
                 use_privileged_container: Optional[pulumi.Input[str]] = None,
                 vmm_controller: Optional[pulumi.Input[str]] = None,
                 vmm_domain: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aep: Attachable entity profile (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] apic_hosts: List of APIC hosts to connect for APIC API (list)
        :param pulumi.Input[str] apic_user_crt: APIC user certificate (string)
        :param pulumi.Input[str] apic_user_key: APIC user key (string)
        :param pulumi.Input[str] apic_user_name: APIC user name (string)
        :param pulumi.Input[str] encap_type: Encap type: vxlan or vlan (string)
        :param pulumi.Input[str] extern_dynamic: Subnet to use for dynamic external IPs (string)
        :param pulumi.Input[str] extern_static: Subnet to use for static external IPs (string)
        :param pulumi.Input[str] kube_api_vlan: The VLAN used by the physdom for nodes (string)
        :param pulumi.Input[str] l3out: L3out (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] l3out_external_networks: L3out external networks (list)
        :param pulumi.Input[str] mcast_range_end: End of mcast range (string)
        :param pulumi.Input[str] mcast_range_start: Start of mcast range (string)
        :param pulumi.Input[str] node_subnet: Subnet to use for nodes (string)
        :param pulumi.Input[str] node_svc_subnet: Subnet to use for service graph (string)
        :param pulumi.Input[str] service_vlan: The VLAN used by LoadBalancer services (string)
        :param pulumi.Input[str] system_id: ACI system ID (string)
        :param pulumi.Input[str] vrf_name: VRF name (string)
        :param pulumi.Input[str] vrf_tenant: VRF tenant (string)
        :param pulumi.Input[str] apic_refresh_ticker_adjust: APIC refresh ticker adjust amount (string)
        :param pulumi.Input[str] apic_refresh_time: APIC refresh time in seconds (string)
        :param pulumi.Input[str] apic_subscription_delay: APIC subscription delay amount (string)
        :param pulumi.Input[str] capic: cAPIC cloud (string)
        :param pulumi.Input[str] controller_log_level: Log level for ACI controller (string)
        :param pulumi.Input[str] disable_periodic_snat_global_info_sync: Whether to disable periodic SNAT global info sync (string)
        :param pulumi.Input[str] disable_wait_for_network: Whether to disable waiting for network (string)
        :param pulumi.Input[str] drop_log_enable: Whether to enable drop log (string)
        :param pulumi.Input[str] duration_wait_for_network: The duration to wait for network (string)
        :param pulumi.Input[str] enable_endpoint_slice: Whether to enable endpoint slices (string)
        :param pulumi.Input[str] ep_registry: EP registry (string)
        :param pulumi.Input[str] gbp_pod_subnet: GBH pod subnet (string)
        :param pulumi.Input[str] host_agent_log_level: Log level for ACI host agent (string)
        :param pulumi.Input[str] image_pull_policy: Image pull policy (string)
        :param pulumi.Input[str] image_pull_secret: Image pull policy (string)
        :param pulumi.Input[str] infra_vlan: The VLAN used by ACI infra (string)
        :param pulumi.Input[str] install_istio: Whether to install Istio (string)
        :param pulumi.Input[str] istio_profile: Istio profile name (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kafka_brokers: List of Kafka broker hosts (list)
        :param pulumi.Input[str] kafka_client_crt: Kafka client certificate (string)
        :param pulumi.Input[str] kafka_client_key: Kafka client key (string)
        :param pulumi.Input[str] max_nodes_svc_graph: Max nodes in service graph (string)
        :param pulumi.Input[str] mtu_head_room: MTU head room amount (string)
        :param pulumi.Input[str] multus_disable: Whether to disable Multus (string)
        :param pulumi.Input[str] no_priority_class: Whether to use priority class (string)
        :param pulumi.Input[str] node_pod_if_enable: Whether to enable node pod interface (string)
        :param pulumi.Input[str] opflex_client_ssl: Whether to use client SSL for Opflex (string)
        :param pulumi.Input[str] opflex_device_delete_timeout: Opflex device delete timeout (string)
        :param pulumi.Input[str] opflex_log_level: Log level for ACI opflex (string)
        :param pulumi.Input[str] opflex_mode: Opflex mode (string)
        :param pulumi.Input[str] opflex_server_port: Opflex server port (string)
        :param pulumi.Input[str] overlay_vrf_name: Overlay VRF name (string)
        :param pulumi.Input[str] ovs_memory_limit: OVS memory limit (string)
        :param pulumi.Input[str] pbr_tracking_non_snat: Policy-based routing tracking non snat (string)
        :param pulumi.Input[str] pod_subnet_chunk_size: Pod subnet chunk size (string)
        :param pulumi.Input[str] run_gbp_container: Whether to run GBP container (string)
        :param pulumi.Input[str] run_opflex_server_container: Whether to run Opflex server container (string)
        :param pulumi.Input[str] service_monitor_interval: Service monitor interval (string)
        :param pulumi.Input[str] snat_contract_scope: Snat contract scope (string)
        :param pulumi.Input[str] snat_namespace: Snat namespace (string)
        :param pulumi.Input[str] snat_port_range_end: End of snat port range (string)
        :param pulumi.Input[str] snat_port_range_start: End of snat port range (string)
        :param pulumi.Input[str] snat_ports_per_node: Snat ports per node (string)
        :param pulumi.Input[str] sriov_enable: Whether to enable SR-IOV (string)
        :param pulumi.Input[str] subnet_domain_name: Subnet domain name (string)
        :param pulumi.Input[str] tenant: ACI tenant (string)
        :param pulumi.Input[str] use_aci_anywhere_crd: Whether to use ACI anywhere CRD (string)
        :param pulumi.Input[str] use_aci_cni_priority_class: Whether to use ACI CNI priority class (string)
        :param pulumi.Input[str] use_cluster_role: Whether to use cluster role (string)
        :param pulumi.Input[str] use_host_netns_volume: Whether to use host netns volume (string)
        :param pulumi.Input[str] use_opflex_server_volume: Whether use Opflex server volume (string)
        :param pulumi.Input[str] use_privileged_container: Whether ACI containers should run as privileged (string)
        :param pulumi.Input[str] vmm_controller: VMM controller configuration (string)
        :param pulumi.Input[str] vmm_domain: VMM domain configuration (string)
        """
        pulumi.set(__self__, "aep", aep)
        pulumi.set(__self__, "apic_hosts", apic_hosts)
        pulumi.set(__self__, "apic_user_crt", apic_user_crt)
        pulumi.set(__self__, "apic_user_key", apic_user_key)
        pulumi.set(__self__, "apic_user_name", apic_user_name)
        pulumi.set(__self__, "encap_type", encap_type)
        pulumi.set(__self__, "extern_dynamic", extern_dynamic)
        pulumi.set(__self__, "extern_static", extern_static)
        pulumi.set(__self__, "kube_api_vlan", kube_api_vlan)
        pulumi.set(__self__, "l3out", l3out)
        pulumi.set(__self__, "l3out_external_networks", l3out_external_networks)
        pulumi.set(__self__, "mcast_range_end", mcast_range_end)
        pulumi.set(__self__, "mcast_range_start", mcast_range_start)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "node_svc_subnet", node_svc_subnet)
        pulumi.set(__self__, "service_vlan", service_vlan)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "vrf_name", vrf_name)
        pulumi.set(__self__, "vrf_tenant", vrf_tenant)
        if apic_refresh_ticker_adjust is not None:
            pulumi.set(__self__, "apic_refresh_ticker_adjust", apic_refresh_ticker_adjust)
        if apic_refresh_time is not None:
            pulumi.set(__self__, "apic_refresh_time", apic_refresh_time)
        if apic_subscription_delay is not None:
            pulumi.set(__self__, "apic_subscription_delay", apic_subscription_delay)
        if capic is not None:
            pulumi.set(__self__, "capic", capic)
        if controller_log_level is not None:
            pulumi.set(__self__, "controller_log_level", controller_log_level)
        if disable_periodic_snat_global_info_sync is not None:
            pulumi.set(__self__, "disable_periodic_snat_global_info_sync", disable_periodic_snat_global_info_sync)
        if disable_wait_for_network is not None:
            pulumi.set(__self__, "disable_wait_for_network", disable_wait_for_network)
        if drop_log_enable is not None:
            pulumi.set(__self__, "drop_log_enable", drop_log_enable)
        if duration_wait_for_network is not None:
            pulumi.set(__self__, "duration_wait_for_network", duration_wait_for_network)
        if enable_endpoint_slice is not None:
            pulumi.set(__self__, "enable_endpoint_slice", enable_endpoint_slice)
        if ep_registry is not None:
            pulumi.set(__self__, "ep_registry", ep_registry)
        if gbp_pod_subnet is not None:
            pulumi.set(__self__, "gbp_pod_subnet", gbp_pod_subnet)
        if host_agent_log_level is not None:
            pulumi.set(__self__, "host_agent_log_level", host_agent_log_level)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if infra_vlan is not None:
            pulumi.set(__self__, "infra_vlan", infra_vlan)
        if install_istio is not None:
            pulumi.set(__self__, "install_istio", install_istio)
        if istio_profile is not None:
            pulumi.set(__self__, "istio_profile", istio_profile)
        if kafka_brokers is not None:
            pulumi.set(__self__, "kafka_brokers", kafka_brokers)
        if kafka_client_crt is not None:
            pulumi.set(__self__, "kafka_client_crt", kafka_client_crt)
        if kafka_client_key is not None:
            pulumi.set(__self__, "kafka_client_key", kafka_client_key)
        if max_nodes_svc_graph is not None:
            pulumi.set(__self__, "max_nodes_svc_graph", max_nodes_svc_graph)
        if mtu_head_room is not None:
            pulumi.set(__self__, "mtu_head_room", mtu_head_room)
        if multus_disable is not None:
            pulumi.set(__self__, "multus_disable", multus_disable)
        if no_priority_class is not None:
            pulumi.set(__self__, "no_priority_class", no_priority_class)
        if node_pod_if_enable is not None:
            pulumi.set(__self__, "node_pod_if_enable", node_pod_if_enable)
        if opflex_client_ssl is not None:
            pulumi.set(__self__, "opflex_client_ssl", opflex_client_ssl)
        if opflex_device_delete_timeout is not None:
            pulumi.set(__self__, "opflex_device_delete_timeout", opflex_device_delete_timeout)
        if opflex_log_level is not None:
            pulumi.set(__self__, "opflex_log_level", opflex_log_level)
        if opflex_mode is not None:
            pulumi.set(__self__, "opflex_mode", opflex_mode)
        if opflex_server_port is not None:
            pulumi.set(__self__, "opflex_server_port", opflex_server_port)
        if overlay_vrf_name is not None:
            pulumi.set(__self__, "overlay_vrf_name", overlay_vrf_name)
        if ovs_memory_limit is not None:
            pulumi.set(__self__, "ovs_memory_limit", ovs_memory_limit)
        if pbr_tracking_non_snat is not None:
            pulumi.set(__self__, "pbr_tracking_non_snat", pbr_tracking_non_snat)
        if pod_subnet_chunk_size is not None:
            pulumi.set(__self__, "pod_subnet_chunk_size", pod_subnet_chunk_size)
        if run_gbp_container is not None:
            pulumi.set(__self__, "run_gbp_container", run_gbp_container)
        if run_opflex_server_container is not None:
            pulumi.set(__self__, "run_opflex_server_container", run_opflex_server_container)
        if service_monitor_interval is not None:
            pulumi.set(__self__, "service_monitor_interval", service_monitor_interval)
        if snat_contract_scope is not None:
            pulumi.set(__self__, "snat_contract_scope", snat_contract_scope)
        if snat_namespace is not None:
            pulumi.set(__self__, "snat_namespace", snat_namespace)
        if snat_port_range_end is not None:
            pulumi.set(__self__, "snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            pulumi.set(__self__, "snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            pulumi.set(__self__, "snat_ports_per_node", snat_ports_per_node)
        if sriov_enable is not None:
            pulumi.set(__self__, "sriov_enable", sriov_enable)
        if subnet_domain_name is not None:
            pulumi.set(__self__, "subnet_domain_name", subnet_domain_name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if use_aci_anywhere_crd is not None:
            pulumi.set(__self__, "use_aci_anywhere_crd", use_aci_anywhere_crd)
        if use_aci_cni_priority_class is not None:
            pulumi.set(__self__, "use_aci_cni_priority_class", use_aci_cni_priority_class)
        if use_cluster_role is not None:
            pulumi.set(__self__, "use_cluster_role", use_cluster_role)
        if use_host_netns_volume is not None:
            pulumi.set(__self__, "use_host_netns_volume", use_host_netns_volume)
        if use_opflex_server_volume is not None:
            pulumi.set(__self__, "use_opflex_server_volume", use_opflex_server_volume)
        if use_privileged_container is not None:
            pulumi.set(__self__, "use_privileged_container", use_privileged_container)
        if vmm_controller is not None:
            pulumi.set(__self__, "vmm_controller", vmm_controller)
        if vmm_domain is not None:
            pulumi.set(__self__, "vmm_domain", vmm_domain)

    @property
    @pulumi.getter
    def aep(self) -> pulumi.Input[str]:
        """
        Attachable entity profile (string)
        """
        return pulumi.get(self, "aep")

    @aep.setter
    def aep(self, value: pulumi.Input[str]):
        pulumi.set(self, "aep", value)

    @property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of APIC hosts to connect for APIC API (list)
        """
        return pulumi.get(self, "apic_hosts")

    @apic_hosts.setter
    def apic_hosts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "apic_hosts", value)

    @property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> pulumi.Input[str]:
        """
        APIC user certificate (string)
        """
        return pulumi.get(self, "apic_user_crt")

    @apic_user_crt.setter
    def apic_user_crt(self, value: pulumi.Input[str]):
        pulumi.set(self, "apic_user_crt", value)

    @property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> pulumi.Input[str]:
        """
        APIC user key (string)
        """
        return pulumi.get(self, "apic_user_key")

    @apic_user_key.setter
    def apic_user_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "apic_user_key", value)

    @property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> pulumi.Input[str]:
        """
        APIC user name (string)
        """
        return pulumi.get(self, "apic_user_name")

    @apic_user_name.setter
    def apic_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "apic_user_name", value)

    @property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> pulumi.Input[str]:
        """
        Encap type: vxlan or vlan (string)
        """
        return pulumi.get(self, "encap_type")

    @encap_type.setter
    def encap_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "encap_type", value)

    @property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> pulumi.Input[str]:
        """
        Subnet to use for dynamic external IPs (string)
        """
        return pulumi.get(self, "extern_dynamic")

    @extern_dynamic.setter
    def extern_dynamic(self, value: pulumi.Input[str]):
        pulumi.set(self, "extern_dynamic", value)

    @property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> pulumi.Input[str]:
        """
        Subnet to use for static external IPs (string)
        """
        return pulumi.get(self, "extern_static")

    @extern_static.setter
    def extern_static(self, value: pulumi.Input[str]):
        pulumi.set(self, "extern_static", value)

    @property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> pulumi.Input[str]:
        """
        The VLAN used by the physdom for nodes (string)
        """
        return pulumi.get(self, "kube_api_vlan")

    @kube_api_vlan.setter
    def kube_api_vlan(self, value: pulumi.Input[str]):
        pulumi.set(self, "kube_api_vlan", value)

    @property
    @pulumi.getter
    def l3out(self) -> pulumi.Input[str]:
        """
        L3out (string)
        """
        return pulumi.get(self, "l3out")

    @l3out.setter
    def l3out(self, value: pulumi.Input[str]):
        pulumi.set(self, "l3out", value)

    @property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        L3out external networks (list)
        """
        return pulumi.get(self, "l3out_external_networks")

    @l3out_external_networks.setter
    def l3out_external_networks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "l3out_external_networks", value)

    @property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> pulumi.Input[str]:
        """
        End of mcast range (string)
        """
        return pulumi.get(self, "mcast_range_end")

    @mcast_range_end.setter
    def mcast_range_end(self, value: pulumi.Input[str]):
        pulumi.set(self, "mcast_range_end", value)

    @property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> pulumi.Input[str]:
        """
        Start of mcast range (string)
        """
        return pulumi.get(self, "mcast_range_start")

    @mcast_range_start.setter
    def mcast_range_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "mcast_range_start", value)

    @property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> pulumi.Input[str]:
        """
        Subnet to use for nodes (string)
        """
        return pulumi.get(self, "node_subnet")

    @node_subnet.setter
    def node_subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_subnet", value)

    @property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> pulumi.Input[str]:
        """
        Subnet to use for service graph (string)
        """
        return pulumi.get(self, "node_svc_subnet")

    @node_svc_subnet.setter
    def node_svc_subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_svc_subnet", value)

    @property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> pulumi.Input[str]:
        """
        The VLAN used by LoadBalancer services (string)
        """
        return pulumi.get(self, "service_vlan")

    @service_vlan.setter
    def service_vlan(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_vlan", value)

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> pulumi.Input[str]:
        """
        ACI system ID (string)
        """
        return pulumi.get(self, "system_id")

    @system_id.setter
    def system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_id", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> pulumi.Input[str]:
        """
        VRF name (string)
        """
        return pulumi.get(self, "vrf_name")

    @vrf_name.setter
    def vrf_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vrf_name", value)

    @property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> pulumi.Input[str]:
        """
        VRF tenant (string)
        """
        return pulumi.get(self, "vrf_tenant")

    @vrf_tenant.setter
    def vrf_tenant(self, value: pulumi.Input[str]):
        pulumi.set(self, "vrf_tenant", value)

    @property
    @pulumi.getter(name="apicRefreshTickerAdjust")
    def apic_refresh_ticker_adjust(self) -> Optional[pulumi.Input[str]]:
        """
        APIC refresh ticker adjust amount (string)
        """
        return pulumi.get(self, "apic_refresh_ticker_adjust")

    @apic_refresh_ticker_adjust.setter
    def apic_refresh_ticker_adjust(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apic_refresh_ticker_adjust", value)

    @property
    @pulumi.getter(name="apicRefreshTime")
    def apic_refresh_time(self) -> Optional[pulumi.Input[str]]:
        """
        APIC refresh time in seconds (string)
        """
        return pulumi.get(self, "apic_refresh_time")

    @apic_refresh_time.setter
    def apic_refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apic_refresh_time", value)

    @property
    @pulumi.getter(name="apicSubscriptionDelay")
    def apic_subscription_delay(self) -> Optional[pulumi.Input[str]]:
        """
        APIC subscription delay amount (string)
        """
        return pulumi.get(self, "apic_subscription_delay")

    @apic_subscription_delay.setter
    def apic_subscription_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apic_subscription_delay", value)

    @property
    @pulumi.getter
    def capic(self) -> Optional[pulumi.Input[str]]:
        """
        cAPIC cloud (string)
        """
        return pulumi.get(self, "capic")

    @capic.setter
    def capic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capic", value)

    @property
    @pulumi.getter(name="controllerLogLevel")
    def controller_log_level(self) -> Optional[pulumi.Input[str]]:
        """
        Log level for ACI controller (string)
        """
        return pulumi.get(self, "controller_log_level")

    @controller_log_level.setter
    def controller_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_log_level", value)

    @property
    @pulumi.getter(name="disablePeriodicSnatGlobalInfoSync")
    def disable_periodic_snat_global_info_sync(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to disable periodic SNAT global info sync (string)
        """
        return pulumi.get(self, "disable_periodic_snat_global_info_sync")

    @disable_periodic_snat_global_info_sync.setter
    def disable_periodic_snat_global_info_sync(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disable_periodic_snat_global_info_sync", value)

    @property
    @pulumi.getter(name="disableWaitForNetwork")
    def disable_wait_for_network(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to disable waiting for network (string)
        """
        return pulumi.get(self, "disable_wait_for_network")

    @disable_wait_for_network.setter
    def disable_wait_for_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disable_wait_for_network", value)

    @property
    @pulumi.getter(name="dropLogEnable")
    def drop_log_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable drop log (string)
        """
        return pulumi.get(self, "drop_log_enable")

    @drop_log_enable.setter
    def drop_log_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drop_log_enable", value)

    @property
    @pulumi.getter(name="durationWaitForNetwork")
    def duration_wait_for_network(self) -> Optional[pulumi.Input[str]]:
        """
        The duration to wait for network (string)
        """
        return pulumi.get(self, "duration_wait_for_network")

    @duration_wait_for_network.setter
    def duration_wait_for_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration_wait_for_network", value)

    @property
    @pulumi.getter(name="enableEndpointSlice")
    def enable_endpoint_slice(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable endpoint slices (string)
        """
        return pulumi.get(self, "enable_endpoint_slice")

    @enable_endpoint_slice.setter
    def enable_endpoint_slice(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_endpoint_slice", value)

    @property
    @pulumi.getter(name="epRegistry")
    def ep_registry(self) -> Optional[pulumi.Input[str]]:
        """
        EP registry (string)
        """
        return pulumi.get(self, "ep_registry")

    @ep_registry.setter
    def ep_registry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ep_registry", value)

    @property
    @pulumi.getter(name="gbpPodSubnet")
    def gbp_pod_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        GBH pod subnet (string)
        """
        return pulumi.get(self, "gbp_pod_subnet")

    @gbp_pod_subnet.setter
    def gbp_pod_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gbp_pod_subnet", value)

    @property
    @pulumi.getter(name="hostAgentLogLevel")
    def host_agent_log_level(self) -> Optional[pulumi.Input[str]]:
        """
        Log level for ACI host agent (string)
        """
        return pulumi.get(self, "host_agent_log_level")

    @host_agent_log_level.setter
    def host_agent_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_agent_log_level", value)

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Image pull policy (string)
        """
        return pulumi.get(self, "image_pull_policy")

    @image_pull_policy.setter
    def image_pull_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_pull_policy", value)

    @property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Image pull policy (string)
        """
        return pulumi.get(self, "image_pull_secret")

    @image_pull_secret.setter
    def image_pull_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_pull_secret", value)

    @property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> Optional[pulumi.Input[str]]:
        """
        The VLAN used by ACI infra (string)
        """
        return pulumi.get(self, "infra_vlan")

    @infra_vlan.setter
    def infra_vlan(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "infra_vlan", value)

    @property
    @pulumi.getter(name="installIstio")
    def install_istio(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to install Istio (string)
        """
        return pulumi.get(self, "install_istio")

    @install_istio.setter
    def install_istio(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_istio", value)

    @property
    @pulumi.getter(name="istioProfile")
    def istio_profile(self) -> Optional[pulumi.Input[str]]:
        """
        Istio profile name (string)
        """
        return pulumi.get(self, "istio_profile")

    @istio_profile.setter
    def istio_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "istio_profile", value)

    @property
    @pulumi.getter(name="kafkaBrokers")
    def kafka_brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Kafka broker hosts (list)
        """
        return pulumi.get(self, "kafka_brokers")

    @kafka_brokers.setter
    def kafka_brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kafka_brokers", value)

    @property
    @pulumi.getter(name="kafkaClientCrt")
    def kafka_client_crt(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka client certificate (string)
        """
        return pulumi.get(self, "kafka_client_crt")

    @kafka_client_crt.setter
    def kafka_client_crt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_client_crt", value)

    @property
    @pulumi.getter(name="kafkaClientKey")
    def kafka_client_key(self) -> Optional[pulumi.Input[str]]:
        """
        Kafka client key (string)
        """
        return pulumi.get(self, "kafka_client_key")

    @kafka_client_key.setter
    def kafka_client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_client_key", value)

    @property
    @pulumi.getter(name="maxNodesSvcGraph")
    def max_nodes_svc_graph(self) -> Optional[pulumi.Input[str]]:
        """
        Max nodes in service graph (string)
        """
        return pulumi.get(self, "max_nodes_svc_graph")

    @max_nodes_svc_graph.setter
    def max_nodes_svc_graph(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_nodes_svc_graph", value)

    @property
    @pulumi.getter(name="mtuHeadRoom")
    def mtu_head_room(self) -> Optional[pulumi.Input[str]]:
        """
        MTU head room amount (string)
        """
        return pulumi.get(self, "mtu_head_room")

    @mtu_head_room.setter
    def mtu_head_room(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mtu_head_room", value)

    @property
    @pulumi.getter(name="multusDisable")
    def multus_disable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to disable Multus (string)
        """
        return pulumi.get(self, "multus_disable")

    @multus_disable.setter
    def multus_disable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multus_disable", value)

    @property
    @pulumi.getter(name="noPriorityClass")
    def no_priority_class(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use priority class (string)
        """
        return pulumi.get(self, "no_priority_class")

    @no_priority_class.setter
    def no_priority_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_priority_class", value)

    @property
    @pulumi.getter(name="nodePodIfEnable")
    def node_pod_if_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable node pod interface (string)
        """
        return pulumi.get(self, "node_pod_if_enable")

    @node_pod_if_enable.setter
    def node_pod_if_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pod_if_enable", value)

    @property
    @pulumi.getter(name="opflexClientSsl")
    def opflex_client_ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use client SSL for Opflex (string)
        """
        return pulumi.get(self, "opflex_client_ssl")

    @opflex_client_ssl.setter
    def opflex_client_ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_client_ssl", value)

    @property
    @pulumi.getter(name="opflexDeviceDeleteTimeout")
    def opflex_device_delete_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Opflex device delete timeout (string)
        """
        return pulumi.get(self, "opflex_device_delete_timeout")

    @opflex_device_delete_timeout.setter
    def opflex_device_delete_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_device_delete_timeout", value)

    @property
    @pulumi.getter(name="opflexLogLevel")
    def opflex_log_level(self) -> Optional[pulumi.Input[str]]:
        """
        Log level for ACI opflex (string)
        """
        return pulumi.get(self, "opflex_log_level")

    @opflex_log_level.setter
    def opflex_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_log_level", value)

    @property
    @pulumi.getter(name="opflexMode")
    def opflex_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Opflex mode (string)
        """
        return pulumi.get(self, "opflex_mode")

    @opflex_mode.setter
    def opflex_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_mode", value)

    @property
    @pulumi.getter(name="opflexServerPort")
    def opflex_server_port(self) -> Optional[pulumi.Input[str]]:
        """
        Opflex server port (string)
        """
        return pulumi.get(self, "opflex_server_port")

    @opflex_server_port.setter
    def opflex_server_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_server_port", value)

    @property
    @pulumi.getter(name="overlayVrfName")
    def overlay_vrf_name(self) -> Optional[pulumi.Input[str]]:
        """
        Overlay VRF name (string)
        """
        return pulumi.get(self, "overlay_vrf_name")

    @overlay_vrf_name.setter
    def overlay_vrf_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overlay_vrf_name", value)

    @property
    @pulumi.getter(name="ovsMemoryLimit")
    def ovs_memory_limit(self) -> Optional[pulumi.Input[str]]:
        """
        OVS memory limit (string)
        """
        return pulumi.get(self, "ovs_memory_limit")

    @ovs_memory_limit.setter
    def ovs_memory_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ovs_memory_limit", value)

    @property
    @pulumi.getter(name="pbrTrackingNonSnat")
    def pbr_tracking_non_snat(self) -> Optional[pulumi.Input[str]]:
        """
        Policy-based routing tracking non snat (string)
        """
        return pulumi.get(self, "pbr_tracking_non_snat")

    @pbr_tracking_non_snat.setter
    def pbr_tracking_non_snat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pbr_tracking_non_snat", value)

    @property
    @pulumi.getter(name="podSubnetChunkSize")
    def pod_subnet_chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Pod subnet chunk size (string)
        """
        return pulumi.get(self, "pod_subnet_chunk_size")

    @pod_subnet_chunk_size.setter
    def pod_subnet_chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_subnet_chunk_size", value)

    @property
    @pulumi.getter(name="runGbpContainer")
    def run_gbp_container(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to run GBP container (string)
        """
        return pulumi.get(self, "run_gbp_container")

    @run_gbp_container.setter
    def run_gbp_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_gbp_container", value)

    @property
    @pulumi.getter(name="runOpflexServerContainer")
    def run_opflex_server_container(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to run Opflex server container (string)
        """
        return pulumi.get(self, "run_opflex_server_container")

    @run_opflex_server_container.setter
    def run_opflex_server_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_opflex_server_container", value)

    @property
    @pulumi.getter(name="serviceMonitorInterval")
    def service_monitor_interval(self) -> Optional[pulumi.Input[str]]:
        """
        Service monitor interval (string)
        """
        return pulumi.get(self, "service_monitor_interval")

    @service_monitor_interval.setter
    def service_monitor_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_monitor_interval", value)

    @property
    @pulumi.getter(name="snatContractScope")
    def snat_contract_scope(self) -> Optional[pulumi.Input[str]]:
        """
        Snat contract scope (string)
        """
        return pulumi.get(self, "snat_contract_scope")

    @snat_contract_scope.setter
    def snat_contract_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_contract_scope", value)

    @property
    @pulumi.getter(name="snatNamespace")
    def snat_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Snat namespace (string)
        """
        return pulumi.get(self, "snat_namespace")

    @snat_namespace.setter
    def snat_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_namespace", value)

    @property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[pulumi.Input[str]]:
        """
        End of snat port range (string)
        """
        return pulumi.get(self, "snat_port_range_end")

    @snat_port_range_end.setter
    def snat_port_range_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_port_range_end", value)

    @property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[pulumi.Input[str]]:
        """
        End of snat port range (string)
        """
        return pulumi.get(self, "snat_port_range_start")

    @snat_port_range_start.setter
    def snat_port_range_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_port_range_start", value)

    @property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[pulumi.Input[str]]:
        """
        Snat ports per node (string)
        """
        return pulumi.get(self, "snat_ports_per_node")

    @snat_ports_per_node.setter
    def snat_ports_per_node(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_ports_per_node", value)

    @property
    @pulumi.getter(name="sriovEnable")
    def sriov_enable(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to enable SR-IOV (string)
        """
        return pulumi.get(self, "sriov_enable")

    @sriov_enable.setter
    def sriov_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sriov_enable", value)

    @property
    @pulumi.getter(name="subnetDomainName")
    def subnet_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        Subnet domain name (string)
        """
        return pulumi.get(self, "subnet_domain_name")

    @subnet_domain_name.setter
    def subnet_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_domain_name", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input[str]]:
        """
        ACI tenant (string)
        """
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter(name="useAciAnywhereCrd")
    def use_aci_anywhere_crd(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use ACI anywhere CRD (string)
        """
        return pulumi.get(self, "use_aci_anywhere_crd")

    @use_aci_anywhere_crd.setter
    def use_aci_anywhere_crd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_aci_anywhere_crd", value)

    @property
    @pulumi.getter(name="useAciCniPriorityClass")
    def use_aci_cni_priority_class(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use ACI CNI priority class (string)
        """
        return pulumi.get(self, "use_aci_cni_priority_class")

    @use_aci_cni_priority_class.setter
    def use_aci_cni_priority_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_aci_cni_priority_class", value)

    @property
    @pulumi.getter(name="useClusterRole")
    def use_cluster_role(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use cluster role (string)
        """
        return pulumi.get(self, "use_cluster_role")

    @use_cluster_role.setter
    def use_cluster_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_cluster_role", value)

    @property
    @pulumi.getter(name="useHostNetnsVolume")
    def use_host_netns_volume(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use host netns volume (string)
        """
        return pulumi.get(self, "use_host_netns_volume")

    @use_host_netns_volume.setter
    def use_host_netns_volume(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_host_netns_volume", value)

    @property
    @pulumi.getter(name="useOpflexServerVolume")
    def use_opflex_server_volume(self) -> Optional[pulumi.Input[str]]:
        """
        Whether use Opflex server volume (string)
        """
        return pulumi.get(self, "use_opflex_server_volume")

    @use_opflex_server_volume.setter
    def use_opflex_server_volume(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_opflex_server_volume", value)

    @property
    @pulumi.getter(name="usePrivilegedContainer")
    def use_privileged_container(self) -> Optional[pulumi.Input[str]]:
        """
        Whether ACI containers should run as privileged (string)
        """
        return pulumi.get(self, "use_privileged_container")

    @use_privileged_container.setter
    def use_privileged_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_privileged_container", value)

    @property
    @pulumi.getter(name="vmmController")
    def vmm_controller(self) -> Optional[pulumi.Input[str]]:
        """
        VMM controller configuration (string)
        """
        return pulumi.get(self, "vmm_controller")

    @vmm_controller.setter
    def vmm_controller(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vmm_controller", value)

    @property
    @pulumi.getter(name="vmmDomain")
    def vmm_domain(self) -> Optional[pulumi.Input[str]]:
        """
        VMM domain configuration (string)
        """
        return pulumi.get(self, "vmm_domain")

    @vmm_domain.setter
    def vmm_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vmm_domain", value)


if not MYPY:
    class ClusterRkeConfigNetworkCalicoNetworkProviderArgsDict(TypedDict):
        cloud_provider: NotRequired[pulumi.Input[str]]
        """
        RKE options for Calico network provider (string)
        """
elif False:
    ClusterRkeConfigNetworkCalicoNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkCalicoNetworkProviderArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cloud_provider: RKE options for Calico network provider (string)
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        """
        RKE options for Calico network provider (string)
        """
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)


if not MYPY:
    class ClusterRkeConfigNetworkCanalNetworkProviderArgsDict(TypedDict):
        iface: NotRequired[pulumi.Input[str]]
        """
        Iface config Flannel network provider (string)
        """
elif False:
    ClusterRkeConfigNetworkCanalNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkCanalNetworkProviderArgs:
    def __init__(__self__, *,
                 iface: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] iface: Iface config Flannel network provider (string)
        """
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @property
    @pulumi.getter
    def iface(self) -> Optional[pulumi.Input[str]]:
        """
        Iface config Flannel network provider (string)
        """
        return pulumi.get(self, "iface")

    @iface.setter
    def iface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iface", value)


if not MYPY:
    class ClusterRkeConfigNetworkFlannelNetworkProviderArgsDict(TypedDict):
        iface: NotRequired[pulumi.Input[str]]
        """
        Iface config Flannel network provider (string)
        """
elif False:
    ClusterRkeConfigNetworkFlannelNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkFlannelNetworkProviderArgs:
    def __init__(__self__, *,
                 iface: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] iface: Iface config Flannel network provider (string)
        """
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @property
    @pulumi.getter
    def iface(self) -> Optional[pulumi.Input[str]]:
        """
        Iface config Flannel network provider (string)
        """
        return pulumi.get(self, "iface")

    @iface.setter
    def iface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iface", value)


if not MYPY:
    class ClusterRkeConfigNetworkTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The GKE taint key (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The GKE taint effect (string)
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The toleration seconds (int)
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The GKE taint value (string)
        """
elif False:
    ClusterRkeConfigNetworkTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] effect: The GKE taint effect (string)
        :param pulumi.Input[str] operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param pulumi.Input[int] seconds: The toleration seconds (int)
        :param pulumi.Input[str] value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterRkeConfigNetworkWeaveNetworkProviderArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        Registry password (string)
        """
elif False:
    ClusterRkeConfigNetworkWeaveNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNetworkWeaveNetworkProviderArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Registry password (string)
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class ClusterRkeConfigNodeArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        Address ip for node (string)
        """
        roles: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Roles for the node. `controlplane`, `etcd` and `worker` are supported. (list)
        """
        user: pulumi.Input[str]
        """
        Registry user (string)
        """
        docker_socket: NotRequired[pulumi.Input[str]]
        """
        Docker socket for node (string)
        """
        hostname_override: NotRequired[pulumi.Input[str]]
        """
        Hostname override for node (string)
        """
        internal_address: NotRequired[pulumi.Input[str]]
        """
        Internal ip for node (string)
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster (map)
        """
        node_id: NotRequired[pulumi.Input[str]]
        """
        Id for the node (string)
        """
        port: NotRequired[pulumi.Input[str]]
        """
        Port for node. Default `22` (string)
        """
        ssh_agent_auth: NotRequired[pulumi.Input[bool]]
        """
        Use ssh agent auth. Default `false` (bool)
        """
        ssh_key: NotRequired[pulumi.Input[str]]
        """
        Node SSH private key (string)
        """
        ssh_key_path: NotRequired[pulumi.Input[str]]
        """
        Node SSH private key path (string)
        """
elif False:
    ClusterRkeConfigNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigNodeArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 roles: pulumi.Input[Sequence[pulumi.Input[str]]],
                 user: pulumi.Input[str],
                 docker_socket: Optional[pulumi.Input[str]] = None,
                 hostname_override: Optional[pulumi.Input[str]] = None,
                 internal_address: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 ssh_agent_auth: Optional[pulumi.Input[bool]] = None,
                 ssh_key: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Address ip for node (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: Roles for the node. `controlplane`, `etcd` and `worker` are supported. (list)
        :param pulumi.Input[str] user: Registry user (string)
        :param pulumi.Input[str] docker_socket: Docker socket for node (string)
        :param pulumi.Input[str] hostname_override: Hostname override for node (string)
        :param pulumi.Input[str] internal_address: Internal ip for node (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster (map)
        :param pulumi.Input[str] node_id: Id for the node (string)
        :param pulumi.Input[str] port: Port for node. Default `22` (string)
        :param pulumi.Input[bool] ssh_agent_auth: Use ssh agent auth. Default `false` (bool)
        :param pulumi.Input[str] ssh_key: Node SSH private key (string)
        :param pulumi.Input[str] ssh_key_path: Node SSH private key path (string)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "user", user)
        if docker_socket is not None:
            pulumi.set(__self__, "docker_socket", docker_socket)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if internal_address is not None:
            pulumi.set(__self__, "internal_address", internal_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def roles(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Roles for the node. `controlplane`, `etcd` and `worker` are supported. (list)
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> Optional[pulumi.Input[str]]:
        """
        Docker socket for node (string)
        """
        return pulumi.get(self, "docker_socket")

    @docker_socket.setter
    def docker_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_socket", value)

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname override for node (string)
        """
        return pulumi.get(self, "hostname_override")

    @hostname_override.setter
    def hostname_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_override", value)

    @property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[pulumi.Input[str]]:
        """
        Internal ip for node (string)
        """
        return pulumi.get(self, "internal_address")

    @internal_address.setter
    def internal_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_address", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        """
        Id for the node (string)
        """
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Use ssh agent auth. Default `false` (bool)
        """
        return pulumi.get(self, "ssh_agent_auth")

    @ssh_agent_auth.setter
    def ssh_agent_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssh_agent_auth", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[str]]:
        """
        Node SSH private key (string)
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        """
        Node SSH private key path (string)
        """
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)


if not MYPY:
    class ClusterRkeConfigPrivateRegistryArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        Registry URL (string)
        """
        ecr_credential_plugin: NotRequired[pulumi.Input['ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgsDict']]
        """
        ECR credential plugin config
        """
        is_default: NotRequired[pulumi.Input[bool]]
        """
        Set as default registry. Default `false` (bool)
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Registry password (string)
        """
        user: NotRequired[pulumi.Input[str]]
        """
        Registry user (string)
        """
elif False:
    ClusterRkeConfigPrivateRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigPrivateRegistryArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 ecr_credential_plugin: Optional[pulumi.Input['ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs']] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] url: Registry URL (string)
        :param pulumi.Input['ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs'] ecr_credential_plugin: ECR credential plugin config
        :param pulumi.Input[bool] is_default: Set as default registry. Default `false` (bool)
        :param pulumi.Input[str] password: Registry password (string)
        :param pulumi.Input[str] user: Registry user (string)
        """
        pulumi.set(__self__, "url", url)
        if ecr_credential_plugin is not None:
            pulumi.set(__self__, "ecr_credential_plugin", ecr_credential_plugin)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="ecrCredentialPlugin")
    def ecr_credential_plugin(self) -> Optional[pulumi.Input['ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs']]:
        """
        ECR credential plugin config
        """
        return pulumi.get(self, "ecr_credential_plugin")

    @ecr_credential_plugin.setter
    def ecr_credential_plugin(self, value: Optional[pulumi.Input['ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs']]):
        pulumi.set(self, "ecr_credential_plugin", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        """
        Set as default registry. Default `false` (bool)
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgsDict(TypedDict):
        aws_access_key_id: NotRequired[pulumi.Input[str]]
        """
        AWS access key ID (string)
        """
        aws_secret_access_key: NotRequired[pulumi.Input[str]]
        """
        AWS secret access key (string)
        """
        aws_session_token: NotRequired[pulumi.Input[str]]
        """
        AWS session token (string)
        """
elif False:
    ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs:
    def __init__(__self__, *,
                 aws_access_key_id: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[str]] = None,
                 aws_session_token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] aws_access_key_id: AWS access key ID (string)
        :param pulumi.Input[str] aws_secret_access_key: AWS secret access key (string)
        :param pulumi.Input[str] aws_session_token: AWS session token (string)
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        AWS access key ID (string)
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS secret access key (string)
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[pulumi.Input[str]]:
        """
        AWS session token (string)
        """
        return pulumi.get(self, "aws_session_token")

    @aws_session_token.setter
    def aws_session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_session_token", value)


if not MYPY:
    class ClusterRkeConfigServicesArgsDict(TypedDict):
        etcd: NotRequired[pulumi.Input['ClusterRkeConfigServicesEtcdArgsDict']]
        """
        Etcd options for RKE services (list maxitems:1)
        """
        kube_api: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeApiArgsDict']]
        """
        Kube API options for RKE services (list maxitems:1)
        """
        kube_controller: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeControllerArgsDict']]
        """
        Kube Controller options for RKE services (list maxitems:1)
        """
        kubelet: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeletArgsDict']]
        """
        Kubelet options for RKE services (list maxitems:1)
        """
        kubeproxy: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeproxyArgsDict']]
        """
        Kubeproxy options for RKE services (list maxitems:1)
        """
        scheduler: NotRequired[pulumi.Input['ClusterRkeConfigServicesSchedulerArgsDict']]
        """
        Scheduler options for RKE services (list maxitems:1)
        """
elif False:
    ClusterRkeConfigServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesArgs:
    def __init__(__self__, *,
                 etcd: Optional[pulumi.Input['ClusterRkeConfigServicesEtcdArgs']] = None,
                 kube_api: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiArgs']] = None,
                 kube_controller: Optional[pulumi.Input['ClusterRkeConfigServicesKubeControllerArgs']] = None,
                 kubelet: Optional[pulumi.Input['ClusterRkeConfigServicesKubeletArgs']] = None,
                 kubeproxy: Optional[pulumi.Input['ClusterRkeConfigServicesKubeproxyArgs']] = None,
                 scheduler: Optional[pulumi.Input['ClusterRkeConfigServicesSchedulerArgs']] = None):
        """
        :param pulumi.Input['ClusterRkeConfigServicesEtcdArgs'] etcd: Etcd options for RKE services (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigServicesKubeApiArgs'] kube_api: Kube API options for RKE services (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigServicesKubeControllerArgs'] kube_controller: Kube Controller options for RKE services (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigServicesKubeletArgs'] kubelet: Kubelet options for RKE services (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigServicesKubeproxyArgs'] kubeproxy: Kubeproxy options for RKE services (list maxitems:1)
        :param pulumi.Input['ClusterRkeConfigServicesSchedulerArgs'] scheduler: Scheduler options for RKE services (list maxitems:1)
        """
        if etcd is not None:
            pulumi.set(__self__, "etcd", etcd)
        if kube_api is not None:
            pulumi.set(__self__, "kube_api", kube_api)
        if kube_controller is not None:
            pulumi.set(__self__, "kube_controller", kube_controller)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if kubeproxy is not None:
            pulumi.set(__self__, "kubeproxy", kubeproxy)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @property
    @pulumi.getter
    def etcd(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesEtcdArgs']]:
        """
        Etcd options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "etcd")

    @etcd.setter
    def etcd(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesEtcdArgs']]):
        pulumi.set(self, "etcd", value)

    @property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiArgs']]:
        """
        Kube API options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kube_api")

    @kube_api.setter
    def kube_api(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiArgs']]):
        pulumi.set(self, "kube_api", value)

    @property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeControllerArgs']]:
        """
        Kube Controller options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kube_controller")

    @kube_controller.setter
    def kube_controller(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeControllerArgs']]):
        pulumi.set(self, "kube_controller", value)

    @property
    @pulumi.getter
    def kubelet(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeletArgs']]:
        """
        Kubelet options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kubelet")

    @kubelet.setter
    def kubelet(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeletArgs']]):
        pulumi.set(self, "kubelet", value)

    @property
    @pulumi.getter
    def kubeproxy(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeproxyArgs']]:
        """
        Kubeproxy options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kubeproxy")

    @kubeproxy.setter
    def kubeproxy(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeproxyArgs']]):
        pulumi.set(self, "kubeproxy", value)

    @property
    @pulumi.getter
    def scheduler(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesSchedulerArgs']]:
        """
        Scheduler options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "scheduler")

    @scheduler.setter
    def scheduler(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesSchedulerArgs']]):
        pulumi.set(self, "scheduler", value)


if not MYPY:
    class ClusterRkeConfigServicesEtcdArgsDict(TypedDict):
        backup_config: NotRequired[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigArgsDict']]
        """
        Backup options for etcd service. For Rancher v2.2.x (list maxitems:1)
        """
        ca_cert: NotRequired[pulumi.Input[str]]
        """
        (Computed/Sensitive) K8s cluster ca cert (string)
        """
        cert: NotRequired[pulumi.Input[str]]
        """
        TLS certificate for etcd service (string)
        """
        creation: NotRequired[pulumi.Input[str]]
        """
        Creation option for etcd service (string)
        """
        external_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        External urls for etcd service (list)
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra binds for scheduler service (list)
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra environment for scheduler service (list)
        """
        gid: NotRequired[pulumi.Input[int]]
        """
        Etcd service GID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image for scheduler service (string)
        """
        key: NotRequired[pulumi.Input[str]]
        """
        The GKE taint key (string)
        """
        path: NotRequired[pulumi.Input[str]]
        """
        (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        retention: NotRequired[pulumi.Input[str]]
        """
        Retention for etcd backup. Default `6` (int)
        """
        snapshot: NotRequired[pulumi.Input[bool]]
        """
        Snapshot option for etcd service (bool)
        """
        uid: NotRequired[pulumi.Input[int]]
        """
        Etcd service UID. Default: `0`. For Rancher v2.3.x and above (int)
        """
elif False:
    ClusterRkeConfigServicesEtcdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesEtcdArgs:
    def __init__(__self__, *,
                 backup_config: Optional[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigArgs']] = None,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 cert: Optional[pulumi.Input[str]] = None,
                 creation: Optional[pulumi.Input[str]] = None,
                 external_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gid: Optional[pulumi.Input[int]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 retention: Optional[pulumi.Input[str]] = None,
                 snapshot: Optional[pulumi.Input[bool]] = None,
                 uid: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigArgs'] backup_config: Backup options for etcd service. For Rancher v2.2.x (list maxitems:1)
        :param pulumi.Input[str] ca_cert: (Computed/Sensitive) K8s cluster ca cert (string)
        :param pulumi.Input[str] cert: TLS certificate for etcd service (string)
        :param pulumi.Input[str] creation: Creation option for etcd service (string)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] external_urls: External urls for etcd service (list)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_binds: Extra binds for scheduler service (list)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_envs: Extra environment for scheduler service (list)
        :param pulumi.Input[int] gid: Etcd service GID. Default: `0`. For Rancher v2.3.x and above (int)
        :param pulumi.Input[str] image: Docker image for scheduler service (string)
        :param pulumi.Input[str] key: The GKE taint key (string)
        :param pulumi.Input[str] path: (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param pulumi.Input[str] retention: Retention for etcd backup. Default `6` (int)
        :param pulumi.Input[bool] snapshot: Snapshot option for etcd service (bool)
        :param pulumi.Input[int] uid: Etcd service UID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        if backup_config is not None:
            pulumi.set(__self__, "backup_config", backup_config)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if creation is not None:
            pulumi.set(__self__, "creation", creation)
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigArgs']]:
        """
        Backup options for etcd service. For Rancher v2.2.x (list maxitems:1)
        """
        return pulumi.get(self, "backup_config")

    @backup_config.setter
    def backup_config(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigArgs']]):
        pulumi.set(self, "backup_config", value)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed/Sensitive) K8s cluster ca cert (string)
        """
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[str]]:
        """
        TLS certificate for etcd service (string)
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def creation(self) -> Optional[pulumi.Input[str]]:
        """
        Creation option for etcd service (string)
        """
        return pulumi.get(self, "creation")

    @creation.setter
    def creation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation", value)

    @property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        External urls for etcd service (list)
        """
        return pulumi.get(self, "external_urls")

    @external_urls.setter
    def external_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_urls", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[int]]:
        """
        Etcd service GID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[str]]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[pulumi.Input[bool]]:
        """
        Snapshot option for etcd service (bool)
        """
        return pulumi.get(self, "snapshot")

    @snapshot.setter
    def snapshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshot", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[int]]:
        """
        Etcd service UID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ClusterRkeConfigServicesEtcdBackupConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        interval_hours: NotRequired[pulumi.Input[int]]
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        retention: NotRequired[pulumi.Input[int]]
        """
        Retention for etcd backup. Default `6` (int)
        """
        s3_backup_config: NotRequired[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict']]
        """
        S3 config options for etcd backup (list maxitems:1)
        """
        safe_timestamp: NotRequired[pulumi.Input[bool]]
        """
        Safe timestamp for etcd backup. Default: `false` (bool)
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        RKE node drain timeout. Default: `60` (int)
        """
elif False:
    ClusterRkeConfigServicesEtcdBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesEtcdBackupConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 interval_hours: Optional[pulumi.Input[int]] = None,
                 retention: Optional[pulumi.Input[int]] = None,
                 s3_backup_config: Optional[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs']] = None,
                 safe_timestamp: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        :param pulumi.Input[int] interval_hours: Interval hours for etcd backup. Default `12` (int)
        :param pulumi.Input[int] retention: Retention for etcd backup. Default `6` (int)
        :param pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs'] s3_backup_config: S3 config options for etcd backup (list maxitems:1)
        :param pulumi.Input[bool] safe_timestamp: Safe timestamp for etcd backup. Default: `false` (bool)
        :param pulumi.Input[int] timeout: RKE node drain timeout. Default: `60` (int)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[pulumi.Input[int]]:
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        return pulumi.get(self, "interval_hours")

    @interval_hours.setter
    def interval_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_hours", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[int]]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs']]:
        """
        S3 config options for etcd backup (list maxitems:1)
        """
        return pulumi.get(self, "s3_backup_config")

    @s3_backup_config.setter
    def s3_backup_config(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs']]):
        pulumi.set(self, "s3_backup_config", value)

    @property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[pulumi.Input[bool]]:
        """
        Safe timestamp for etcd backup. Default: `false` (bool)
        """
        return pulumi.get(self, "safe_timestamp")

    @safe_timestamp.setter
    def safe_timestamp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "safe_timestamp", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        RKE node drain timeout. Default: `60` (int)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        Bucket name for S3 service (string)
        """
        endpoint: pulumi.Input[str]
        """
        Endpoint for S3 service (string)
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        The AWS Client ID to use (string)
        """
        custom_ca: NotRequired[pulumi.Input[str]]
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        folder: NotRequired[pulumi.Input[str]]
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        region: NotRequired[pulumi.Input[str]]
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        The AWS Client Secret associated with the Client ID (string)
        """
elif False:
    ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 custom_ca: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: Bucket name for S3 service (string)
        :param pulumi.Input[str] endpoint: Endpoint for S3 service (string)
        :param pulumi.Input[str] access_key: The AWS Client ID to use (string)
        :param pulumi.Input[str] custom_ca: Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        :param pulumi.Input[str] folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param pulumi.Input[str] region: The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        :param pulumi.Input[str] secret_key: The AWS Client Secret associated with the Client ID (string)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Bucket name for S3 service (string)
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Endpoint for S3 service (string)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Client ID to use (string)
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        return pulumi.get(self, "custom_ca")

    @custom_ca.setter
    def custom_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_ca", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Client Secret associated with the Client ID (string)
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiArgsDict(TypedDict):
        admission_configuration: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgsDict']]
        """
        Cluster admission configuration
        """
        always_pull_images: NotRequired[pulumi.Input[bool]]
        """
        Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) Default: `false` (bool)
        """
        audit_log: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogArgsDict']]
        """
        K8s audit log configuration. (list maxitems: 1)
        """
        event_rate_limit: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeApiEventRateLimitArgsDict']]
        """
        K8s event rate limit configuration. (list maxitems: 1)
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra binds for scheduler service (list)
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra environment for scheduler service (list)
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image for scheduler service (string)
        """
        secrets_encryption_config: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict']]
        """
        [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        """
        service_cluster_ip_range: NotRequired[pulumi.Input[str]]
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        service_node_port_range: NotRequired[pulumi.Input[str]]
        """
        Service Node Port Range option for kube API service (string)
        """
elif False:
    ClusterRkeConfigServicesKubeApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiArgs:
    def __init__(__self__, *,
                 admission_configuration: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs']] = None,
                 always_pull_images: Optional[pulumi.Input[bool]] = None,
                 audit_log: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogArgs']] = None,
                 event_rate_limit: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiEventRateLimitArgs']] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 secrets_encryption_config: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs']] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
                 service_node_port_range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs'] admission_configuration: Cluster admission configuration
        :param pulumi.Input[bool] always_pull_images: Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) Default: `false` (bool)
        :param pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogArgs'] audit_log: K8s audit log configuration. (list maxitems: 1)
        :param pulumi.Input['ClusterRkeConfigServicesKubeApiEventRateLimitArgs'] event_rate_limit: K8s event rate limit configuration. (list maxitems: 1)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_binds: Extra binds for scheduler service (list)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_envs: Extra environment for scheduler service (list)
        :param pulumi.Input[str] image: Docker image for scheduler service (string)
        :param pulumi.Input['ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs'] secrets_encryption_config: [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        :param pulumi.Input[str] service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        :param pulumi.Input[str] service_node_port_range: Service Node Port Range option for kube API service (string)
        """
        if admission_configuration is not None:
            pulumi.set(__self__, "admission_configuration", admission_configuration)
        if always_pull_images is not None:
            pulumi.set(__self__, "always_pull_images", always_pull_images)
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if event_rate_limit is not None:
            pulumi.set(__self__, "event_rate_limit", event_rate_limit)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if secrets_encryption_config is not None:
            pulumi.set(__self__, "secrets_encryption_config", secrets_encryption_config)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            pulumi.set(__self__, "service_node_port_range", service_node_port_range)

    @property
    @pulumi.getter(name="admissionConfiguration")
    def admission_configuration(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs']]:
        """
        Cluster admission configuration
        """
        return pulumi.get(self, "admission_configuration")

    @admission_configuration.setter
    def admission_configuration(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs']]):
        pulumi.set(self, "admission_configuration", value)

    @property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) Default: `false` (bool)
        """
        return pulumi.get(self, "always_pull_images")

    @always_pull_images.setter
    def always_pull_images(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_pull_images", value)

    @property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogArgs']]:
        """
        K8s audit log configuration. (list maxitems: 1)
        """
        return pulumi.get(self, "audit_log")

    @audit_log.setter
    def audit_log(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogArgs']]):
        pulumi.set(self, "audit_log", value)

    @property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiEventRateLimitArgs']]:
        """
        K8s event rate limit configuration. (list maxitems: 1)
        """
        return pulumi.get(self, "event_rate_limit")

    @event_rate_limit.setter
    def event_rate_limit(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiEventRateLimitArgs']]):
        pulumi.set(self, "event_rate_limit", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs']]:
        """
        [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        """
        return pulumi.get(self, "secrets_encryption_config")

    @secrets_encryption_config.setter
    def secrets_encryption_config(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs']]):
        pulumi.set(self, "secrets_encryption_config", value)

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @service_cluster_ip_range.setter
    def service_cluster_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cluster_ip_range", value)

    @property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[pulumi.Input[str]]:
        """
        Service Node Port Range option for kube API service (string)
        """
        return pulumi.get(self, "service_node_port_range")

    @service_node_port_range.setter
    def service_node_port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_node_port_range", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[str]]
        """
        Admission configuration ApiVersion
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Admission configuration Kind
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict']]]]
        """
        Admission configuration plugins
        """
elif False:
    ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]]] = None):
        """
        :param pulumi.Input[str] api_version: Admission configuration ApiVersion
        :param pulumi.Input[str] kind: Admission configuration Kind
        :param pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]] plugins: Admission configuration plugins
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Admission configuration ApiVersion
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Admission configuration Kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]]]:
        """
        Admission configuration plugins
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input[str]]
        """
        Plugin configuration
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the Cluster (string)
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Plugin path
        """
elif False:
    ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] configuration: Plugin configuration
        :param pulumi.Input[str] name: The name of the Cluster (string)
        :param pulumi.Input[str] path: Plugin path
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin configuration
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiAuditLogArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgsDict']]
        """
        Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:

        ```
        configuration = <<EOF
        apiVersion: eventratelimit.admission.k8s.io/v1alpha1
        kind: Configuration
        limits:
        - type: Server
        burst: 35000
        qps: 6000
        EOF
        ```
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
elif False:
    ClusterRkeConfigServicesKubeApiAuditLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiAuditLogArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs'] configuration: Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:
               
               ```
               configuration = <<EOF
               apiVersion: eventratelimit.admission.k8s.io/v1alpha1
               kind: Configuration
               limits:
               - type: Server
               burst: 35000
               qps: 6000
               EOF
               ```
        :param pulumi.Input[bool] enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs']]:
        """
        Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:

        ```
        configuration = <<EOF
        apiVersion: eventratelimit.admission.k8s.io/v1alpha1
        kind: Configuration
        limits:
        - type: Server
        burst: 35000
        qps: 6000
        EOF
        ```
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgsDict(TypedDict):
        format: NotRequired[pulumi.Input[str]]
        """
        Audit log format. Default: 'json' (string)
        """
        max_age: NotRequired[pulumi.Input[int]]
        """
        Audit log max age. Default: `30` (int)
        """
        max_backup: NotRequired[pulumi.Input[int]]
        """
        Audit log max backup. Default: `10` (int)
        """
        max_size: NotRequired[pulumi.Input[int]]
        """
        The EKS node group maximum size. Default `2` (int)
        """
        path: NotRequired[pulumi.Input[str]]
        """
        (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        policy: NotRequired[pulumi.Input[str]]
        """
        Audit policy yaml encoded definition. `apiVersion` and `kind: Policy\\nrules:"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string) Ex:

        ```
        policy = <<EOF
        apiVersion: audit.k8s.io/v1
        kind: Policy
        rules:
        - level: RequestResponse
        resources:
        - resources:
        - pods
        EOF
        ```
        """
elif False:
    ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs:
    def __init__(__self__, *,
                 format: Optional[pulumi.Input[str]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 max_backup: Optional[pulumi.Input[int]] = None,
                 max_size: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] format: Audit log format. Default: 'json' (string)
        :param pulumi.Input[int] max_age: Audit log max age. Default: `30` (int)
        :param pulumi.Input[int] max_backup: Audit log max backup. Default: `10` (int)
        :param pulumi.Input[int] max_size: The EKS node group maximum size. Default `2` (int)
        :param pulumi.Input[str] path: (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param pulumi.Input[str] policy: Audit policy yaml encoded definition. `apiVersion` and `kind: Policy\\nrules:"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string) Ex:
               
               ```
               policy = <<EOF
               apiVersion: audit.k8s.io/v1
               kind: Policy
               rules:
               - level: RequestResponse
               resources:
               - resources:
               - pods
               EOF
               ```
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_backup is not None:
            pulumi.set(__self__, "max_backup", max_backup)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Audit log format. Default: 'json' (string)
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        Audit log max age. Default: `30` (int)
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[pulumi.Input[int]]:
        """
        Audit log max backup. Default: `10` (int)
        """
        return pulumi.get(self, "max_backup")

    @max_backup.setter
    def max_backup(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_backup", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[int]]:
        """
        The EKS node group maximum size. Default `2` (int)
        """
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Audit policy yaml encoded definition. `apiVersion` and `kind: Policy\\nrules:"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string) Ex:

        ```
        policy = <<EOF
        apiVersion: audit.k8s.io/v1
        kind: Policy
        rules:
        - level: RequestResponse
        resources:
        - resources:
        - pods
        EOF
        ```
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiEventRateLimitArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input[str]]
        """
        Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:

        ```
        configuration = <<EOF
        apiVersion: eventratelimit.admission.k8s.io/v1alpha1
        kind: Configuration
        limits:
        - type: Server
        burst: 35000
        qps: 6000
        EOF
        ```
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
elif False:
    ClusterRkeConfigServicesKubeApiEventRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiEventRateLimitArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] configuration: Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:
               
               ```
               configuration = <<EOF
               apiVersion: eventratelimit.admission.k8s.io/v1alpha1
               kind: Configuration
               limits:
               - type: Server
               burst: 35000
               qps: 6000
               EOF
               ```
        :param pulumi.Input[bool] enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:

        ```
        configuration = <<EOF
        apiVersion: eventratelimit.admission.k8s.io/v1alpha1
        kind: Configuration
        limits:
        - type: Server
        burst: 35000
        qps: 6000
        EOF
        ```
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict(TypedDict):
        custom_config: NotRequired[pulumi.Input[str]]
        """
        Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string) Ex:

        ```
        custom_config = <<EOF
        apiVersion: apiserver.config.k8s.io/v1
        kind: EncryptionConfiguration
        resources:
        - resources:
        - secrets
        providers:
        - aescbc:
        keys:
        - name: k-fw5hn
        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=
        identity: {}
        EOF

        ```
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
elif False:
    ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs:
    def __init__(__self__, *,
                 custom_config: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] custom_config: Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string) Ex:
               
               ```
               custom_config = <<EOF
               apiVersion: apiserver.config.k8s.io/v1
               kind: EncryptionConfiguration
               resources:
               - resources:
               - secrets
               providers:
               - aescbc:
               keys:
               - name: k-fw5hn
               secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=
               identity: {}
               EOF
               
               ```
        :param pulumi.Input[bool] enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        """
        if custom_config is not None:
            pulumi.set(__self__, "custom_config", custom_config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> Optional[pulumi.Input[str]]:
        """
        Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string) Ex:

        ```
        custom_config = <<EOF
        apiVersion: apiserver.config.k8s.io/v1
        kind: EncryptionConfiguration
        resources:
        - resources:
        - secrets
        providers:
        - aescbc:
        keys:
        - name: k-fw5hn
        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=
        identity: {}
        EOF

        ```
        """
        return pulumi.get(self, "custom_config")

    @custom_config.setter
    def custom_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_config", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeControllerArgsDict(TypedDict):
        cluster_cidr: NotRequired[pulumi.Input[str]]
        """
        Cluster CIDR option for kube controller service (string)
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra binds for scheduler service (list)
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra environment for scheduler service (list)
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image for scheduler service (string)
        """
        service_cluster_ip_range: NotRequired[pulumi.Input[str]]
        """
        Service Cluster ip Range option for kube controller service (string)
        """
elif False:
    ClusterRkeConfigServicesKubeControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeControllerArgs:
    def __init__(__self__, *,
                 cluster_cidr: Optional[pulumi.Input[str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_cidr: Cluster CIDR option for kube controller service (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_binds: Extra binds for scheduler service (list)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_envs: Extra environment for scheduler service (list)
        :param pulumi.Input[str] image: Docker image for scheduler service (string)
        :param pulumi.Input[str] service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        """
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster CIDR option for kube controller service (string)
        """
        return pulumi.get(self, "cluster_cidr")

    @cluster_cidr.setter
    def cluster_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_cidr", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @service_cluster_ip_range.setter
    def service_cluster_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cluster_ip_range", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeletArgsDict(TypedDict):
        cluster_dns_server: NotRequired[pulumi.Input[str]]
        """
        Cluster DNS Server option for kubelet service (string)
        """
        cluster_domain: NotRequired[pulumi.Input[str]]
        """
        Cluster Domain option for kubelet service (string)
        """
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra binds for scheduler service (list)
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra environment for scheduler service (list)
        """
        fail_swap_on: NotRequired[pulumi.Input[bool]]
        """
        Enable or disable failing when swap on is not supported (bool)
        """
        generate_serving_certificate: NotRequired[pulumi.Input[bool]]
        """
        [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image for scheduler service (string)
        """
        infra_container_image: NotRequired[pulumi.Input[str]]
        """
        Infra container image for kubelet service (string)
        """
elif False:
    ClusterRkeConfigServicesKubeletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeletArgs:
    def __init__(__self__, *,
                 cluster_dns_server: Optional[pulumi.Input[str]] = None,
                 cluster_domain: Optional[pulumi.Input[str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_swap_on: Optional[pulumi.Input[bool]] = None,
                 generate_serving_certificate: Optional[pulumi.Input[bool]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 infra_container_image: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_dns_server: Cluster DNS Server option for kubelet service (string)
        :param pulumi.Input[str] cluster_domain: Cluster Domain option for kubelet service (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_binds: Extra binds for scheduler service (list)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_envs: Extra environment for scheduler service (list)
        :param pulumi.Input[bool] fail_swap_on: Enable or disable failing when swap on is not supported (bool)
        :param pulumi.Input[bool] generate_serving_certificate: [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        :param pulumi.Input[str] image: Docker image for scheduler service (string)
        :param pulumi.Input[str] infra_container_image: Infra container image for kubelet service (string)
        """
        if cluster_dns_server is not None:
            pulumi.set(__self__, "cluster_dns_server", cluster_dns_server)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if generate_serving_certificate is not None:
            pulumi.set(__self__, "generate_serving_certificate", generate_serving_certificate)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra_container_image is not None:
            pulumi.set(__self__, "infra_container_image", infra_container_image)

    @property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster DNS Server option for kubelet service (string)
        """
        return pulumi.get(self, "cluster_dns_server")

    @cluster_dns_server.setter
    def cluster_dns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_dns_server", value)

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster Domain option for kubelet service (string)
        """
        return pulumi.get(self, "cluster_domain")

    @cluster_domain.setter
    def cluster_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_domain", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable or disable failing when swap on is not supported (bool)
        """
        return pulumi.get(self, "fail_swap_on")

    @fail_swap_on.setter
    def fail_swap_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_swap_on", value)

    @property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[pulumi.Input[bool]]:
        """
        [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        """
        return pulumi.get(self, "generate_serving_certificate")

    @generate_serving_certificate.setter
    def generate_serving_certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_serving_certificate", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> Optional[pulumi.Input[str]]:
        """
        Infra container image for kubelet service (string)
        """
        return pulumi.get(self, "infra_container_image")

    @infra_container_image.setter
    def infra_container_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "infra_container_image", value)


if not MYPY:
    class ClusterRkeConfigServicesKubeproxyArgsDict(TypedDict):
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra binds for scheduler service (list)
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra environment for scheduler service (list)
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image for scheduler service (string)
        """
elif False:
    ClusterRkeConfigServicesKubeproxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesKubeproxyArgs:
    def __init__(__self__, *,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_binds: Extra binds for scheduler service (list)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_envs: Extra environment for scheduler service (list)
        :param pulumi.Input[str] image: Docker image for scheduler service (string)
        """
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ClusterRkeConfigServicesSchedulerArgsDict(TypedDict):
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Extra arguments for scheduler service (map)
        """
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra binds for scheduler service (list)
        """
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra environment for scheduler service (list)
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Docker image for scheduler service (string)
        """
elif False:
    ClusterRkeConfigServicesSchedulerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigServicesSchedulerArgs:
    def __init__(__self__, *,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] extra_args: Extra arguments for scheduler service (map)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_binds: Extra binds for scheduler service (list)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_envs: Extra environment for scheduler service (list)
        :param pulumi.Input[str] image: Docker image for scheduler service (string)
        """
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ClusterRkeConfigUpgradeStrategyArgsDict(TypedDict):
        drain: NotRequired[pulumi.Input[bool]]
        """
        RKE drain nodes. Default: `false` (bool)
        """
        drain_input: NotRequired[pulumi.Input['ClusterRkeConfigUpgradeStrategyDrainInputArgsDict']]
        """
        RKE drain node input (list Maxitems: 1)
        """
        max_unavailable_controlplane: NotRequired[pulumi.Input[str]]
        """
        RKE max unavailable controlplane nodes. Default: `1` (string)
        """
        max_unavailable_worker: NotRequired[pulumi.Input[str]]
        """
        RKE max unavailable worker nodes. Default: `10%` (string)
        """
elif False:
    ClusterRkeConfigUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigUpgradeStrategyArgs:
    def __init__(__self__, *,
                 drain: Optional[pulumi.Input[bool]] = None,
                 drain_input: Optional[pulumi.Input['ClusterRkeConfigUpgradeStrategyDrainInputArgs']] = None,
                 max_unavailable_controlplane: Optional[pulumi.Input[str]] = None,
                 max_unavailable_worker: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] drain: RKE drain nodes. Default: `false` (bool)
        :param pulumi.Input['ClusterRkeConfigUpgradeStrategyDrainInputArgs'] drain_input: RKE drain node input (list Maxitems: 1)
        :param pulumi.Input[str] max_unavailable_controlplane: RKE max unavailable controlplane nodes. Default: `1` (string)
        :param pulumi.Input[str] max_unavailable_worker: RKE max unavailable worker nodes. Default: `10%` (string)
        """
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if drain_input is not None:
            pulumi.set(__self__, "drain_input", drain_input)
        if max_unavailable_controlplane is not None:
            pulumi.set(__self__, "max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            pulumi.set(__self__, "max_unavailable_worker", max_unavailable_worker)

    @property
    @pulumi.getter
    def drain(self) -> Optional[pulumi.Input[bool]]:
        """
        RKE drain nodes. Default: `false` (bool)
        """
        return pulumi.get(self, "drain")

    @drain.setter
    def drain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain", value)

    @property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> Optional[pulumi.Input['ClusterRkeConfigUpgradeStrategyDrainInputArgs']]:
        """
        RKE drain node input (list Maxitems: 1)
        """
        return pulumi.get(self, "drain_input")

    @drain_input.setter
    def drain_input(self, value: Optional[pulumi.Input['ClusterRkeConfigUpgradeStrategyDrainInputArgs']]):
        pulumi.set(self, "drain_input", value)

    @property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[pulumi.Input[str]]:
        """
        RKE max unavailable controlplane nodes. Default: `1` (string)
        """
        return pulumi.get(self, "max_unavailable_controlplane")

    @max_unavailable_controlplane.setter
    def max_unavailable_controlplane(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_unavailable_controlplane", value)

    @property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[pulumi.Input[str]]:
        """
        RKE max unavailable worker nodes. Default: `10%` (string)
        """
        return pulumi.get(self, "max_unavailable_worker")

    @max_unavailable_worker.setter
    def max_unavailable_worker(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_unavailable_worker", value)


if not MYPY:
    class ClusterRkeConfigUpgradeStrategyDrainInputArgsDict(TypedDict):
        delete_local_data: NotRequired[pulumi.Input[bool]]
        """
        Delete RKE node local data. Default: `false` (bool)
        """
        force: NotRequired[pulumi.Input[bool]]
        """
        Force RKE node drain. Default: `false` (bool)
        """
        grace_period: NotRequired[pulumi.Input[int]]
        """
        RKE node drain grace period. Default: `-1` (int)
        """
        ignore_daemon_sets: NotRequired[pulumi.Input[bool]]
        """
        Ignore RKE daemon sets. Default: `true` (bool)
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        RKE node drain timeout. Default: `60` (int)
        """
elif False:
    ClusterRkeConfigUpgradeStrategyDrainInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterRkeConfigUpgradeStrategyDrainInputArgs:
    def __init__(__self__, *,
                 delete_local_data: Optional[pulumi.Input[bool]] = None,
                 force: Optional[pulumi.Input[bool]] = None,
                 grace_period: Optional[pulumi.Input[int]] = None,
                 ignore_daemon_sets: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] delete_local_data: Delete RKE node local data. Default: `false` (bool)
        :param pulumi.Input[bool] force: Force RKE node drain. Default: `false` (bool)
        :param pulumi.Input[int] grace_period: RKE node drain grace period. Default: `-1` (int)
        :param pulumi.Input[bool] ignore_daemon_sets: Ignore RKE daemon sets. Default: `true` (bool)
        :param pulumi.Input[int] timeout: RKE node drain timeout. Default: `60` (int)
        """
        if delete_local_data is not None:
            pulumi.set(__self__, "delete_local_data", delete_local_data)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[pulumi.Input[bool]]:
        """
        Delete RKE node local data. Default: `false` (bool)
        """
        return pulumi.get(self, "delete_local_data")

    @delete_local_data.setter
    def delete_local_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_local_data", value)

    @property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[bool]]:
        """
        Force RKE node drain. Default: `false` (bool)
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        """
        RKE node drain grace period. Default: `-1` (int)
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore RKE daemon sets. Default: `true` (bool)
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @ignore_daemon_sets.setter
    def ignore_daemon_sets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_daemon_sets", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        RKE node drain timeout. Default: `60` (int)
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ClusterSyncNodeArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations of the resource
        """
        capacity: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The total resources of a node (map).
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        The cluster ID that is syncing (string)
        """
        external_ip_address: NotRequired[pulumi.Input[str]]
        """
        The external IP address of the node (string).
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        The hostname of the node (string).
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) The ID of the resource. Same as `cluster_id` (string)
        """
        ip_address: NotRequired[pulumi.Input[str]]
        """
        The private IP address of the node (string).
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels of the resource
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the node (string).
        """
        node_pool_id: NotRequired[pulumi.Input[str]]
        """
        The Node Pool ID of the node (string).
        """
        node_template_id: NotRequired[pulumi.Input[str]]
        """
        The Node Template ID of the node (string).
        """
        provider_id: NotRequired[pulumi.Input[str]]
        """
        The Provider ID of the node (string).
        """
        requested_hostname: NotRequired[pulumi.Input[str]]
        """
        The requested hostname (string).
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Roles of the node. `controlplane`, `etcd` and `worker`. (list)
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        The user to connect to the node (string).
        """
        system_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        General information about the node, such as kernel version, kubelet and kube-proxy version, Docker version (if used), and OS name.
        """
elif False:
    ClusterSyncNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterSyncNodeArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 capacity: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 external_ip_address: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_pool_id: Optional[pulumi.Input[str]] = None,
                 node_template_id: Optional[pulumi.Input[str]] = None,
                 provider_id: Optional[pulumi.Input[str]] = None,
                 requested_hostname: Optional[pulumi.Input[str]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 system_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations of the resource
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] capacity: The total resources of a node (map).
        :param pulumi.Input[str] cluster_id: The cluster ID that is syncing (string)
        :param pulumi.Input[str] external_ip_address: The external IP address of the node (string).
        :param pulumi.Input[str] hostname: The hostname of the node (string).
        :param pulumi.Input[str] id: (Computed) The ID of the resource. Same as `cluster_id` (string)
        :param pulumi.Input[str] ip_address: The private IP address of the node (string).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels of the resource
        :param pulumi.Input[str] name: The name of the node (string).
        :param pulumi.Input[str] node_pool_id: The Node Pool ID of the node (string).
        :param pulumi.Input[str] node_template_id: The Node Template ID of the node (string).
        :param pulumi.Input[str] provider_id: The Provider ID of the node (string).
        :param pulumi.Input[str] requested_hostname: The requested hostname (string).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] roles: Roles of the node. `controlplane`, `etcd` and `worker`. (list)
        :param pulumi.Input[str] ssh_user: The user to connect to the node (string).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] system_info: General information about the node, such as kernel version, kubelet and kube-proxy version, Docker version (if used), and OS name.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if external_ip_address is not None:
            pulumi.set(__self__, "external_ip_address", external_ip_address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_pool_id is not None:
            pulumi.set(__self__, "node_pool_id", node_pool_id)
        if node_template_id is not None:
            pulumi.set(__self__, "node_template_id", node_template_id)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if requested_hostname is not None:
            pulumi.set(__self__, "requested_hostname", requested_hostname)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if system_info is not None:
            pulumi.set(__self__, "system_info", system_info)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations of the resource
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The total resources of a node (map).
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "capacity", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster ID that is syncing (string)
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="externalIpAddress")
    def external_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The external IP address of the node (string).
        """
        return pulumi.get(self, "external_ip_address")

    @external_ip_address.setter
    def external_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "external_ip_address", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The hostname of the node (string).
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The ID of the resource. Same as `cluster_id` (string)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        The private IP address of the node (string).
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels of the resource
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the node (string).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Node Pool ID of the node (string).
        """
        return pulumi.get(self, "node_pool_id")

    @node_pool_id.setter
    def node_pool_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pool_id", value)

    @property
    @pulumi.getter(name="nodeTemplateId")
    def node_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Node Template ID of the node (string).
        """
        return pulumi.get(self, "node_template_id")

    @node_template_id.setter
    def node_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_template_id", value)

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Provider ID of the node (string).
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter(name="requestedHostname")
    def requested_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The requested hostname (string).
        """
        return pulumi.get(self, "requested_hostname")

    @requested_hostname.setter
    def requested_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requested_hostname", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Roles of the node. `controlplane`, `etcd` and `worker`. (list)
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        The user to connect to the node (string).
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="systemInfo")
    def system_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        General information about the node, such as kernel version, kubelet and kube-proxy version, Docker version (if used), and OS name.
        """
        return pulumi.get(self, "system_info")

    @system_info.setter
    def system_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "system_info", value)


if not MYPY:
    class ClusterTemplateMemberArgsDict(TypedDict):
        access_type: NotRequired[pulumi.Input[str]]
        """
        Member access type: member, owner, read-only
        """
        group_principal_id: NotRequired[pulumi.Input[str]]
        """
        Member group principal id
        """
        user_principal_id: NotRequired[pulumi.Input[str]]
        """
        Member user principal id
        """
elif False:
    ClusterTemplateMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateMemberArgs:
    def __init__(__self__, *,
                 access_type: Optional[pulumi.Input[str]] = None,
                 group_principal_id: Optional[pulumi.Input[str]] = None,
                 user_principal_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_type: Member access type: member, owner, read-only
        :param pulumi.Input[str] group_principal_id: Member group principal id
        :param pulumi.Input[str] user_principal_id: Member user principal id
        """
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if group_principal_id is not None:
            pulumi.set(__self__, "group_principal_id", group_principal_id)
        if user_principal_id is not None:
            pulumi.set(__self__, "user_principal_id", user_principal_id)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[str]]:
        """
        Member access type: member, owner, read-only
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_type", value)

    @property
    @pulumi.getter(name="groupPrincipalId")
    def group_principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Member group principal id
        """
        return pulumi.get(self, "group_principal_id")

    @group_principal_id.setter
    def group_principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_principal_id", value)

    @property
    @pulumi.getter(name="userPrincipalId")
    def user_principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Member user principal id
        """
        return pulumi.get(self, "user_principal_id")

    @user_principal_id.setter
    def user_principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_id", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionArgsDict(TypedDict):
        cluster_config: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigArgsDict']
        """
        Cluster configuration
        """
        name: pulumi.Input[str]
        """
        The cluster template name (string)
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations for the cluster template (map)
        """
        cluster_template_id: NotRequired[pulumi.Input[str]]
        """
        Cluster template ID
        """
        default: NotRequired[pulumi.Input[bool]]
        """
        Default cluster template revision
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable cluster template revision
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed) The ID of the resource (string)
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the cluster template (map)
        """
        questions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionQuestionArgsDict']]]]
        """
        Cluster template questions
        """
elif False:
    ClusterTemplateTemplateRevisionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionArgs:
    def __init__(__self__, *,
                 cluster_config: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigArgs'],
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cluster_template_id: Optional[pulumi.Input[str]] = None,
                 default: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 questions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionQuestionArgs']]]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigArgs'] cluster_config: Cluster configuration
        :param pulumi.Input[str] name: The cluster template name (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations for the cluster template (map)
        :param pulumi.Input[str] cluster_template_id: Cluster template ID
        :param pulumi.Input[bool] default: Default cluster template revision
        :param pulumi.Input[bool] enabled: Enable cluster template revision
        :param pulumi.Input[str] id: (Computed) The ID of the resource (string)
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the cluster template (map)
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionQuestionArgs']]] questions: Cluster template questions
        """
        pulumi.set(__self__, "cluster_config", cluster_config)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_template_id is not None:
            pulumi.set(__self__, "cluster_template_id", cluster_template_id)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if questions is not None:
            pulumi.set(__self__, "questions", questions)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigArgs']:
        """
        Cluster configuration
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigArgs']):
        pulumi.set(self, "cluster_config", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations for the cluster template (map)
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterTemplateId")
    def cluster_template_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster template ID
        """
        return pulumi.get(self, "cluster_template_id")

    @cluster_template_id.setter
    def cluster_template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_template_id", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[bool]]:
        """
        Default cluster template revision
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable cluster template revision
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the cluster template (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def questions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionQuestionArgs']]]]:
        """
        Cluster template questions
        """
        return pulumi.get(self, "questions")

    @questions.setter
    def questions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionQuestionArgs']]]]):
        pulumi.set(self, "questions", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigArgsDict(TypedDict):
        rke_config: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgsDict']
        """
        Rancher Kubernetes Engine Config
        """
        cluster_auth_endpoint: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgsDict']]
        """
        Local cluster auth endpoint
        """
        default_cluster_role_for_project_members: NotRequired[pulumi.Input[str]]
        """
        Default cluster role for project members
        """
        default_pod_security_admission_configuration_template_name: NotRequired[pulumi.Input[str]]
        """
        Default pod security admission configuration template name
        """
        desired_agent_image: NotRequired[pulumi.Input[str]]
        """
        Desired agent image
        """
        desired_auth_image: NotRequired[pulumi.Input[str]]
        """
        Desired auth image
        """
        docker_root_dir: NotRequired[pulumi.Input[str]]
        """
        Docker Root Dir
        """
        enable_network_policy: NotRequired[pulumi.Input[bool]]
        """
        Enable project network isolation
        """
        windows_prefered_cluster: NotRequired[pulumi.Input[bool]]
        """
        Windows prefered cluster
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigArgs:
    def __init__(__self__, *,
                 rke_config: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs'],
                 cluster_auth_endpoint: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs']] = None,
                 default_cluster_role_for_project_members: Optional[pulumi.Input[str]] = None,
                 default_pod_security_admission_configuration_template_name: Optional[pulumi.Input[str]] = None,
                 desired_agent_image: Optional[pulumi.Input[str]] = None,
                 desired_auth_image: Optional[pulumi.Input[str]] = None,
                 docker_root_dir: Optional[pulumi.Input[str]] = None,
                 enable_network_policy: Optional[pulumi.Input[bool]] = None,
                 windows_prefered_cluster: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs'] rke_config: Rancher Kubernetes Engine Config
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs'] cluster_auth_endpoint: Local cluster auth endpoint
        :param pulumi.Input[str] default_cluster_role_for_project_members: Default cluster role for project members
        :param pulumi.Input[str] default_pod_security_admission_configuration_template_name: Default pod security admission configuration template name
        :param pulumi.Input[str] desired_agent_image: Desired agent image
        :param pulumi.Input[str] desired_auth_image: Desired auth image
        :param pulumi.Input[str] docker_root_dir: Docker Root Dir
        :param pulumi.Input[bool] enable_network_policy: Enable project network isolation
        :param pulumi.Input[bool] windows_prefered_cluster: Windows prefered cluster
        """
        pulumi.set(__self__, "rke_config", rke_config)
        if cluster_auth_endpoint is not None:
            pulumi.set(__self__, "cluster_auth_endpoint", cluster_auth_endpoint)
        if default_cluster_role_for_project_members is not None:
            pulumi.set(__self__, "default_cluster_role_for_project_members", default_cluster_role_for_project_members)
        if default_pod_security_admission_configuration_template_name is not None:
            pulumi.set(__self__, "default_pod_security_admission_configuration_template_name", default_pod_security_admission_configuration_template_name)
        if desired_agent_image is not None:
            pulumi.set(__self__, "desired_agent_image", desired_agent_image)
        if desired_auth_image is not None:
            pulumi.set(__self__, "desired_auth_image", desired_auth_image)
        if docker_root_dir is not None:
            pulumi.set(__self__, "docker_root_dir", docker_root_dir)
        if enable_network_policy is not None:
            pulumi.set(__self__, "enable_network_policy", enable_network_policy)
        if windows_prefered_cluster is not None:
            pulumi.set(__self__, "windows_prefered_cluster", windows_prefered_cluster)

    @property
    @pulumi.getter(name="rkeConfig")
    def rke_config(self) -> pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs']:
        """
        Rancher Kubernetes Engine Config
        """
        return pulumi.get(self, "rke_config")

    @rke_config.setter
    def rke_config(self, value: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs']):
        pulumi.set(self, "rke_config", value)

    @property
    @pulumi.getter(name="clusterAuthEndpoint")
    def cluster_auth_endpoint(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs']]:
        """
        Local cluster auth endpoint
        """
        return pulumi.get(self, "cluster_auth_endpoint")

    @cluster_auth_endpoint.setter
    def cluster_auth_endpoint(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs']]):
        pulumi.set(self, "cluster_auth_endpoint", value)

    @property
    @pulumi.getter(name="defaultClusterRoleForProjectMembers")
    def default_cluster_role_for_project_members(self) -> Optional[pulumi.Input[str]]:
        """
        Default cluster role for project members
        """
        return pulumi.get(self, "default_cluster_role_for_project_members")

    @default_cluster_role_for_project_members.setter
    def default_cluster_role_for_project_members(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_cluster_role_for_project_members", value)

    @property
    @pulumi.getter(name="defaultPodSecurityAdmissionConfigurationTemplateName")
    def default_pod_security_admission_configuration_template_name(self) -> Optional[pulumi.Input[str]]:
        """
        Default pod security admission configuration template name
        """
        return pulumi.get(self, "default_pod_security_admission_configuration_template_name")

    @default_pod_security_admission_configuration_template_name.setter
    def default_pod_security_admission_configuration_template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_pod_security_admission_configuration_template_name", value)

    @property
    @pulumi.getter(name="desiredAgentImage")
    def desired_agent_image(self) -> Optional[pulumi.Input[str]]:
        """
        Desired agent image
        """
        return pulumi.get(self, "desired_agent_image")

    @desired_agent_image.setter
    def desired_agent_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "desired_agent_image", value)

    @property
    @pulumi.getter(name="desiredAuthImage")
    def desired_auth_image(self) -> Optional[pulumi.Input[str]]:
        """
        Desired auth image
        """
        return pulumi.get(self, "desired_auth_image")

    @desired_auth_image.setter
    def desired_auth_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "desired_auth_image", value)

    @property
    @pulumi.getter(name="dockerRootDir")
    def docker_root_dir(self) -> Optional[pulumi.Input[str]]:
        """
        Docker Root Dir
        """
        return pulumi.get(self, "docker_root_dir")

    @docker_root_dir.setter
    def docker_root_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_root_dir", value)

    @property
    @pulumi.getter(name="enableNetworkPolicy")
    def enable_network_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable project network isolation
        """
        return pulumi.get(self, "enable_network_policy")

    @enable_network_policy.setter
    def enable_network_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_policy", value)

    @property
    @pulumi.getter(name="windowsPreferedCluster")
    def windows_prefered_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        Windows prefered cluster
        """
        return pulumi.get(self, "windows_prefered_cluster")

    @windows_prefered_cluster.setter
    def windows_prefered_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "windows_prefered_cluster", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable cluster template revision. Default `true` (bool)
        """
        fqdn: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable cluster template revision. Default `true` (bool)
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgsDict(TypedDict):
        addon_job_timeout: NotRequired[pulumi.Input[int]]
        """
        Optional duration in seconds of addon job.
        """
        addons: NotRequired[pulumi.Input[str]]
        """
        Optional addons descripton to deploy on rke cluster.
        """
        addons_includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        authentication: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgsDict']]
        """
        Kubernetes cluster authentication
        """
        authorization: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgsDict']]
        """
        Kubernetes cluster authorization
        """
        bastion_host: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgsDict']]
        """
        RKE bastion host
        """
        cloud_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgsDict']]
        dns: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgsDict']]
        enable_cri_dockerd: NotRequired[pulumi.Input[bool]]
        """
        Enable/disable using cri-dockerd
        """
        ignore_docker_version: NotRequired[pulumi.Input[bool]]
        """
        Optional ignore docker version on nodes
        """
        ingress: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgsDict']]
        """
        Kubernetes ingress configuration
        """
        kubernetes_version: NotRequired[pulumi.Input[str]]
        """
        Optional kubernetes version to deploy
        """
        monitoring: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgsDict']]
        """
        Kubernetes cluster monitoring
        """
        network: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgsDict']]
        """
        Kubernetes cluster networking
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgsDict']]]]
        """
        Optional RKE cluster nodes
        """
        prefix_path: NotRequired[pulumi.Input[str]]
        """
        Optional prefix to customize kubernetes path
        """
        private_registries: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgsDict']]]]
        """
        Optional private registries for docker images
        """
        services: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgsDict']]
        """
        Kubernetes cluster services
        """
        ssh_agent_auth: NotRequired[pulumi.Input[bool]]
        """
        Optional use ssh agent auth
        """
        ssh_cert_path: NotRequired[pulumi.Input[str]]
        """
        Optional cluster level SSH certificate path
        """
        ssh_key_path: NotRequired[pulumi.Input[str]]
        """
        Optional cluster level SSH private key path
        """
        upgrade_strategy: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgsDict']]
        """
        RKE upgrade strategy
        """
        win_prefix_path: NotRequired[pulumi.Input[str]]
        """
        Optional prefix to customize kubernetes path for windows
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs:
    def __init__(__self__, *,
                 addon_job_timeout: Optional[pulumi.Input[int]] = None,
                 addons: Optional[pulumi.Input[str]] = None,
                 addons_includes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 authentication: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs']] = None,
                 authorization: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs']] = None,
                 bastion_host: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs']] = None,
                 cloud_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgs']] = None,
                 dns: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgs']] = None,
                 enable_cri_dockerd: Optional[pulumi.Input[bool]] = None,
                 ignore_docker_version: Optional[pulumi.Input[bool]] = None,
                 ingress: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs']] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs']] = None,
                 network: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs']] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs']]]] = None,
                 prefix_path: Optional[pulumi.Input[str]] = None,
                 private_registries: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs']]]] = None,
                 services: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs']] = None,
                 ssh_agent_auth: Optional[pulumi.Input[bool]] = None,
                 ssh_cert_path: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None,
                 upgrade_strategy: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs']] = None,
                 win_prefix_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] addon_job_timeout: Optional duration in seconds of addon job.
        :param pulumi.Input[str] addons: Optional addons descripton to deploy on rke cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addons_includes: Optional addons yaml manisfest to deploy on rke cluster.
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs'] authentication: Kubernetes cluster authentication
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs'] authorization: Kubernetes cluster authorization
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs'] bastion_host: RKE bastion host
        :param pulumi.Input[bool] enable_cri_dockerd: Enable/disable using cri-dockerd
        :param pulumi.Input[bool] ignore_docker_version: Optional ignore docker version on nodes
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs'] ingress: Kubernetes ingress configuration
        :param pulumi.Input[str] kubernetes_version: Optional kubernetes version to deploy
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs'] monitoring: Kubernetes cluster monitoring
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs'] network: Kubernetes cluster networking
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs']]] nodes: Optional RKE cluster nodes
        :param pulumi.Input[str] prefix_path: Optional prefix to customize kubernetes path
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs']]] private_registries: Optional private registries for docker images
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs'] services: Kubernetes cluster services
        :param pulumi.Input[bool] ssh_agent_auth: Optional use ssh agent auth
        :param pulumi.Input[str] ssh_cert_path: Optional cluster level SSH certificate path
        :param pulumi.Input[str] ssh_key_path: Optional cluster level SSH private key path
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs'] upgrade_strategy: RKE upgrade strategy
        :param pulumi.Input[str] win_prefix_path: Optional prefix to customize kubernetes path for windows
        """
        if addon_job_timeout is not None:
            pulumi.set(__self__, "addon_job_timeout", addon_job_timeout)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if addons_includes is not None:
            pulumi.set(__self__, "addons_includes", addons_includes)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if bastion_host is not None:
            pulumi.set(__self__, "bastion_host", bastion_host)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if enable_cri_dockerd is not None:
            pulumi.set(__self__, "enable_cri_dockerd", enable_cri_dockerd)
        if ignore_docker_version is not None:
            pulumi.set(__self__, "ignore_docker_version", ignore_docker_version)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if private_registries is not None:
            pulumi.set(__self__, "private_registries", private_registries)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_cert_path is not None:
            pulumi.set(__self__, "ssh_cert_path", ssh_cert_path)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if win_prefix_path is not None:
            pulumi.set(__self__, "win_prefix_path", win_prefix_path)

    @property
    @pulumi.getter(name="addonJobTimeout")
    def addon_job_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Optional duration in seconds of addon job.
        """
        return pulumi.get(self, "addon_job_timeout")

    @addon_job_timeout.setter
    def addon_job_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "addon_job_timeout", value)

    @property
    @pulumi.getter
    def addons(self) -> Optional[pulumi.Input[str]]:
        """
        Optional addons descripton to deploy on rke cluster.
        """
        return pulumi.get(self, "addons")

    @addons.setter
    def addons(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "addons", value)

    @property
    @pulumi.getter(name="addonsIncludes")
    def addons_includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        return pulumi.get(self, "addons_includes")

    @addons_includes.setter
    def addons_includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addons_includes", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs']]:
        """
        Kubernetes cluster authentication
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs']]:
        """
        Kubernetes cluster authorization
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="bastionHost")
    def bastion_host(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs']]:
        """
        RKE bastion host
        """
        return pulumi.get(self, "bastion_host")

    @bastion_host.setter
    def bastion_host(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs']]):
        pulumi.set(self, "bastion_host", value)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgs']]:
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgs']]):
        pulumi.set(self, "cloud_provider", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgs']]:
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgs']]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="enableCriDockerd")
    def enable_cri_dockerd(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable/disable using cri-dockerd
        """
        return pulumi.get(self, "enable_cri_dockerd")

    @enable_cri_dockerd.setter
    def enable_cri_dockerd(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cri_dockerd", value)

    @property
    @pulumi.getter(name="ignoreDockerVersion")
    def ignore_docker_version(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional ignore docker version on nodes
        """
        return pulumi.get(self, "ignore_docker_version")

    @ignore_docker_version.setter
    def ignore_docker_version(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_docker_version", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs']]:
        """
        Kubernetes ingress configuration
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs']]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional kubernetes version to deploy
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs']]:
        """
        Kubernetes cluster monitoring
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs']]:
        """
        Kubernetes cluster networking
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs']]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs']]]]:
        """
        Optional RKE cluster nodes
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional prefix to customize kubernetes path
        """
        return pulumi.get(self, "prefix_path")

    @prefix_path.setter
    def prefix_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix_path", value)

    @property
    @pulumi.getter(name="privateRegistries")
    def private_registries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs']]]]:
        """
        Optional private registries for docker images
        """
        return pulumi.get(self, "private_registries")

    @private_registries.setter
    def private_registries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs']]]]):
        pulumi.set(self, "private_registries", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs']]:
        """
        Kubernetes cluster services
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs']]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional use ssh agent auth
        """
        return pulumi.get(self, "ssh_agent_auth")

    @ssh_agent_auth.setter
    def ssh_agent_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssh_agent_auth", value)

    @property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional cluster level SSH certificate path
        """
        return pulumi.get(self, "ssh_cert_path")

    @ssh_cert_path.setter
    def ssh_cert_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_cert_path", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional cluster level SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)

    @property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs']]:
        """
        RKE upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @upgrade_strategy.setter
    def upgrade_strategy(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs']]):
        pulumi.set(self, "upgrade_strategy", value)

    @property
    @pulumi.getter(name="winPrefixPath")
    def win_prefix_path(self) -> Optional[pulumi.Input[str]]:
        """
        Optional prefix to customize kubernetes path for windows
        """
        return pulumi.get(self, "win_prefix_path")

    @win_prefix_path.setter
    def win_prefix_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "win_prefix_path", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgsDict(TypedDict):
        sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        strategy: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs:
    def __init__(__self__, *,
                 sans: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter
    def sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "sans")

    @sans.setter
    def sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sans", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgsDict(TypedDict):
        address: pulumi.Input[str]
        user: pulumi.Input[str]
        port: NotRequired[pulumi.Input[str]]
        ssh_agent_auth: NotRequired[pulumi.Input[bool]]
        ssh_key: NotRequired[pulumi.Input[str]]
        ssh_key_path: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 user: pulumi.Input[str],
                 port: Optional[pulumi.Input[str]] = None,
                 ssh_agent_auth: Optional[pulumi.Input[bool]] = None,
                 ssh_key: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ssh_agent_auth")

    @ssh_agent_auth.setter
    def ssh_agent_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssh_agent_auth", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgsDict(TypedDict):
        aws_cloud_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgsDict']]
        azure_cloud_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgsDict']]
        custom_cloud_provider: NotRequired[pulumi.Input[str]]
        name: NotRequired[pulumi.Input[str]]
        """
        The cluster template name (string)
        """
        openstack_cloud_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgsDict']]
        vsphere_cloud_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgsDict']]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderArgs:
    def __init__(__self__, *,
                 aws_cloud_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgs']] = None,
                 azure_cloud_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgs']] = None,
                 custom_cloud_provider: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 openstack_cloud_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgs']] = None,
                 vsphere_cloud_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgs']] = None):
        """
        :param pulumi.Input[str] name: The cluster template name (string)
        """
        if aws_cloud_provider is not None:
            pulumi.set(__self__, "aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_provider is not None:
            pulumi.set(__self__, "azure_cloud_provider", azure_cloud_provider)
        if custom_cloud_provider is not None:
            pulumi.set(__self__, "custom_cloud_provider", custom_cloud_provider)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if openstack_cloud_provider is not None:
            pulumi.set(__self__, "openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_provider is not None:
            pulumi.set(__self__, "vsphere_cloud_provider", vsphere_cloud_provider)

    @property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgs']]:
        return pulumi.get(self, "aws_cloud_provider")

    @aws_cloud_provider.setter
    def aws_cloud_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgs']]):
        pulumi.set(self, "aws_cloud_provider", value)

    @property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgs']]:
        return pulumi.get(self, "azure_cloud_provider")

    @azure_cloud_provider.setter
    def azure_cloud_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgs']]):
        pulumi.set(self, "azure_cloud_provider", value)

    @property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_cloud_provider")

    @custom_cloud_provider.setter
    def custom_cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_cloud_provider", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgs']]:
        return pulumi.get(self, "openstack_cloud_provider")

    @openstack_cloud_provider.setter
    def openstack_cloud_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgs']]):
        pulumi.set(self, "openstack_cloud_provider", value)

    @property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgs']]:
        return pulumi.get(self, "vsphere_cloud_provider")

    @vsphere_cloud_provider.setter
    def vsphere_cloud_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgs']]):
        pulumi.set(self, "vsphere_cloud_provider", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgsDict(TypedDict):
        global_: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict']]
        service_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict']]]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderArgs:
    def __init__(__self__, *,
                 global_: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgs']] = None,
                 service_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]]] = None):
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if service_overrides is not None:
            pulumi.set(__self__, "service_overrides", service_overrides)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgs']]:
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgs']]):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]]]:
        return pulumi.get(self, "service_overrides")

    @service_overrides.setter
    def service_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs']]]]):
        pulumi.set(self, "service_overrides", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict(TypedDict):
        disable_security_group_ingress: NotRequired[pulumi.Input[bool]]
        disable_strict_zone_check: NotRequired[pulumi.Input[bool]]
        elb_security_group: NotRequired[pulumi.Input[str]]
        kubernetes_cluster_id: NotRequired[pulumi.Input[str]]
        kubernetes_cluster_tag: NotRequired[pulumi.Input[str]]
        role_arn: NotRequired[pulumi.Input[str]]
        route_table_id: NotRequired[pulumi.Input[str]]
        subnet_id: NotRequired[pulumi.Input[str]]
        vpc: NotRequired[pulumi.Input[str]]
        zone: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalArgs:
    def __init__(__self__, *,
                 disable_security_group_ingress: Optional[pulumi.Input[bool]] = None,
                 disable_strict_zone_check: Optional[pulumi.Input[bool]] = None,
                 elb_security_group: Optional[pulumi.Input[str]] = None,
                 kubernetes_cluster_id: Optional[pulumi.Input[str]] = None,
                 kubernetes_cluster_tag: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 route_table_id: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 vpc: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            pulumi.set(__self__, "disable_strict_zone_check", disable_strict_zone_check)
        if elb_security_group is not None:
            pulumi.set(__self__, "elb_security_group", elb_security_group)
        if kubernetes_cluster_id is not None:
            pulumi.set(__self__, "kubernetes_cluster_id", kubernetes_cluster_id)
        if kubernetes_cluster_tag is not None:
            pulumi.set(__self__, "kubernetes_cluster_tag", kubernetes_cluster_tag)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_security_group_ingress")

    @disable_security_group_ingress.setter
    def disable_security_group_ingress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_security_group_ingress", value)

    @property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disable_strict_zone_check")

    @disable_strict_zone_check.setter
    def disable_strict_zone_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_strict_zone_check", value)

    @property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "elb_security_group")

    @elb_security_group.setter
    def elb_security_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "elb_security_group", value)

    @property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kubernetes_cluster_id")

    @kubernetes_cluster_id.setter
    def kubernetes_cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_cluster_id", value)

    @property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kubernetes_cluster_tag")

    @kubernetes_cluster_tag.setter
    def kubernetes_cluster_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_cluster_tag", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "route_table_id")

    @route_table_id.setter
    def route_table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_id", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter
    def vpc(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict(TypedDict):
        service: pulumi.Input[str]
        region: NotRequired[pulumi.Input[str]]
        signing_method: NotRequired[pulumi.Input[str]]
        signing_name: NotRequired[pulumi.Input[str]]
        signing_region: NotRequired[pulumi.Input[str]]
        url: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 region: Optional[pulumi.Input[str]] = None,
                 signing_method: Optional[pulumi.Input[str]] = None,
                 signing_name: Optional[pulumi.Input[str]] = None,
                 signing_region: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "service", service)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if signing_method is not None:
            pulumi.set(__self__, "signing_method", signing_method)
        if signing_name is not None:
            pulumi.set(__self__, "signing_name", signing_name)
        if signing_region is not None:
            pulumi.set(__self__, "signing_region", signing_region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "signing_method")

    @signing_method.setter
    def signing_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_method", value)

    @property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "signing_name")

    @signing_name.setter
    def signing_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_name", value)

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "signing_region")

    @signing_region.setter
    def signing_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signing_region", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgsDict(TypedDict):
        aad_client_id: pulumi.Input[str]
        aad_client_secret: pulumi.Input[str]
        subscription_id: pulumi.Input[str]
        tenant_id: pulumi.Input[str]
        aad_client_cert_password: NotRequired[pulumi.Input[str]]
        aad_client_cert_path: NotRequired[pulumi.Input[str]]
        cloud: NotRequired[pulumi.Input[str]]
        cloud_provider_backoff: NotRequired[pulumi.Input[bool]]
        cloud_provider_backoff_duration: NotRequired[pulumi.Input[int]]
        cloud_provider_backoff_exponent: NotRequired[pulumi.Input[int]]
        cloud_provider_backoff_jitter: NotRequired[pulumi.Input[int]]
        cloud_provider_backoff_retries: NotRequired[pulumi.Input[int]]
        cloud_provider_rate_limit: NotRequired[pulumi.Input[bool]]
        cloud_provider_rate_limit_bucket: NotRequired[pulumi.Input[int]]
        cloud_provider_rate_limit_qps: NotRequired[pulumi.Input[int]]
        load_balancer_sku: NotRequired[pulumi.Input[str]]
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        location: NotRequired[pulumi.Input[str]]
        maximum_load_balancer_rule_count: NotRequired[pulumi.Input[int]]
        primary_availability_set_name: NotRequired[pulumi.Input[str]]
        primary_scale_set_name: NotRequired[pulumi.Input[str]]
        resource_group: NotRequired[pulumi.Input[str]]
        route_table_name: NotRequired[pulumi.Input[str]]
        security_group_name: NotRequired[pulumi.Input[str]]
        subnet_name: NotRequired[pulumi.Input[str]]
        use_instance_metadata: NotRequired[pulumi.Input[bool]]
        use_managed_identity_extension: NotRequired[pulumi.Input[bool]]
        vm_type: NotRequired[pulumi.Input[str]]
        vnet_name: NotRequired[pulumi.Input[str]]
        vnet_resource_group: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderArgs:
    def __init__(__self__, *,
                 aad_client_id: pulumi.Input[str],
                 aad_client_secret: pulumi.Input[str],
                 subscription_id: pulumi.Input[str],
                 tenant_id: pulumi.Input[str],
                 aad_client_cert_password: Optional[pulumi.Input[str]] = None,
                 aad_client_cert_path: Optional[pulumi.Input[str]] = None,
                 cloud: Optional[pulumi.Input[str]] = None,
                 cloud_provider_backoff: Optional[pulumi.Input[bool]] = None,
                 cloud_provider_backoff_duration: Optional[pulumi.Input[int]] = None,
                 cloud_provider_backoff_exponent: Optional[pulumi.Input[int]] = None,
                 cloud_provider_backoff_jitter: Optional[pulumi.Input[int]] = None,
                 cloud_provider_backoff_retries: Optional[pulumi.Input[int]] = None,
                 cloud_provider_rate_limit: Optional[pulumi.Input[bool]] = None,
                 cloud_provider_rate_limit_bucket: Optional[pulumi.Input[int]] = None,
                 cloud_provider_rate_limit_qps: Optional[pulumi.Input[int]] = None,
                 load_balancer_sku: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 maximum_load_balancer_rule_count: Optional[pulumi.Input[int]] = None,
                 primary_availability_set_name: Optional[pulumi.Input[str]] = None,
                 primary_scale_set_name: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 route_table_name: Optional[pulumi.Input[str]] = None,
                 security_group_name: Optional[pulumi.Input[str]] = None,
                 subnet_name: Optional[pulumi.Input[str]] = None,
                 use_instance_metadata: Optional[pulumi.Input[bool]] = None,
                 use_managed_identity_extension: Optional[pulumi.Input[bool]] = None,
                 vm_type: Optional[pulumi.Input[str]] = None,
                 vnet_name: Optional[pulumi.Input[str]] = None,
                 vnet_resource_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        pulumi.set(__self__, "aad_client_id", aad_client_id)
        pulumi.set(__self__, "aad_client_secret", aad_client_secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if aad_client_cert_password is not None:
            pulumi.set(__self__, "aad_client_cert_password", aad_client_cert_password)
        if aad_client_cert_path is not None:
            pulumi.set(__self__, "aad_client_cert_path", aad_client_cert_path)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if cloud_provider_backoff is not None:
            pulumi.set(__self__, "cloud_provider_backoff", cloud_provider_backoff)
        if cloud_provider_backoff_duration is not None:
            pulumi.set(__self__, "cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        if cloud_provider_backoff_exponent is not None:
            pulumi.set(__self__, "cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        if cloud_provider_backoff_jitter is not None:
            pulumi.set(__self__, "cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        if cloud_provider_backoff_retries is not None:
            pulumi.set(__self__, "cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        if cloud_provider_rate_limit is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit", cloud_provider_rate_limit)
        if cloud_provider_rate_limit_bucket is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        if cloud_provider_rate_limit_qps is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_load_balancer_rule_count is not None:
            pulumi.set(__self__, "maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        if primary_availability_set_name is not None:
            pulumi.set(__self__, "primary_availability_set_name", primary_availability_set_name)
        if primary_scale_set_name is not None:
            pulumi.set(__self__, "primary_scale_set_name", primary_scale_set_name)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if route_table_name is not None:
            pulumi.set(__self__, "route_table_name", route_table_name)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if use_instance_metadata is not None:
            pulumi.set(__self__, "use_instance_metadata", use_instance_metadata)
        if use_managed_identity_extension is not None:
            pulumi.set(__self__, "use_managed_identity_extension", use_managed_identity_extension)
        if vm_type is not None:
            pulumi.set(__self__, "vm_type", vm_type)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)
        if vnet_resource_group is not None:
            pulumi.set(__self__, "vnet_resource_group", vnet_resource_group)

    @property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aad_client_id")

    @aad_client_id.setter
    def aad_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "aad_client_id", value)

    @property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aad_client_secret")

    @aad_client_secret.setter
    def aad_client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "aad_client_secret", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aad_client_cert_password")

    @aad_client_cert_password.setter
    def aad_client_cert_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aad_client_cert_password", value)

    @property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aad_client_cert_path")

    @aad_client_cert_path.setter
    def aad_client_cert_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aad_client_cert_path", value)

    @property
    @pulumi.getter
    def cloud(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud")

    @cloud.setter
    def cloud(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud", value)

    @property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cloud_provider_backoff")

    @cloud_provider_backoff.setter
    def cloud_provider_backoff(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloud_provider_backoff", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @cloud_provider_backoff_duration.setter
    def cloud_provider_backoff_duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_duration", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @cloud_provider_backoff_exponent.setter
    def cloud_provider_backoff_exponent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_exponent", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @cloud_provider_backoff_jitter.setter
    def cloud_provider_backoff_jitter(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_jitter", value)

    @property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @cloud_provider_backoff_retries.setter
    def cloud_provider_backoff_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_backoff_retries", value)

    @property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "cloud_provider_rate_limit")

    @cloud_provider_rate_limit.setter
    def cloud_provider_rate_limit(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "cloud_provider_rate_limit", value)

    @property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @cloud_provider_rate_limit_bucket.setter
    def cloud_provider_rate_limit_bucket(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_rate_limit_bucket", value)

    @property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @cloud_provider_rate_limit_qps.setter
    def cloud_provider_rate_limit_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloud_provider_rate_limit_qps", value)

    @property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")

    @load_balancer_sku.setter
    def load_balancer_sku(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "load_balancer_sku", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @maximum_load_balancer_rule_count.setter
    def maximum_load_balancer_rule_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_load_balancer_rule_count", value)

    @property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_availability_set_name")

    @primary_availability_set_name.setter
    def primary_availability_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_availability_set_name", value)

    @property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "primary_scale_set_name")

    @primary_scale_set_name.setter
    def primary_scale_set_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "primary_scale_set_name", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "route_table_name")

    @route_table_name.setter
    def route_table_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_table_name", value)

    @property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "security_group_name")

    @security_group_name.setter
    def security_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_group_name", value)

    @property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_name")

    @subnet_name.setter
    def subnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_name", value)

    @property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_instance_metadata")

    @use_instance_metadata.setter
    def use_instance_metadata(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_instance_metadata", value)

    @property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_managed_identity_extension")

    @use_managed_identity_extension.setter
    def use_managed_identity_extension(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_managed_identity_extension", value)

    @property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vm_type")

    @vm_type.setter
    def vm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_type", value)

    @property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vnet_name")

    @vnet_name.setter
    def vnet_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_name", value)

    @property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vnet_resource_group")

    @vnet_resource_group.setter
    def vnet_resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet_resource_group", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgsDict(TypedDict):
        global_: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict']
        block_storage: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict']]
        load_balancer: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict']]
        metadata: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict']]
        route: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict']]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderArgs:
    def __init__(__self__, *,
                 global_: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs'],
                 block_storage: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs']] = None,
                 load_balancer: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs']] = None,
                 metadata: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs']] = None,
                 route: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgs']] = None):
        pulumi.set(__self__, "global_", global_)
        if block_storage is not None:
            pulumi.set(__self__, "block_storage", block_storage)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs']:
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs']):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs']]:
        return pulumi.get(self, "block_storage")

    @block_storage.setter
    def block_storage(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs']]):
        pulumi.set(self, "block_storage", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs']]:
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs']]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs']]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs']]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgs']]:
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgs']]):
        pulumi.set(self, "route", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict(TypedDict):
        bs_version: NotRequired[pulumi.Input[str]]
        ignore_volume_az: NotRequired[pulumi.Input[bool]]
        trust_device_path: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs:
    def __init__(__self__, *,
                 bs_version: Optional[pulumi.Input[str]] = None,
                 ignore_volume_az: Optional[pulumi.Input[bool]] = None,
                 trust_device_path: Optional[pulumi.Input[bool]] = None):
        if bs_version is not None:
            pulumi.set(__self__, "bs_version", bs_version)
        if ignore_volume_az is not None:
            pulumi.set(__self__, "ignore_volume_az", ignore_volume_az)
        if trust_device_path is not None:
            pulumi.set(__self__, "trust_device_path", trust_device_path)

    @property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bs_version")

    @bs_version.setter
    def bs_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bs_version", value)

    @property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ignore_volume_az")

    @ignore_volume_az.setter
    def ignore_volume_az(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_volume_az", value)

    @property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "trust_device_path")

    @trust_device_path.setter
    def trust_device_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "trust_device_path", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict(TypedDict):
        auth_url: pulumi.Input[str]
        password: pulumi.Input[str]
        username: pulumi.Input[str]
        ca_file: NotRequired[pulumi.Input[str]]
        domain_id: NotRequired[pulumi.Input[str]]
        domain_name: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        tenant_id: NotRequired[pulumi.Input[str]]
        tenant_name: NotRequired[pulumi.Input[str]]
        trust_id: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs:
    def __init__(__self__, *,
                 auth_url: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 ca_file: Optional[pulumi.Input[str]] = None,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 tenant_name: Optional[pulumi.Input[str]] = None,
                 trust_id: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if trust_id is not None:
            pulumi.set(__self__, "trust_id", trust_id)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_name", value)

    @property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trust_id")

    @trust_id.setter
    def trust_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trust_id", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict(TypedDict):
        create_monitor: NotRequired[pulumi.Input[bool]]
        floating_network_id: NotRequired[pulumi.Input[str]]
        lb_method: NotRequired[pulumi.Input[str]]
        lb_provider: NotRequired[pulumi.Input[str]]
        lb_version: NotRequired[pulumi.Input[str]]
        manage_security_groups: NotRequired[pulumi.Input[bool]]
        monitor_delay: NotRequired[pulumi.Input[str]]
        monitor_max_retries: NotRequired[pulumi.Input[int]]
        monitor_timeout: NotRequired[pulumi.Input[str]]
        subnet_id: NotRequired[pulumi.Input[str]]
        use_octavia: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs:
    def __init__(__self__, *,
                 create_monitor: Optional[pulumi.Input[bool]] = None,
                 floating_network_id: Optional[pulumi.Input[str]] = None,
                 lb_method: Optional[pulumi.Input[str]] = None,
                 lb_provider: Optional[pulumi.Input[str]] = None,
                 lb_version: Optional[pulumi.Input[str]] = None,
                 manage_security_groups: Optional[pulumi.Input[bool]] = None,
                 monitor_delay: Optional[pulumi.Input[str]] = None,
                 monitor_max_retries: Optional[pulumi.Input[int]] = None,
                 monitor_timeout: Optional[pulumi.Input[str]] = None,
                 subnet_id: Optional[pulumi.Input[str]] = None,
                 use_octavia: Optional[pulumi.Input[bool]] = None):
        if create_monitor is not None:
            pulumi.set(__self__, "create_monitor", create_monitor)
        if floating_network_id is not None:
            pulumi.set(__self__, "floating_network_id", floating_network_id)
        if lb_method is not None:
            pulumi.set(__self__, "lb_method", lb_method)
        if lb_provider is not None:
            pulumi.set(__self__, "lb_provider", lb_provider)
        if lb_version is not None:
            pulumi.set(__self__, "lb_version", lb_version)
        if manage_security_groups is not None:
            pulumi.set(__self__, "manage_security_groups", manage_security_groups)
        if monitor_delay is not None:
            pulumi.set(__self__, "monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            pulumi.set(__self__, "monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if use_octavia is not None:
            pulumi.set(__self__, "use_octavia", use_octavia)

    @property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "create_monitor")

    @create_monitor.setter
    def create_monitor(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_monitor", value)

    @property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "floating_network_id")

    @floating_network_id.setter
    def floating_network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "floating_network_id", value)

    @property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lb_method")

    @lb_method.setter
    def lb_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_method", value)

    @property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lb_provider")

    @lb_provider.setter
    def lb_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_provider", value)

    @property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "lb_version")

    @lb_version.setter
    def lb_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_version", value)

    @property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "manage_security_groups")

    @manage_security_groups.setter
    def manage_security_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manage_security_groups", value)

    @property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "monitor_delay")

    @monitor_delay.setter
    def monitor_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor_delay", value)

    @property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "monitor_max_retries")

    @monitor_max_retries.setter
    def monitor_max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "monitor_max_retries", value)

    @property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "monitor_timeout")

    @monitor_timeout.setter
    def monitor_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitor_timeout", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_octavia")

    @use_octavia.setter
    def use_octavia(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_octavia", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict(TypedDict):
        request_timeout: NotRequired[pulumi.Input[int]]
        search_order: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs:
    def __init__(__self__, *,
                 request_timeout: Optional[pulumi.Input[int]] = None,
                 search_order: Optional[pulumi.Input[str]] = None):
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if search_order is not None:
            pulumi.set(__self__, "search_order", search_order)

    @property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "request_timeout")

    @request_timeout.setter
    def request_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "request_timeout", value)

    @property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_order")

    @search_order.setter
    def search_order(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_order", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict(TypedDict):
        router_id: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteArgs:
    def __init__(__self__, *,
                 router_id: Optional[pulumi.Input[str]] = None):
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "router_id")

    @router_id.setter
    def router_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "router_id", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgsDict(TypedDict):
        virtual_centers: pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict']]]
        workspace: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict']
        disk: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict']]
        global_: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict']]
        network: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict']]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderArgs:
    def __init__(__self__, *,
                 virtual_centers: pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]],
                 workspace: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs'],
                 disk: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgs']] = None,
                 global_: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgs']] = None,
                 network: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgs']] = None):
        pulumi.set(__self__, "virtual_centers", virtual_centers)
        pulumi.set(__self__, "workspace", workspace)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]]:
        return pulumi.get(self, "virtual_centers")

    @virtual_centers.setter
    def virtual_centers(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs']]]):
        pulumi.set(self, "virtual_centers", value)

    @property
    @pulumi.getter
    def workspace(self) -> pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs']:
        return pulumi.get(self, "workspace")

    @workspace.setter
    def workspace(self, value: pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs']):
        pulumi.set(self, "workspace", value)

    @property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgs']]:
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgs']]):
        pulumi.set(self, "disk", value)

    @property
    @pulumi.getter(name="global")
    def global_(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgs']]:
        return pulumi.get(self, "global_")

    @global_.setter
    def global_(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgs']]):
        pulumi.set(self, "global_", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgs']]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgs']]):
        pulumi.set(self, "network", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict(TypedDict):
        scsi_controller_type: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskArgs:
    def __init__(__self__, *,
                 scsi_controller_type: Optional[pulumi.Input[str]] = None):
        if scsi_controller_type is not None:
            pulumi.set(__self__, "scsi_controller_type", scsi_controller_type)

    @property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "scsi_controller_type")

    @scsi_controller_type.setter
    def scsi_controller_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scsi_controller_type", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict(TypedDict):
        datacenters: NotRequired[pulumi.Input[str]]
        graceful_shutdown_timeout: NotRequired[pulumi.Input[str]]
        insecure_flag: NotRequired[pulumi.Input[bool]]
        password: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[str]]
        soap_roundtrip_count: NotRequired[pulumi.Input[int]]
        user: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalArgs:
    def __init__(__self__, *,
                 datacenters: Optional[pulumi.Input[str]] = None,
                 graceful_shutdown_timeout: Optional[pulumi.Input[str]] = None,
                 insecure_flag: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 soap_roundtrip_count: Optional[pulumi.Input[int]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if insecure_flag is not None:
            pulumi.set(__self__, "insecure_flag", insecure_flag)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenters", value)

    @property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "graceful_shutdown_timeout")

    @graceful_shutdown_timeout.setter
    def graceful_shutdown_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graceful_shutdown_timeout", value)

    @property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "insecure_flag")

    @insecure_flag.setter
    def insecure_flag(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_flag", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "soap_roundtrip_count")

    @soap_roundtrip_count.setter
    def soap_roundtrip_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "soap_roundtrip_count", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict(TypedDict):
        public_network: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkArgs:
    def __init__(__self__, *,
                 public_network: Optional[pulumi.Input[str]] = None):
        if public_network is not None:
            pulumi.set(__self__, "public_network", public_network)

    @property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "public_network")

    @public_network.setter
    def public_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_network", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict(TypedDict):
        datacenters: pulumi.Input[str]
        name: pulumi.Input[str]
        """
        The cluster template name (string)
        """
        password: pulumi.Input[str]
        user: pulumi.Input[str]
        port: NotRequired[pulumi.Input[str]]
        soap_roundtrip_count: NotRequired[pulumi.Input[int]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs:
    def __init__(__self__, *,
                 datacenters: pulumi.Input[str],
                 name: pulumi.Input[str],
                 password: pulumi.Input[str],
                 user: pulumi.Input[str],
                 port: Optional[pulumi.Input[str]] = None,
                 soap_roundtrip_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The cluster template name (string)
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)

    @property
    @pulumi.getter
    def datacenters(self) -> pulumi.Input[str]:
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenters", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "soap_roundtrip_count")

    @soap_roundtrip_count.setter
    def soap_roundtrip_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "soap_roundtrip_count", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict(TypedDict):
        datacenter: pulumi.Input[str]
        folder: pulumi.Input[str]
        server: pulumi.Input[str]
        default_datastore: NotRequired[pulumi.Input[str]]
        resourcepool_path: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs:
    def __init__(__self__, *,
                 datacenter: pulumi.Input[str],
                 folder: pulumi.Input[str],
                 server: pulumi.Input[str],
                 default_datastore: Optional[pulumi.Input[str]] = None,
                 resourcepool_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "server", server)
        if default_datastore is not None:
            pulumi.set(__self__, "default_datastore", default_datastore)
        if resourcepool_path is not None:
            pulumi.set(__self__, "resourcepool_path", resourcepool_path)

    @property
    @pulumi.getter
    def datacenter(self) -> pulumi.Input[str]:
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: pulumi.Input[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def folder(self) -> pulumi.Input[str]:
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: pulumi.Input[str]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[str]:
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_datastore")

    @default_datastore.setter
    def default_datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_datastore", value)

    @property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resourcepool_path")

    @resourcepool_path.setter
    def resourcepool_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resourcepool_path", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgsDict(TypedDict):
        linear_autoscaler_params: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgsDict']]
        """
        Linear Autoscaler Params
        """
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        nodelocal: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgsDict']]
        """
        Nodelocal dns
        """
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        provider: NotRequired[pulumi.Input[str]]
        reverse_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgsDict']]]]
        """
        DNS service tolerations
        """
        update_strategy: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgsDict']]
        """
        Update deployment strategy
        """
        upstream_nameservers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsArgs:
    def __init__(__self__, *,
                 linear_autoscaler_params: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs']] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 nodelocal: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs']] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 reverse_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs']]]] = None,
                 update_strategy: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs']] = None,
                 upstream_nameservers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs'] linear_autoscaler_params: Linear Autoscaler Params
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs'] nodelocal: Nodelocal dns
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs']]] tolerations: DNS service tolerations
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs'] update_strategy: Update deployment strategy
        """
        if linear_autoscaler_params is not None:
            pulumi.set(__self__, "linear_autoscaler_params", linear_autoscaler_params)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if nodelocal is not None:
            pulumi.set(__self__, "nodelocal", nodelocal)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if reverse_cidrs is not None:
            pulumi.set(__self__, "reverse_cidrs", reverse_cidrs)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)
        if upstream_nameservers is not None:
            pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)

    @property
    @pulumi.getter(name="linearAutoscalerParams")
    def linear_autoscaler_params(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs']]:
        """
        Linear Autoscaler Params
        """
        return pulumi.get(self, "linear_autoscaler_params")

    @linear_autoscaler_params.setter
    def linear_autoscaler_params(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs']]):
        pulumi.set(self, "linear_autoscaler_params", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def nodelocal(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs']]:
        """
        Nodelocal dns
        """
        return pulumi.get(self, "nodelocal")

    @nodelocal.setter
    def nodelocal(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs']]):
        pulumi.set(self, "nodelocal", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "reverse_cidrs")

    @reverse_cidrs.setter
    def reverse_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "reverse_cidrs", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs']]]]:
        """
        DNS service tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs']]:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)

    @property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "upstream_nameservers")

    @upstream_nameservers.setter
    def upstream_nameservers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "upstream_nameservers", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgsDict(TypedDict):
        cores_per_replica: NotRequired[pulumi.Input[float]]
        max: NotRequired[pulumi.Input[int]]
        min: NotRequired[pulumi.Input[int]]
        nodes_per_replica: NotRequired[pulumi.Input[float]]
        prevent_single_point_failure: NotRequired[pulumi.Input[bool]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs:
    def __init__(__self__, *,
                 cores_per_replica: Optional[pulumi.Input[float]] = None,
                 max: Optional[pulumi.Input[int]] = None,
                 min: Optional[pulumi.Input[int]] = None,
                 nodes_per_replica: Optional[pulumi.Input[float]] = None,
                 prevent_single_point_failure: Optional[pulumi.Input[bool]] = None):
        if cores_per_replica is not None:
            pulumi.set(__self__, "cores_per_replica", cores_per_replica)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if nodes_per_replica is not None:
            pulumi.set(__self__, "nodes_per_replica", nodes_per_replica)
        if prevent_single_point_failure is not None:
            pulumi.set(__self__, "prevent_single_point_failure", prevent_single_point_failure)

    @property
    @pulumi.getter(name="coresPerReplica")
    def cores_per_replica(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "cores_per_replica")

    @cores_per_replica.setter
    def cores_per_replica(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cores_per_replica", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min", value)

    @property
    @pulumi.getter(name="nodesPerReplica")
    def nodes_per_replica(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "nodes_per_replica")

    @nodes_per_replica.setter
    def nodes_per_replica(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "nodes_per_replica", value)

    @property
    @pulumi.getter(name="preventSinglePointFailure")
    def prevent_single_point_failure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "prevent_single_point_failure")

    @prevent_single_point_failure.setter
    def prevent_single_point_failure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "prevent_single_point_failure", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[str]]
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Node selector key pair
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] node_selector: Node selector key pair
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Node selector key pair
        """
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        effect: NotRequired[pulumi.Input[str]]
        operator: NotRequired[pulumi.Input[str]]
        seconds: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgsDict']]
        """
        Rolling update for update strategy
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Strategy
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs']] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs'] rolling_update: Rolling update for update strategy
        :param pulumi.Input[str] strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs']]:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgsDict(TypedDict):
        max_surge: NotRequired[pulumi.Input[int]]
        """
        Rolling update max surge
        """
        max_unavailable: NotRequired[pulumi.Input[int]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[int]] = None,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_surge: Rolling update max surge
        :param pulumi.Input[int] max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgsDict(TypedDict):
        default_backend: NotRequired[pulumi.Input[bool]]
        dns_policy: NotRequired[pulumi.Input[str]]
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        http_port: NotRequired[pulumi.Input[int]]
        https_port: NotRequired[pulumi.Input[int]]
        network_mode: NotRequired[pulumi.Input[str]]
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        provider: NotRequired[pulumi.Input[str]]
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgsDict']]]]
        """
        Ingress add-on tolerations
        """
        update_strategy: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgsDict']]
        """
        Update daemon set strategy
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs:
    def __init__(__self__, *,
                 default_backend: Optional[pulumi.Input[bool]] = None,
                 dns_policy: Optional[pulumi.Input[str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 http_port: Optional[pulumi.Input[int]] = None,
                 https_port: Optional[pulumi.Input[int]] = None,
                 network_mode: Optional[pulumi.Input[str]] = None,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs']]]] = None,
                 update_strategy: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs']]] tolerations: Ingress add-on tolerations
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs'] update_strategy: Update daemon set strategy
        """
        if default_backend is not None:
            pulumi.set(__self__, "default_backend", default_backend)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "default_backend")

    @default_backend.setter
    def default_backend(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "default_backend", value)

    @property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dns_policy")

    @dns_policy.setter
    def dns_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_policy", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "https_port")

    @https_port.setter
    def https_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "https_port", value)

    @property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network_mode")

    @network_mode.setter
    def network_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_mode", value)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs']]]]:
        """
        Ingress add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs']]:
        """
        Update daemon set strategy
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        effect: NotRequired[pulumi.Input[str]]
        operator: NotRequired[pulumi.Input[str]]
        seconds: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgsDict']]
        """
        Rolling update for update strategy
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Strategy
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs']] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs'] rolling_update: Rolling update for update strategy
        :param pulumi.Input[str] strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs']]:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgsDict(TypedDict):
        max_unavailable: NotRequired[pulumi.Input[int]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_unavailable: Rolling update max unavailable
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgsDict(TypedDict):
        node_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        provider: NotRequired[pulumi.Input[str]]
        replicas: NotRequired[pulumi.Input[int]]
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgsDict']]]]
        """
        Monitoring add-on tolerations
        """
        update_strategy: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgsDict']]
        """
        Update deployment strategy
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs:
    def __init__(__self__, *,
                 node_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 provider: Optional[pulumi.Input[str]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs']]]] = None,
                 update_strategy: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs']]] tolerations: Monitoring add-on tolerations
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs'] update_strategy: Update deployment strategy
        """
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "node_selector")

    @node_selector.setter
    def node_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "node_selector", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provider", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs']]]]:
        """
        Monitoring add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs']]:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")

    @update_strategy.setter
    def update_strategy(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs']]):
        pulumi.set(self, "update_strategy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        effect: NotRequired[pulumi.Input[str]]
        operator: NotRequired[pulumi.Input[str]]
        seconds: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict']]
        """
        Rolling update for update strategy
        """
        strategy: NotRequired[pulumi.Input[str]]
        """
        Strategy
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs']] = None,
                 strategy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs'] rolling_update: Rolling update for update strategy
        :param pulumi.Input[str] strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs']]:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[str]]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict(TypedDict):
        max_surge: NotRequired[pulumi.Input[int]]
        """
        Rolling update max surge
        """
        max_unavailable: NotRequired[pulumi.Input[int]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[int]] = None,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_surge: Rolling update max surge
        :param pulumi.Input[int] max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgsDict(TypedDict):
        aci_network_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgsDict']]
        calico_network_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgsDict']]
        canal_network_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgsDict']]
        flannel_network_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgsDict']]
        mtu: NotRequired[pulumi.Input[int]]
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        plugin: NotRequired[pulumi.Input[str]]
        tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgsDict']]]]
        """
        Network add-on tolerations
        """
        weave_network_provider: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgsDict']]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs:
    def __init__(__self__, *,
                 aci_network_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgs']] = None,
                 calico_network_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgs']] = None,
                 canal_network_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgs']] = None,
                 flannel_network_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgs']] = None,
                 mtu: Optional[pulumi.Input[int]] = None,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 plugin: Optional[pulumi.Input[str]] = None,
                 tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs']]]] = None,
                 weave_network_provider: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs']]] tolerations: Network add-on tolerations
        """
        if aci_network_provider is not None:
            pulumi.set(__self__, "aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            pulumi.set(__self__, "calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            pulumi.set(__self__, "canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            pulumi.set(__self__, "flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if weave_network_provider is not None:
            pulumi.set(__self__, "weave_network_provider", weave_network_provider)

    @property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgs']]:
        return pulumi.get(self, "aci_network_provider")

    @aci_network_provider.setter
    def aci_network_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgs']]):
        pulumi.set(self, "aci_network_provider", value)

    @property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgs']]:
        return pulumi.get(self, "calico_network_provider")

    @calico_network_provider.setter
    def calico_network_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgs']]):
        pulumi.set(self, "calico_network_provider", value)

    @property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgs']]:
        return pulumi.get(self, "canal_network_provider")

    @canal_network_provider.setter
    def canal_network_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgs']]):
        pulumi.set(self, "canal_network_provider", value)

    @property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgs']]:
        return pulumi.get(self, "flannel_network_provider")

    @flannel_network_provider.setter
    def flannel_network_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgs']]):
        pulumi.set(self, "flannel_network_provider", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def plugin(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "plugin")

    @plugin.setter
    def plugin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plugin", value)

    @property
    @pulumi.getter
    def tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs']]]]:
        """
        Network add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @tolerations.setter
    def tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs']]]]):
        pulumi.set(self, "tolerations", value)

    @property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgs']]:
        return pulumi.get(self, "weave_network_provider")

    @weave_network_provider.setter
    def weave_network_provider(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgs']]):
        pulumi.set(self, "weave_network_provider", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgsDict(TypedDict):
        aep: pulumi.Input[str]
        apic_hosts: pulumi.Input[Sequence[pulumi.Input[str]]]
        apic_user_crt: pulumi.Input[str]
        apic_user_key: pulumi.Input[str]
        apic_user_name: pulumi.Input[str]
        encap_type: pulumi.Input[str]
        extern_dynamic: pulumi.Input[str]
        extern_static: pulumi.Input[str]
        kube_api_vlan: pulumi.Input[str]
        l3out: pulumi.Input[str]
        l3out_external_networks: pulumi.Input[Sequence[pulumi.Input[str]]]
        mcast_range_end: pulumi.Input[str]
        mcast_range_start: pulumi.Input[str]
        node_subnet: pulumi.Input[str]
        node_svc_subnet: pulumi.Input[str]
        service_vlan: pulumi.Input[str]
        system_id: pulumi.Input[str]
        token: pulumi.Input[str]
        vrf_name: pulumi.Input[str]
        vrf_tenant: pulumi.Input[str]
        apic_refresh_ticker_adjust: NotRequired[pulumi.Input[str]]
        apic_refresh_time: NotRequired[pulumi.Input[str]]
        apic_subscription_delay: NotRequired[pulumi.Input[str]]
        capic: NotRequired[pulumi.Input[str]]
        controller_log_level: NotRequired[pulumi.Input[str]]
        disable_periodic_snat_global_info_sync: NotRequired[pulumi.Input[str]]
        disable_wait_for_network: NotRequired[pulumi.Input[str]]
        drop_log_enable: NotRequired[pulumi.Input[str]]
        duration_wait_for_network: NotRequired[pulumi.Input[str]]
        enable_endpoint_slice: NotRequired[pulumi.Input[str]]
        ep_registry: NotRequired[pulumi.Input[str]]
        gbp_pod_subnet: NotRequired[pulumi.Input[str]]
        host_agent_log_level: NotRequired[pulumi.Input[str]]
        image_pull_policy: NotRequired[pulumi.Input[str]]
        image_pull_secret: NotRequired[pulumi.Input[str]]
        infra_vlan: NotRequired[pulumi.Input[str]]
        install_istio: NotRequired[pulumi.Input[str]]
        istio_profile: NotRequired[pulumi.Input[str]]
        kafka_brokers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        kafka_client_crt: NotRequired[pulumi.Input[str]]
        kafka_client_key: NotRequired[pulumi.Input[str]]
        max_nodes_svc_graph: NotRequired[pulumi.Input[str]]
        mtu_head_room: NotRequired[pulumi.Input[str]]
        multus_disable: NotRequired[pulumi.Input[str]]
        no_priority_class: NotRequired[pulumi.Input[str]]
        node_pod_if_enable: NotRequired[pulumi.Input[str]]
        opflex_client_ssl: NotRequired[pulumi.Input[str]]
        opflex_device_delete_timeout: NotRequired[pulumi.Input[str]]
        opflex_log_level: NotRequired[pulumi.Input[str]]
        opflex_mode: NotRequired[pulumi.Input[str]]
        opflex_server_port: NotRequired[pulumi.Input[str]]
        overlay_vrf_name: NotRequired[pulumi.Input[str]]
        ovs_memory_limit: NotRequired[pulumi.Input[str]]
        pbr_tracking_non_snat: NotRequired[pulumi.Input[str]]
        pod_subnet_chunk_size: NotRequired[pulumi.Input[str]]
        run_gbp_container: NotRequired[pulumi.Input[str]]
        run_opflex_server_container: NotRequired[pulumi.Input[str]]
        service_monitor_interval: NotRequired[pulumi.Input[str]]
        snat_contract_scope: NotRequired[pulumi.Input[str]]
        snat_namespace: NotRequired[pulumi.Input[str]]
        snat_port_range_end: NotRequired[pulumi.Input[str]]
        snat_port_range_start: NotRequired[pulumi.Input[str]]
        snat_ports_per_node: NotRequired[pulumi.Input[str]]
        sriov_enable: NotRequired[pulumi.Input[str]]
        subnet_domain_name: NotRequired[pulumi.Input[str]]
        tenant: NotRequired[pulumi.Input[str]]
        use_aci_anywhere_crd: NotRequired[pulumi.Input[str]]
        use_aci_cni_priority_class: NotRequired[pulumi.Input[str]]
        use_cluster_role: NotRequired[pulumi.Input[str]]
        use_host_netns_volume: NotRequired[pulumi.Input[str]]
        use_opflex_server_volume: NotRequired[pulumi.Input[str]]
        use_privileged_container: NotRequired[pulumi.Input[str]]
        vmm_controller: NotRequired[pulumi.Input[str]]
        vmm_domain: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderArgs:
    def __init__(__self__, *,
                 aep: pulumi.Input[str],
                 apic_hosts: pulumi.Input[Sequence[pulumi.Input[str]]],
                 apic_user_crt: pulumi.Input[str],
                 apic_user_key: pulumi.Input[str],
                 apic_user_name: pulumi.Input[str],
                 encap_type: pulumi.Input[str],
                 extern_dynamic: pulumi.Input[str],
                 extern_static: pulumi.Input[str],
                 kube_api_vlan: pulumi.Input[str],
                 l3out: pulumi.Input[str],
                 l3out_external_networks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 mcast_range_end: pulumi.Input[str],
                 mcast_range_start: pulumi.Input[str],
                 node_subnet: pulumi.Input[str],
                 node_svc_subnet: pulumi.Input[str],
                 service_vlan: pulumi.Input[str],
                 system_id: pulumi.Input[str],
                 token: pulumi.Input[str],
                 vrf_name: pulumi.Input[str],
                 vrf_tenant: pulumi.Input[str],
                 apic_refresh_ticker_adjust: Optional[pulumi.Input[str]] = None,
                 apic_refresh_time: Optional[pulumi.Input[str]] = None,
                 apic_subscription_delay: Optional[pulumi.Input[str]] = None,
                 capic: Optional[pulumi.Input[str]] = None,
                 controller_log_level: Optional[pulumi.Input[str]] = None,
                 disable_periodic_snat_global_info_sync: Optional[pulumi.Input[str]] = None,
                 disable_wait_for_network: Optional[pulumi.Input[str]] = None,
                 drop_log_enable: Optional[pulumi.Input[str]] = None,
                 duration_wait_for_network: Optional[pulumi.Input[str]] = None,
                 enable_endpoint_slice: Optional[pulumi.Input[str]] = None,
                 ep_registry: Optional[pulumi.Input[str]] = None,
                 gbp_pod_subnet: Optional[pulumi.Input[str]] = None,
                 host_agent_log_level: Optional[pulumi.Input[str]] = None,
                 image_pull_policy: Optional[pulumi.Input[str]] = None,
                 image_pull_secret: Optional[pulumi.Input[str]] = None,
                 infra_vlan: Optional[pulumi.Input[str]] = None,
                 install_istio: Optional[pulumi.Input[str]] = None,
                 istio_profile: Optional[pulumi.Input[str]] = None,
                 kafka_brokers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 kafka_client_crt: Optional[pulumi.Input[str]] = None,
                 kafka_client_key: Optional[pulumi.Input[str]] = None,
                 max_nodes_svc_graph: Optional[pulumi.Input[str]] = None,
                 mtu_head_room: Optional[pulumi.Input[str]] = None,
                 multus_disable: Optional[pulumi.Input[str]] = None,
                 no_priority_class: Optional[pulumi.Input[str]] = None,
                 node_pod_if_enable: Optional[pulumi.Input[str]] = None,
                 opflex_client_ssl: Optional[pulumi.Input[str]] = None,
                 opflex_device_delete_timeout: Optional[pulumi.Input[str]] = None,
                 opflex_log_level: Optional[pulumi.Input[str]] = None,
                 opflex_mode: Optional[pulumi.Input[str]] = None,
                 opflex_server_port: Optional[pulumi.Input[str]] = None,
                 overlay_vrf_name: Optional[pulumi.Input[str]] = None,
                 ovs_memory_limit: Optional[pulumi.Input[str]] = None,
                 pbr_tracking_non_snat: Optional[pulumi.Input[str]] = None,
                 pod_subnet_chunk_size: Optional[pulumi.Input[str]] = None,
                 run_gbp_container: Optional[pulumi.Input[str]] = None,
                 run_opflex_server_container: Optional[pulumi.Input[str]] = None,
                 service_monitor_interval: Optional[pulumi.Input[str]] = None,
                 snat_contract_scope: Optional[pulumi.Input[str]] = None,
                 snat_namespace: Optional[pulumi.Input[str]] = None,
                 snat_port_range_end: Optional[pulumi.Input[str]] = None,
                 snat_port_range_start: Optional[pulumi.Input[str]] = None,
                 snat_ports_per_node: Optional[pulumi.Input[str]] = None,
                 sriov_enable: Optional[pulumi.Input[str]] = None,
                 subnet_domain_name: Optional[pulumi.Input[str]] = None,
                 tenant: Optional[pulumi.Input[str]] = None,
                 use_aci_anywhere_crd: Optional[pulumi.Input[str]] = None,
                 use_aci_cni_priority_class: Optional[pulumi.Input[str]] = None,
                 use_cluster_role: Optional[pulumi.Input[str]] = None,
                 use_host_netns_volume: Optional[pulumi.Input[str]] = None,
                 use_opflex_server_volume: Optional[pulumi.Input[str]] = None,
                 use_privileged_container: Optional[pulumi.Input[str]] = None,
                 vmm_controller: Optional[pulumi.Input[str]] = None,
                 vmm_domain: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "aep", aep)
        pulumi.set(__self__, "apic_hosts", apic_hosts)
        pulumi.set(__self__, "apic_user_crt", apic_user_crt)
        pulumi.set(__self__, "apic_user_key", apic_user_key)
        pulumi.set(__self__, "apic_user_name", apic_user_name)
        pulumi.set(__self__, "encap_type", encap_type)
        pulumi.set(__self__, "extern_dynamic", extern_dynamic)
        pulumi.set(__self__, "extern_static", extern_static)
        pulumi.set(__self__, "kube_api_vlan", kube_api_vlan)
        pulumi.set(__self__, "l3out", l3out)
        pulumi.set(__self__, "l3out_external_networks", l3out_external_networks)
        pulumi.set(__self__, "mcast_range_end", mcast_range_end)
        pulumi.set(__self__, "mcast_range_start", mcast_range_start)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "node_svc_subnet", node_svc_subnet)
        pulumi.set(__self__, "service_vlan", service_vlan)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "vrf_name", vrf_name)
        pulumi.set(__self__, "vrf_tenant", vrf_tenant)
        if apic_refresh_ticker_adjust is not None:
            pulumi.set(__self__, "apic_refresh_ticker_adjust", apic_refresh_ticker_adjust)
        if apic_refresh_time is not None:
            pulumi.set(__self__, "apic_refresh_time", apic_refresh_time)
        if apic_subscription_delay is not None:
            pulumi.set(__self__, "apic_subscription_delay", apic_subscription_delay)
        if capic is not None:
            pulumi.set(__self__, "capic", capic)
        if controller_log_level is not None:
            pulumi.set(__self__, "controller_log_level", controller_log_level)
        if disable_periodic_snat_global_info_sync is not None:
            pulumi.set(__self__, "disable_periodic_snat_global_info_sync", disable_periodic_snat_global_info_sync)
        if disable_wait_for_network is not None:
            pulumi.set(__self__, "disable_wait_for_network", disable_wait_for_network)
        if drop_log_enable is not None:
            pulumi.set(__self__, "drop_log_enable", drop_log_enable)
        if duration_wait_for_network is not None:
            pulumi.set(__self__, "duration_wait_for_network", duration_wait_for_network)
        if enable_endpoint_slice is not None:
            pulumi.set(__self__, "enable_endpoint_slice", enable_endpoint_slice)
        if ep_registry is not None:
            pulumi.set(__self__, "ep_registry", ep_registry)
        if gbp_pod_subnet is not None:
            pulumi.set(__self__, "gbp_pod_subnet", gbp_pod_subnet)
        if host_agent_log_level is not None:
            pulumi.set(__self__, "host_agent_log_level", host_agent_log_level)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if infra_vlan is not None:
            pulumi.set(__self__, "infra_vlan", infra_vlan)
        if install_istio is not None:
            pulumi.set(__self__, "install_istio", install_istio)
        if istio_profile is not None:
            pulumi.set(__self__, "istio_profile", istio_profile)
        if kafka_brokers is not None:
            pulumi.set(__self__, "kafka_brokers", kafka_brokers)
        if kafka_client_crt is not None:
            pulumi.set(__self__, "kafka_client_crt", kafka_client_crt)
        if kafka_client_key is not None:
            pulumi.set(__self__, "kafka_client_key", kafka_client_key)
        if max_nodes_svc_graph is not None:
            pulumi.set(__self__, "max_nodes_svc_graph", max_nodes_svc_graph)
        if mtu_head_room is not None:
            pulumi.set(__self__, "mtu_head_room", mtu_head_room)
        if multus_disable is not None:
            pulumi.set(__self__, "multus_disable", multus_disable)
        if no_priority_class is not None:
            pulumi.set(__self__, "no_priority_class", no_priority_class)
        if node_pod_if_enable is not None:
            pulumi.set(__self__, "node_pod_if_enable", node_pod_if_enable)
        if opflex_client_ssl is not None:
            pulumi.set(__self__, "opflex_client_ssl", opflex_client_ssl)
        if opflex_device_delete_timeout is not None:
            pulumi.set(__self__, "opflex_device_delete_timeout", opflex_device_delete_timeout)
        if opflex_log_level is not None:
            pulumi.set(__self__, "opflex_log_level", opflex_log_level)
        if opflex_mode is not None:
            pulumi.set(__self__, "opflex_mode", opflex_mode)
        if opflex_server_port is not None:
            pulumi.set(__self__, "opflex_server_port", opflex_server_port)
        if overlay_vrf_name is not None:
            pulumi.set(__self__, "overlay_vrf_name", overlay_vrf_name)
        if ovs_memory_limit is not None:
            pulumi.set(__self__, "ovs_memory_limit", ovs_memory_limit)
        if pbr_tracking_non_snat is not None:
            pulumi.set(__self__, "pbr_tracking_non_snat", pbr_tracking_non_snat)
        if pod_subnet_chunk_size is not None:
            pulumi.set(__self__, "pod_subnet_chunk_size", pod_subnet_chunk_size)
        if run_gbp_container is not None:
            pulumi.set(__self__, "run_gbp_container", run_gbp_container)
        if run_opflex_server_container is not None:
            pulumi.set(__self__, "run_opflex_server_container", run_opflex_server_container)
        if service_monitor_interval is not None:
            pulumi.set(__self__, "service_monitor_interval", service_monitor_interval)
        if snat_contract_scope is not None:
            pulumi.set(__self__, "snat_contract_scope", snat_contract_scope)
        if snat_namespace is not None:
            pulumi.set(__self__, "snat_namespace", snat_namespace)
        if snat_port_range_end is not None:
            pulumi.set(__self__, "snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            pulumi.set(__self__, "snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            pulumi.set(__self__, "snat_ports_per_node", snat_ports_per_node)
        if sriov_enable is not None:
            pulumi.set(__self__, "sriov_enable", sriov_enable)
        if subnet_domain_name is not None:
            pulumi.set(__self__, "subnet_domain_name", subnet_domain_name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if use_aci_anywhere_crd is not None:
            pulumi.set(__self__, "use_aci_anywhere_crd", use_aci_anywhere_crd)
        if use_aci_cni_priority_class is not None:
            pulumi.set(__self__, "use_aci_cni_priority_class", use_aci_cni_priority_class)
        if use_cluster_role is not None:
            pulumi.set(__self__, "use_cluster_role", use_cluster_role)
        if use_host_netns_volume is not None:
            pulumi.set(__self__, "use_host_netns_volume", use_host_netns_volume)
        if use_opflex_server_volume is not None:
            pulumi.set(__self__, "use_opflex_server_volume", use_opflex_server_volume)
        if use_privileged_container is not None:
            pulumi.set(__self__, "use_privileged_container", use_privileged_container)
        if vmm_controller is not None:
            pulumi.set(__self__, "vmm_controller", vmm_controller)
        if vmm_domain is not None:
            pulumi.set(__self__, "vmm_domain", vmm_domain)

    @property
    @pulumi.getter
    def aep(self) -> pulumi.Input[str]:
        return pulumi.get(self, "aep")

    @aep.setter
    def aep(self, value: pulumi.Input[str]):
        pulumi.set(self, "aep", value)

    @property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "apic_hosts")

    @apic_hosts.setter
    def apic_hosts(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "apic_hosts", value)

    @property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> pulumi.Input[str]:
        return pulumi.get(self, "apic_user_crt")

    @apic_user_crt.setter
    def apic_user_crt(self, value: pulumi.Input[str]):
        pulumi.set(self, "apic_user_crt", value)

    @property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "apic_user_key")

    @apic_user_key.setter
    def apic_user_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "apic_user_key", value)

    @property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "apic_user_name")

    @apic_user_name.setter
    def apic_user_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "apic_user_name", value)

    @property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "encap_type")

    @encap_type.setter
    def encap_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "encap_type", value)

    @property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> pulumi.Input[str]:
        return pulumi.get(self, "extern_dynamic")

    @extern_dynamic.setter
    def extern_dynamic(self, value: pulumi.Input[str]):
        pulumi.set(self, "extern_dynamic", value)

    @property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> pulumi.Input[str]:
        return pulumi.get(self, "extern_static")

    @extern_static.setter
    def extern_static(self, value: pulumi.Input[str]):
        pulumi.set(self, "extern_static", value)

    @property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> pulumi.Input[str]:
        return pulumi.get(self, "kube_api_vlan")

    @kube_api_vlan.setter
    def kube_api_vlan(self, value: pulumi.Input[str]):
        pulumi.set(self, "kube_api_vlan", value)

    @property
    @pulumi.getter
    def l3out(self) -> pulumi.Input[str]:
        return pulumi.get(self, "l3out")

    @l3out.setter
    def l3out(self, value: pulumi.Input[str]):
        pulumi.set(self, "l3out", value)

    @property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "l3out_external_networks")

    @l3out_external_networks.setter
    def l3out_external_networks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "l3out_external_networks", value)

    @property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mcast_range_end")

    @mcast_range_end.setter
    def mcast_range_end(self, value: pulumi.Input[str]):
        pulumi.set(self, "mcast_range_end", value)

    @property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mcast_range_start")

    @mcast_range_start.setter
    def mcast_range_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "mcast_range_start", value)

    @property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "node_subnet")

    @node_subnet.setter
    def node_subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_subnet", value)

    @property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> pulumi.Input[str]:
        return pulumi.get(self, "node_svc_subnet")

    @node_svc_subnet.setter
    def node_svc_subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "node_svc_subnet", value)

    @property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> pulumi.Input[str]:
        return pulumi.get(self, "service_vlan")

    @service_vlan.setter
    def service_vlan(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_vlan", value)

    @property
    @pulumi.getter(name="systemId")
    def system_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "system_id")

    @system_id.setter
    def system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "system_id", value)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vrf_name")

    @vrf_name.setter
    def vrf_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vrf_name", value)

    @property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> pulumi.Input[str]:
        return pulumi.get(self, "vrf_tenant")

    @vrf_tenant.setter
    def vrf_tenant(self, value: pulumi.Input[str]):
        pulumi.set(self, "vrf_tenant", value)

    @property
    @pulumi.getter(name="apicRefreshTickerAdjust")
    def apic_refresh_ticker_adjust(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "apic_refresh_ticker_adjust")

    @apic_refresh_ticker_adjust.setter
    def apic_refresh_ticker_adjust(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apic_refresh_ticker_adjust", value)

    @property
    @pulumi.getter(name="apicRefreshTime")
    def apic_refresh_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "apic_refresh_time")

    @apic_refresh_time.setter
    def apic_refresh_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apic_refresh_time", value)

    @property
    @pulumi.getter(name="apicSubscriptionDelay")
    def apic_subscription_delay(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "apic_subscription_delay")

    @apic_subscription_delay.setter
    def apic_subscription_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "apic_subscription_delay", value)

    @property
    @pulumi.getter
    def capic(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "capic")

    @capic.setter
    def capic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capic", value)

    @property
    @pulumi.getter(name="controllerLogLevel")
    def controller_log_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "controller_log_level")

    @controller_log_level.setter
    def controller_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "controller_log_level", value)

    @property
    @pulumi.getter(name="disablePeriodicSnatGlobalInfoSync")
    def disable_periodic_snat_global_info_sync(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disable_periodic_snat_global_info_sync")

    @disable_periodic_snat_global_info_sync.setter
    def disable_periodic_snat_global_info_sync(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disable_periodic_snat_global_info_sync", value)

    @property
    @pulumi.getter(name="disableWaitForNetwork")
    def disable_wait_for_network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "disable_wait_for_network")

    @disable_wait_for_network.setter
    def disable_wait_for_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disable_wait_for_network", value)

    @property
    @pulumi.getter(name="dropLogEnable")
    def drop_log_enable(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "drop_log_enable")

    @drop_log_enable.setter
    def drop_log_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "drop_log_enable", value)

    @property
    @pulumi.getter(name="durationWaitForNetwork")
    def duration_wait_for_network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "duration_wait_for_network")

    @duration_wait_for_network.setter
    def duration_wait_for_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration_wait_for_network", value)

    @property
    @pulumi.getter(name="enableEndpointSlice")
    def enable_endpoint_slice(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "enable_endpoint_slice")

    @enable_endpoint_slice.setter
    def enable_endpoint_slice(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enable_endpoint_slice", value)

    @property
    @pulumi.getter(name="epRegistry")
    def ep_registry(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ep_registry")

    @ep_registry.setter
    def ep_registry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ep_registry", value)

    @property
    @pulumi.getter(name="gbpPodSubnet")
    def gbp_pod_subnet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "gbp_pod_subnet")

    @gbp_pod_subnet.setter
    def gbp_pod_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gbp_pod_subnet", value)

    @property
    @pulumi.getter(name="hostAgentLogLevel")
    def host_agent_log_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "host_agent_log_level")

    @host_agent_log_level.setter
    def host_agent_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_agent_log_level", value)

    @property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_pull_policy")

    @image_pull_policy.setter
    def image_pull_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_pull_policy", value)

    @property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image_pull_secret")

    @image_pull_secret.setter
    def image_pull_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_pull_secret", value)

    @property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "infra_vlan")

    @infra_vlan.setter
    def infra_vlan(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "infra_vlan", value)

    @property
    @pulumi.getter(name="installIstio")
    def install_istio(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "install_istio")

    @install_istio.setter
    def install_istio(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "install_istio", value)

    @property
    @pulumi.getter(name="istioProfile")
    def istio_profile(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "istio_profile")

    @istio_profile.setter
    def istio_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "istio_profile", value)

    @property
    @pulumi.getter(name="kafkaBrokers")
    def kafka_brokers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "kafka_brokers")

    @kafka_brokers.setter
    def kafka_brokers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kafka_brokers", value)

    @property
    @pulumi.getter(name="kafkaClientCrt")
    def kafka_client_crt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kafka_client_crt")

    @kafka_client_crt.setter
    def kafka_client_crt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_client_crt", value)

    @property
    @pulumi.getter(name="kafkaClientKey")
    def kafka_client_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "kafka_client_key")

    @kafka_client_key.setter
    def kafka_client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kafka_client_key", value)

    @property
    @pulumi.getter(name="maxNodesSvcGraph")
    def max_nodes_svc_graph(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_nodes_svc_graph")

    @max_nodes_svc_graph.setter
    def max_nodes_svc_graph(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_nodes_svc_graph", value)

    @property
    @pulumi.getter(name="mtuHeadRoom")
    def mtu_head_room(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mtu_head_room")

    @mtu_head_room.setter
    def mtu_head_room(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mtu_head_room", value)

    @property
    @pulumi.getter(name="multusDisable")
    def multus_disable(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "multus_disable")

    @multus_disable.setter
    def multus_disable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "multus_disable", value)

    @property
    @pulumi.getter(name="noPriorityClass")
    def no_priority_class(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "no_priority_class")

    @no_priority_class.setter
    def no_priority_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "no_priority_class", value)

    @property
    @pulumi.getter(name="nodePodIfEnable")
    def node_pod_if_enable(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_pod_if_enable")

    @node_pod_if_enable.setter
    def node_pod_if_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_pod_if_enable", value)

    @property
    @pulumi.getter(name="opflexClientSsl")
    def opflex_client_ssl(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opflex_client_ssl")

    @opflex_client_ssl.setter
    def opflex_client_ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_client_ssl", value)

    @property
    @pulumi.getter(name="opflexDeviceDeleteTimeout")
    def opflex_device_delete_timeout(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opflex_device_delete_timeout")

    @opflex_device_delete_timeout.setter
    def opflex_device_delete_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_device_delete_timeout", value)

    @property
    @pulumi.getter(name="opflexLogLevel")
    def opflex_log_level(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opflex_log_level")

    @opflex_log_level.setter
    def opflex_log_level(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_log_level", value)

    @property
    @pulumi.getter(name="opflexMode")
    def opflex_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opflex_mode")

    @opflex_mode.setter
    def opflex_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_mode", value)

    @property
    @pulumi.getter(name="opflexServerPort")
    def opflex_server_port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "opflex_server_port")

    @opflex_server_port.setter
    def opflex_server_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "opflex_server_port", value)

    @property
    @pulumi.getter(name="overlayVrfName")
    def overlay_vrf_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "overlay_vrf_name")

    @overlay_vrf_name.setter
    def overlay_vrf_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "overlay_vrf_name", value)

    @property
    @pulumi.getter(name="ovsMemoryLimit")
    def ovs_memory_limit(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ovs_memory_limit")

    @ovs_memory_limit.setter
    def ovs_memory_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ovs_memory_limit", value)

    @property
    @pulumi.getter(name="pbrTrackingNonSnat")
    def pbr_tracking_non_snat(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pbr_tracking_non_snat")

    @pbr_tracking_non_snat.setter
    def pbr_tracking_non_snat(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pbr_tracking_non_snat", value)

    @property
    @pulumi.getter(name="podSubnetChunkSize")
    def pod_subnet_chunk_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pod_subnet_chunk_size")

    @pod_subnet_chunk_size.setter
    def pod_subnet_chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pod_subnet_chunk_size", value)

    @property
    @pulumi.getter(name="runGbpContainer")
    def run_gbp_container(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_gbp_container")

    @run_gbp_container.setter
    def run_gbp_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_gbp_container", value)

    @property
    @pulumi.getter(name="runOpflexServerContainer")
    def run_opflex_server_container(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "run_opflex_server_container")

    @run_opflex_server_container.setter
    def run_opflex_server_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_opflex_server_container", value)

    @property
    @pulumi.getter(name="serviceMonitorInterval")
    def service_monitor_interval(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_monitor_interval")

    @service_monitor_interval.setter
    def service_monitor_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_monitor_interval", value)

    @property
    @pulumi.getter(name="snatContractScope")
    def snat_contract_scope(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snat_contract_scope")

    @snat_contract_scope.setter
    def snat_contract_scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_contract_scope", value)

    @property
    @pulumi.getter(name="snatNamespace")
    def snat_namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snat_namespace")

    @snat_namespace.setter
    def snat_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_namespace", value)

    @property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snat_port_range_end")

    @snat_port_range_end.setter
    def snat_port_range_end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_port_range_end", value)

    @property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snat_port_range_start")

    @snat_port_range_start.setter
    def snat_port_range_start(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_port_range_start", value)

    @property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "snat_ports_per_node")

    @snat_ports_per_node.setter
    def snat_ports_per_node(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_ports_per_node", value)

    @property
    @pulumi.getter(name="sriovEnable")
    def sriov_enable(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "sriov_enable")

    @sriov_enable.setter
    def sriov_enable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sriov_enable", value)

    @property
    @pulumi.getter(name="subnetDomainName")
    def subnet_domain_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subnet_domain_name")

    @subnet_domain_name.setter
    def subnet_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_domain_name", value)

    @property
    @pulumi.getter
    def tenant(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "tenant")

    @tenant.setter
    def tenant(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant", value)

    @property
    @pulumi.getter(name="useAciAnywhereCrd")
    def use_aci_anywhere_crd(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "use_aci_anywhere_crd")

    @use_aci_anywhere_crd.setter
    def use_aci_anywhere_crd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_aci_anywhere_crd", value)

    @property
    @pulumi.getter(name="useAciCniPriorityClass")
    def use_aci_cni_priority_class(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "use_aci_cni_priority_class")

    @use_aci_cni_priority_class.setter
    def use_aci_cni_priority_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_aci_cni_priority_class", value)

    @property
    @pulumi.getter(name="useClusterRole")
    def use_cluster_role(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "use_cluster_role")

    @use_cluster_role.setter
    def use_cluster_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_cluster_role", value)

    @property
    @pulumi.getter(name="useHostNetnsVolume")
    def use_host_netns_volume(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "use_host_netns_volume")

    @use_host_netns_volume.setter
    def use_host_netns_volume(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_host_netns_volume", value)

    @property
    @pulumi.getter(name="useOpflexServerVolume")
    def use_opflex_server_volume(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "use_opflex_server_volume")

    @use_opflex_server_volume.setter
    def use_opflex_server_volume(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_opflex_server_volume", value)

    @property
    @pulumi.getter(name="usePrivilegedContainer")
    def use_privileged_container(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "use_privileged_container")

    @use_privileged_container.setter
    def use_privileged_container(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_privileged_container", value)

    @property
    @pulumi.getter(name="vmmController")
    def vmm_controller(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vmm_controller")

    @vmm_controller.setter
    def vmm_controller(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vmm_controller", value)

    @property
    @pulumi.getter(name="vmmDomain")
    def vmm_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "vmm_domain")

    @vmm_domain.setter
    def vmm_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vmm_domain", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgsDict(TypedDict):
        cloud_provider: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderArgs:
    def __init__(__self__, *,
                 cloud_provider: Optional[pulumi.Input[str]] = None):
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cloud_provider")

    @cloud_provider.setter
    def cloud_provider(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_provider", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgsDict(TypedDict):
        iface: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderArgs:
    def __init__(__self__, *,
                 iface: Optional[pulumi.Input[str]] = None):
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @property
    @pulumi.getter
    def iface(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iface")

    @iface.setter
    def iface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iface", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgsDict(TypedDict):
        iface: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderArgs:
    def __init__(__self__, *,
                 iface: Optional[pulumi.Input[str]] = None):
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @property
    @pulumi.getter
    def iface(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "iface")

    @iface.setter
    def iface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iface", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        effect: NotRequired[pulumi.Input[str]]
        operator: NotRequired[pulumi.Input[str]]
        seconds: NotRequired[pulumi.Input[int]]
        value: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgsDict(TypedDict):
        password: pulumi.Input[str]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgsDict(TypedDict):
        address: pulumi.Input[str]
        roles: pulumi.Input[Sequence[pulumi.Input[str]]]
        user: pulumi.Input[str]
        docker_socket: NotRequired[pulumi.Input[str]]
        hostname_override: NotRequired[pulumi.Input[str]]
        internal_address: NotRequired[pulumi.Input[str]]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the cluster template (map)
        """
        node_id: NotRequired[pulumi.Input[str]]
        port: NotRequired[pulumi.Input[str]]
        ssh_agent_auth: NotRequired[pulumi.Input[bool]]
        ssh_key: NotRequired[pulumi.Input[str]]
        ssh_key_path: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 roles: pulumi.Input[Sequence[pulumi.Input[str]]],
                 user: pulumi.Input[str],
                 docker_socket: Optional[pulumi.Input[str]] = None,
                 hostname_override: Optional[pulumi.Input[str]] = None,
                 internal_address: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 ssh_agent_auth: Optional[pulumi.Input[bool]] = None,
                 ssh_key: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the cluster template (map)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "user", user)
        if docker_socket is not None:
            pulumi.set(__self__, "docker_socket", docker_socket)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if internal_address is not None:
            pulumi.set(__self__, "internal_address", internal_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def roles(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "docker_socket")

    @docker_socket.setter
    def docker_socket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_socket", value)

    @property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "hostname_override")

    @hostname_override.setter
    def hostname_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname_override", value)

    @property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "internal_address")

    @internal_address.setter
    def internal_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "internal_address", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the cluster template (map)
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "node_id")

    @node_id.setter
    def node_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ssh_agent_auth")

    @ssh_agent_auth.setter
    def ssh_agent_auth(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssh_agent_auth", value)

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgsDict(TypedDict):
        url: pulumi.Input[str]
        ecr_credential_plugin: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgsDict']]
        """
        ECR credential plugin config
        """
        is_default: NotRequired[pulumi.Input[bool]]
        password: NotRequired[pulumi.Input[str]]
        user: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 ecr_credential_plugin: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs']] = None,
                 is_default: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs'] ecr_credential_plugin: ECR credential plugin config
        """
        pulumi.set(__self__, "url", url)
        if ecr_credential_plugin is not None:
            pulumi.set(__self__, "ecr_credential_plugin", ecr_credential_plugin)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="ecrCredentialPlugin")
    def ecr_credential_plugin(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs']]:
        """
        ECR credential plugin config
        """
        return pulumi.get(self, "ecr_credential_plugin")

    @ecr_credential_plugin.setter
    def ecr_credential_plugin(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs']]):
        pulumi.set(self, "ecr_credential_plugin", value)

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_default", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgsDict(TypedDict):
        aws_access_key_id: NotRequired[pulumi.Input[str]]
        aws_secret_access_key: NotRequired[pulumi.Input[str]]
        aws_session_token: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs:
    def __init__(__self__, *,
                 aws_access_key_id: Optional[pulumi.Input[str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[str]] = None,
                 aws_session_token: Optional[pulumi.Input[str]] = None):
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aws_session_token")

    @aws_session_token.setter
    def aws_session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_session_token", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgsDict(TypedDict):
        etcd: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgsDict']]
        kube_api: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgsDict']]
        kube_controller: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgsDict']]
        kubelet: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgsDict']]
        kubeproxy: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgsDict']]
        scheduler: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgsDict']]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs:
    def __init__(__self__, *,
                 etcd: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgs']] = None,
                 kube_api: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgs']] = None,
                 kube_controller: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgs']] = None,
                 kubelet: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgs']] = None,
                 kubeproxy: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgs']] = None,
                 scheduler: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgs']] = None):
        if etcd is not None:
            pulumi.set(__self__, "etcd", etcd)
        if kube_api is not None:
            pulumi.set(__self__, "kube_api", kube_api)
        if kube_controller is not None:
            pulumi.set(__self__, "kube_controller", kube_controller)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if kubeproxy is not None:
            pulumi.set(__self__, "kubeproxy", kubeproxy)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @property
    @pulumi.getter
    def etcd(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgs']]:
        return pulumi.get(self, "etcd")

    @etcd.setter
    def etcd(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgs']]):
        pulumi.set(self, "etcd", value)

    @property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgs']]:
        return pulumi.get(self, "kube_api")

    @kube_api.setter
    def kube_api(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgs']]):
        pulumi.set(self, "kube_api", value)

    @property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgs']]:
        return pulumi.get(self, "kube_controller")

    @kube_controller.setter
    def kube_controller(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgs']]):
        pulumi.set(self, "kube_controller", value)

    @property
    @pulumi.getter
    def kubelet(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgs']]:
        return pulumi.get(self, "kubelet")

    @kubelet.setter
    def kubelet(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgs']]):
        pulumi.set(self, "kubelet", value)

    @property
    @pulumi.getter
    def kubeproxy(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgs']]:
        return pulumi.get(self, "kubeproxy")

    @kubeproxy.setter
    def kubeproxy(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgs']]):
        pulumi.set(self, "kubeproxy", value)

    @property
    @pulumi.getter
    def scheduler(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgs']]:
        return pulumi.get(self, "scheduler")

    @scheduler.setter
    def scheduler(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgs']]):
        pulumi.set(self, "scheduler", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgsDict(TypedDict):
        backup_config: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgsDict']]
        ca_cert: NotRequired[pulumi.Input[str]]
        cert: NotRequired[pulumi.Input[str]]
        creation: NotRequired[pulumi.Input[str]]
        external_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        gid: NotRequired[pulumi.Input[int]]
        image: NotRequired[pulumi.Input[str]]
        key: NotRequired[pulumi.Input[str]]
        path: NotRequired[pulumi.Input[str]]
        retention: NotRequired[pulumi.Input[str]]
        snapshot: NotRequired[pulumi.Input[bool]]
        uid: NotRequired[pulumi.Input[int]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdArgs:
    def __init__(__self__, *,
                 backup_config: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgs']] = None,
                 ca_cert: Optional[pulumi.Input[str]] = None,
                 cert: Optional[pulumi.Input[str]] = None,
                 creation: Optional[pulumi.Input[str]] = None,
                 external_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gid: Optional[pulumi.Input[int]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 retention: Optional[pulumi.Input[str]] = None,
                 snapshot: Optional[pulumi.Input[bool]] = None,
                 uid: Optional[pulumi.Input[int]] = None):
        if backup_config is not None:
            pulumi.set(__self__, "backup_config", backup_config)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if creation is not None:
            pulumi.set(__self__, "creation", creation)
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgs']]:
        return pulumi.get(self, "backup_config")

    @backup_config.setter
    def backup_config(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgs']]):
        pulumi.set(self, "backup_config", value)

    @property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_cert")

    @ca_cert.setter
    def ca_cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert", value)

    @property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cert", value)

    @property
    @pulumi.getter
    def creation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation")

    @creation.setter
    def creation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation", value)

    @property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "external_urls")

    @external_urls.setter
    def external_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "external_urls", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter
    def snapshot(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "snapshot")

    @snapshot.setter
    def snapshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "snapshot", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable cluster template revision. Default `true` (bool)
        """
        interval_hours: NotRequired[pulumi.Input[int]]
        retention: NotRequired[pulumi.Input[int]]
        s3_backup_config: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict']]
        safe_timestamp: NotRequired[pulumi.Input[bool]]
        timeout: NotRequired[pulumi.Input[int]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 interval_hours: Optional[pulumi.Input[int]] = None,
                 retention: Optional[pulumi.Input[int]] = None,
                 s3_backup_config: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs']] = None,
                 safe_timestamp: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable cluster template revision. Default `true` (bool)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "interval_hours")

    @interval_hours.setter
    def interval_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_hours", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs']]:
        return pulumi.get(self, "s3_backup_config")

    @s3_backup_config.setter
    def s3_backup_config(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs']]):
        pulumi.set(self, "s3_backup_config", value)

    @property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "safe_timestamp")

    @safe_timestamp.setter
    def safe_timestamp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "safe_timestamp", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        endpoint: pulumi.Input[str]
        access_key: NotRequired[pulumi.Input[str]]
        custom_ca: NotRequired[pulumi.Input[str]]
        folder: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        secret_key: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 custom_ca: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_ca")

    @custom_ca.setter
    def custom_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_ca", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgsDict(TypedDict):
        admission_configuration: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgsDict']]
        """
        Cluster admission configuration
        """
        always_pull_images: NotRequired[pulumi.Input[bool]]
        audit_log: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgsDict']]
        event_rate_limit: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgsDict']]
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        image: NotRequired[pulumi.Input[str]]
        secrets_encryption_config: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict']]
        service_cluster_ip_range: NotRequired[pulumi.Input[str]]
        service_node_port_range: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiArgs:
    def __init__(__self__, *,
                 admission_configuration: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs']] = None,
                 always_pull_images: Optional[pulumi.Input[bool]] = None,
                 audit_log: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgs']] = None,
                 event_rate_limit: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgs']] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 secrets_encryption_config: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgs']] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None,
                 service_node_port_range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs'] admission_configuration: Cluster admission configuration
        """
        if admission_configuration is not None:
            pulumi.set(__self__, "admission_configuration", admission_configuration)
        if always_pull_images is not None:
            pulumi.set(__self__, "always_pull_images", always_pull_images)
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if event_rate_limit is not None:
            pulumi.set(__self__, "event_rate_limit", event_rate_limit)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if secrets_encryption_config is not None:
            pulumi.set(__self__, "secrets_encryption_config", secrets_encryption_config)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            pulumi.set(__self__, "service_node_port_range", service_node_port_range)

    @property
    @pulumi.getter(name="admissionConfiguration")
    def admission_configuration(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs']]:
        """
        Cluster admission configuration
        """
        return pulumi.get(self, "admission_configuration")

    @admission_configuration.setter
    def admission_configuration(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs']]):
        pulumi.set(self, "admission_configuration", value)

    @property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "always_pull_images")

    @always_pull_images.setter
    def always_pull_images(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_pull_images", value)

    @property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgs']]:
        return pulumi.get(self, "audit_log")

    @audit_log.setter
    def audit_log(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgs']]):
        pulumi.set(self, "audit_log", value)

    @property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgs']]:
        return pulumi.get(self, "event_rate_limit")

    @event_rate_limit.setter
    def event_rate_limit(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgs']]):
        pulumi.set(self, "event_rate_limit", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgs']]:
        return pulumi.get(self, "secrets_encryption_config")

    @secrets_encryption_config.setter
    def secrets_encryption_config(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgs']]):
        pulumi.set(self, "secrets_encryption_config", value)

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_cluster_ip_range")

    @service_cluster_ip_range.setter
    def service_cluster_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cluster_ip_range", value)

    @property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_node_port_range")

    @service_node_port_range.setter
    def service_node_port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_node_port_range", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[str]]
        """
        Admission configuration ApiVersion
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        Admission configuration Kind
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict']]]]
        """
        Admission configuration plugins
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]]] = None):
        """
        :param pulumi.Input[str] api_version: Admission configuration ApiVersion
        :param pulumi.Input[str] kind: Admission configuration Kind
        :param pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]] plugins: Admission configuration plugins
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Admission configuration ApiVersion
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        Admission configuration Kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]]]:
        """
        Admission configuration plugins
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs']]]]):
        pulumi.set(self, "plugins", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input[str]]
        """
        Plugin configuration
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The cluster template name (string)
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Plugin path
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] configuration: Plugin configuration
        :param pulumi.Input[str] name: The cluster template name (string)
        :param pulumi.Input[str] path: Plugin path
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin configuration
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Plugin path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgsDict']]
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable cluster template revision. Default `true` (bool)
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgs']] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable cluster template revision. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgs']]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgsDict(TypedDict):
        format: NotRequired[pulumi.Input[str]]
        max_age: NotRequired[pulumi.Input[int]]
        max_backup: NotRequired[pulumi.Input[int]]
        max_size: NotRequired[pulumi.Input[int]]
        path: NotRequired[pulumi.Input[str]]
        policy: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationArgs:
    def __init__(__self__, *,
                 format: Optional[pulumi.Input[str]] = None,
                 max_age: Optional[pulumi.Input[int]] = None,
                 max_backup: Optional[pulumi.Input[int]] = None,
                 max_size: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 policy: Optional[pulumi.Input[str]] = None):
        if format is not None:
            pulumi.set(__self__, "format", format)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_backup is not None:
            pulumi.set(__self__, "max_backup", max_backup)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_backup")

    @max_backup.setter
    def max_backup(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_backup", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_size", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgsDict(TypedDict):
        configuration: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable cluster template revision. Default `true` (bool)
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitArgs:
    def __init__(__self__, *,
                 configuration: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable cluster template revision. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict(TypedDict):
        custom_config: NotRequired[pulumi.Input[str]]
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable cluster template revision. Default `true` (bool)
        """
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigArgs:
    def __init__(__self__, *,
                 custom_config: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable cluster template revision. Default `true` (bool)
        """
        if custom_config is not None:
            pulumi.set(__self__, "custom_config", custom_config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "custom_config")

    @custom_config.setter
    def custom_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_config", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgsDict(TypedDict):
        cluster_cidr: NotRequired[pulumi.Input[str]]
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        image: NotRequired[pulumi.Input[str]]
        service_cluster_ip_range: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerArgs:
    def __init__(__self__, *,
                 cluster_cidr: Optional[pulumi.Input[str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 service_cluster_ip_range: Optional[pulumi.Input[str]] = None):
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)

    @property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_cidr")

    @cluster_cidr.setter
    def cluster_cidr(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_cidr", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_cluster_ip_range")

    @service_cluster_ip_range.setter
    def service_cluster_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_cluster_ip_range", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgsDict(TypedDict):
        cluster_dns_server: NotRequired[pulumi.Input[str]]
        cluster_domain: NotRequired[pulumi.Input[str]]
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        fail_swap_on: NotRequired[pulumi.Input[bool]]
        generate_serving_certificate: NotRequired[pulumi.Input[bool]]
        image: NotRequired[pulumi.Input[str]]
        infra_container_image: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletArgs:
    def __init__(__self__, *,
                 cluster_dns_server: Optional[pulumi.Input[str]] = None,
                 cluster_domain: Optional[pulumi.Input[str]] = None,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 fail_swap_on: Optional[pulumi.Input[bool]] = None,
                 generate_serving_certificate: Optional[pulumi.Input[bool]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 infra_container_image: Optional[pulumi.Input[str]] = None):
        if cluster_dns_server is not None:
            pulumi.set(__self__, "cluster_dns_server", cluster_dns_server)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if generate_serving_certificate is not None:
            pulumi.set(__self__, "generate_serving_certificate", generate_serving_certificate)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra_container_image is not None:
            pulumi.set(__self__, "infra_container_image", infra_container_image)

    @property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_dns_server")

    @cluster_dns_server.setter
    def cluster_dns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_dns_server", value)

    @property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "cluster_domain")

    @cluster_domain.setter
    def cluster_domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_domain", value)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "fail_swap_on")

    @fail_swap_on.setter
    def fail_swap_on(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fail_swap_on", value)

    @property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "generate_serving_certificate")

    @generate_serving_certificate.setter
    def generate_serving_certificate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generate_serving_certificate", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "infra_container_image")

    @infra_container_image.setter
    def infra_container_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "infra_container_image", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgsDict(TypedDict):
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        image: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyArgs:
    def __init__(__self__, *,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgsDict(TypedDict):
        extra_args: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        extra_binds: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        extra_envs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        image: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerArgs:
    def __init__(__self__, *,
                 extra_args: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 extra_binds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_envs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_args")

    @extra_args.setter
    def extra_args(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "extra_args", value)

    @property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_binds")

    @extra_binds.setter
    def extra_binds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_binds", value)

    @property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "extra_envs")

    @extra_envs.setter
    def extra_envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_envs", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgsDict(TypedDict):
        drain: NotRequired[pulumi.Input[bool]]
        drain_input: NotRequired[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgsDict']]
        max_unavailable_controlplane: NotRequired[pulumi.Input[str]]
        max_unavailable_worker: NotRequired[pulumi.Input[str]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs:
    def __init__(__self__, *,
                 drain: Optional[pulumi.Input[bool]] = None,
                 drain_input: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgs']] = None,
                 max_unavailable_controlplane: Optional[pulumi.Input[str]] = None,
                 max_unavailable_worker: Optional[pulumi.Input[str]] = None):
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if drain_input is not None:
            pulumi.set(__self__, "drain_input", drain_input)
        if max_unavailable_controlplane is not None:
            pulumi.set(__self__, "max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            pulumi.set(__self__, "max_unavailable_worker", max_unavailable_worker)

    @property
    @pulumi.getter
    def drain(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "drain")

    @drain.setter
    def drain(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain", value)

    @property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgs']]:
        return pulumi.get(self, "drain_input")

    @drain_input.setter
    def drain_input(self, value: Optional[pulumi.Input['ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgs']]):
        pulumi.set(self, "drain_input", value)

    @property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_unavailable_controlplane")

    @max_unavailable_controlplane.setter
    def max_unavailable_controlplane(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_unavailable_controlplane", value)

    @property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_unavailable_worker")

    @max_unavailable_worker.setter
    def max_unavailable_worker(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_unavailable_worker", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgsDict(TypedDict):
        delete_local_data: NotRequired[pulumi.Input[bool]]
        force: NotRequired[pulumi.Input[bool]]
        grace_period: NotRequired[pulumi.Input[int]]
        ignore_daemon_sets: NotRequired[pulumi.Input[bool]]
        timeout: NotRequired[pulumi.Input[int]]
elif False:
    ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputArgs:
    def __init__(__self__, *,
                 delete_local_data: Optional[pulumi.Input[bool]] = None,
                 force: Optional[pulumi.Input[bool]] = None,
                 grace_period: Optional[pulumi.Input[int]] = None,
                 ignore_daemon_sets: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        if delete_local_data is not None:
            pulumi.set(__self__, "delete_local_data", delete_local_data)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_local_data")

    @delete_local_data.setter
    def delete_local_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_local_data", value)

    @property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ignore_daemon_sets")

    @ignore_daemon_sets.setter
    def ignore_daemon_sets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_daemon_sets", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ClusterTemplateTemplateRevisionQuestionArgsDict(TypedDict):
        default: pulumi.Input[str]
        """
        Default variable value
        """
        variable: pulumi.Input[str]
        """
        Variable name
        """
        required: NotRequired[pulumi.Input[bool]]
        """
        Required variable
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Variable type
        """
elif False:
    ClusterTemplateTemplateRevisionQuestionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterTemplateTemplateRevisionQuestionArgs:
    def __init__(__self__, *,
                 default: pulumi.Input[str],
                 variable: pulumi.Input[str],
                 required: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default: Default variable value
        :param pulumi.Input[str] variable: Variable name
        :param pulumi.Input[bool] required: Required variable
        :param pulumi.Input[str] type: Variable type
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "variable", variable)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def default(self) -> pulumi.Input[str]:
        """
        Default variable value
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input[str]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def variable(self) -> pulumi.Input[str]:
        """
        Variable name
        """
        return pulumi.get(self, "variable")

    @variable.setter
    def variable(self, value: pulumi.Input[str]):
        pulumi.set(self, "variable", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Required variable
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Variable type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ClusterV2AgentEnvVarArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the cluster.
        """
        value: pulumi.Input[str]
        """
        The taint value.
        """
elif False:
    ClusterV2AgentEnvVarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2AgentEnvVarArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[str] value: The taint value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterV2ClusterAgentDeploymentCustomizationArgsDict(TypedDict):
        append_tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgsDict']]]]
        """
        User defined tolerations to append to agent
        """
        override_affinity: NotRequired[pulumi.Input[str]]
        """
        User defined affinity to override default agent affinity
        """
        override_resource_requirements: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict']]]]
        """
        User defined resource requirements to set on the agent
        """
elif False:
    ClusterV2ClusterAgentDeploymentCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ClusterAgentDeploymentCustomizationArgs:
    def __init__(__self__, *,
                 append_tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs']]]] = None,
                 override_affinity: Optional[pulumi.Input[str]] = None,
                 override_resource_requirements: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs']]] append_tolerations: User defined tolerations to append to agent
        :param pulumi.Input[str] override_affinity: User defined affinity to override default agent affinity
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]] override_resource_requirements: User defined resource requirements to set on the agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)

    @property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs']]]]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @append_tolerations.setter
    def append_tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs']]]]):
        pulumi.set(self, "append_tolerations", value)

    @property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @override_affinity.setter
    def override_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_affinity", value)

    @property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")

    @override_resource_requirements.setter
    def override_resource_requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]):
        pulumi.set(self, "override_resource_requirements", value)


if not MYPY:
    class ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key is the name of the key of the item to retrieve.
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds a pod will stay bound to a node with a matching taint.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The taint value.
        """
elif False:
    ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key is the name of the key of the item to retrieve.
        :param pulumi.Input[str] effect: The taint effect. Default: `\\"NoExecute\\"`.
        :param pulumi.Input[str] operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[int] seconds: The number of seconds a pod will stay bound to a node with a matching taint.
        :param pulumi.Input[str] value: The taint value.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key is the name of the key of the item to retrieve.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds a pod will stay bound to a node with a matching taint.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict(TypedDict):
        cpu_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum CPU limit for agent
        """
        cpu_request: NotRequired[pulumi.Input[str]]
        """
        The minimum CPU required for agent
        """
        memory_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum memory limit for agent
        """
        memory_request: NotRequired[pulumi.Input[str]]
        """
        The minimum memory required for agent
        """
elif False:
    ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs:
    def __init__(__self__, *,
                 cpu_limit: Optional[pulumi.Input[str]] = None,
                 cpu_request: Optional[pulumi.Input[str]] = None,
                 memory_limit: Optional[pulumi.Input[str]] = None,
                 memory_request: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_limit: The maximum CPU limit for agent
        :param pulumi.Input[str] cpu_request: The minimum CPU required for agent
        :param pulumi.Input[str] memory_limit: The maximum memory limit for agent
        :param pulumi.Input[str] memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @cpu_request.setter
    def cpu_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_request", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_limit", value)

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")

    @memory_request.setter
    def memory_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_request", value)


if not MYPY:
    class ClusterV2ClusterRegistrationTokenArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations for the Cluster.
        """
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        Cluster ID.
        """
        command: NotRequired[pulumi.Input[str]]
        """
        Command to execute in an imported k8s cluster.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        (Computed, string) The ID of the resource.
        """
        insecure_command: NotRequired[pulumi.Input[str]]
        """
        Insecure command to execute in an imported k8s cluster.
        """
        insecure_node_command: NotRequired[pulumi.Input[str]]
        """
        Insecure node command to execute in an imported k8s cluster.
        """
        insecure_windows_node_command: NotRequired[pulumi.Input[str]]
        """
        Insecure windows command to execute in an imported k8s cluster.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster.
        """
        manifest_url: NotRequired[pulumi.Input[str]]
        """
        K8s manifest url to execute with `kubectl` to import an existing k8s cluster.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the cluster.
        """
        node_command: NotRequired[pulumi.Input[str]]
        """
        Node command to execute in Linux nodes for custom k8s cluster.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Token for cluster registration token object.
        """
        windows_node_command: NotRequired[pulumi.Input[str]]
        """
        Node command to execute in Windows nodes for custom k8s cluster.
        """
elif False:
    ClusterV2ClusterRegistrationTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2ClusterRegistrationTokenArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 command: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 insecure_command: Optional[pulumi.Input[str]] = None,
                 insecure_node_command: Optional[pulumi.Input[str]] = None,
                 insecure_windows_node_command: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 manifest_url: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 node_command: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 windows_node_command: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations for the Cluster.
        :param pulumi.Input[str] cluster_id: Cluster ID.
        :param pulumi.Input[str] command: Command to execute in an imported k8s cluster.
        :param pulumi.Input[str] id: (Computed, string) The ID of the resource.
        :param pulumi.Input[str] insecure_command: Insecure command to execute in an imported k8s cluster.
        :param pulumi.Input[str] insecure_node_command: Insecure node command to execute in an imported k8s cluster.
        :param pulumi.Input[str] insecure_windows_node_command: Insecure windows command to execute in an imported k8s cluster.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster.
        :param pulumi.Input[str] manifest_url: K8s manifest url to execute with `kubectl` to import an existing k8s cluster.
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[str] node_command: Node command to execute in Linux nodes for custom k8s cluster.
        :param pulumi.Input[str] token: Token for cluster registration token object.
        :param pulumi.Input[str] windows_node_command: Node command to execute in Windows nodes for custom k8s cluster.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure_command is not None:
            pulumi.set(__self__, "insecure_command", insecure_command)
        if insecure_node_command is not None:
            pulumi.set(__self__, "insecure_node_command", insecure_node_command)
        if insecure_windows_node_command is not None:
            pulumi.set(__self__, "insecure_windows_node_command", insecure_windows_node_command)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if manifest_url is not None:
            pulumi.set(__self__, "manifest_url", manifest_url)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_command is not None:
            pulumi.set(__self__, "node_command", node_command)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if windows_node_command is not None:
            pulumi.set(__self__, "windows_node_command", windows_node_command)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations for the Cluster.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[str]]:
        """
        Command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        (Computed, string) The ID of the resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="insecureCommand")
    def insecure_command(self) -> Optional[pulumi.Input[str]]:
        """
        Insecure command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "insecure_command")

    @insecure_command.setter
    def insecure_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insecure_command", value)

    @property
    @pulumi.getter(name="insecureNodeCommand")
    def insecure_node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Insecure node command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "insecure_node_command")

    @insecure_node_command.setter
    def insecure_node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insecure_node_command", value)

    @property
    @pulumi.getter(name="insecureWindowsNodeCommand")
    def insecure_windows_node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Insecure windows command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "insecure_windows_node_command")

    @insecure_windows_node_command.setter
    def insecure_windows_node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insecure_windows_node_command", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="manifestUrl")
    def manifest_url(self) -> Optional[pulumi.Input[str]]:
        """
        K8s manifest url to execute with `kubectl` to import an existing k8s cluster.
        """
        return pulumi.get(self, "manifest_url")

    @manifest_url.setter
    def manifest_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manifest_url", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nodeCommand")
    def node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Node command to execute in Linux nodes for custom k8s cluster.
        """
        return pulumi.get(self, "node_command")

    @node_command.setter
    def node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_command", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Token for cluster registration token object.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="windowsNodeCommand")
    def windows_node_command(self) -> Optional[pulumi.Input[str]]:
        """
        Node command to execute in Windows nodes for custom k8s cluster.
        """
        return pulumi.get(self, "windows_node_command")

    @windows_node_command.setter
    def windows_node_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_node_command", value)


if not MYPY:
    class ClusterV2FleetAgentDeploymentCustomizationArgsDict(TypedDict):
        append_tolerations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgsDict']]]]
        """
        User defined tolerations to append to agent
        """
        override_affinity: NotRequired[pulumi.Input[str]]
        """
        User defined affinity to override default agent affinity
        """
        override_resource_requirements: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict']]]]
        """
        User defined resource requirements to set on the agent
        """
elif False:
    ClusterV2FleetAgentDeploymentCustomizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2FleetAgentDeploymentCustomizationArgs:
    def __init__(__self__, *,
                 append_tolerations: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs']]]] = None,
                 override_affinity: Optional[pulumi.Input[str]] = None,
                 override_resource_requirements: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs']]] append_tolerations: User defined tolerations to append to agent
        :param pulumi.Input[str] override_affinity: User defined affinity to override default agent affinity
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]] override_resource_requirements: User defined resource requirements to set on the agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)

    @property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs']]]]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @append_tolerations.setter
    def append_tolerations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs']]]]):
        pulumi.set(self, "append_tolerations", value)

    @property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @override_affinity.setter
    def override_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_affinity", value)

    @property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")

    @override_resource_requirements.setter
    def override_resource_requirements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs']]]]):
        pulumi.set(self, "override_resource_requirements", value)


if not MYPY:
    class ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key is the name of the key of the item to retrieve.
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds a pod will stay bound to a node with a matching taint.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The taint value.
        """
elif False:
    ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 seconds: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key is the name of the key of the item to retrieve.
        :param pulumi.Input[str] effect: The taint effect. Default: `\\"NoExecute\\"`.
        :param pulumi.Input[str] operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param pulumi.Input[int] seconds: The number of seconds a pod will stay bound to a node with a matching taint.
        :param pulumi.Input[str] value: The taint value.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key is the name of the key of the item to retrieve.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds a pod will stay bound to a node with a matching taint.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict(TypedDict):
        cpu_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum CPU limit for agent
        """
        cpu_request: NotRequired[pulumi.Input[str]]
        """
        The minimum CPU required for agent
        """
        memory_limit: NotRequired[pulumi.Input[str]]
        """
        The maximum memory limit for agent
        """
        memory_request: NotRequired[pulumi.Input[str]]
        """
        The minimum memory required for agent
        """
elif False:
    ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs:
    def __init__(__self__, *,
                 cpu_limit: Optional[pulumi.Input[str]] = None,
                 cpu_request: Optional[pulumi.Input[str]] = None,
                 memory_limit: Optional[pulumi.Input[str]] = None,
                 memory_request: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cpu_limit: The maximum CPU limit for agent
        :param pulumi.Input[str] cpu_request: The minimum CPU required for agent
        :param pulumi.Input[str] memory_limit: The maximum memory limit for agent
        :param pulumi.Input[str] memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @cpu_limit.setter
    def cpu_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_limit", value)

    @property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @cpu_request.setter
    def cpu_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_request", value)

    @property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @memory_limit.setter
    def memory_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_limit", value)

    @property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")

    @memory_request.setter
    def memory_request(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_request", value)


if not MYPY:
    class ClusterV2LocalAuthEndpointArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[str]]
        """
        CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        If `enabled` is set to true, nodes will be drained before upgrade.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
elif False:
    ClusterV2LocalAuthEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2LocalAuthEndpointArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certs: CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        :param pulumi.Input[bool] enabled: If `enabled` is set to true, nodes will be drained before upgrade.
        :param pulumi.Input[str] fqdn: FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[str]]:
        """
        CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If `enabled` is set to true, nodes will be drained before upgrade.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class ClusterV2RkeConfigArgsDict(TypedDict):
        additional_manifest: NotRequired[pulumi.Input[str]]
        """
        Cluster V2 additional manifest
        """
        chart_values: NotRequired[pulumi.Input[str]]
        """
        Cluster V2 chart values. It should be in YAML format
        """
        etcd: NotRequired[pulumi.Input['ClusterV2RkeConfigEtcdArgsDict']]
        """
        Cluster V2 etcd
        """
        etcd_snapshot_create: NotRequired[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotCreateArgsDict']]
        """
        Cluster V2 etcd snapshot create
        """
        etcd_snapshot_restore: NotRequired[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotRestoreArgsDict']]
        """
        Cluster V2 etcd snapshot restore
        """
        local_auth_endpoint: NotRequired[pulumi.Input['ClusterV2RkeConfigLocalAuthEndpointArgsDict']]
        """
        Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to [Rancher Documentation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/kubernetes-clusters-in-rancher-setup/register-existing-clusters#authorized-cluster-endpoint-support-for-rke2-and-k3s-clusters).
        """
        machine_global_config: NotRequired[pulumi.Input[str]]
        """
        Cluster V2 machine global config
        """
        machine_pool_defaults: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolDefaultArgsDict']]]]
        """
        Default values for machine pool configurations if unset
        """
        machine_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolArgsDict']]]]
        """
        Cluster V2 machine pools
        """
        machine_selector_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigArgsDict']]]]
        """
        Cluster V2 machine selector config
        """
        machine_selector_files: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileArgsDict']]]]
        """
        Cluster V2 machine selector files
        """
        registries: NotRequired[pulumi.Input['ClusterV2RkeConfigRegistriesArgsDict']]
        """
        Cluster V2 registries
        """
        rotate_certificates: NotRequired[pulumi.Input['ClusterV2RkeConfigRotateCertificatesArgsDict']]
        """
        Cluster V2 certificate rotation
        """
        upgrade_strategy: NotRequired[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyArgsDict']]
        """
        Cluster V2 upgrade strategy
        """
elif False:
    ClusterV2RkeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigArgs:
    def __init__(__self__, *,
                 additional_manifest: Optional[pulumi.Input[str]] = None,
                 chart_values: Optional[pulumi.Input[str]] = None,
                 etcd: Optional[pulumi.Input['ClusterV2RkeConfigEtcdArgs']] = None,
                 etcd_snapshot_create: Optional[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotCreateArgs']] = None,
                 etcd_snapshot_restore: Optional[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotRestoreArgs']] = None,
                 local_auth_endpoint: Optional[pulumi.Input['ClusterV2RkeConfigLocalAuthEndpointArgs']] = None,
                 machine_global_config: Optional[pulumi.Input[str]] = None,
                 machine_pool_defaults: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolDefaultArgs']]]] = None,
                 machine_pools: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolArgs']]]] = None,
                 machine_selector_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigArgs']]]] = None,
                 machine_selector_files: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileArgs']]]] = None,
                 registries: Optional[pulumi.Input['ClusterV2RkeConfigRegistriesArgs']] = None,
                 rotate_certificates: Optional[pulumi.Input['ClusterV2RkeConfigRotateCertificatesArgs']] = None,
                 upgrade_strategy: Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyArgs']] = None):
        """
        :param pulumi.Input[str] additional_manifest: Cluster V2 additional manifest
        :param pulumi.Input[str] chart_values: Cluster V2 chart values. It should be in YAML format
        :param pulumi.Input['ClusterV2RkeConfigEtcdArgs'] etcd: Cluster V2 etcd
        :param pulumi.Input['ClusterV2RkeConfigEtcdSnapshotCreateArgs'] etcd_snapshot_create: Cluster V2 etcd snapshot create
        :param pulumi.Input['ClusterV2RkeConfigEtcdSnapshotRestoreArgs'] etcd_snapshot_restore: Cluster V2 etcd snapshot restore
        :param pulumi.Input['ClusterV2RkeConfigLocalAuthEndpointArgs'] local_auth_endpoint: Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to [Rancher Documentation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/kubernetes-clusters-in-rancher-setup/register-existing-clusters#authorized-cluster-endpoint-support-for-rke2-and-k3s-clusters).
        :param pulumi.Input[str] machine_global_config: Cluster V2 machine global config
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolDefaultArgs']]] machine_pool_defaults: Default values for machine pool configurations if unset
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolArgs']]] machine_pools: Cluster V2 machine pools
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigArgs']]] machine_selector_configs: Cluster V2 machine selector config
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileArgs']]] machine_selector_files: Cluster V2 machine selector files
        :param pulumi.Input['ClusterV2RkeConfigRegistriesArgs'] registries: Cluster V2 registries
        :param pulumi.Input['ClusterV2RkeConfigRotateCertificatesArgs'] rotate_certificates: Cluster V2 certificate rotation
        :param pulumi.Input['ClusterV2RkeConfigUpgradeStrategyArgs'] upgrade_strategy: Cluster V2 upgrade strategy
        """
        if additional_manifest is not None:
            pulumi.set(__self__, "additional_manifest", additional_manifest)
        if chart_values is not None:
            pulumi.set(__self__, "chart_values", chart_values)
        if etcd is not None:
            pulumi.set(__self__, "etcd", etcd)
        if etcd_snapshot_create is not None:
            pulumi.set(__self__, "etcd_snapshot_create", etcd_snapshot_create)
        if etcd_snapshot_restore is not None:
            pulumi.set(__self__, "etcd_snapshot_restore", etcd_snapshot_restore)
        if local_auth_endpoint is not None:
            warnings.warn("""Use rancher2_cluster_v2.local_auth_endpoint instead""", DeprecationWarning)
            pulumi.log.warn("""local_auth_endpoint is deprecated: Use rancher2_cluster_v2.local_auth_endpoint instead""")
        if local_auth_endpoint is not None:
            pulumi.set(__self__, "local_auth_endpoint", local_auth_endpoint)
        if machine_global_config is not None:
            pulumi.set(__self__, "machine_global_config", machine_global_config)
        if machine_pool_defaults is not None:
            pulumi.set(__self__, "machine_pool_defaults", machine_pool_defaults)
        if machine_pools is not None:
            pulumi.set(__self__, "machine_pools", machine_pools)
        if machine_selector_configs is not None:
            pulumi.set(__self__, "machine_selector_configs", machine_selector_configs)
        if machine_selector_files is not None:
            pulumi.set(__self__, "machine_selector_files", machine_selector_files)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if rotate_certificates is not None:
            pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)

    @property
    @pulumi.getter(name="additionalManifest")
    def additional_manifest(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster V2 additional manifest
        """
        return pulumi.get(self, "additional_manifest")

    @additional_manifest.setter
    def additional_manifest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "additional_manifest", value)

    @property
    @pulumi.getter(name="chartValues")
    def chart_values(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster V2 chart values. It should be in YAML format
        """
        return pulumi.get(self, "chart_values")

    @chart_values.setter
    def chart_values(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chart_values", value)

    @property
    @pulumi.getter
    def etcd(self) -> Optional[pulumi.Input['ClusterV2RkeConfigEtcdArgs']]:
        """
        Cluster V2 etcd
        """
        return pulumi.get(self, "etcd")

    @etcd.setter
    def etcd(self, value: Optional[pulumi.Input['ClusterV2RkeConfigEtcdArgs']]):
        pulumi.set(self, "etcd", value)

    @property
    @pulumi.getter(name="etcdSnapshotCreate")
    def etcd_snapshot_create(self) -> Optional[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotCreateArgs']]:
        """
        Cluster V2 etcd snapshot create
        """
        return pulumi.get(self, "etcd_snapshot_create")

    @etcd_snapshot_create.setter
    def etcd_snapshot_create(self, value: Optional[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotCreateArgs']]):
        pulumi.set(self, "etcd_snapshot_create", value)

    @property
    @pulumi.getter(name="etcdSnapshotRestore")
    def etcd_snapshot_restore(self) -> Optional[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotRestoreArgs']]:
        """
        Cluster V2 etcd snapshot restore
        """
        return pulumi.get(self, "etcd_snapshot_restore")

    @etcd_snapshot_restore.setter
    def etcd_snapshot_restore(self, value: Optional[pulumi.Input['ClusterV2RkeConfigEtcdSnapshotRestoreArgs']]):
        pulumi.set(self, "etcd_snapshot_restore", value)

    @property
    @pulumi.getter(name="localAuthEndpoint")
    @_utilities.deprecated("""Use rancher2_cluster_v2.local_auth_endpoint instead""")
    def local_auth_endpoint(self) -> Optional[pulumi.Input['ClusterV2RkeConfigLocalAuthEndpointArgs']]:
        """
        Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to [Rancher Documentation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/kubernetes-clusters-in-rancher-setup/register-existing-clusters#authorized-cluster-endpoint-support-for-rke2-and-k3s-clusters).
        """
        return pulumi.get(self, "local_auth_endpoint")

    @local_auth_endpoint.setter
    def local_auth_endpoint(self, value: Optional[pulumi.Input['ClusterV2RkeConfigLocalAuthEndpointArgs']]):
        pulumi.set(self, "local_auth_endpoint", value)

    @property
    @pulumi.getter(name="machineGlobalConfig")
    def machine_global_config(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster V2 machine global config
        """
        return pulumi.get(self, "machine_global_config")

    @machine_global_config.setter
    def machine_global_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "machine_global_config", value)

    @property
    @pulumi.getter(name="machinePoolDefaults")
    def machine_pool_defaults(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolDefaultArgs']]]]:
        """
        Default values for machine pool configurations if unset
        """
        return pulumi.get(self, "machine_pool_defaults")

    @machine_pool_defaults.setter
    def machine_pool_defaults(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolDefaultArgs']]]]):
        pulumi.set(self, "machine_pool_defaults", value)

    @property
    @pulumi.getter(name="machinePools")
    def machine_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolArgs']]]]:
        """
        Cluster V2 machine pools
        """
        return pulumi.get(self, "machine_pools")

    @machine_pools.setter
    def machine_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolArgs']]]]):
        pulumi.set(self, "machine_pools", value)

    @property
    @pulumi.getter(name="machineSelectorConfigs")
    def machine_selector_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigArgs']]]]:
        """
        Cluster V2 machine selector config
        """
        return pulumi.get(self, "machine_selector_configs")

    @machine_selector_configs.setter
    def machine_selector_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigArgs']]]]):
        pulumi.set(self, "machine_selector_configs", value)

    @property
    @pulumi.getter(name="machineSelectorFiles")
    def machine_selector_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileArgs']]]]:
        """
        Cluster V2 machine selector files
        """
        return pulumi.get(self, "machine_selector_files")

    @machine_selector_files.setter
    def machine_selector_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileArgs']]]]):
        pulumi.set(self, "machine_selector_files", value)

    @property
    @pulumi.getter
    def registries(self) -> Optional[pulumi.Input['ClusterV2RkeConfigRegistriesArgs']]:
        """
        Cluster V2 registries
        """
        return pulumi.get(self, "registries")

    @registries.setter
    def registries(self, value: Optional[pulumi.Input['ClusterV2RkeConfigRegistriesArgs']]):
        pulumi.set(self, "registries", value)

    @property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> Optional[pulumi.Input['ClusterV2RkeConfigRotateCertificatesArgs']]:
        """
        Cluster V2 certificate rotation
        """
        return pulumi.get(self, "rotate_certificates")

    @rotate_certificates.setter
    def rotate_certificates(self, value: Optional[pulumi.Input['ClusterV2RkeConfigRotateCertificatesArgs']]):
        pulumi.set(self, "rotate_certificates", value)

    @property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyArgs']]:
        """
        Cluster V2 upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @upgrade_strategy.setter
    def upgrade_strategy(self, value: Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyArgs']]):
        pulumi.set(self, "upgrade_strategy", value)


if not MYPY:
    class ClusterV2RkeConfigEtcdArgsDict(TypedDict):
        disable_snapshots: NotRequired[pulumi.Input[bool]]
        """
        Disable ETCD snapshots
        """
        s3_config: NotRequired[pulumi.Input['ClusterV2RkeConfigEtcdS3ConfigArgsDict']]
        """
        ETCD snapshot S3 config
        """
        snapshot_retention: NotRequired[pulumi.Input[int]]
        """
        ETCD snapshot retention
        """
        snapshot_schedule_cron: NotRequired[pulumi.Input[str]]
        """
        ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
elif False:
    ClusterV2RkeConfigEtcdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigEtcdArgs:
    def __init__(__self__, *,
                 disable_snapshots: Optional[pulumi.Input[bool]] = None,
                 s3_config: Optional[pulumi.Input['ClusterV2RkeConfigEtcdS3ConfigArgs']] = None,
                 snapshot_retention: Optional[pulumi.Input[int]] = None,
                 snapshot_schedule_cron: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_snapshots: Disable ETCD snapshots
        :param pulumi.Input['ClusterV2RkeConfigEtcdS3ConfigArgs'] s3_config: ETCD snapshot S3 config
        :param pulumi.Input[int] snapshot_retention: ETCD snapshot retention
        :param pulumi.Input[str] snapshot_schedule_cron: ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
        if disable_snapshots is not None:
            pulumi.set(__self__, "disable_snapshots", disable_snapshots)
        if s3_config is not None:
            pulumi.set(__self__, "s3_config", s3_config)
        if snapshot_retention is not None:
            pulumi.set(__self__, "snapshot_retention", snapshot_retention)
        if snapshot_schedule_cron is not None:
            pulumi.set(__self__, "snapshot_schedule_cron", snapshot_schedule_cron)

    @property
    @pulumi.getter(name="disableSnapshots")
    def disable_snapshots(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable ETCD snapshots
        """
        return pulumi.get(self, "disable_snapshots")

    @disable_snapshots.setter
    def disable_snapshots(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_snapshots", value)

    @property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> Optional[pulumi.Input['ClusterV2RkeConfigEtcdS3ConfigArgs']]:
        """
        ETCD snapshot S3 config
        """
        return pulumi.get(self, "s3_config")

    @s3_config.setter
    def s3_config(self, value: Optional[pulumi.Input['ClusterV2RkeConfigEtcdS3ConfigArgs']]):
        pulumi.set(self, "s3_config", value)

    @property
    @pulumi.getter(name="snapshotRetention")
    def snapshot_retention(self) -> Optional[pulumi.Input[int]]:
        """
        ETCD snapshot retention
        """
        return pulumi.get(self, "snapshot_retention")

    @snapshot_retention.setter
    def snapshot_retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "snapshot_retention", value)

    @property
    @pulumi.getter(name="snapshotScheduleCron")
    def snapshot_schedule_cron(self) -> Optional[pulumi.Input[str]]:
        """
        ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
        return pulumi.get(self, "snapshot_schedule_cron")

    @snapshot_schedule_cron.setter
    def snapshot_schedule_cron(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snapshot_schedule_cron", value)


if not MYPY:
    class ClusterV2RkeConfigEtcdS3ConfigArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        ETCD snapshot S3 bucket
        """
        endpoint: pulumi.Input[str]
        """
        ETCD snapshot S3 endpoint
        """
        cloud_credential_name: NotRequired[pulumi.Input[str]]
        """
        ETCD snapshot S3 cloud credential name
        """
        endpoint_ca: NotRequired[pulumi.Input[str]]
        """
        ETCD snapshot S3 endpoint CA
        """
        folder: NotRequired[pulumi.Input[str]]
        """
        ETCD snapshot S3 folder
        """
        region: NotRequired[pulumi.Input[str]]
        """
        ETCD snapshot S3 region
        """
        skip_ssl_verify: NotRequired[pulumi.Input[bool]]
        """
        Disable ETCD skip ssl verify
        """
elif False:
    ClusterV2RkeConfigEtcdS3ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigEtcdS3ConfigArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 cloud_credential_name: Optional[pulumi.Input[str]] = None,
                 endpoint_ca: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 skip_ssl_verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket: ETCD snapshot S3 bucket
        :param pulumi.Input[str] endpoint: ETCD snapshot S3 endpoint
        :param pulumi.Input[str] cloud_credential_name: ETCD snapshot S3 cloud credential name
        :param pulumi.Input[str] endpoint_ca: ETCD snapshot S3 endpoint CA
        :param pulumi.Input[str] folder: ETCD snapshot S3 folder
        :param pulumi.Input[str] region: ETCD snapshot S3 region
        :param pulumi.Input[bool] skip_ssl_verify: Disable ETCD skip ssl verify
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "endpoint", endpoint)
        if cloud_credential_name is not None:
            pulumi.set(__self__, "cloud_credential_name", cloud_credential_name)
        if endpoint_ca is not None:
            pulumi.set(__self__, "endpoint_ca", endpoint_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if skip_ssl_verify is not None:
            pulumi.set(__self__, "skip_ssl_verify", skip_ssl_verify)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        ETCD snapshot S3 bucket
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        ETCD snapshot S3 endpoint
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="cloudCredentialName")
    def cloud_credential_name(self) -> Optional[pulumi.Input[str]]:
        """
        ETCD snapshot S3 cloud credential name
        """
        return pulumi.get(self, "cloud_credential_name")

    @cloud_credential_name.setter
    def cloud_credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_credential_name", value)

    @property
    @pulumi.getter(name="endpointCa")
    def endpoint_ca(self) -> Optional[pulumi.Input[str]]:
        """
        ETCD snapshot S3 endpoint CA
        """
        return pulumi.get(self, "endpoint_ca")

    @endpoint_ca.setter
    def endpoint_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_ca", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        ETCD snapshot S3 folder
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        ETCD snapshot S3 region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="skipSslVerify")
    def skip_ssl_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable ETCD skip ssl verify
        """
        return pulumi.get(self, "skip_ssl_verify")

    @skip_ssl_verify.setter
    def skip_ssl_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_ssl_verify", value)


if not MYPY:
    class ClusterV2RkeConfigEtcdSnapshotCreateArgsDict(TypedDict):
        generation: pulumi.Input[int]
        """
        ETCD generation to initiate a snapshot
        """
elif False:
    ClusterV2RkeConfigEtcdSnapshotCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigEtcdSnapshotCreateArgs:
    def __init__(__self__, *,
                 generation: pulumi.Input[int]):
        """
        :param pulumi.Input[int] generation: ETCD generation to initiate a snapshot
        """
        pulumi.set(__self__, "generation", generation)

    @property
    @pulumi.getter
    def generation(self) -> pulumi.Input[int]:
        """
        ETCD generation to initiate a snapshot
        """
        return pulumi.get(self, "generation")

    @generation.setter
    def generation(self, value: pulumi.Input[int]):
        pulumi.set(self, "generation", value)


if not MYPY:
    class ClusterV2RkeConfigEtcdSnapshotRestoreArgsDict(TypedDict):
        generation: pulumi.Input[int]
        """
        ETCD snapshot desired generation
        """
        name: pulumi.Input[str]
        """
        The name of the cluster.
        """
        restore_rke_config: NotRequired[pulumi.Input[str]]
        """
        ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
elif False:
    ClusterV2RkeConfigEtcdSnapshotRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigEtcdSnapshotRestoreArgs:
    def __init__(__self__, *,
                 generation: pulumi.Input[int],
                 name: pulumi.Input[str],
                 restore_rke_config: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] generation: ETCD snapshot desired generation
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[str] restore_rke_config: ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "name", name)
        if restore_rke_config is not None:
            pulumi.set(__self__, "restore_rke_config", restore_rke_config)

    @property
    @pulumi.getter
    def generation(self) -> pulumi.Input[int]:
        """
        ETCD snapshot desired generation
        """
        return pulumi.get(self, "generation")

    @generation.setter
    def generation(self, value: pulumi.Input[int]):
        pulumi.set(self, "generation", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="restoreRkeConfig")
    def restore_rke_config(self) -> Optional[pulumi.Input[str]]:
        """
        ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
        return pulumi.get(self, "restore_rke_config")

    @restore_rke_config.setter
    def restore_rke_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "restore_rke_config", value)


if not MYPY:
    class ClusterV2RkeConfigLocalAuthEndpointArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[str]]
        """
        CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        If `enabled` is set to true, nodes will be drained before upgrade.
        """
        fqdn: NotRequired[pulumi.Input[str]]
        """
        FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
elif False:
    ClusterV2RkeConfigLocalAuthEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigLocalAuthEndpointArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 fqdn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_certs: CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        :param pulumi.Input[bool] enabled: If `enabled` is set to true, nodes will be drained before upgrade.
        :param pulumi.Input[str] fqdn: FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[str]]:
        """
        CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certs", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        If `enabled` is set to true, nodes will be drained before upgrade.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[str]]:
        """
        FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fqdn", value)


if not MYPY:
    class ClusterV2RkeConfigMachinePoolArgsDict(TypedDict):
        machine_config: pulumi.Input['ClusterV2RkeConfigMachinePoolMachineConfigArgsDict']
        """
        Machine config data
        """
        name: pulumi.Input[str]
        """
        The name of the cluster.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Annotations for the Cluster.
        """
        cloud_credential_secret_name: NotRequired[pulumi.Input[str]]
        """
        Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
        """
        control_plane_role: NotRequired[pulumi.Input[bool]]
        """
        Machine pool control plane role
        """
        drain_before_delete: NotRequired[pulumi.Input[bool]]
        """
        Machine pool drain before delete
        """
        etcd_role: NotRequired[pulumi.Input[bool]]
        """
        Machine pool etcd role
        """
        hostname_length_limit: NotRequired[pulumi.Input[int]]
        """
        maximum length for autogenerated hostname
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels for the Cluster.
        """
        machine_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Labels of the machine
        """
        max_unhealthy: NotRequired[pulumi.Input[str]]
        """
        max unhealthy nodes for automated replacement to be allowed
        """
        node_drain_timeout: NotRequired[pulumi.Input[int]]
        """
        seconds to wait for machine pool drain to complete before machine deletion
        """
        node_startup_timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        seconds a new node has to become active before it is replaced
        """
        paused: NotRequired[pulumi.Input[bool]]
        """
        Machine pool paused
        """
        quantity: NotRequired[pulumi.Input[int]]
        """
        Machine pool quantity
        """
        rolling_update: NotRequired[pulumi.Input['ClusterV2RkeConfigMachinePoolRollingUpdateArgsDict']]
        """
        Machine pool rolling update
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolTaintArgsDict']]]]
        """
        Machine pool taints
        """
        unhealthy_node_timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        seconds an unhealthy node has to become active before it is replaced
        """
        unhealthy_range: NotRequired[pulumi.Input[str]]
        """
        range of unhealthy nodes for automated replacement to be allowed
        """
        worker_role: NotRequired[pulumi.Input[bool]]
        """
        Machine pool worker role
        """
elif False:
    ClusterV2RkeConfigMachinePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachinePoolArgs:
    def __init__(__self__, *,
                 machine_config: pulumi.Input['ClusterV2RkeConfigMachinePoolMachineConfigArgs'],
                 name: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 cloud_credential_secret_name: Optional[pulumi.Input[str]] = None,
                 control_plane_role: Optional[pulumi.Input[bool]] = None,
                 drain_before_delete: Optional[pulumi.Input[bool]] = None,
                 etcd_role: Optional[pulumi.Input[bool]] = None,
                 hostname_length_limit: Optional[pulumi.Input[int]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 machine_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 max_unhealthy: Optional[pulumi.Input[str]] = None,
                 node_drain_timeout: Optional[pulumi.Input[int]] = None,
                 node_startup_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 paused: Optional[pulumi.Input[bool]] = None,
                 quantity: Optional[pulumi.Input[int]] = None,
                 rolling_update: Optional[pulumi.Input['ClusterV2RkeConfigMachinePoolRollingUpdateArgs']] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolTaintArgs']]]] = None,
                 unhealthy_node_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 unhealthy_range: Optional[pulumi.Input[str]] = None,
                 worker_role: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterV2RkeConfigMachinePoolMachineConfigArgs'] machine_config: Machine config data
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Annotations for the Cluster.
        :param pulumi.Input[str] cloud_credential_secret_name: Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
        :param pulumi.Input[bool] control_plane_role: Machine pool control plane role
        :param pulumi.Input[bool] drain_before_delete: Machine pool drain before delete
        :param pulumi.Input[bool] etcd_role: Machine pool etcd role
        :param pulumi.Input[int] hostname_length_limit: maximum length for autogenerated hostname
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels for the Cluster.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] machine_labels: Labels of the machine
        :param pulumi.Input[str] max_unhealthy: max unhealthy nodes for automated replacement to be allowed
        :param pulumi.Input[int] node_drain_timeout: seconds to wait for machine pool drain to complete before machine deletion
        :param pulumi.Input[int] node_startup_timeout_seconds: seconds a new node has to become active before it is replaced
        :param pulumi.Input[bool] paused: Machine pool paused
        :param pulumi.Input[int] quantity: Machine pool quantity
        :param pulumi.Input['ClusterV2RkeConfigMachinePoolRollingUpdateArgs'] rolling_update: Machine pool rolling update
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolTaintArgs']]] taints: Machine pool taints
        :param pulumi.Input[int] unhealthy_node_timeout_seconds: seconds an unhealthy node has to become active before it is replaced
        :param pulumi.Input[str] unhealthy_range: range of unhealthy nodes for automated replacement to be allowed
        :param pulumi.Input[bool] worker_role: Machine pool worker role
        """
        pulumi.set(__self__, "machine_config", machine_config)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cloud_credential_secret_name is not None:
            pulumi.set(__self__, "cloud_credential_secret_name", cloud_credential_secret_name)
        if control_plane_role is not None:
            pulumi.set(__self__, "control_plane_role", control_plane_role)
        if drain_before_delete is not None:
            pulumi.set(__self__, "drain_before_delete", drain_before_delete)
        if etcd_role is not None:
            pulumi.set(__self__, "etcd_role", etcd_role)
        if hostname_length_limit is not None:
            pulumi.set(__self__, "hostname_length_limit", hostname_length_limit)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if machine_labels is not None:
            pulumi.set(__self__, "machine_labels", machine_labels)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_startup_timeout_seconds is not None:
            pulumi.set(__self__, "node_startup_timeout_seconds", node_startup_timeout_seconds)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if unhealthy_node_timeout_seconds is not None:
            pulumi.set(__self__, "unhealthy_node_timeout_seconds", unhealthy_node_timeout_seconds)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)
        if worker_role is not None:
            pulumi.set(__self__, "worker_role", worker_role)

    @property
    @pulumi.getter(name="machineConfig")
    def machine_config(self) -> pulumi.Input['ClusterV2RkeConfigMachinePoolMachineConfigArgs']:
        """
        Machine config data
        """
        return pulumi.get(self, "machine_config")

    @machine_config.setter
    def machine_config(self, value: pulumi.Input['ClusterV2RkeConfigMachinePoolMachineConfigArgs']):
        pulumi.set(self, "machine_config", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Annotations for the Cluster.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="cloudCredentialSecretName")
    def cloud_credential_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
        """
        return pulumi.get(self, "cloud_credential_secret_name")

    @cloud_credential_secret_name.setter
    def cloud_credential_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_credential_secret_name", value)

    @property
    @pulumi.getter(name="controlPlaneRole")
    def control_plane_role(self) -> Optional[pulumi.Input[bool]]:
        """
        Machine pool control plane role
        """
        return pulumi.get(self, "control_plane_role")

    @control_plane_role.setter
    def control_plane_role(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "control_plane_role", value)

    @property
    @pulumi.getter(name="drainBeforeDelete")
    def drain_before_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Machine pool drain before delete
        """
        return pulumi.get(self, "drain_before_delete")

    @drain_before_delete.setter
    def drain_before_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drain_before_delete", value)

    @property
    @pulumi.getter(name="etcdRole")
    def etcd_role(self) -> Optional[pulumi.Input[bool]]:
        """
        Machine pool etcd role
        """
        return pulumi.get(self, "etcd_role")

    @etcd_role.setter
    def etcd_role(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "etcd_role", value)

    @property
    @pulumi.getter(name="hostnameLengthLimit")
    def hostname_length_limit(self) -> Optional[pulumi.Input[int]]:
        """
        maximum length for autogenerated hostname
        """
        return pulumi.get(self, "hostname_length_limit")

    @hostname_length_limit.setter
    def hostname_length_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hostname_length_limit", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels for the Cluster.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="machineLabels")
    def machine_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels of the machine
        """
        return pulumi.get(self, "machine_labels")

    @machine_labels.setter
    def machine_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "machine_labels", value)

    @property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[pulumi.Input[str]]:
        """
        max unhealthy nodes for automated replacement to be allowed
        """
        return pulumi.get(self, "max_unhealthy")

    @max_unhealthy.setter
    def max_unhealthy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_unhealthy", value)

    @property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[pulumi.Input[int]]:
        """
        seconds to wait for machine pool drain to complete before machine deletion
        """
        return pulumi.get(self, "node_drain_timeout")

    @node_drain_timeout.setter
    def node_drain_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_drain_timeout", value)

    @property
    @pulumi.getter(name="nodeStartupTimeoutSeconds")
    def node_startup_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        seconds a new node has to become active before it is replaced
        """
        return pulumi.get(self, "node_startup_timeout_seconds")

    @node_startup_timeout_seconds.setter
    def node_startup_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_startup_timeout_seconds", value)

    @property
    @pulumi.getter
    def paused(self) -> Optional[pulumi.Input[bool]]:
        """
        Machine pool paused
        """
        return pulumi.get(self, "paused")

    @paused.setter
    def paused(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "paused", value)

    @property
    @pulumi.getter
    def quantity(self) -> Optional[pulumi.Input[int]]:
        """
        Machine pool quantity
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quantity", value)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['ClusterV2RkeConfigMachinePoolRollingUpdateArgs']]:
        """
        Machine pool rolling update
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['ClusterV2RkeConfigMachinePoolRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolTaintArgs']]]]:
        """
        Machine pool taints
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachinePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)

    @property
    @pulumi.getter(name="unhealthyNodeTimeoutSeconds")
    def unhealthy_node_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        seconds an unhealthy node has to become active before it is replaced
        """
        return pulumi.get(self, "unhealthy_node_timeout_seconds")

    @unhealthy_node_timeout_seconds.setter
    def unhealthy_node_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_node_timeout_seconds", value)

    @property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[pulumi.Input[str]]:
        """
        range of unhealthy nodes for automated replacement to be allowed
        """
        return pulumi.get(self, "unhealthy_range")

    @unhealthy_range.setter
    def unhealthy_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unhealthy_range", value)

    @property
    @pulumi.getter(name="workerRole")
    def worker_role(self) -> Optional[pulumi.Input[bool]]:
        """
        Machine pool worker role
        """
        return pulumi.get(self, "worker_role")

    @worker_role.setter
    def worker_role(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "worker_role", value)


if not MYPY:
    class ClusterV2RkeConfigMachinePoolDefaultArgsDict(TypedDict):
        hostname_length_limit: NotRequired[pulumi.Input[int]]
        """
        maximum length for autogenerated hostname
        """
elif False:
    ClusterV2RkeConfigMachinePoolDefaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachinePoolDefaultArgs:
    def __init__(__self__, *,
                 hostname_length_limit: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hostname_length_limit: maximum length for autogenerated hostname
        """
        if hostname_length_limit is not None:
            pulumi.set(__self__, "hostname_length_limit", hostname_length_limit)

    @property
    @pulumi.getter(name="hostnameLengthLimit")
    def hostname_length_limit(self) -> Optional[pulumi.Input[int]]:
        """
        maximum length for autogenerated hostname
        """
        return pulumi.get(self, "hostname_length_limit")

    @hostname_length_limit.setter
    def hostname_length_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hostname_length_limit", value)


if not MYPY:
    class ClusterV2RkeConfigMachinePoolMachineConfigArgsDict(TypedDict):
        kind: pulumi.Input[str]
        """
        Machine config kind
        """
        name: pulumi.Input[str]
        """
        The name of the cluster.
        """
        api_version: NotRequired[pulumi.Input[str]]
        """
        Machine config API version
        """
elif False:
    ClusterV2RkeConfigMachinePoolMachineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachinePoolMachineConfigArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input[str],
                 name: pulumi.Input[str],
                 api_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kind: Machine config kind
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[str] api_version: Machine config API version
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input[str]:
        """
        Machine config kind
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input[str]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[str]]:
        """
        Machine config API version
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_version", value)


if not MYPY:
    class ClusterV2RkeConfigMachinePoolRollingUpdateArgsDict(TypedDict):
        max_surge: NotRequired[pulumi.Input[str]]
        """
        Rolling update max surge
        """
        max_unavailable: NotRequired[pulumi.Input[str]]
        """
        Rolling update max unavailable
        """
elif False:
    ClusterV2RkeConfigMachinePoolRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachinePoolRollingUpdateArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[str]] = None,
                 max_unavailable: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] max_surge: Rolling update max surge
        :param pulumi.Input[str] max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[str]]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[str]]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class ClusterV2RkeConfigMachinePoolTaintArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Key is the name of the key of the item to retrieve.
        """
        value: pulumi.Input[str]
        """
        The taint value.
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
elif False:
    ClusterV2RkeConfigMachinePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachinePoolTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key is the name of the key of the item to retrieve.
        :param pulumi.Input[str] value: The taint value.
        :param pulumi.Input[str] effect: The taint effect. Default: `\\"NoExecute\\"`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key is the name of the key of the item to retrieve.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorConfigArgsDict(TypedDict):
        config: NotRequired[pulumi.Input[str]]
        """
        Machine selector config
        """
        machine_label_selector: NotRequired[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgsDict']]
        """
        Machine label selector
        """
elif False:
    ClusterV2RkeConfigMachineSelectorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorConfigArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input[str]] = None,
                 machine_label_selector: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs']] = None):
        """
        :param pulumi.Input[str] config: Machine selector config
        :param pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs'] machine_label_selector: Machine label selector
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if machine_label_selector is not None:
            pulumi.set(__self__, "machine_label_selector", machine_label_selector)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input[str]]:
        """
        Machine selector config
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter(name="machineLabelSelector")
    def machine_label_selector(self) -> Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs']]:
        """
        Machine label selector
        """
        return pulumi.get(self, "machine_label_selector")

    @machine_label_selector.setter
    def machine_label_selector(self, value: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs']]):
        pulumi.set(self, "machine_label_selector", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgsDict']]]]
        """
        Label selector match expressions
        """
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Label selector match labels
        """
elif False:
    ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs']]] match_expressions: Label selector match expressions
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: Label selector match labels
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs']]]]:
        """
        Label selector match expressions
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Label selector match labels
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Label selector requirement key
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Label selector operator
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Label selector requirement values
        """
elif False:
    ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Label selector requirement key
        :param pulumi.Input[str] operator: Label selector operator
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Label selector requirement values
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector requirement key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector operator
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Label selector requirement values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileArgsDict(TypedDict):
        file_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceArgsDict']]]]
        """
        File sources
        """
        machine_label_selector: NotRequired[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgsDict']]
        """
        Machine label selector
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileArgs:
    def __init__(__self__, *,
                 file_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceArgs']]]] = None,
                 machine_label_selector: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceArgs']]] file_sources: File sources
        :param pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs'] machine_label_selector: Machine label selector
        """
        if file_sources is not None:
            pulumi.set(__self__, "file_sources", file_sources)
        if machine_label_selector is not None:
            pulumi.set(__self__, "machine_label_selector", machine_label_selector)

    @property
    @pulumi.getter(name="fileSources")
    def file_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceArgs']]]]:
        """
        File sources
        """
        return pulumi.get(self, "file_sources")

    @file_sources.setter
    def file_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceArgs']]]]):
        pulumi.set(self, "file_sources", value)

    @property
    @pulumi.getter(name="machineLabelSelector")
    def machine_label_selector(self) -> Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs']]:
        """
        Machine label selector
        """
        return pulumi.get(self, "machine_label_selector")

    @machine_label_selector.setter
    def machine_label_selector(self, value: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs']]):
        pulumi.set(self, "machine_label_selector", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileFileSourceArgsDict(TypedDict):
        configmap: NotRequired[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgsDict']]
        """
        The configmap which is the source of files
        """
        secret: NotRequired[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgsDict']]
        """
        The secret which is the source of files
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileFileSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceArgs:
    def __init__(__self__, *,
                 configmap: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs']] = None,
                 secret: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs']] = None):
        """
        :param pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs'] configmap: The configmap which is the source of files
        :param pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs'] secret: The secret which is the source of files
        """
        if configmap is not None:
            pulumi.set(__self__, "configmap", configmap)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @property
    @pulumi.getter
    def configmap(self) -> Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs']]:
        """
        The configmap which is the source of files
        """
        return pulumi.get(self, "configmap")

    @configmap.setter
    def configmap(self, value: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs']]):
        pulumi.set(self, "configmap", value)

    @property
    @pulumi.getter
    def secret(self) -> Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs']]:
        """
        The secret which is the source of files
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: Optional[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs']]):
        pulumi.set(self, "secret", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the cluster.
        """
        default_permissions: NotRequired[pulumi.Input[str]]
        """
        The default permissions to be applied when they are not set at the item level
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgsDict']]]]
        """
        Items(files) to retrieve from the K8s object
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default_permissions: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[str] default_permissions: The default permissions to be applied when they are not set at the item level
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs']]] items: Items(files) to retrieve from the K8s object
        """
        pulumi.set(__self__, "name", name)
        if default_permissions is not None:
            pulumi.set(__self__, "default_permissions", default_permissions)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultPermissions")
    def default_permissions(self) -> Optional[pulumi.Input[str]]:
        """
        The default permissions to be applied when they are not set at the item level
        """
        return pulumi.get(self, "default_permissions")

    @default_permissions.setter
    def default_permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_permissions", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs']]]]:
        """
        Items(files) to retrieve from the K8s object
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the item(file) to retrieve
        """
        path: pulumi.Input[str]
        """
        The path to put the file in the target node
        """
        dynamic: NotRequired[pulumi.Input[bool]]
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        hash: NotRequired[pulumi.Input[str]]
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        permissions: NotRequired[pulumi.Input[str]]
        """
        The numeric representation of the file permissions
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 path: pulumi.Input[str],
                 dynamic: Optional[pulumi.Input[bool]] = None,
                 hash: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the item(file) to retrieve
        :param pulumi.Input[str] path: The path to put the file in the target node
        :param pulumi.Input[bool] dynamic: If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        :param pulumi.Input[str] hash: The base64 encoded value of the SHA256 checksum of the file's content
        :param pulumi.Input[str] permissions: The numeric representation of the file permissions
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the item(file) to retrieve
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to put the file in the target node
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input[bool]]:
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic", value)

    @property
    @pulumi.getter
    def hash(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[str]]:
        """
        The numeric representation of the file permissions
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the cluster.
        """
        default_permissions: NotRequired[pulumi.Input[str]]
        """
        The default permissions to be applied when they are not set at the item level
        """
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgsDict']]]]
        """
        Items(files) to retrieve from the K8s object
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default_permissions: Optional[pulumi.Input[str]] = None,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the cluster.
        :param pulumi.Input[str] default_permissions: The default permissions to be applied when they are not set at the item level
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs']]] items: Items(files) to retrieve from the K8s object
        """
        pulumi.set(__self__, "name", name)
        if default_permissions is not None:
            pulumi.set(__self__, "default_permissions", default_permissions)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultPermissions")
    def default_permissions(self) -> Optional[pulumi.Input[str]]:
        """
        The default permissions to be applied when they are not set at the item level
        """
        return pulumi.get(self, "default_permissions")

    @default_permissions.setter
    def default_permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_permissions", value)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs']]]]:
        """
        Items(files) to retrieve from the K8s object
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs']]]]):
        pulumi.set(self, "items", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the item(file) to retrieve
        """
        path: pulumi.Input[str]
        """
        The path to put the file in the target node
        """
        dynamic: NotRequired[pulumi.Input[bool]]
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        hash: NotRequired[pulumi.Input[str]]
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        permissions: NotRequired[pulumi.Input[str]]
        """
        The numeric representation of the file permissions
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 path: pulumi.Input[str],
                 dynamic: Optional[pulumi.Input[bool]] = None,
                 hash: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The key of the item(file) to retrieve
        :param pulumi.Input[str] path: The path to put the file in the target node
        :param pulumi.Input[bool] dynamic: If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        :param pulumi.Input[str] hash: The base64 encoded value of the SHA256 checksum of the file's content
        :param pulumi.Input[str] permissions: The numeric representation of the file permissions
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the item(file) to retrieve
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The path to put the file in the target node
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input[bool]]:
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic", value)

    @property
    @pulumi.getter
    def hash(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        return pulumi.get(self, "hash")

    @hash.setter
    def hash(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input[str]]:
        """
        The numeric representation of the file permissions
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "permissions", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgsDict(TypedDict):
        match_expressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgsDict']]]]
        """
        Label selector match expressions
        """
        match_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Label selector match labels
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs:
    def __init__(__self__, *,
                 match_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs']]]] = None,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs']]] match_expressions: Label selector match expressions
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] match_labels: Label selector match labels
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs']]]]:
        """
        Label selector match expressions
        """
        return pulumi.get(self, "match_expressions")

    @match_expressions.setter
    def match_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs']]]]):
        pulumi.set(self, "match_expressions", value)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Label selector match labels
        """
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


if not MYPY:
    class ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        Label selector requirement key
        """
        operator: NotRequired[pulumi.Input[str]]
        """
        Label selector operator
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Label selector requirement values
        """
elif False:
    ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 operator: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] key: Label selector requirement key
        :param pulumi.Input[str] operator: Label selector operator
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Label selector requirement values
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector requirement key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Label selector operator
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Label selector requirement values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class ClusterV2RkeConfigRegistriesArgsDict(TypedDict):
        configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesConfigArgsDict']]]]
        """
        Registry config
        """
        mirrors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesMirrorArgsDict']]]]
        """
        Registry mirrors
        """
elif False:
    ClusterV2RkeConfigRegistriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigRegistriesArgs:
    def __init__(__self__, *,
                 configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesConfigArgs']]]] = None,
                 mirrors: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesMirrorArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesConfigArgs']]] configs: Registry config
        :param pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesMirrorArgs']]] mirrors: Registry mirrors
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)

    @property
    @pulumi.getter
    def configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesConfigArgs']]]]:
        """
        Registry config
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesConfigArgs']]]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter
    def mirrors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesMirrorArgs']]]]:
        """
        Registry mirrors
        """
        return pulumi.get(self, "mirrors")

    @mirrors.setter
    def mirrors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterV2RkeConfigRegistriesMirrorArgs']]]]):
        pulumi.set(self, "mirrors", value)


if not MYPY:
    class ClusterV2RkeConfigRegistriesConfigArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        Registry hostname
        """
        auth_config_secret_name: NotRequired[pulumi.Input[str]]
        """
        Registry auth config secret name
        """
        ca_bundle: NotRequired[pulumi.Input[str]]
        """
        Registry CA bundle
        """
        insecure: NotRequired[pulumi.Input[bool]]
        """
        Registry insecure connectivity
        """
        tls_secret_name: NotRequired[pulumi.Input[str]]
        """
        Registry TLS secret name. TLS is a pair of Cert/Key
        """
elif False:
    ClusterV2RkeConfigRegistriesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigRegistriesConfigArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 auth_config_secret_name: Optional[pulumi.Input[str]] = None,
                 ca_bundle: Optional[pulumi.Input[str]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 tls_secret_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: Registry hostname
        :param pulumi.Input[str] auth_config_secret_name: Registry auth config secret name
        :param pulumi.Input[str] ca_bundle: Registry CA bundle
        :param pulumi.Input[bool] insecure: Registry insecure connectivity
        :param pulumi.Input[str] tls_secret_name: Registry TLS secret name. TLS is a pair of Cert/Key
        """
        pulumi.set(__self__, "hostname", hostname)
        if auth_config_secret_name is not None:
            pulumi.set(__self__, "auth_config_secret_name", auth_config_secret_name)
        if ca_bundle is not None:
            pulumi.set(__self__, "ca_bundle", ca_bundle)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if tls_secret_name is not None:
            pulumi.set(__self__, "tls_secret_name", tls_secret_name)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Registry hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter(name="authConfigSecretName")
    def auth_config_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Registry auth config secret name
        """
        return pulumi.get(self, "auth_config_secret_name")

    @auth_config_secret_name.setter
    def auth_config_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_config_secret_name", value)

    @property
    @pulumi.getter(name="caBundle")
    def ca_bundle(self) -> Optional[pulumi.Input[str]]:
        """
        Registry CA bundle
        """
        return pulumi.get(self, "ca_bundle")

    @ca_bundle.setter
    def ca_bundle(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_bundle", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Registry insecure connectivity
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="tlsSecretName")
    def tls_secret_name(self) -> Optional[pulumi.Input[str]]:
        """
        Registry TLS secret name. TLS is a pair of Cert/Key
        """
        return pulumi.get(self, "tls_secret_name")

    @tls_secret_name.setter
    def tls_secret_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_secret_name", value)


if not MYPY:
    class ClusterV2RkeConfigRegistriesMirrorArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        Registry hostname
        """
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Registry mirror endpoints
        """
        rewrites: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Registry mirror rewrites
        """
elif False:
    ClusterV2RkeConfigRegistriesMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigRegistriesMirrorArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 rewrites: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] hostname: Registry hostname
        :param pulumi.Input[Sequence[pulumi.Input[str]]] endpoints: Registry mirror endpoints
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] rewrites: Registry mirror rewrites
        """
        pulumi.set(__self__, "hostname", hostname)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if rewrites is not None:
            pulumi.set(__self__, "rewrites", rewrites)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Registry hostname
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Registry mirror endpoints
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def rewrites(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Registry mirror rewrites
        """
        return pulumi.get(self, "rewrites")

    @rewrites.setter
    def rewrites(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "rewrites", value)


if not MYPY:
    class ClusterV2RkeConfigRotateCertificatesArgsDict(TypedDict):
        generation: pulumi.Input[int]
        """
        Desired certificate rotation generation.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Service certificates to rotate with this generation.
        """
elif False:
    ClusterV2RkeConfigRotateCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigRotateCertificatesArgs:
    def __init__(__self__, *,
                 generation: pulumi.Input[int],
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] generation: Desired certificate rotation generation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: Service certificates to rotate with this generation.
        """
        pulumi.set(__self__, "generation", generation)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @property
    @pulumi.getter
    def generation(self) -> pulumi.Input[int]:
        """
        Desired certificate rotation generation.
        """
        return pulumi.get(self, "generation")

    @generation.setter
    def generation(self, value: pulumi.Input[int]):
        pulumi.set(self, "generation", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Service certificates to rotate with this generation.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class ClusterV2RkeConfigUpgradeStrategyArgsDict(TypedDict):
        control_plane_concurrency: NotRequired[pulumi.Input[str]]
        """
        How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        """
        control_plane_drain_options: NotRequired[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgsDict']]
        """
        Controlplane nodes drain options
        """
        worker_concurrency: NotRequired[pulumi.Input[str]]
        """
        How many worker nodes should be upgrade at time
        """
        worker_drain_options: NotRequired[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgsDict']]
        """
        Worker nodes drain options
        """
elif False:
    ClusterV2RkeConfigUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigUpgradeStrategyArgs:
    def __init__(__self__, *,
                 control_plane_concurrency: Optional[pulumi.Input[str]] = None,
                 control_plane_drain_options: Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs']] = None,
                 worker_concurrency: Optional[pulumi.Input[str]] = None,
                 worker_drain_options: Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs']] = None):
        """
        :param pulumi.Input[str] control_plane_concurrency: How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        :param pulumi.Input['ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs'] control_plane_drain_options: Controlplane nodes drain options
        :param pulumi.Input[str] worker_concurrency: How many worker nodes should be upgrade at time
        :param pulumi.Input['ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs'] worker_drain_options: Worker nodes drain options
        """
        if control_plane_concurrency is not None:
            pulumi.set(__self__, "control_plane_concurrency", control_plane_concurrency)
        if control_plane_drain_options is not None:
            pulumi.set(__self__, "control_plane_drain_options", control_plane_drain_options)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)
        if worker_drain_options is not None:
            pulumi.set(__self__, "worker_drain_options", worker_drain_options)

    @property
    @pulumi.getter(name="controlPlaneConcurrency")
    def control_plane_concurrency(self) -> Optional[pulumi.Input[str]]:
        """
        How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        """
        return pulumi.get(self, "control_plane_concurrency")

    @control_plane_concurrency.setter
    def control_plane_concurrency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_concurrency", value)

    @property
    @pulumi.getter(name="controlPlaneDrainOptions")
    def control_plane_drain_options(self) -> Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs']]:
        """
        Controlplane nodes drain options
        """
        return pulumi.get(self, "control_plane_drain_options")

    @control_plane_drain_options.setter
    def control_plane_drain_options(self, value: Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs']]):
        pulumi.set(self, "control_plane_drain_options", value)

    @property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[pulumi.Input[str]]:
        """
        How many worker nodes should be upgrade at time
        """
        return pulumi.get(self, "worker_concurrency")

    @worker_concurrency.setter
    def worker_concurrency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "worker_concurrency", value)

    @property
    @pulumi.getter(name="workerDrainOptions")
    def worker_drain_options(self) -> Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs']]:
        """
        Worker nodes drain options
        """
        return pulumi.get(self, "worker_drain_options")

    @worker_drain_options.setter
    def worker_drain_options(self, value: Optional[pulumi.Input['ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs']]):
        pulumi.set(self, "worker_drain_options", value)


if not MYPY:
    class ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgsDict(TypedDict):
        delete_empty_dir_data: NotRequired[pulumi.Input[bool]]
        """
        Drain options delete empty dir data
        """
        disable_eviction: NotRequired[pulumi.Input[bool]]
        """
        Drain options disable eviction
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Drain options enabled?
        """
        force: NotRequired[pulumi.Input[bool]]
        """
        Drain options force
        """
        grace_period: NotRequired[pulumi.Input[int]]
        """
        Drain options grace period
        """
        ignore_daemon_sets: NotRequired[pulumi.Input[bool]]
        """
        Drain options ignore daemon sets
        """
        ignore_errors: NotRequired[pulumi.Input[bool]]
        """
        Drain options ignore errors
        """
        skip_wait_for_delete_timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Drain options skip wait for delete timeout seconds
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        Drain options timeout
        """
elif False:
    ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs:
    def __init__(__self__, *,
                 delete_empty_dir_data: Optional[pulumi.Input[bool]] = None,
                 disable_eviction: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 force: Optional[pulumi.Input[bool]] = None,
                 grace_period: Optional[pulumi.Input[int]] = None,
                 ignore_daemon_sets: Optional[pulumi.Input[bool]] = None,
                 ignore_errors: Optional[pulumi.Input[bool]] = None,
                 skip_wait_for_delete_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] delete_empty_dir_data: Drain options delete empty dir data
        :param pulumi.Input[bool] disable_eviction: Drain options disable eviction
        :param pulumi.Input[bool] enabled: Drain options enabled?
        :param pulumi.Input[bool] force: Drain options force
        :param pulumi.Input[int] grace_period: Drain options grace period
        :param pulumi.Input[bool] ignore_daemon_sets: Drain options ignore daemon sets
        :param pulumi.Input[bool] ignore_errors: Drain options ignore errors
        :param pulumi.Input[int] skip_wait_for_delete_timeout_seconds: Drain options skip wait for delete timeout seconds
        :param pulumi.Input[int] timeout: Drain options timeout
        """
        if delete_empty_dir_data is not None:
            pulumi.set(__self__, "delete_empty_dir_data", delete_empty_dir_data)
        if disable_eviction is not None:
            pulumi.set(__self__, "disable_eviction", disable_eviction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if ignore_errors is not None:
            pulumi.set(__self__, "ignore_errors", ignore_errors)
        if skip_wait_for_delete_timeout_seconds is not None:
            pulumi.set(__self__, "skip_wait_for_delete_timeout_seconds", skip_wait_for_delete_timeout_seconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="deleteEmptyDirData")
    def delete_empty_dir_data(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options delete empty dir data
        """
        return pulumi.get(self, "delete_empty_dir_data")

    @delete_empty_dir_data.setter
    def delete_empty_dir_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_empty_dir_data", value)

    @property
    @pulumi.getter(name="disableEviction")
    def disable_eviction(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options disable eviction
        """
        return pulumi.get(self, "disable_eviction")

    @disable_eviction.setter
    def disable_eviction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_eviction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options force
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        """
        Drain options grace period
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options ignore daemon sets
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @ignore_daemon_sets.setter
    def ignore_daemon_sets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_daemon_sets", value)

    @property
    @pulumi.getter(name="ignoreErrors")
    def ignore_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options ignore errors
        """
        return pulumi.get(self, "ignore_errors")

    @ignore_errors.setter
    def ignore_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors", value)

    @property
    @pulumi.getter(name="skipWaitForDeleteTimeoutSeconds")
    def skip_wait_for_delete_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Drain options skip wait for delete timeout seconds
        """
        return pulumi.get(self, "skip_wait_for_delete_timeout_seconds")

    @skip_wait_for_delete_timeout_seconds.setter
    def skip_wait_for_delete_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_wait_for_delete_timeout_seconds", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Drain options timeout
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgsDict(TypedDict):
        delete_empty_dir_data: NotRequired[pulumi.Input[bool]]
        """
        Drain options delete empty dir data
        """
        disable_eviction: NotRequired[pulumi.Input[bool]]
        """
        Drain options disable eviction
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Drain options enabled?
        """
        force: NotRequired[pulumi.Input[bool]]
        """
        Drain options force
        """
        grace_period: NotRequired[pulumi.Input[int]]
        """
        Drain options grace period
        """
        ignore_daemon_sets: NotRequired[pulumi.Input[bool]]
        """
        Drain options ignore daemon sets
        """
        ignore_errors: NotRequired[pulumi.Input[bool]]
        """
        Drain options ignore errors
        """
        skip_wait_for_delete_timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        Drain options skip wait for delete timeout seconds
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        Drain options timeout
        """
elif False:
    ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs:
    def __init__(__self__, *,
                 delete_empty_dir_data: Optional[pulumi.Input[bool]] = None,
                 disable_eviction: Optional[pulumi.Input[bool]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 force: Optional[pulumi.Input[bool]] = None,
                 grace_period: Optional[pulumi.Input[int]] = None,
                 ignore_daemon_sets: Optional[pulumi.Input[bool]] = None,
                 ignore_errors: Optional[pulumi.Input[bool]] = None,
                 skip_wait_for_delete_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] delete_empty_dir_data: Drain options delete empty dir data
        :param pulumi.Input[bool] disable_eviction: Drain options disable eviction
        :param pulumi.Input[bool] enabled: Drain options enabled?
        :param pulumi.Input[bool] force: Drain options force
        :param pulumi.Input[int] grace_period: Drain options grace period
        :param pulumi.Input[bool] ignore_daemon_sets: Drain options ignore daemon sets
        :param pulumi.Input[bool] ignore_errors: Drain options ignore errors
        :param pulumi.Input[int] skip_wait_for_delete_timeout_seconds: Drain options skip wait for delete timeout seconds
        :param pulumi.Input[int] timeout: Drain options timeout
        """
        if delete_empty_dir_data is not None:
            pulumi.set(__self__, "delete_empty_dir_data", delete_empty_dir_data)
        if disable_eviction is not None:
            pulumi.set(__self__, "disable_eviction", disable_eviction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if ignore_errors is not None:
            pulumi.set(__self__, "ignore_errors", ignore_errors)
        if skip_wait_for_delete_timeout_seconds is not None:
            pulumi.set(__self__, "skip_wait_for_delete_timeout_seconds", skip_wait_for_delete_timeout_seconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="deleteEmptyDirData")
    def delete_empty_dir_data(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options delete empty dir data
        """
        return pulumi.get(self, "delete_empty_dir_data")

    @delete_empty_dir_data.setter
    def delete_empty_dir_data(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_empty_dir_data", value)

    @property
    @pulumi.getter(name="disableEviction")
    def disable_eviction(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options disable eviction
        """
        return pulumi.get(self, "disable_eviction")

    @disable_eviction.setter
    def disable_eviction(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_eviction", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options enabled?
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def force(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options force
        """
        return pulumi.get(self, "force")

    @force.setter
    def force(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force", value)

    @property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[pulumi.Input[int]]:
        """
        Drain options grace period
        """
        return pulumi.get(self, "grace_period")

    @grace_period.setter
    def grace_period(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "grace_period", value)

    @property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options ignore daemon sets
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @ignore_daemon_sets.setter
    def ignore_daemon_sets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_daemon_sets", value)

    @property
    @pulumi.getter(name="ignoreErrors")
    def ignore_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Drain options ignore errors
        """
        return pulumi.get(self, "ignore_errors")

    @ignore_errors.setter
    def ignore_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_errors", value)

    @property
    @pulumi.getter(name="skipWaitForDeleteTimeoutSeconds")
    def skip_wait_for_delete_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Drain options skip wait for delete timeout seconds
        """
        return pulumi.get(self, "skip_wait_for_delete_timeout_seconds")

    @skip_wait_for_delete_timeout_seconds.setter
    def skip_wait_for_delete_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_wait_for_delete_timeout_seconds", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Drain options timeout
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class EtcdBackupBackupConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable etcd backup (bool)
        """
        interval_hours: NotRequired[pulumi.Input[int]]
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        retention: NotRequired[pulumi.Input[int]]
        """
        Retention for etcd backup. Default `6` (int)
        """
        s3_backup_config: NotRequired[pulumi.Input['EtcdBackupBackupConfigS3BackupConfigArgsDict']]
        """
        S3 config options for etcd backup. Valid for `imported` and `rke` clusters. (list maxitems:1)
        """
        safe_timestamp: NotRequired[pulumi.Input[bool]]
        timeout: NotRequired[pulumi.Input[int]]
elif False:
    EtcdBackupBackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EtcdBackupBackupConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 interval_hours: Optional[pulumi.Input[int]] = None,
                 retention: Optional[pulumi.Input[int]] = None,
                 s3_backup_config: Optional[pulumi.Input['EtcdBackupBackupConfigS3BackupConfigArgs']] = None,
                 safe_timestamp: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable etcd backup (bool)
        :param pulumi.Input[int] interval_hours: Interval hours for etcd backup. Default `12` (int)
        :param pulumi.Input[int] retention: Retention for etcd backup. Default `6` (int)
        :param pulumi.Input['EtcdBackupBackupConfigS3BackupConfigArgs'] s3_backup_config: S3 config options for etcd backup. Valid for `imported` and `rke` clusters. (list maxitems:1)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable etcd backup (bool)
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[pulumi.Input[int]]:
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        return pulumi.get(self, "interval_hours")

    @interval_hours.setter
    def interval_hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval_hours", value)

    @property
    @pulumi.getter
    def retention(self) -> Optional[pulumi.Input[int]]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @retention.setter
    def retention(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "retention", value)

    @property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional[pulumi.Input['EtcdBackupBackupConfigS3BackupConfigArgs']]:
        """
        S3 config options for etcd backup. Valid for `imported` and `rke` clusters. (list maxitems:1)
        """
        return pulumi.get(self, "s3_backup_config")

    @s3_backup_config.setter
    def s3_backup_config(self, value: Optional[pulumi.Input['EtcdBackupBackupConfigS3BackupConfigArgs']]):
        pulumi.set(self, "s3_backup_config", value)

    @property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "safe_timestamp")

    @safe_timestamp.setter
    def safe_timestamp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "safe_timestamp", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class EtcdBackupBackupConfigS3BackupConfigArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        Bucket name for S3 service (string)
        """
        endpoint: pulumi.Input[str]
        """
        Endpoint for S3 service (string)
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Access key for S3 service (string)
        """
        custom_ca: NotRequired[pulumi.Input[str]]
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        folder: NotRequired[pulumi.Input[str]]
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Region for S3 service (string)
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Secret key for S3 service (string)
        """
elif False:
    EtcdBackupBackupConfigS3BackupConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EtcdBackupBackupConfigS3BackupConfigArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 custom_ca: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: Bucket name for S3 service (string)
        :param pulumi.Input[str] endpoint: Endpoint for S3 service (string)
        :param pulumi.Input[str] access_key: Access key for S3 service (string)
        :param pulumi.Input[str] custom_ca: Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        :param pulumi.Input[str] folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param pulumi.Input[str] region: Region for S3 service (string)
        :param pulumi.Input[str] secret_key: Secret key for S3 service (string)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Bucket name for S3 service (string)
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Endpoint for S3 service (string)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Access key for S3 service (string)
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[pulumi.Input[str]]:
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        return pulumi.get(self, "custom_ca")

    @custom_ca.setter
    def custom_ca(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_ca", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Secret key for S3 service (string)
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class GlobalRoleRuleArgsDict(TypedDict):
        api_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule api groups
        """
        non_resource_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule non resource urls
        """
        resource_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule resource names
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule resources
        """
        verbs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule verbs
        """
elif False:
    GlobalRoleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalRoleRuleArgs:
    def __init__(__self__, *,
                 api_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 non_resource_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verbs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] api_groups: Policy rule api groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_resource_urls: Policy rule non resource urls
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_names: Policy rule resource names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resources: Policy rule resources
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @api_groups.setter
    def api_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "api_groups", value)

    @property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @non_resource_urls.setter
    def non_resource_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_resource_urls", value)

    @property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @resource_names.setter
    def resource_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_names", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def verbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")

    @verbs.setter
    def verbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verbs", value)


if not MYPY:
    class MachineConfigV2Amazonec2ConfigArgsDict(TypedDict):
        ami: pulumi.Input[str]
        """
        AWS machine image
        """
        region: pulumi.Input[str]
        """
        AWS Region
        """
        security_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        AWS VPC security group
        """
        subnet_id: pulumi.Input[str]
        """
        AWS VPC subnet id
        """
        vpc_id: pulumi.Input[str]
        """
        AWS VPC id
        """
        zone: pulumi.Input[str]
        """
        AWS zone for instance (i.e. a,b,c,d,e)
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        AWS Access Key
        """
        block_duration_minutes: NotRequired[pulumi.Input[str]]
        """
        AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        AWS root device name
        """
        encrypt_ebs_volume: NotRequired[pulumi.Input[bool]]
        """
        Encrypt EBS volume
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Optional endpoint URL (hostname only or fully qualified URI)
        """
        http_endpoint: NotRequired[pulumi.Input[str]]
        """
        Enables or disables the HTTP metadata endpoint on your instances
        """
        http_tokens: NotRequired[pulumi.Input[str]]
        """
        The state of token usage for your instance metadata requests
        """
        iam_instance_profile: NotRequired[pulumi.Input[str]]
        """
        AWS IAM Instance Profile
        """
        insecure_transport: NotRequired[pulumi.Input[bool]]
        """
        Disable SSL when sending requests
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        AWS instance type
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        Custom KMS key ID using the AWS Managed CMK
        """
        monitoring: NotRequired[pulumi.Input[bool]]
        """
        Set this flag to enable CloudWatch monitoring
        """
        open_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Make the specified port number accessible from the Internet
        """
        private_address_only: NotRequired[pulumi.Input[bool]]
        """
        Only use a private IP address
        """
        request_spot_instance: NotRequired[pulumi.Input[bool]]
        """
        Set this flag to request spot instance
        """
        retries: NotRequired[pulumi.Input[str]]
        """
        Set retry count for recoverable failures (use -1 to disable)
        """
        root_size: NotRequired[pulumi.Input[str]]
        """
        AWS root disk size (in GB)
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        AWS Secret Key
        """
        security_group_readonly: NotRequired[pulumi.Input[bool]]
        """
        Skip adding default rules to security groups
        """
        session_token: NotRequired[pulumi.Input[str]]
        """
        AWS Session Token
        """
        spot_price: NotRequired[pulumi.Input[str]]
        """
        AWS spot instance bid price (in dollar)
        """
        ssh_key_contents: NotRequired[pulumi.Input[str]]
        """
        SSH Key file contents for sshKeyContents
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        Set the name of the ssh user
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        AWS Tags (e.g. key1,value1,key2,value2)
        """
        use_ebs_optimized_instance: NotRequired[pulumi.Input[bool]]
        """
        Create an EBS optimized instance
        """
        use_private_address: NotRequired[pulumi.Input[bool]]
        """
        Force the usage of private IP address
        """
        userdata: NotRequired[pulumi.Input[str]]
        """
        Path to file with cloud-init user data
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        Amazon EBS volume type
        """
elif False:
    MachineConfigV2Amazonec2ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2Amazonec2ConfigArgs:
    def __init__(__self__, *,
                 ami: pulumi.Input[str],
                 region: pulumi.Input[str],
                 security_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_id: pulumi.Input[str],
                 vpc_id: pulumi.Input[str],
                 zone: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 block_duration_minutes: Optional[pulumi.Input[str]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypt_ebs_volume: Optional[pulumi.Input[bool]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None,
                 iam_instance_profile: Optional[pulumi.Input[str]] = None,
                 insecure_transport: Optional[pulumi.Input[bool]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 open_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_address_only: Optional[pulumi.Input[bool]] = None,
                 request_spot_instance: Optional[pulumi.Input[bool]] = None,
                 retries: Optional[pulumi.Input[str]] = None,
                 root_size: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 security_group_readonly: Optional[pulumi.Input[bool]] = None,
                 session_token: Optional[pulumi.Input[str]] = None,
                 spot_price: Optional[pulumi.Input[str]] = None,
                 ssh_key_contents: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 use_ebs_optimized_instance: Optional[pulumi.Input[bool]] = None,
                 use_private_address: Optional[pulumi.Input[bool]] = None,
                 userdata: Optional[pulumi.Input[str]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ami: AWS machine image
        :param pulumi.Input[str] region: AWS Region
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: AWS VPC security group
        :param pulumi.Input[str] subnet_id: AWS VPC subnet id
        :param pulumi.Input[str] vpc_id: AWS VPC id
        :param pulumi.Input[str] zone: AWS zone for instance (i.e. a,b,c,d,e)
        :param pulumi.Input[str] access_key: AWS Access Key
        :param pulumi.Input[str] block_duration_minutes: AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        :param pulumi.Input[str] device_name: AWS root device name
        :param pulumi.Input[bool] encrypt_ebs_volume: Encrypt EBS volume
        :param pulumi.Input[str] endpoint: Optional endpoint URL (hostname only or fully qualified URI)
        :param pulumi.Input[str] http_endpoint: Enables or disables the HTTP metadata endpoint on your instances
        :param pulumi.Input[str] http_tokens: The state of token usage for your instance metadata requests
        :param pulumi.Input[str] iam_instance_profile: AWS IAM Instance Profile
        :param pulumi.Input[bool] insecure_transport: Disable SSL when sending requests
        :param pulumi.Input[str] instance_type: AWS instance type
        :param pulumi.Input[str] kms_key: Custom KMS key ID using the AWS Managed CMK
        :param pulumi.Input[bool] monitoring: Set this flag to enable CloudWatch monitoring
        :param pulumi.Input[Sequence[pulumi.Input[str]]] open_ports: Make the specified port number accessible from the Internet
        :param pulumi.Input[bool] private_address_only: Only use a private IP address
        :param pulumi.Input[bool] request_spot_instance: Set this flag to request spot instance
        :param pulumi.Input[str] retries: Set retry count for recoverable failures (use -1 to disable)
        :param pulumi.Input[str] root_size: AWS root disk size (in GB)
        :param pulumi.Input[str] secret_key: AWS Secret Key
        :param pulumi.Input[bool] security_group_readonly: Skip adding default rules to security groups
        :param pulumi.Input[str] session_token: AWS Session Token
        :param pulumi.Input[str] spot_price: AWS spot instance bid price (in dollar)
        :param pulumi.Input[str] ssh_key_contents: SSH Key file contents for sshKeyContents
        :param pulumi.Input[str] ssh_user: Set the name of the ssh user
        :param pulumi.Input[str] tags: AWS Tags (e.g. key1,value1,key2,value2)
        :param pulumi.Input[bool] use_ebs_optimized_instance: Create an EBS optimized instance
        :param pulumi.Input[bool] use_private_address: Force the usage of private IP address
        :param pulumi.Input[str] userdata: Path to file with cloud-init user data
        :param pulumi.Input[str] volume_type: Amazon EBS volume type
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone", zone)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypt_ebs_volume is not None:
            pulumi.set(__self__, "encrypt_ebs_volume", encrypt_ebs_volume)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if insecure_transport is not None:
            pulumi.set(__self__, "insecure_transport", insecure_transport)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if private_address_only is not None:
            pulumi.set(__self__, "private_address_only", private_address_only)
        if request_spot_instance is not None:
            pulumi.set(__self__, "request_spot_instance", request_spot_instance)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if security_group_readonly is not None:
            pulumi.set(__self__, "security_group_readonly", security_group_readonly)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if ssh_key_contents is not None:
            pulumi.set(__self__, "ssh_key_contents", ssh_key_contents)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_ebs_optimized_instance is not None:
            pulumi.set(__self__, "use_ebs_optimized_instance", use_ebs_optimized_instance)
        if use_private_address is not None:
            pulumi.set(__self__, "use_private_address", use_private_address)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def ami(self) -> pulumi.Input[str]:
        """
        AWS machine image
        """
        return pulumi.get(self, "ami")

    @ami.setter
    def ami(self, value: pulumi.Input[str]):
        pulumi.set(self, "ami", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        AWS VPC security group
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        AWS VPC subnet id
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        """
        AWS VPC id
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        AWS zone for instance (i.e. a,b,c,d,e)
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[str]]:
        """
        AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        """
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_duration_minutes", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS root device name
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="encryptEbsVolume")
    def encrypt_ebs_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Encrypt EBS volume
        """
        return pulumi.get(self, "encrypt_ebs_volume")

    @encrypt_ebs_volume.setter
    def encrypt_ebs_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypt_ebs_volume", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Optional endpoint URL (hostname only or fully qualified URI)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Enables or disables the HTTP metadata endpoint on your instances
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        The state of token usage for your instance metadata requests
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[pulumi.Input[str]]:
        """
        AWS IAM Instance Profile
        """
        return pulumi.get(self, "iam_instance_profile")

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_instance_profile", value)

    @property
    @pulumi.getter(name="insecureTransport")
    def insecure_transport(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable SSL when sending requests
        """
        return pulumi.get(self, "insecure_transport")

    @insecure_transport.setter
    def insecure_transport(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_transport", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        AWS instance type
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        Custom KMS key ID using the AWS Managed CMK
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this flag to enable CloudWatch monitoring
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @open_ports.setter
    def open_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "open_ports", value)

    @property
    @pulumi.getter(name="privateAddressOnly")
    def private_address_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Only use a private IP address
        """
        return pulumi.get(self, "private_address_only")

    @private_address_only.setter
    def private_address_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_address_only", value)

    @property
    @pulumi.getter(name="requestSpotInstance")
    def request_spot_instance(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this flag to request spot instance
        """
        return pulumi.get(self, "request_spot_instance")

    @request_spot_instance.setter
    def request_spot_instance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "request_spot_instance", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[str]]:
        """
        Set retry count for recoverable failures (use -1 to disable)
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[str]]:
        """
        AWS root disk size (in GB)
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_size", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="securityGroupReadonly")
    def security_group_readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip adding default rules to security groups
        """
        return pulumi.get(self, "security_group_readonly")

    @security_group_readonly.setter
    def security_group_readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "security_group_readonly", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Session Token
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_token", value)

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[str]]:
        """
        AWS spot instance bid price (in dollar)
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_price", value)

    @property
    @pulumi.getter(name="sshKeyContents")
    def ssh_key_contents(self) -> Optional[pulumi.Input[str]]:
        """
        SSH Key file contents for sshKeyContents
        """
        return pulumi.get(self, "ssh_key_contents")

    @ssh_key_contents.setter
    def ssh_key_contents(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_contents", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        Set the name of the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Tags (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="useEbsOptimizedInstance")
    def use_ebs_optimized_instance(self) -> Optional[pulumi.Input[bool]]:
        """
        Create an EBS optimized instance
        """
        return pulumi.get(self, "use_ebs_optimized_instance")

    @use_ebs_optimized_instance.setter
    def use_ebs_optimized_instance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ebs_optimized_instance", value)

    @property
    @pulumi.getter(name="usePrivateAddress")
    def use_private_address(self) -> Optional[pulumi.Input[bool]]:
        """
        Force the usage of private IP address
        """
        return pulumi.get(self, "use_private_address")

    @use_private_address.setter
    def use_private_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_private_address", value)

    @property
    @pulumi.getter
    def userdata(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with cloud-init user data
        """
        return pulumi.get(self, "userdata")

    @userdata.setter
    def userdata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userdata", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon EBS volume type
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class MachineConfigV2AzureConfigArgsDict(TypedDict):
        accelerated_networking: NotRequired[pulumi.Input[bool]]
        """
        Use Accelerated Networking when creating a network interface for the Azure VM
        """
        availability_set: NotRequired[pulumi.Input[str]]
        """
        Azure Availability Set to place the virtual machine into
        """
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        The Availability Zone that the Azure VM should be created in
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Azure Service Principal Account ID (optional, browser auth is used if not specified)
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Azure Service Principal Account password (optional, browser auth is used if not specified)
        """
        custom_data: NotRequired[pulumi.Input[str]]
        """
        Path to file with custom-data
        """
        disk_size: NotRequired[pulumi.Input[str]]
        """
        Disk size if using managed disk
        """
        dns: NotRequired[pulumi.Input[str]]
        """
        A unique DNS label for the public IP adddress
        """
        docker_port: NotRequired[pulumi.Input[str]]
        """
        Port number for Docker engine
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        fault_domain_count: NotRequired[pulumi.Input[str]]
        """
        Fault domain count to use for availability set
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Azure virtual machine OS image
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Azure region to create the virtual machine
        """
        managed_disks: NotRequired[pulumi.Input[bool]]
        """
        Configures VM and availability set for managed disks
        """
        no_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Do not create a public IP address for the machine
        """
        nsg: NotRequired[pulumi.Input[str]]
        """
        Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        """
        open_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Make the specified port number accessible from the Internet
        """
        private_address_only: NotRequired[pulumi.Input[bool]]
        """
        Only use a private IP address
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        Specify a static private IP address for the machine
        """
        resource_group: NotRequired[pulumi.Input[str]]
        """
        Azure Resource Group name (will be created if missing)
        """
        size: NotRequired[pulumi.Input[str]]
        """
        Size for Azure Virtual Machine
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        Username for SSH login
        """
        static_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Assign a static public IP address to the machine
        """
        storage_type: NotRequired[pulumi.Input[str]]
        """
        Type of Storage Account to host the OS Disk for the machine
        """
        subnet: NotRequired[pulumi.Input[str]]
        """
        Azure Subnet Name to be used within the Virtual Network
        """
        subnet_prefix: NotRequired[pulumi.Input[str]]
        """
        Private CIDR block to be used for the new subnet, should comply RFC 1918
        """
        subscription_id: NotRequired[pulumi.Input[str]]
        """
        Azure Subscription ID
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        Azure Tenant ID
        """
        update_domain_count: NotRequired[pulumi.Input[str]]
        """
        Update domain count to use for availability set
        """
        use_private_ip: NotRequired[pulumi.Input[bool]]
        """
        Use private IP address of the machine to connect
        """
        use_public_ip_standard_sku: NotRequired[pulumi.Input[bool]]
        """
        Use the standard SKU when creating a Public IP for the Azure VM instance
        """
        vnet: NotRequired[pulumi.Input[str]]
        """
        Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
elif False:
    MachineConfigV2AzureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2AzureConfigArgs:
    def __init__(__self__, *,
                 accelerated_networking: Optional[pulumi.Input[bool]] = None,
                 availability_set: Optional[pulumi.Input[str]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 disk_size: Optional[pulumi.Input[str]] = None,
                 dns: Optional[pulumi.Input[str]] = None,
                 docker_port: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 fault_domain_count: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 managed_disks: Optional[pulumi.Input[bool]] = None,
                 no_public_ip: Optional[pulumi.Input[bool]] = None,
                 nsg: Optional[pulumi.Input[str]] = None,
                 open_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_address_only: Optional[pulumi.Input[bool]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 static_public_ip: Optional[pulumi.Input[bool]] = None,
                 storage_type: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None,
                 subnet_prefix: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 update_domain_count: Optional[pulumi.Input[str]] = None,
                 use_private_ip: Optional[pulumi.Input[bool]] = None,
                 use_public_ip_standard_sku: Optional[pulumi.Input[bool]] = None,
                 vnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] accelerated_networking: Use Accelerated Networking when creating a network interface for the Azure VM
        :param pulumi.Input[str] availability_set: Azure Availability Set to place the virtual machine into
        :param pulumi.Input[str] availability_zone: The Availability Zone that the Azure VM should be created in
        :param pulumi.Input[str] client_id: Azure Service Principal Account ID (optional, browser auth is used if not specified)
        :param pulumi.Input[str] client_secret: Azure Service Principal Account password (optional, browser auth is used if not specified)
        :param pulumi.Input[str] custom_data: Path to file with custom-data
        :param pulumi.Input[str] disk_size: Disk size if using managed disk
        :param pulumi.Input[str] dns: A unique DNS label for the public IP adddress
        :param pulumi.Input[str] docker_port: Port number for Docker engine
        :param pulumi.Input[str] environment: Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        :param pulumi.Input[str] fault_domain_count: Fault domain count to use for availability set
        :param pulumi.Input[str] image: Azure virtual machine OS image
        :param pulumi.Input[str] location: Azure region to create the virtual machine
        :param pulumi.Input[bool] managed_disks: Configures VM and availability set for managed disks
        :param pulumi.Input[bool] no_public_ip: Do not create a public IP address for the machine
        :param pulumi.Input[str] nsg: Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] open_ports: Make the specified port number accessible from the Internet
        :param pulumi.Input[bool] private_address_only: Only use a private IP address
        :param pulumi.Input[str] private_ip_address: Specify a static private IP address for the machine
        :param pulumi.Input[str] resource_group: Azure Resource Group name (will be created if missing)
        :param pulumi.Input[str] size: Size for Azure Virtual Machine
        :param pulumi.Input[str] ssh_user: Username for SSH login
        :param pulumi.Input[bool] static_public_ip: Assign a static public IP address to the machine
        :param pulumi.Input[str] storage_type: Type of Storage Account to host the OS Disk for the machine
        :param pulumi.Input[str] subnet: Azure Subnet Name to be used within the Virtual Network
        :param pulumi.Input[str] subnet_prefix: Private CIDR block to be used for the new subnet, should comply RFC 1918
        :param pulumi.Input[str] subscription_id: Azure Subscription ID
        :param pulumi.Input[str] tags: Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        :param pulumi.Input[str] tenant_id: Azure Tenant ID
        :param pulumi.Input[str] update_domain_count: Update domain count to use for availability set
        :param pulumi.Input[bool] use_private_ip: Use private IP address of the machine to connect
        :param pulumi.Input[bool] use_public_ip_standard_sku: Use the standard SKU when creating a Public IP for the Azure VM instance
        :param pulumi.Input[str] vnet: Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if availability_set is not None:
            pulumi.set(__self__, "availability_set", availability_set)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if fault_domain_count is not None:
            pulumi.set(__self__, "fault_domain_count", fault_domain_count)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if managed_disks is not None:
            pulumi.set(__self__, "managed_disks", managed_disks)
        if no_public_ip is not None:
            pulumi.set(__self__, "no_public_ip", no_public_ip)
        if nsg is not None:
            pulumi.set(__self__, "nsg", nsg)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if private_address_only is not None:
            pulumi.set(__self__, "private_address_only", private_address_only)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if static_public_ip is not None:
            pulumi.set(__self__, "static_public_ip", static_public_ip)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_prefix is not None:
            pulumi.set(__self__, "subnet_prefix", subnet_prefix)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if update_domain_count is not None:
            pulumi.set(__self__, "update_domain_count", update_domain_count)
        if use_private_ip is not None:
            pulumi.set(__self__, "use_private_ip", use_private_ip)
        if use_public_ip_standard_sku is not None:
            pulumi.set(__self__, "use_public_ip_standard_sku", use_public_ip_standard_sku)
        if vnet is not None:
            pulumi.set(__self__, "vnet", vnet)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Use Accelerated Networking when creating a network interface for the Azure VM
        """
        return pulumi.get(self, "accelerated_networking")

    @accelerated_networking.setter
    def accelerated_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accelerated_networking", value)

    @property
    @pulumi.getter(name="availabilitySet")
    def availability_set(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Availability Set to place the virtual machine into
        """
        return pulumi.get(self, "availability_set")

    @availability_set.setter
    def availability_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_set", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The Availability Zone that the Azure VM should be created in
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Service Principal Account ID (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Service Principal Account password (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with custom-data
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Disk size if using managed disk
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[str]]:
        """
        A unique DNS label for the public IP adddress
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[pulumi.Input[str]]:
        """
        Port number for Docker engine
        """
        return pulumi.get(self, "docker_port")

    @docker_port.setter
    def docker_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_port", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="faultDomainCount")
    def fault_domain_count(self) -> Optional[pulumi.Input[str]]:
        """
        Fault domain count to use for availability set
        """
        return pulumi.get(self, "fault_domain_count")

    @fault_domain_count.setter
    def fault_domain_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain_count", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Azure virtual machine OS image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Azure region to create the virtual machine
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="managedDisks")
    def managed_disks(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures VM and availability set for managed disks
        """
        return pulumi.get(self, "managed_disks")

    @managed_disks.setter
    def managed_disks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "managed_disks", value)

    @property
    @pulumi.getter(name="noPublicIp")
    def no_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not create a public IP address for the machine
        """
        return pulumi.get(self, "no_public_ip")

    @no_public_ip.setter
    def no_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_public_ip", value)

    @property
    @pulumi.getter
    def nsg(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        """
        return pulumi.get(self, "nsg")

    @nsg.setter
    def nsg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nsg", value)

    @property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @open_ports.setter
    def open_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "open_ports", value)

    @property
    @pulumi.getter(name="privateAddressOnly")
    def private_address_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Only use a private IP address
        """
        return pulumi.get(self, "private_address_only")

    @private_address_only.setter
    def private_address_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_address_only", value)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a static private IP address for the machine
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Resource Group name (will be created if missing)
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Size for Azure Virtual Machine
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        Username for SSH login
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="staticPublicIp")
    def static_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Assign a static public IP address to the machine
        """
        return pulumi.get(self, "static_public_ip")

    @static_public_ip.setter
    def static_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static_public_ip", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Storage Account to host the OS Disk for the machine
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Subnet Name to be used within the Virtual Network
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="subnetPrefix")
    def subnet_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Private CIDR block to be used for the new subnet, should comply RFC 1918
        """
        return pulumi.get(self, "subnet_prefix")

    @subnet_prefix.setter
    def subnet_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_prefix", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Subscription ID
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="updateDomainCount")
    def update_domain_count(self) -> Optional[pulumi.Input[str]]:
        """
        Update domain count to use for availability set
        """
        return pulumi.get(self, "update_domain_count")

    @update_domain_count.setter
    def update_domain_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_domain_count", value)

    @property
    @pulumi.getter(name="usePrivateIp")
    def use_private_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Use private IP address of the machine to connect
        """
        return pulumi.get(self, "use_private_ip")

    @use_private_ip.setter
    def use_private_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_private_ip", value)

    @property
    @pulumi.getter(name="usePublicIpStandardSku")
    def use_public_ip_standard_sku(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the standard SKU when creating a Public IP for the Azure VM instance
        """
        return pulumi.get(self, "use_public_ip_standard_sku")

    @use_public_ip_standard_sku.setter
    def use_public_ip_standard_sku(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_public_ip_standard_sku", value)

    @property
    @pulumi.getter
    def vnet(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        return pulumi.get(self, "vnet")

    @vnet.setter
    def vnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet", value)


if not MYPY:
    class MachineConfigV2DigitaloceanConfigArgsDict(TypedDict):
        access_token: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean access token
        """
        backups: NotRequired[pulumi.Input[bool]]
        """
        Enable backups for droplet
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean Image
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        """
        Enable ipv6 for droplet
        """
        monitoring: NotRequired[pulumi.Input[bool]]
        """
        Enable monitoring for droplet
        """
        private_networking: NotRequired[pulumi.Input[bool]]
        """
        Enable private networking for droplet
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean region
        """
        size: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean size
        """
        ssh_key_contents: NotRequired[pulumi.Input[str]]
        """
        SSH private key contents
        """
        ssh_key_fingerprint: NotRequired[pulumi.Input[str]]
        """
        SSH key fingerprint
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        SSH port
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        SSH username
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of tags to apply to the Droplet
        """
        userdata: NotRequired[pulumi.Input[str]]
        """
        Path to file with cloud-init user-data
        """
elif False:
    MachineConfigV2DigitaloceanConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2DigitaloceanConfigArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 backups: Optional[pulumi.Input[bool]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 private_networking: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 ssh_key_contents: Optional[pulumi.Input[str]] = None,
                 ssh_key_fingerprint: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 userdata: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Digital Ocean access token
        :param pulumi.Input[bool] backups: Enable backups for droplet
        :param pulumi.Input[str] image: Digital Ocean Image
        :param pulumi.Input[bool] ipv6: Enable ipv6 for droplet
        :param pulumi.Input[bool] monitoring: Enable monitoring for droplet
        :param pulumi.Input[bool] private_networking: Enable private networking for droplet
        :param pulumi.Input[str] region: Digital Ocean region
        :param pulumi.Input[str] size: Digital Ocean size
        :param pulumi.Input[str] ssh_key_contents: SSH private key contents
        :param pulumi.Input[str] ssh_key_fingerprint: SSH key fingerprint
        :param pulumi.Input[str] ssh_port: SSH port
        :param pulumi.Input[str] ssh_user: SSH username
        :param pulumi.Input[str] tags: Comma-separated list of tags to apply to the Droplet
        :param pulumi.Input[str] userdata: Path to file with cloud-init user-data
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if backups is not None:
            pulumi.set(__self__, "backups", backups)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if private_networking is not None:
            pulumi.set(__self__, "private_networking", private_networking)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_contents is not None:
            pulumi.set(__self__, "ssh_key_contents", ssh_key_contents)
        if ssh_key_fingerprint is not None:
            pulumi.set(__self__, "ssh_key_fingerprint", ssh_key_fingerprint)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean access token
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def backups(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable backups for droplet
        """
        return pulumi.get(self, "backups")

    @backups.setter
    def backups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backups", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean Image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable ipv6 for droplet
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable monitoring for droplet
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="privateNetworking")
    def private_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable private networking for droplet
        """
        return pulumi.get(self, "private_networking")

    @private_networking.setter
    def private_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_networking", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean size
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshKeyContents")
    def ssh_key_contents(self) -> Optional[pulumi.Input[str]]:
        """
        SSH private key contents
        """
        return pulumi.get(self, "ssh_key_contents")

    @ssh_key_contents.setter
    def ssh_key_contents(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_contents", value)

    @property
    @pulumi.getter(name="sshKeyFingerprint")
    def ssh_key_fingerprint(self) -> Optional[pulumi.Input[str]]:
        """
        SSH key fingerprint
        """
        return pulumi.get(self, "ssh_key_fingerprint")

    @ssh_key_fingerprint.setter
    def ssh_key_fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_fingerprint", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        SSH port
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of tags to apply to the Droplet
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def userdata(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with cloud-init user-data
        """
        return pulumi.get(self, "userdata")

    @userdata.setter
    def userdata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userdata", value)


if not MYPY:
    class MachineConfigV2HarvesterConfigArgsDict(TypedDict):
        ssh_user: pulumi.Input[str]
        """
        SSH username
        """
        vm_namespace: pulumi.Input[str]
        """
        Virtual machine namespace
        """
        cpu_count: NotRequired[pulumi.Input[str]]
        """
        CPU count
        """
        disk_bus: NotRequired[pulumi.Input[str]]
        """
        Disk bus
        """
        disk_info: NotRequired[pulumi.Input[str]]
        """
        A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        """
        disk_size: NotRequired[pulumi.Input[str]]
        """
        Disk size (in GiB)
        """
        image_name: NotRequired[pulumi.Input[str]]
        """
        Image name
        """
        memory_size: NotRequired[pulumi.Input[str]]
        """
        Memory size (in GiB)
        """
        network_data: NotRequired[pulumi.Input[str]]
        """
        NetworkData content of cloud-init, base64 is supported
        """
        network_info: NotRequired[pulumi.Input[str]]
        """
        A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        """
        network_model: NotRequired[pulumi.Input[str]]
        """
        Network model
        """
        network_name: NotRequired[pulumi.Input[str]]
        """
        Network name
        """
        ssh_password: NotRequired[pulumi.Input[str]]
        """
        SSH password
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        """
        vm_affinity: NotRequired[pulumi.Input[str]]
        """
        VM affinity, base64 is supported
        """
elif False:
    MachineConfigV2HarvesterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2HarvesterConfigArgs:
    def __init__(__self__, *,
                 ssh_user: pulumi.Input[str],
                 vm_namespace: pulumi.Input[str],
                 cpu_count: Optional[pulumi.Input[str]] = None,
                 disk_bus: Optional[pulumi.Input[str]] = None,
                 disk_info: Optional[pulumi.Input[str]] = None,
                 disk_size: Optional[pulumi.Input[str]] = None,
                 image_name: Optional[pulumi.Input[str]] = None,
                 memory_size: Optional[pulumi.Input[str]] = None,
                 network_data: Optional[pulumi.Input[str]] = None,
                 network_info: Optional[pulumi.Input[str]] = None,
                 network_model: Optional[pulumi.Input[str]] = None,
                 network_name: Optional[pulumi.Input[str]] = None,
                 ssh_password: Optional[pulumi.Input[str]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vm_affinity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ssh_user: SSH username
        :param pulumi.Input[str] vm_namespace: Virtual machine namespace
        :param pulumi.Input[str] cpu_count: CPU count
        :param pulumi.Input[str] disk_bus: Disk bus
        :param pulumi.Input[str] disk_info: A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        :param pulumi.Input[str] disk_size: Disk size (in GiB)
        :param pulumi.Input[str] image_name: Image name
        :param pulumi.Input[str] memory_size: Memory size (in GiB)
        :param pulumi.Input[str] network_data: NetworkData content of cloud-init, base64 is supported
        :param pulumi.Input[str] network_info: A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        :param pulumi.Input[str] network_model: Network model
        :param pulumi.Input[str] network_name: Network name
        :param pulumi.Input[str] ssh_password: SSH password
        :param pulumi.Input[str] user_data: UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        :param pulumi.Input[str] vm_affinity: VM affinity, base64 is supported
        """
        pulumi.set(__self__, "ssh_user", ssh_user)
        pulumi.set(__self__, "vm_namespace", vm_namespace)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if disk_bus is not None:
            warnings.warn("""Use disk_info instead""", DeprecationWarning)
            pulumi.log.warn("""disk_bus is deprecated: Use disk_info instead""")
        if disk_bus is not None:
            pulumi.set(__self__, "disk_bus", disk_bus)
        if disk_info is not None:
            pulumi.set(__self__, "disk_info", disk_info)
        if disk_size is not None:
            warnings.warn("""Use disk_info instead""", DeprecationWarning)
            pulumi.log.warn("""disk_size is deprecated: Use disk_info instead""")
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if image_name is not None:
            warnings.warn("""Use disk_info instead""", DeprecationWarning)
            pulumi.log.warn("""image_name is deprecated: Use disk_info instead""")
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if network_data is not None:
            pulumi.set(__self__, "network_data", network_data)
        if network_info is not None:
            pulumi.set(__self__, "network_info", network_info)
        if network_model is not None:
            warnings.warn("""Use network_info instead""", DeprecationWarning)
            pulumi.log.warn("""network_model is deprecated: Use network_info instead""")
        if network_model is not None:
            pulumi.set(__self__, "network_model", network_model)
        if network_name is not None:
            warnings.warn("""Use network_info instead""", DeprecationWarning)
            pulumi.log.warn("""network_name is deprecated: Use network_info instead""")
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vm_affinity is not None:
            pulumi.set(__self__, "vm_affinity", vm_affinity)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> pulumi.Input[str]:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="vmNamespace")
    def vm_namespace(self) -> pulumi.Input[str]:
        """
        Virtual machine namespace
        """
        return pulumi.get(self, "vm_namespace")

    @vm_namespace.setter
    def vm_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_namespace", value)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[str]]:
        """
        CPU count
        """
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="diskBus")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_bus(self) -> Optional[pulumi.Input[str]]:
        """
        Disk bus
        """
        return pulumi.get(self, "disk_bus")

    @disk_bus.setter
    def disk_bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_bus", value)

    @property
    @pulumi.getter(name="diskInfo")
    def disk_info(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        """
        return pulumi.get(self, "disk_info")

    @disk_info.setter
    def disk_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_info", value)

    @property
    @pulumi.getter(name="diskSize")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Disk size (in GiB)
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="imageName")
    @_utilities.deprecated("""Use disk_info instead""")
    def image_name(self) -> Optional[pulumi.Input[str]]:
        """
        Image name
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[pulumi.Input[str]]:
        """
        Memory size (in GiB)
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_size", value)

    @property
    @pulumi.getter(name="networkData")
    def network_data(self) -> Optional[pulumi.Input[str]]:
        """
        NetworkData content of cloud-init, base64 is supported
        """
        return pulumi.get(self, "network_data")

    @network_data.setter
    def network_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_data", value)

    @property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        """
        return pulumi.get(self, "network_info")

    @network_info.setter
    def network_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_info", value)

    @property
    @pulumi.getter(name="networkModel")
    @_utilities.deprecated("""Use network_info instead""")
    def network_model(self) -> Optional[pulumi.Input[str]]:
        """
        Network model
        """
        return pulumi.get(self, "network_model")

    @network_model.setter
    def network_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_model", value)

    @property
    @pulumi.getter(name="networkName")
    @_utilities.deprecated("""Use network_info instead""")
    def network_name(self) -> Optional[pulumi.Input[str]]:
        """
        Network name
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[pulumi.Input[str]]:
        """
        SSH password
        """
        return pulumi.get(self, "ssh_password")

    @ssh_password.setter
    def ssh_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_password", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="vmAffinity")
    def vm_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        VM affinity, base64 is supported
        """
        return pulumi.get(self, "vm_affinity")

    @vm_affinity.setter
    def vm_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_affinity", value)


if not MYPY:
    class MachineConfigV2LinodeConfigArgsDict(TypedDict):
        authorized_users: NotRequired[pulumi.Input[str]]
        """
        Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        """
        create_private_ip: NotRequired[pulumi.Input[bool]]
        """
        Create private IP for the instance
        """
        docker_port: NotRequired[pulumi.Input[str]]
        """
        Docker Port
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Specifies the Linode Instance image which determines the OS distribution and base files
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        Linode Instance Label
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Specifies the region (location) of the Linode instance
        """
        root_pass: NotRequired[pulumi.Input[str]]
        """
        Root Password
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        Linode Instance SSH Port
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        """
        stackscript: NotRequired[pulumi.Input[str]]
        """
        Specifies the Linode StackScript to use to create the instance
        """
        stackscript_data: NotRequired[pulumi.Input[str]]
        """
        A JSON string specifying data for the selected StackScript
        """
        swap_size: NotRequired[pulumi.Input[str]]
        """
        Linode Instance Swap Size (MB)
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        A comma separated list of tags to apply to the the Linode resource
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Linode API Token
        """
        ua_prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix the User-Agent in Linode API calls with some 'product/version'
        """
elif False:
    MachineConfigV2LinodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2LinodeConfigArgs:
    def __init__(__self__, *,
                 authorized_users: Optional[pulumi.Input[str]] = None,
                 create_private_ip: Optional[pulumi.Input[bool]] = None,
                 docker_port: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 root_pass: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 stackscript: Optional[pulumi.Input[str]] = None,
                 stackscript_data: Optional[pulumi.Input[str]] = None,
                 swap_size: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 ua_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authorized_users: Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        :param pulumi.Input[bool] create_private_ip: Create private IP for the instance
        :param pulumi.Input[str] docker_port: Docker Port
        :param pulumi.Input[str] image: Specifies the Linode Instance image which determines the OS distribution and base files
        :param pulumi.Input[str] instance_type: Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        :param pulumi.Input[str] label: Linode Instance Label
        :param pulumi.Input[str] region: Specifies the region (location) of the Linode instance
        :param pulumi.Input[str] root_pass: Root Password
        :param pulumi.Input[str] ssh_port: Linode Instance SSH Port
        :param pulumi.Input[str] ssh_user: Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        :param pulumi.Input[str] stackscript: Specifies the Linode StackScript to use to create the instance
        :param pulumi.Input[str] stackscript_data: A JSON string specifying data for the selected StackScript
        :param pulumi.Input[str] swap_size: Linode Instance Swap Size (MB)
        :param pulumi.Input[str] tags: A comma separated list of tags to apply to the the Linode resource
        :param pulumi.Input[str] token: Linode API Token
        :param pulumi.Input[str] ua_prefix: Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        if authorized_users is not None:
            pulumi.set(__self__, "authorized_users", authorized_users)
        if create_private_ip is not None:
            pulumi.set(__self__, "create_private_ip", create_private_ip)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if root_pass is not None:
            pulumi.set(__self__, "root_pass", root_pass)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if stackscript is not None:
            pulumi.set(__self__, "stackscript", stackscript)
        if stackscript_data is not None:
            pulumi.set(__self__, "stackscript_data", stackscript_data)
        if swap_size is not None:
            pulumi.set(__self__, "swap_size", swap_size)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if ua_prefix is not None:
            pulumi.set(__self__, "ua_prefix", ua_prefix)

    @property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[pulumi.Input[str]]:
        """
        Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        """
        return pulumi.get(self, "authorized_users")

    @authorized_users.setter
    def authorized_users(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorized_users", value)

    @property
    @pulumi.getter(name="createPrivateIp")
    def create_private_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Create private IP for the instance
        """
        return pulumi.get(self, "create_private_ip")

    @create_private_ip.setter
    def create_private_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_private_ip", value)

    @property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[pulumi.Input[str]]:
        """
        Docker Port
        """
        return pulumi.get(self, "docker_port")

    @docker_port.setter
    def docker_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_port", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Linode Instance image which determines the OS distribution and base files
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Linode Instance Label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the region (location) of the Linode instance
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="rootPass")
    def root_pass(self) -> Optional[pulumi.Input[str]]:
        """
        Root Password
        """
        return pulumi.get(self, "root_pass")

    @root_pass.setter
    def root_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_pass", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        Linode Instance SSH Port
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter
    def stackscript(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Linode StackScript to use to create the instance
        """
        return pulumi.get(self, "stackscript")

    @stackscript.setter
    def stackscript(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stackscript", value)

    @property
    @pulumi.getter(name="stackscriptData")
    def stackscript_data(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON string specifying data for the selected StackScript
        """
        return pulumi.get(self, "stackscript_data")

    @stackscript_data.setter
    def stackscript_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stackscript_data", value)

    @property
    @pulumi.getter(name="swapSize")
    def swap_size(self) -> Optional[pulumi.Input[str]]:
        """
        Linode Instance Swap Size (MB)
        """
        return pulumi.get(self, "swap_size")

    @swap_size.setter
    def swap_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "swap_size", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        A comma separated list of tags to apply to the the Linode resource
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Linode API Token
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="uaPrefix")
    def ua_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        return pulumi.get(self, "ua_prefix")

    @ua_prefix.setter
    def ua_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ua_prefix", value)


if not MYPY:
    class MachineConfigV2OpenstackConfigArgsDict(TypedDict):
        auth_url: pulumi.Input[str]
        """
        OpenStack authentication URL (string)
        """
        availability_zone: pulumi.Input[str]
        """
        OpenStack availability zone (string)
        """
        region: pulumi.Input[str]
        """
        OpenStack region name (string)
        """
        active_timeout: NotRequired[pulumi.Input[str]]
        """
        OpenStack active timeout Default `200` (string)
        """
        application_credential_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack application credential id. Conflicts with `application_credential_name` (string)
        """
        application_credential_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack application credential name. Conflicts with `application_credential_id` (string)
        """
        application_credential_secret: NotRequired[pulumi.Input[str]]
        """
        OpenStack application credential secret (string)
        """
        boot_from_volume: NotRequired[pulumi.Input[bool]]
        """
        Enable booting from volume. Default is `false` (bool)
        """
        cacert: NotRequired[pulumi.Input[str]]
        """
        CA certificate bundle to verify against (string)
        """
        config_drive: NotRequired[pulumi.Input[bool]]
        """
        Enables the OpenStack config drive for the instance. Default `false` (bool)
        """
        domain_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        """
        domain_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        """
        endpoint_type: NotRequired[pulumi.Input[str]]
        """
        OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        """
        flavor_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        """
        flavor_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        """
        floating_ip_pool: NotRequired[pulumi.Input[str]]
        """
        OpenStack floating IP pool to get an IP from to assign to the instance (string)
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        image_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        insecure: NotRequired[pulumi.Input[bool]]
        """
        Disable TLS credential checking. Default `false` (bool)
        """
        ip_version: NotRequired[pulumi.Input[str]]
        """
        OpenStack version of IP address assigned for the machine Default `4` (string)
        """
        keypair_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack keypair to use to SSH to the instance (string)
        """
        net_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        """
        net_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        """
        nova_network: NotRequired[pulumi.Input[bool]]
        """
        Use the nova networking services instead of neutron (string)
        """
        password: NotRequired[pulumi.Input[str]]
        """
        OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        private_key_file: NotRequired[pulumi.Input[str]]
        """
        Private key content to use for SSH (string)
        """
        sec_groups: NotRequired[pulumi.Input[str]]
        """
        OpenStack comma separated security groups for the machine (string)
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh port. Default `22` (string)
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. (string)
        """
        tenant_domain_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack tenant domain id. Conflicts with `tenant_domain_name` (string)
        """
        tenant_domain_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack tenant domain name. Conflicts with `tenant_domain_id` (string)
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack tenant id. Conflicts with `tenant_name` (string)
        """
        tenant_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack tenant name. Conflicts with `tenant_id` (string)
        """
        user_data_file: NotRequired[pulumi.Input[str]]
        """
        File containing an openstack userdata script (string)
        """
        user_domain_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack user domain id. Conflicts with `user_domain_name` (string)
        """
        user_domain_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack user domain name. Conflicts with `user_domain_id` (string)
        """
        username: NotRequired[pulumi.Input[str]]
        """
        OpenStack username (string)
        """
        volume_device_path: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
        > **Note:**: `Required+` denotes that either the _name or _id is required but you cannot use both.
        > **Note:**: `Required++` denotes that either the _name or _id is required unless `application_credential_id` is defined.
        > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        """
        volume_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        volume_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        volume_size: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
elif False:
    MachineConfigV2OpenstackConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2OpenstackConfigArgs:
    def __init__(__self__, *,
                 auth_url: pulumi.Input[str],
                 availability_zone: pulumi.Input[str],
                 region: pulumi.Input[str],
                 active_timeout: Optional[pulumi.Input[str]] = None,
                 application_credential_id: Optional[pulumi.Input[str]] = None,
                 application_credential_name: Optional[pulumi.Input[str]] = None,
                 application_credential_secret: Optional[pulumi.Input[str]] = None,
                 boot_from_volume: Optional[pulumi.Input[bool]] = None,
                 cacert: Optional[pulumi.Input[str]] = None,
                 config_drive: Optional[pulumi.Input[bool]] = None,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 endpoint_type: Optional[pulumi.Input[str]] = None,
                 flavor_id: Optional[pulumi.Input[str]] = None,
                 flavor_name: Optional[pulumi.Input[str]] = None,
                 floating_ip_pool: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 image_name: Optional[pulumi.Input[str]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 keypair_name: Optional[pulumi.Input[str]] = None,
                 net_id: Optional[pulumi.Input[str]] = None,
                 net_name: Optional[pulumi.Input[str]] = None,
                 nova_network: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 private_key_file: Optional[pulumi.Input[str]] = None,
                 sec_groups: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 tenant_domain_id: Optional[pulumi.Input[str]] = None,
                 tenant_domain_name: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 tenant_name: Optional[pulumi.Input[str]] = None,
                 user_data_file: Optional[pulumi.Input[str]] = None,
                 user_domain_id: Optional[pulumi.Input[str]] = None,
                 user_domain_name: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 volume_device_path: Optional[pulumi.Input[str]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[str]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_url: OpenStack authentication URL (string)
        :param pulumi.Input[str] availability_zone: OpenStack availability zone (string)
        :param pulumi.Input[str] region: OpenStack region name (string)
        :param pulumi.Input[str] active_timeout: OpenStack active timeout Default `200` (string)
        :param pulumi.Input[str] application_credential_id: OpenStack application credential id. Conflicts with `application_credential_name` (string)
        :param pulumi.Input[str] application_credential_name: OpenStack application credential name. Conflicts with `application_credential_id` (string)
        :param pulumi.Input[str] application_credential_secret: OpenStack application credential secret (string)
        :param pulumi.Input[bool] boot_from_volume: Enable booting from volume. Default is `false` (bool)
        :param pulumi.Input[str] cacert: CA certificate bundle to verify against (string)
        :param pulumi.Input[bool] config_drive: Enables the OpenStack config drive for the instance. Default `false` (bool)
        :param pulumi.Input[str] domain_id: OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        :param pulumi.Input[str] domain_name: OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        :param pulumi.Input[str] endpoint_type: OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        :param pulumi.Input[str] flavor_id: OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        :param pulumi.Input[str] flavor_name: OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        :param pulumi.Input[str] floating_ip_pool: OpenStack floating IP pool to get an IP from to assign to the instance (string)
        :param pulumi.Input[str] image_id: OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        :param pulumi.Input[str] image_name: OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        :param pulumi.Input[bool] insecure: Disable TLS credential checking. Default `false` (bool)
        :param pulumi.Input[str] ip_version: OpenStack version of IP address assigned for the machine Default `4` (string)
        :param pulumi.Input[str] keypair_name: OpenStack keypair to use to SSH to the instance (string)
        :param pulumi.Input[str] net_id: OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        :param pulumi.Input[str] net_name: OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        :param pulumi.Input[bool] nova_network: Use the nova networking services instead of neutron (string)
        :param pulumi.Input[str] password: OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param pulumi.Input[str] private_key_file: Private key content to use for SSH (string)
        :param pulumi.Input[str] sec_groups: OpenStack comma separated security groups for the machine (string)
        :param pulumi.Input[str] ssh_port: If using a non-B2D image you can specify the ssh port. Default `22` (string)
        :param pulumi.Input[str] ssh_user: If using a non-B2D image you can specify the ssh user. Default `docker`. (string)
        :param pulumi.Input[str] tenant_domain_id: OpenStack tenant domain id. Conflicts with `tenant_domain_name` (string)
        :param pulumi.Input[str] tenant_domain_name: OpenStack tenant domain name. Conflicts with `tenant_domain_id` (string)
        :param pulumi.Input[str] tenant_id: OpenStack tenant id. Conflicts with `tenant_name` (string)
        :param pulumi.Input[str] tenant_name: OpenStack tenant name. Conflicts with `tenant_id` (string)
        :param pulumi.Input[str] user_data_file: File containing an openstack userdata script (string)
        :param pulumi.Input[str] user_domain_id: OpenStack user domain id. Conflicts with `user_domain_name` (string)
        :param pulumi.Input[str] user_domain_name: OpenStack user domain name. Conflicts with `user_domain_id` (string)
        :param pulumi.Input[str] username: OpenStack username (string)
        :param pulumi.Input[str] volume_device_path: OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
               > **Note:**: `Required+` denotes that either the _name or _id is required but you cannot use both.
               > **Note:**: `Required++` denotes that either the _name or _id is required unless `application_credential_id` is defined.
               > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        :param pulumi.Input[str] volume_id: OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param pulumi.Input[str] volume_name: OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param pulumi.Input[str] volume_size: OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        :param pulumi.Input[str] volume_type: OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "region", region)
        if active_timeout is not None:
            pulumi.set(__self__, "active_timeout", active_timeout)
        if application_credential_id is not None:
            pulumi.set(__self__, "application_credential_id", application_credential_id)
        if application_credential_name is not None:
            pulumi.set(__self__, "application_credential_name", application_credential_name)
        if application_credential_secret is not None:
            pulumi.set(__self__, "application_credential_secret", application_credential_secret)
        if boot_from_volume is not None:
            pulumi.set(__self__, "boot_from_volume", boot_from_volume)
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if config_drive is not None:
            pulumi.set(__self__, "config_drive", config_drive)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if flavor_name is not None:
            pulumi.set(__self__, "flavor_name", flavor_name)
        if floating_ip_pool is not None:
            pulumi.set(__self__, "floating_ip_pool", floating_ip_pool)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if keypair_name is not None:
            pulumi.set(__self__, "keypair_name", keypair_name)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if net_name is not None:
            pulumi.set(__self__, "net_name", net_name)
        if nova_network is not None:
            pulumi.set(__self__, "nova_network", nova_network)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key_file is not None:
            pulumi.set(__self__, "private_key_file", private_key_file)
        if sec_groups is not None:
            pulumi.set(__self__, "sec_groups", sec_groups)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tenant_domain_id is not None:
            pulumi.set(__self__, "tenant_domain_id", tenant_domain_id)
        if tenant_domain_name is not None:
            pulumi.set(__self__, "tenant_domain_name", tenant_domain_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if user_data_file is not None:
            pulumi.set(__self__, "user_data_file", user_data_file)
        if user_domain_id is not None:
            pulumi.set(__self__, "user_domain_id", user_domain_id)
        if user_domain_name is not None:
            pulumi.set(__self__, "user_domain_name", user_domain_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if volume_device_path is not None:
            pulumi.set(__self__, "volume_device_path", volume_device_path)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[str]:
        """
        OpenStack authentication URL (string)
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        """
        OpenStack availability zone (string)
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        OpenStack region name (string)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="activeTimeout")
    def active_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack active timeout Default `200` (string)
        """
        return pulumi.get(self, "active_timeout")

    @active_timeout.setter
    def active_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_timeout", value)

    @property
    @pulumi.getter(name="applicationCredentialId")
    def application_credential_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack application credential id. Conflicts with `application_credential_name` (string)
        """
        return pulumi.get(self, "application_credential_id")

    @application_credential_id.setter
    def application_credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_credential_id", value)

    @property
    @pulumi.getter(name="applicationCredentialName")
    def application_credential_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack application credential name. Conflicts with `application_credential_id` (string)
        """
        return pulumi.get(self, "application_credential_name")

    @application_credential_name.setter
    def application_credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_credential_name", value)

    @property
    @pulumi.getter(name="applicationCredentialSecret")
    def application_credential_secret(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack application credential secret (string)
        """
        return pulumi.get(self, "application_credential_secret")

    @application_credential_secret.setter
    def application_credential_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_credential_secret", value)

    @property
    @pulumi.getter(name="bootFromVolume")
    def boot_from_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable booting from volume. Default is `false` (bool)
        """
        return pulumi.get(self, "boot_from_volume")

    @boot_from_volume.setter
    def boot_from_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot_from_volume", value)

    @property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate bundle to verify against (string)
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cacert", value)

    @property
    @pulumi.getter(name="configDrive")
    def config_drive(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the OpenStack config drive for the instance. Default `false` (bool)
        """
        return pulumi.get(self, "config_drive")

    @config_drive.setter
    def config_drive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "config_drive", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        """
        return pulumi.get(self, "flavor_id")

    @flavor_id.setter
    def flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flavor_id", value)

    @property
    @pulumi.getter(name="flavorName")
    def flavor_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        """
        return pulumi.get(self, "flavor_name")

    @flavor_name.setter
    def flavor_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flavor_name", value)

    @property
    @pulumi.getter(name="floatingIpPool")
    def floating_ip_pool(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack floating IP pool to get an IP from to assign to the instance (string)
        """
        return pulumi.get(self, "floating_ip_pool")

    @floating_ip_pool.setter
    def floating_ip_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "floating_ip_pool", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS credential checking. Default `false` (bool)
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack version of IP address assigned for the machine Default `4` (string)
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="keypairName")
    def keypair_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack keypair to use to SSH to the instance (string)
        """
        return pulumi.get(self, "keypair_name")

    @keypair_name.setter
    def keypair_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keypair_name", value)

    @property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_id", value)

    @property
    @pulumi.getter(name="netName")
    def net_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        """
        return pulumi.get(self, "net_name")

    @net_name.setter
    def net_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_name", value)

    @property
    @pulumi.getter(name="novaNetwork")
    def nova_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the nova networking services instead of neutron (string)
        """
        return pulumi.get(self, "nova_network")

    @nova_network.setter
    def nova_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nova_network", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="privateKeyFile")
    def private_key_file(self) -> Optional[pulumi.Input[str]]:
        """
        Private key content to use for SSH (string)
        """
        return pulumi.get(self, "private_key_file")

    @private_key_file.setter
    def private_key_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_file", value)

    @property
    @pulumi.getter(name="secGroups")
    def sec_groups(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack comma separated security groups for the machine (string)
        """
        return pulumi.get(self, "sec_groups")

    @sec_groups.setter
    def sec_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sec_groups", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh port. Default `22` (string)
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. (string)
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="tenantDomainId")
    def tenant_domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack tenant domain id. Conflicts with `tenant_domain_name` (string)
        """
        return pulumi.get(self, "tenant_domain_id")

    @tenant_domain_id.setter
    def tenant_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_domain_id", value)

    @property
    @pulumi.getter(name="tenantDomainName")
    def tenant_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack tenant domain name. Conflicts with `tenant_domain_id` (string)
        """
        return pulumi.get(self, "tenant_domain_name")

    @tenant_domain_name.setter
    def tenant_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_domain_name", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack tenant id. Conflicts with `tenant_name` (string)
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack tenant name. Conflicts with `tenant_id` (string)
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_name", value)

    @property
    @pulumi.getter(name="userDataFile")
    def user_data_file(self) -> Optional[pulumi.Input[str]]:
        """
        File containing an openstack userdata script (string)
        """
        return pulumi.get(self, "user_data_file")

    @user_data_file.setter
    def user_data_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data_file", value)

    @property
    @pulumi.getter(name="userDomainId")
    def user_domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack user domain id. Conflicts with `user_domain_name` (string)
        """
        return pulumi.get(self, "user_domain_id")

    @user_domain_id.setter
    def user_domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_domain_id", value)

    @property
    @pulumi.getter(name="userDomainName")
    def user_domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack user domain name. Conflicts with `user_domain_id` (string)
        """
        return pulumi.get(self, "user_domain_name")

    @user_domain_name.setter
    def user_domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_domain_name", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack username (string)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="volumeDevicePath")
    def volume_device_path(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
        > **Note:**: `Required+` denotes that either the _name or _id is required but you cannot use both.
        > **Note:**: `Required++` denotes that either the _name or _id is required unless `application_credential_id` is defined.
        > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        """
        return pulumi.get(self, "volume_device_path")

    @volume_device_path.setter
    def volume_device_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_device_path", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class MachineConfigV2VsphereConfigArgsDict(TypedDict):
        boot2docker_url: NotRequired[pulumi.Input[str]]
        """
        vSphere URL for boot2docker image
        """
        cfgparams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere vm configuration parameters (used for guestinfo)
        """
        clone_from: NotRequired[pulumi.Input[str]]
        """
        If you choose creation type clone a name of what you want to clone is required
        """
        cloud_config: NotRequired[pulumi.Input[str]]
        """
        Filepath to a cloud-config yaml file to put into the ISO user-data
        """
        cloudinit: NotRequired[pulumi.Input[str]]
        """
        vSphere cloud-init filepath or url to add to guestinfo
        """
        content_library: NotRequired[pulumi.Input[str]]
        """
        If you choose to clone from a content library template specify the name of the library
        """
        cpu_count: NotRequired[pulumi.Input[str]]
        """
        vSphere CPU number for docker VM
        """
        creation_type: NotRequired[pulumi.Input[str]]
        """
        Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        """
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere custom attributes, format key/value e.g. '200=my custom value'
        """
        datacenter: NotRequired[pulumi.Input[str]]
        """
        vSphere datacenter for virtual machine
        """
        datastore: NotRequired[pulumi.Input[str]]
        """
        vSphere datastore for virtual machine
        """
        datastore_cluster: NotRequired[pulumi.Input[str]]
        """
        vSphere datastore cluster for virtual machine
        """
        disk_size: NotRequired[pulumi.Input[str]]
        """
        vSphere size of disk for docker VM (in MB)
        """
        folder: NotRequired[pulumi.Input[str]]
        """
        vSphere folder for the docker VM. This folder must already exist in the datacenter
        """
        graceful_shutdown_timeout: NotRequired[pulumi.Input[str]]
        """
        Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        """
        hostsystem: NotRequired[pulumi.Input[str]]
        """
        vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        """
        memory_size: NotRequired[pulumi.Input[str]]
        """
        vSphere size of memory for docker VM (in MB)
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere network where the virtual machine will be attached
        """
        password: NotRequired[pulumi.Input[str]]
        """
        vSphere password
        """
        pool: NotRequired[pulumi.Input[str]]
        """
        vSphere resource pool for docker VM
        """
        ssh_password: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh password
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh port
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh user
        """
        ssh_user_group: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere tags id e.g. urn:xxx
        """
        username: NotRequired[pulumi.Input[str]]
        """
        vSphere username
        """
        vapp_ip_allocation_policy: NotRequired[pulumi.Input[str]]
        """
        vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        """
        vapp_ip_protocol: NotRequired[pulumi.Input[str]]
        """
        vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        """
        vapp_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere vApp properties
        """
        vapp_transport: NotRequired[pulumi.Input[str]]
        """
        vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        """
        vcenter: NotRequired[pulumi.Input[str]]
        """
        vSphere IP/hostname for vCenter
        """
        vcenter_port: NotRequired[pulumi.Input[str]]
        """
        vSphere Port for vCenter
        """
elif False:
    MachineConfigV2VsphereConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MachineConfigV2VsphereConfigArgs:
    def __init__(__self__, *,
                 boot2docker_url: Optional[pulumi.Input[str]] = None,
                 cfgparams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 clone_from: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[str]] = None,
                 cloudinit: Optional[pulumi.Input[str]] = None,
                 content_library: Optional[pulumi.Input[str]] = None,
                 cpu_count: Optional[pulumi.Input[str]] = None,
                 creation_type: Optional[pulumi.Input[str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 datacenter: Optional[pulumi.Input[str]] = None,
                 datastore: Optional[pulumi.Input[str]] = None,
                 datastore_cluster: Optional[pulumi.Input[str]] = None,
                 disk_size: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 graceful_shutdown_timeout: Optional[pulumi.Input[str]] = None,
                 hostsystem: Optional[pulumi.Input[str]] = None,
                 memory_size: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 pool: Optional[pulumi.Input[str]] = None,
                 ssh_password: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 ssh_user_group: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 vapp_ip_allocation_policy: Optional[pulumi.Input[str]] = None,
                 vapp_ip_protocol: Optional[pulumi.Input[str]] = None,
                 vapp_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vapp_transport: Optional[pulumi.Input[str]] = None,
                 vcenter: Optional[pulumi.Input[str]] = None,
                 vcenter_port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot2docker_url: vSphere URL for boot2docker image
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cfgparams: vSphere vm configuration parameters (used for guestinfo)
        :param pulumi.Input[str] clone_from: If you choose creation type clone a name of what you want to clone is required
        :param pulumi.Input[str] cloud_config: Filepath to a cloud-config yaml file to put into the ISO user-data
        :param pulumi.Input[str] cloudinit: vSphere cloud-init filepath or url to add to guestinfo
        :param pulumi.Input[str] content_library: If you choose to clone from a content library template specify the name of the library
        :param pulumi.Input[str] cpu_count: vSphere CPU number for docker VM
        :param pulumi.Input[str] creation_type: Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_attributes: vSphere custom attributes, format key/value e.g. '200=my custom value'
        :param pulumi.Input[str] datacenter: vSphere datacenter for virtual machine
        :param pulumi.Input[str] datastore: vSphere datastore for virtual machine
        :param pulumi.Input[str] datastore_cluster: vSphere datastore cluster for virtual machine
        :param pulumi.Input[str] disk_size: vSphere size of disk for docker VM (in MB)
        :param pulumi.Input[str] folder: vSphere folder for the docker VM. This folder must already exist in the datacenter
        :param pulumi.Input[str] graceful_shutdown_timeout: Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        :param pulumi.Input[str] hostsystem: vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        :param pulumi.Input[str] memory_size: vSphere size of memory for docker VM (in MB)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: vSphere network where the virtual machine will be attached
        :param pulumi.Input[str] password: vSphere password
        :param pulumi.Input[str] pool: vSphere resource pool for docker VM
        :param pulumi.Input[str] ssh_password: If using a non-B2D image you can specify the ssh password
        :param pulumi.Input[str] ssh_port: If using a non-B2D image you can specify the ssh port
        :param pulumi.Input[str] ssh_user: If using a non-B2D image you can specify the ssh user
        :param pulumi.Input[str] ssh_user_group: If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: vSphere tags id e.g. urn:xxx
        :param pulumi.Input[str] username: vSphere username
        :param pulumi.Input[str] vapp_ip_allocation_policy: vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        :param pulumi.Input[str] vapp_ip_protocol: vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vapp_properties: vSphere vApp properties
        :param pulumi.Input[str] vapp_transport: vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        :param pulumi.Input[str] vcenter: vSphere IP/hostname for vCenter
        :param pulumi.Input[str] vcenter_port: vSphere Port for vCenter
        """
        if boot2docker_url is not None:
            pulumi.set(__self__, "boot2docker_url", boot2docker_url)
        if cfgparams is not None:
            pulumi.set(__self__, "cfgparams", cfgparams)
        if clone_from is not None:
            pulumi.set(__self__, "clone_from", clone_from)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloudinit is not None:
            pulumi.set(__self__, "cloudinit", cloudinit)
        if content_library is not None:
            pulumi.set(__self__, "content_library", content_library)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if datastore_cluster is not None:
            pulumi.set(__self__, "datastore_cluster", datastore_cluster)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if hostsystem is not None:
            pulumi.set(__self__, "hostsystem", hostsystem)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if ssh_user_group is not None:
            pulumi.set(__self__, "ssh_user_group", ssh_user_group)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vapp_ip_allocation_policy is not None:
            pulumi.set(__self__, "vapp_ip_allocation_policy", vapp_ip_allocation_policy)
        if vapp_ip_protocol is not None:
            pulumi.set(__self__, "vapp_ip_protocol", vapp_ip_protocol)
        if vapp_properties is not None:
            pulumi.set(__self__, "vapp_properties", vapp_properties)
        if vapp_transport is not None:
            pulumi.set(__self__, "vapp_transport", vapp_transport)
        if vcenter is not None:
            pulumi.set(__self__, "vcenter", vcenter)
        if vcenter_port is not None:
            pulumi.set(__self__, "vcenter_port", vcenter_port)

    @property
    @pulumi.getter(name="boot2dockerUrl")
    def boot2docker_url(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere URL for boot2docker image
        """
        return pulumi.get(self, "boot2docker_url")

    @boot2docker_url.setter
    def boot2docker_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot2docker_url", value)

    @property
    @pulumi.getter
    def cfgparams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere vm configuration parameters (used for guestinfo)
        """
        return pulumi.get(self, "cfgparams")

    @cfgparams.setter
    def cfgparams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cfgparams", value)

    @property
    @pulumi.getter(name="cloneFrom")
    def clone_from(self) -> Optional[pulumi.Input[str]]:
        """
        If you choose creation type clone a name of what you want to clone is required
        """
        return pulumi.get(self, "clone_from")

    @clone_from.setter
    def clone_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clone_from", value)

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[pulumi.Input[str]]:
        """
        Filepath to a cloud-config yaml file to put into the ISO user-data
        """
        return pulumi.get(self, "cloud_config")

    @cloud_config.setter
    def cloud_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_config", value)

    @property
    @pulumi.getter
    def cloudinit(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere cloud-init filepath or url to add to guestinfo
        """
        return pulumi.get(self, "cloudinit")

    @cloudinit.setter
    def cloudinit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudinit", value)

    @property
    @pulumi.getter(name="contentLibrary")
    def content_library(self) -> Optional[pulumi.Input[str]]:
        """
        If you choose to clone from a content library template specify the name of the library
        """
        return pulumi.get(self, "content_library")

    @content_library.setter
    def content_library(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_library", value)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere CPU number for docker VM
        """
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        """
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere custom attributes, format key/value e.g. '200=my custom value'
        """
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_attributes", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere datacenter for virtual machine
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere datastore for virtual machine
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter(name="datastoreCluster")
    def datastore_cluster(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere datastore cluster for virtual machine
        """
        return pulumi.get(self, "datastore_cluster")

    @datastore_cluster.setter
    def datastore_cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_cluster", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere size of disk for docker VM (in MB)
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere folder for the docker VM. This folder must already exist in the datacenter
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        """
        return pulumi.get(self, "graceful_shutdown_timeout")

    @graceful_shutdown_timeout.setter
    def graceful_shutdown_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graceful_shutdown_timeout", value)

    @property
    @pulumi.getter
    def hostsystem(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        """
        return pulumi.get(self, "hostsystem")

    @hostsystem.setter
    def hostsystem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostsystem", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere size of memory for docker VM (in MB)
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_size", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere network where the virtual machine will be attached
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def pool(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere resource pool for docker VM
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh password
        """
        return pulumi.get(self, "ssh_password")

    @ssh_password.setter
    def ssh_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_password", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh port
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="sshUserGroup")
    def ssh_user_group(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        """
        return pulumi.get(self, "ssh_user_group")

    @ssh_user_group.setter
    def ssh_user_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user_group", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere tags id e.g. urn:xxx
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="vappIpAllocationPolicy")
    def vapp_ip_allocation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        """
        return pulumi.get(self, "vapp_ip_allocation_policy")

    @vapp_ip_allocation_policy.setter
    def vapp_ip_allocation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_ip_allocation_policy", value)

    @property
    @pulumi.getter(name="vappIpProtocol")
    def vapp_ip_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        """
        return pulumi.get(self, "vapp_ip_protocol")

    @vapp_ip_protocol.setter
    def vapp_ip_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_ip_protocol", value)

    @property
    @pulumi.getter(name="vappProperties")
    def vapp_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere vApp properties
        """
        return pulumi.get(self, "vapp_properties")

    @vapp_properties.setter
    def vapp_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vapp_properties", value)

    @property
    @pulumi.getter(name="vappTransport")
    def vapp_transport(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        """
        return pulumi.get(self, "vapp_transport")

    @vapp_transport.setter
    def vapp_transport(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_transport", value)

    @property
    @pulumi.getter
    def vcenter(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere IP/hostname for vCenter
        """
        return pulumi.get(self, "vcenter")

    @vcenter.setter
    def vcenter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter", value)

    @property
    @pulumi.getter(name="vcenterPort")
    def vcenter_port(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere Port for vCenter
        """
        return pulumi.get(self, "vcenter_port")

    @vcenter_port.setter
    def vcenter_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter_port", value)


if not MYPY:
    class MultiClusterAppAnswerArgsDict(TypedDict):
        cluster_id: NotRequired[pulumi.Input[str]]
        """
        Cluster ID for answer
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        Project ID for answer
        """
        values: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key/values for answer
        """
elif False:
    MultiClusterAppAnswerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiClusterAppAnswerArgs:
    def __init__(__self__, *,
                 cluster_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 values: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] cluster_id: Cluster ID for answer
        :param pulumi.Input[str] project_id: Project ID for answer
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] values: Key/values for answer
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[str]]:
        """
        Cluster ID for answer
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Project ID for answer
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key/values for answer
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class MultiClusterAppMemberArgsDict(TypedDict):
        access_type: NotRequired[pulumi.Input[str]]
        """
        Member access type: member, owner, read-only
        """
        group_principal_id: NotRequired[pulumi.Input[str]]
        """
        Member group principal id
        """
        user_principal_id: NotRequired[pulumi.Input[str]]
        """
        Member user principal id
        """
elif False:
    MultiClusterAppMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiClusterAppMemberArgs:
    def __init__(__self__, *,
                 access_type: Optional[pulumi.Input[str]] = None,
                 group_principal_id: Optional[pulumi.Input[str]] = None,
                 user_principal_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_type: Member access type: member, owner, read-only
        :param pulumi.Input[str] group_principal_id: Member group principal id
        :param pulumi.Input[str] user_principal_id: Member user principal id
        """
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if group_principal_id is not None:
            pulumi.set(__self__, "group_principal_id", group_principal_id)
        if user_principal_id is not None:
            pulumi.set(__self__, "user_principal_id", user_principal_id)

    @property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[pulumi.Input[str]]:
        """
        Member access type: member, owner, read-only
        """
        return pulumi.get(self, "access_type")

    @access_type.setter
    def access_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_type", value)

    @property
    @pulumi.getter(name="groupPrincipalId")
    def group_principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Member group principal id
        """
        return pulumi.get(self, "group_principal_id")

    @group_principal_id.setter
    def group_principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_principal_id", value)

    @property
    @pulumi.getter(name="userPrincipalId")
    def user_principal_id(self) -> Optional[pulumi.Input[str]]:
        """
        Member user principal id
        """
        return pulumi.get(self, "user_principal_id")

    @user_principal_id.setter
    def user_principal_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_principal_id", value)


if not MYPY:
    class MultiClusterAppTargetArgsDict(TypedDict):
        project_id: pulumi.Input[str]
        """
        Project ID for target
        """
        app_id: NotRequired[pulumi.Input[str]]
        """
        App ID for target
        """
        health_state: NotRequired[pulumi.Input[str]]
        """
        App health state for target
        """
        state: NotRequired[pulumi.Input[str]]
        """
        App state for target
        """
elif False:
    MultiClusterAppTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiClusterAppTargetArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str],
                 app_id: Optional[pulumi.Input[str]] = None,
                 health_state: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] project_id: Project ID for target
        :param pulumi.Input[str] app_id: App ID for target
        :param pulumi.Input[str] health_state: App health state for target
        :param pulumi.Input[str] state: App state for target
        """
        pulumi.set(__self__, "project_id", project_id)
        if app_id is not None:
            pulumi.set(__self__, "app_id", app_id)
        if health_state is not None:
            pulumi.set(__self__, "health_state", health_state)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Project ID for target
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="appId")
    def app_id(self) -> Optional[pulumi.Input[str]]:
        """
        App ID for target
        """
        return pulumi.get(self, "app_id")

    @app_id.setter
    def app_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "app_id", value)

    @property
    @pulumi.getter(name="healthState")
    def health_state(self) -> Optional[pulumi.Input[str]]:
        """
        App health state for target
        """
        return pulumi.get(self, "health_state")

    @health_state.setter
    def health_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_state", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        App state for target
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MultiClusterAppUpgradeStrategyArgsDict(TypedDict):
        rolling_update: NotRequired[pulumi.Input['MultiClusterAppUpgradeStrategyRollingUpdateArgsDict']]
        """
        Rolling update for upgrade strategy
        """
elif False:
    MultiClusterAppUpgradeStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiClusterAppUpgradeStrategyArgs:
    def __init__(__self__, *,
                 rolling_update: Optional[pulumi.Input['MultiClusterAppUpgradeStrategyRollingUpdateArgs']] = None):
        """
        :param pulumi.Input['MultiClusterAppUpgradeStrategyRollingUpdateArgs'] rolling_update: Rolling update for upgrade strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)

    @property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional[pulumi.Input['MultiClusterAppUpgradeStrategyRollingUpdateArgs']]:
        """
        Rolling update for upgrade strategy
        """
        return pulumi.get(self, "rolling_update")

    @rolling_update.setter
    def rolling_update(self, value: Optional[pulumi.Input['MultiClusterAppUpgradeStrategyRollingUpdateArgs']]):
        pulumi.set(self, "rolling_update", value)


if not MYPY:
    class MultiClusterAppUpgradeStrategyRollingUpdateArgsDict(TypedDict):
        batch_size: NotRequired[pulumi.Input[int]]
        """
        Rolling update batch size
        """
        interval: NotRequired[pulumi.Input[int]]
        """
        Rolling update interval
        """
elif False:
    MultiClusterAppUpgradeStrategyRollingUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MultiClusterAppUpgradeStrategyRollingUpdateArgs:
    def __init__(__self__, *,
                 batch_size: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] batch_size: Rolling update batch size
        :param pulumi.Input[int] interval: Rolling update interval
        """
        if batch_size is not None:
            pulumi.set(__self__, "batch_size", batch_size)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update batch size
        """
        return pulumi.get(self, "batch_size")

    @batch_size.setter
    def batch_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "batch_size", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[int]]:
        """
        Rolling update interval
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "interval", value)


if not MYPY:
    class NamespaceContainerResourceLimitArgsDict(TypedDict):
        limits_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for limits cpu in namespace (string)
        """
        limits_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for limits memory in namespace (string)
        """
        requests_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for requests cpu in namespace (string)
        """
        requests_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for requests memory in namespace (string)
        """
elif False:
    NamespaceContainerResourceLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceContainerResourceLimitArgs:
    def __init__(__self__, *,
                 limits_cpu: Optional[pulumi.Input[str]] = None,
                 limits_memory: Optional[pulumi.Input[str]] = None,
                 requests_cpu: Optional[pulumi.Input[str]] = None,
                 requests_memory: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] limits_cpu: Limit for limits cpu in namespace (string)
        :param pulumi.Input[str] limits_memory: Limit for limits memory in namespace (string)
        :param pulumi.Input[str] requests_cpu: Limit for requests cpu in namespace (string)
        :param pulumi.Input[str] requests_memory: Limit for requests memory in namespace (string)
        """
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)

    @property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits cpu in namespace (string)
        """
        return pulumi.get(self, "limits_cpu")

    @limits_cpu.setter
    def limits_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_cpu", value)

    @property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits memory in namespace (string)
        """
        return pulumi.get(self, "limits_memory")

    @limits_memory.setter
    def limits_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_memory", value)

    @property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests cpu in namespace (string)
        """
        return pulumi.get(self, "requests_cpu")

    @requests_cpu.setter
    def requests_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_cpu", value)

    @property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests memory in namespace (string)
        """
        return pulumi.get(self, "requests_memory")

    @requests_memory.setter
    def requests_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_memory", value)


if not MYPY:
    class NamespaceResourceQuotaArgsDict(TypedDict):
        limit: pulumi.Input['NamespaceResourceQuotaLimitArgsDict']
        """
        Resource quota limit for namespace (list maxitems:1)
        """
elif False:
    NamespaceResourceQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceResourceQuotaArgs:
    def __init__(__self__, *,
                 limit: pulumi.Input['NamespaceResourceQuotaLimitArgs']):
        """
        :param pulumi.Input['NamespaceResourceQuotaLimitArgs'] limit: Resource quota limit for namespace (list maxitems:1)
        """
        pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input['NamespaceResourceQuotaLimitArgs']:
        """
        Resource quota limit for namespace (list maxitems:1)
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input['NamespaceResourceQuotaLimitArgs']):
        pulumi.set(self, "limit", value)


if not MYPY:
    class NamespaceResourceQuotaLimitArgsDict(TypedDict):
        config_maps: NotRequired[pulumi.Input[str]]
        """
        Limit for config maps in namespace (string)
        """
        limits_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for limits cpu in namespace (string)
        """
        limits_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for limits memory in namespace (string)
        """
        persistent_volume_claims: NotRequired[pulumi.Input[str]]
        """
        Limit for persistent volume claims in namespace (string)
        """
        pods: NotRequired[pulumi.Input[str]]
        """
        Limit for pods in namespace (string)
        """
        replication_controllers: NotRequired[pulumi.Input[str]]
        """
        Limit for replication controllers in namespace (string)
        """
        requests_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for requests cpu in namespace (string)
        """
        requests_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for requests memory in namespace (string)
        """
        requests_storage: NotRequired[pulumi.Input[str]]
        """
        Limit for requests storage in namespace (string)
        """
        secrets: NotRequired[pulumi.Input[str]]
        """
        Limit for secrets in namespace (string)
        """
        services: NotRequired[pulumi.Input[str]]
        services_load_balancers: NotRequired[pulumi.Input[str]]
        """
        Limit for services load balancers in namespace (string)
        """
        services_node_ports: NotRequired[pulumi.Input[str]]
        """
        Limit for services node ports in namespace (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
elif False:
    NamespaceResourceQuotaLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NamespaceResourceQuotaLimitArgs:
    def __init__(__self__, *,
                 config_maps: Optional[pulumi.Input[str]] = None,
                 limits_cpu: Optional[pulumi.Input[str]] = None,
                 limits_memory: Optional[pulumi.Input[str]] = None,
                 persistent_volume_claims: Optional[pulumi.Input[str]] = None,
                 pods: Optional[pulumi.Input[str]] = None,
                 replication_controllers: Optional[pulumi.Input[str]] = None,
                 requests_cpu: Optional[pulumi.Input[str]] = None,
                 requests_memory: Optional[pulumi.Input[str]] = None,
                 requests_storage: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[str]] = None,
                 services_load_balancers: Optional[pulumi.Input[str]] = None,
                 services_node_ports: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_maps: Limit for config maps in namespace (string)
        :param pulumi.Input[str] limits_cpu: Limit for limits cpu in namespace (string)
        :param pulumi.Input[str] limits_memory: Limit for limits memory in namespace (string)
        :param pulumi.Input[str] persistent_volume_claims: Limit for persistent volume claims in namespace (string)
        :param pulumi.Input[str] pods: Limit for pods in namespace (string)
        :param pulumi.Input[str] replication_controllers: Limit for replication controllers in namespace (string)
        :param pulumi.Input[str] requests_cpu: Limit for requests cpu in namespace (string)
        :param pulumi.Input[str] requests_memory: Limit for requests memory in namespace (string)
        :param pulumi.Input[str] requests_storage: Limit for requests storage in namespace (string)
        :param pulumi.Input[str] secrets: Limit for secrets in namespace (string)
        :param pulumi.Input[str] services_load_balancers: Limit for services load balancers in namespace (string)
        :param pulumi.Input[str] services_node_ports: Limit for services node ports in namespace (string)
               
               More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for config maps in namespace (string)
        """
        return pulumi.get(self, "config_maps")

    @config_maps.setter
    def config_maps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_maps", value)

    @property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits cpu in namespace (string)
        """
        return pulumi.get(self, "limits_cpu")

    @limits_cpu.setter
    def limits_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_cpu", value)

    @property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits memory in namespace (string)
        """
        return pulumi.get(self, "limits_memory")

    @limits_memory.setter
    def limits_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_memory", value)

    @property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for persistent volume claims in namespace (string)
        """
        return pulumi.get(self, "persistent_volume_claims")

    @persistent_volume_claims.setter
    def persistent_volume_claims(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "persistent_volume_claims", value)

    @property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for pods in namespace (string)
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pods", value)

    @property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for replication controllers in namespace (string)
        """
        return pulumi.get(self, "replication_controllers")

    @replication_controllers.setter
    def replication_controllers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_controllers", value)

    @property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests cpu in namespace (string)
        """
        return pulumi.get(self, "requests_cpu")

    @requests_cpu.setter
    def requests_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_cpu", value)

    @property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests memory in namespace (string)
        """
        return pulumi.get(self, "requests_memory")

    @requests_memory.setter
    def requests_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_memory", value)

    @property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests storage in namespace (string)
        """
        return pulumi.get(self, "requests_storage")

    @requests_storage.setter
    def requests_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_storage", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for secrets in namespace (string)
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for services load balancers in namespace (string)
        """
        return pulumi.get(self, "services_load_balancers")

    @services_load_balancers.setter
    def services_load_balancers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_load_balancers", value)

    @property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for services node ports in namespace (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        return pulumi.get(self, "services_node_ports")

    @services_node_ports.setter
    def services_node_ports(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_node_ports", value)


if not MYPY:
    class NodePoolNodeTaintArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Taint key (string)
        """
        value: pulumi.Input[str]
        """
        Taint value (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        """
        time_added: NotRequired[pulumi.Input[str]]
        """
        Taint time added (string)
        """
elif False:
    NodePoolNodeTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodePoolNodeTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 time_added: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Taint key (string)
        :param pulumi.Input[str] value: Taint value (string)
        :param pulumi.Input[str] effect: Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        :param pulumi.Input[str] time_added: Taint time added (string)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if time_added is not None:
            pulumi.set(__self__, "time_added", time_added)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> Optional[pulumi.Input[str]]:
        """
        Taint time added (string)
        """
        return pulumi.get(self, "time_added")

    @time_added.setter
    def time_added(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_added", value)


if not MYPY:
    class NodeTemplateAmazonec2ConfigArgsDict(TypedDict):
        ami: pulumi.Input[str]
        """
        AWS machine image
        """
        region: pulumi.Input[str]
        """
        AWS Region
        """
        security_groups: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        AWS VPC security group
        """
        subnet_id: pulumi.Input[str]
        """
        AWS VPC subnet id
        """
        vpc_id: pulumi.Input[str]
        """
        AWS VPC id
        """
        zone: pulumi.Input[str]
        """
        AWS zone for instance (i.e. a,b,c,d,e)
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        AWS Access Key
        """
        block_duration_minutes: NotRequired[pulumi.Input[str]]
        """
        AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        """
        device_name: NotRequired[pulumi.Input[str]]
        """
        AWS root device name
        """
        encrypt_ebs_volume: NotRequired[pulumi.Input[bool]]
        """
        Encrypt EBS volume
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Optional endpoint URL (hostname only or fully qualified URI)
        """
        http_endpoint: NotRequired[pulumi.Input[str]]
        """
        Enables or disables the HTTP metadata endpoint on your instances
        """
        http_tokens: NotRequired[pulumi.Input[str]]
        """
        The state of token usage for your instance metadata requests
        """
        iam_instance_profile: NotRequired[pulumi.Input[str]]
        """
        AWS IAM Instance Profile
        """
        insecure_transport: NotRequired[pulumi.Input[bool]]
        """
        Disable SSL when sending requests
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        AWS instance type
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        Custom KMS key ID using the AWS Managed CMK
        """
        monitoring: NotRequired[pulumi.Input[bool]]
        """
        Set this flag to enable CloudWatch monitoring
        """
        open_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Make the specified port number accessible from the Internet
        """
        private_address_only: NotRequired[pulumi.Input[bool]]
        """
        Only use a private IP address
        """
        request_spot_instance: NotRequired[pulumi.Input[bool]]
        """
        Set this flag to request spot instance
        """
        retries: NotRequired[pulumi.Input[str]]
        """
        Set retry count for recoverable failures (use -1 to disable)
        """
        root_size: NotRequired[pulumi.Input[str]]
        """
        AWS root disk size (in GB)
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        AWS Secret Key
        """
        security_group_readonly: NotRequired[pulumi.Input[bool]]
        """
        Skip adding default rules to security groups
        """
        session_token: NotRequired[pulumi.Input[str]]
        """
        AWS Session Token
        """
        spot_price: NotRequired[pulumi.Input[str]]
        """
        AWS spot instance bid price (in dollar)
        """
        ssh_keypath: NotRequired[pulumi.Input[str]]
        """
        SSH Key for Instance
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        Set the name of the ssh user
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        AWS Tags (e.g. key1,value1,key2,value2)
        """
        use_ebs_optimized_instance: NotRequired[pulumi.Input[bool]]
        """
        Create an EBS optimized instance
        """
        use_private_address: NotRequired[pulumi.Input[bool]]
        """
        Force the usage of private IP address
        """
        userdata: NotRequired[pulumi.Input[str]]
        """
        Path to file with cloud-init user data
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        Amazon EBS volume type
        """
elif False:
    NodeTemplateAmazonec2ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateAmazonec2ConfigArgs:
    def __init__(__self__, *,
                 ami: pulumi.Input[str],
                 region: pulumi.Input[str],
                 security_groups: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnet_id: pulumi.Input[str],
                 vpc_id: pulumi.Input[str],
                 zone: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 block_duration_minutes: Optional[pulumi.Input[str]] = None,
                 device_name: Optional[pulumi.Input[str]] = None,
                 encrypt_ebs_volume: Optional[pulumi.Input[bool]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 http_endpoint: Optional[pulumi.Input[str]] = None,
                 http_tokens: Optional[pulumi.Input[str]] = None,
                 iam_instance_profile: Optional[pulumi.Input[str]] = None,
                 insecure_transport: Optional[pulumi.Input[bool]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 kms_key: Optional[pulumi.Input[str]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 open_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 private_address_only: Optional[pulumi.Input[bool]] = None,
                 request_spot_instance: Optional[pulumi.Input[bool]] = None,
                 retries: Optional[pulumi.Input[str]] = None,
                 root_size: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 security_group_readonly: Optional[pulumi.Input[bool]] = None,
                 session_token: Optional[pulumi.Input[str]] = None,
                 spot_price: Optional[pulumi.Input[str]] = None,
                 ssh_keypath: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 use_ebs_optimized_instance: Optional[pulumi.Input[bool]] = None,
                 use_private_address: Optional[pulumi.Input[bool]] = None,
                 userdata: Optional[pulumi.Input[str]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ami: AWS machine image
        :param pulumi.Input[str] region: AWS Region
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: AWS VPC security group
        :param pulumi.Input[str] subnet_id: AWS VPC subnet id
        :param pulumi.Input[str] vpc_id: AWS VPC id
        :param pulumi.Input[str] zone: AWS zone for instance (i.e. a,b,c,d,e)
        :param pulumi.Input[str] access_key: AWS Access Key
        :param pulumi.Input[str] block_duration_minutes: AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        :param pulumi.Input[str] device_name: AWS root device name
        :param pulumi.Input[bool] encrypt_ebs_volume: Encrypt EBS volume
        :param pulumi.Input[str] endpoint: Optional endpoint URL (hostname only or fully qualified URI)
        :param pulumi.Input[str] http_endpoint: Enables or disables the HTTP metadata endpoint on your instances
        :param pulumi.Input[str] http_tokens: The state of token usage for your instance metadata requests
        :param pulumi.Input[str] iam_instance_profile: AWS IAM Instance Profile
        :param pulumi.Input[bool] insecure_transport: Disable SSL when sending requests
        :param pulumi.Input[str] instance_type: AWS instance type
        :param pulumi.Input[str] kms_key: Custom KMS key ID using the AWS Managed CMK
        :param pulumi.Input[bool] monitoring: Set this flag to enable CloudWatch monitoring
        :param pulumi.Input[Sequence[pulumi.Input[str]]] open_ports: Make the specified port number accessible from the Internet
        :param pulumi.Input[bool] private_address_only: Only use a private IP address
        :param pulumi.Input[bool] request_spot_instance: Set this flag to request spot instance
        :param pulumi.Input[str] retries: Set retry count for recoverable failures (use -1 to disable)
        :param pulumi.Input[str] root_size: AWS root disk size (in GB)
        :param pulumi.Input[str] secret_key: AWS Secret Key
        :param pulumi.Input[bool] security_group_readonly: Skip adding default rules to security groups
        :param pulumi.Input[str] session_token: AWS Session Token
        :param pulumi.Input[str] spot_price: AWS spot instance bid price (in dollar)
        :param pulumi.Input[str] ssh_keypath: SSH Key for Instance
        :param pulumi.Input[str] ssh_user: Set the name of the ssh user
        :param pulumi.Input[str] tags: AWS Tags (e.g. key1,value1,key2,value2)
        :param pulumi.Input[bool] use_ebs_optimized_instance: Create an EBS optimized instance
        :param pulumi.Input[bool] use_private_address: Force the usage of private IP address
        :param pulumi.Input[str] userdata: Path to file with cloud-init user data
        :param pulumi.Input[str] volume_type: Amazon EBS volume type
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone", zone)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypt_ebs_volume is not None:
            pulumi.set(__self__, "encrypt_ebs_volume", encrypt_ebs_volume)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if insecure_transport is not None:
            pulumi.set(__self__, "insecure_transport", insecure_transport)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if private_address_only is not None:
            pulumi.set(__self__, "private_address_only", private_address_only)
        if request_spot_instance is not None:
            pulumi.set(__self__, "request_spot_instance", request_spot_instance)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if security_group_readonly is not None:
            pulumi.set(__self__, "security_group_readonly", security_group_readonly)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if ssh_keypath is not None:
            pulumi.set(__self__, "ssh_keypath", ssh_keypath)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_ebs_optimized_instance is not None:
            pulumi.set(__self__, "use_ebs_optimized_instance", use_ebs_optimized_instance)
        if use_private_address is not None:
            pulumi.set(__self__, "use_private_address", use_private_address)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter
    def ami(self) -> pulumi.Input[str]:
        """
        AWS machine image
        """
        return pulumi.get(self, "ami")

    @ami.setter
    def ami(self, value: pulumi.Input[str]):
        pulumi.set(self, "ami", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        AWS Region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        AWS VPC security group
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        AWS VPC subnet id
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[str]:
        """
        AWS VPC id
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc_id", value)

    @property
    @pulumi.getter
    def zone(self) -> pulumi.Input[str]:
        """
        AWS zone for instance (i.e. a,b,c,d,e)
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "zone", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[str]]:
        """
        AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        """
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "block_duration_minutes", value)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS root device name
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter(name="encryptEbsVolume")
    def encrypt_ebs_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Encrypt EBS volume
        """
        return pulumi.get(self, "encrypt_ebs_volume")

    @encrypt_ebs_volume.setter
    def encrypt_ebs_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "encrypt_ebs_volume", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Optional endpoint URL (hostname only or fully qualified URI)
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Enables or disables the HTTP metadata endpoint on your instances
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_endpoint", value)

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[str]]:
        """
        The state of token usage for your instance metadata requests
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_tokens", value)

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[pulumi.Input[str]]:
        """
        AWS IAM Instance Profile
        """
        return pulumi.get(self, "iam_instance_profile")

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_instance_profile", value)

    @property
    @pulumi.getter(name="insecureTransport")
    def insecure_transport(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable SSL when sending requests
        """
        return pulumi.get(self, "insecure_transport")

    @insecure_transport.setter
    def insecure_transport(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_transport", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        AWS instance type
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        Custom KMS key ID using the AWS Managed CMK
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this flag to enable CloudWatch monitoring
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @open_ports.setter
    def open_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "open_ports", value)

    @property
    @pulumi.getter(name="privateAddressOnly")
    def private_address_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Only use a private IP address
        """
        return pulumi.get(self, "private_address_only")

    @private_address_only.setter
    def private_address_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_address_only", value)

    @property
    @pulumi.getter(name="requestSpotInstance")
    def request_spot_instance(self) -> Optional[pulumi.Input[bool]]:
        """
        Set this flag to request spot instance
        """
        return pulumi.get(self, "request_spot_instance")

    @request_spot_instance.setter
    def request_spot_instance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "request_spot_instance", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[str]]:
        """
        Set retry count for recoverable failures (use -1 to disable)
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[pulumi.Input[str]]:
        """
        AWS root disk size (in GB)
        """
        return pulumi.get(self, "root_size")

    @root_size.setter
    def root_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_size", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="securityGroupReadonly")
    def security_group_readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        Skip adding default rules to security groups
        """
        return pulumi.get(self, "security_group_readonly")

    @security_group_readonly.setter
    def security_group_readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "security_group_readonly", value)

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Session Token
        """
        return pulumi.get(self, "session_token")

    @session_token.setter
    def session_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_token", value)

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[str]]:
        """
        AWS spot instance bid price (in dollar)
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "spot_price", value)

    @property
    @pulumi.getter(name="sshKeypath")
    def ssh_keypath(self) -> Optional[pulumi.Input[str]]:
        """
        SSH Key for Instance
        """
        return pulumi.get(self, "ssh_keypath")

    @ssh_keypath.setter
    def ssh_keypath(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_keypath", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        Set the name of the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Tags (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="useEbsOptimizedInstance")
    def use_ebs_optimized_instance(self) -> Optional[pulumi.Input[bool]]:
        """
        Create an EBS optimized instance
        """
        return pulumi.get(self, "use_ebs_optimized_instance")

    @use_ebs_optimized_instance.setter
    def use_ebs_optimized_instance(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_ebs_optimized_instance", value)

    @property
    @pulumi.getter(name="usePrivateAddress")
    def use_private_address(self) -> Optional[pulumi.Input[bool]]:
        """
        Force the usage of private IP address
        """
        return pulumi.get(self, "use_private_address")

    @use_private_address.setter
    def use_private_address(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_private_address", value)

    @property
    @pulumi.getter
    def userdata(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with cloud-init user data
        """
        return pulumi.get(self, "userdata")

    @userdata.setter
    def userdata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userdata", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Amazon EBS volume type
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class NodeTemplateAzureConfigArgsDict(TypedDict):
        accelerated_networking: NotRequired[pulumi.Input[bool]]
        """
        Enable Accelerated Networking when creating an Azure Network Interface
        """
        availability_set: NotRequired[pulumi.Input[str]]
        """
        Azure Availability Set to place the virtual machine into
        """
        availability_zone: NotRequired[pulumi.Input[str]]
        """
        The Azure Availability Zone the VM should be created in
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        Azure Service Principal Account ID (optional, browser auth is used if not specified)
        """
        client_secret: NotRequired[pulumi.Input[str]]
        """
        Azure Service Principal Account password (optional, browser auth is used if not specified)
        """
        custom_data: NotRequired[pulumi.Input[str]]
        """
        Path to file with custom-data
        """
        disk_size: NotRequired[pulumi.Input[str]]
        """
        Disk size if using managed disk
        """
        dns: NotRequired[pulumi.Input[str]]
        """
        A unique DNS label for the public IP adddress
        """
        docker_port: NotRequired[pulumi.Input[str]]
        """
        Port number for Docker engine
        """
        environment: NotRequired[pulumi.Input[str]]
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        fault_domain_count: NotRequired[pulumi.Input[str]]
        """
        Fault domain count to use for availability set
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Azure virtual machine OS image
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Azure region to create the virtual machine
        """
        managed_disks: NotRequired[pulumi.Input[bool]]
        """
        Configures VM and availability set for managed disks
        """
        no_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Do not create a public IP address for the machine
        """
        nsg: NotRequired[pulumi.Input[str]]
        """
        Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        """
        open_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Make the specified port number accessible from the Internet
        """
        plan: NotRequired[pulumi.Input[str]]
        """
        Purchase plan for Azure Virtual Machine (in <publisher>:<product>:<plan> format)
        """
        private_ip_address: NotRequired[pulumi.Input[str]]
        """
        Specify a static private IP address for the machine
        """
        resource_group: NotRequired[pulumi.Input[str]]
        """
        Azure Resource Group name (will be created if missing)
        """
        size: NotRequired[pulumi.Input[str]]
        """
        Size for Azure Virtual Machine
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        Username for SSH login
        """
        static_public_ip: NotRequired[pulumi.Input[bool]]
        """
        Assign a static public IP address to the machine
        """
        storage_type: NotRequired[pulumi.Input[str]]
        """
        Type of Storage Account to host the OS Disk for the machine
        """
        subnet: NotRequired[pulumi.Input[str]]
        """
        Azure Subnet Name to be used within the Virtual Network
        """
        subnet_prefix: NotRequired[pulumi.Input[str]]
        """
        Private CIDR block to be used for the new subnet, should comply RFC 1918
        """
        subscription_id: NotRequired[pulumi.Input[str]]
        """
        Azure Subscription ID
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        """
        update_domain_count: NotRequired[pulumi.Input[str]]
        """
        Update domain count to use for availability set
        """
        use_private_ip: NotRequired[pulumi.Input[bool]]
        """
        Use private IP address of the machine to connect
        """
        use_public_ip_standard_sku: NotRequired[pulumi.Input[bool]]
        """
        Use the Standard SKU when creating a public IP for an Azure VM
        """
        vnet: NotRequired[pulumi.Input[str]]
        """
        Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
elif False:
    NodeTemplateAzureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateAzureConfigArgs:
    def __init__(__self__, *,
                 accelerated_networking: Optional[pulumi.Input[bool]] = None,
                 availability_set: Optional[pulumi.Input[str]] = None,
                 availability_zone: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_secret: Optional[pulumi.Input[str]] = None,
                 custom_data: Optional[pulumi.Input[str]] = None,
                 disk_size: Optional[pulumi.Input[str]] = None,
                 dns: Optional[pulumi.Input[str]] = None,
                 docker_port: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 fault_domain_count: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 managed_disks: Optional[pulumi.Input[bool]] = None,
                 no_public_ip: Optional[pulumi.Input[bool]] = None,
                 nsg: Optional[pulumi.Input[str]] = None,
                 open_ports: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 plan: Optional[pulumi.Input[str]] = None,
                 private_ip_address: Optional[pulumi.Input[str]] = None,
                 resource_group: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 static_public_ip: Optional[pulumi.Input[bool]] = None,
                 storage_type: Optional[pulumi.Input[str]] = None,
                 subnet: Optional[pulumi.Input[str]] = None,
                 subnet_prefix: Optional[pulumi.Input[str]] = None,
                 subscription_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 update_domain_count: Optional[pulumi.Input[str]] = None,
                 use_private_ip: Optional[pulumi.Input[bool]] = None,
                 use_public_ip_standard_sku: Optional[pulumi.Input[bool]] = None,
                 vnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] accelerated_networking: Enable Accelerated Networking when creating an Azure Network Interface
        :param pulumi.Input[str] availability_set: Azure Availability Set to place the virtual machine into
        :param pulumi.Input[str] availability_zone: The Azure Availability Zone the VM should be created in
        :param pulumi.Input[str] client_id: Azure Service Principal Account ID (optional, browser auth is used if not specified)
        :param pulumi.Input[str] client_secret: Azure Service Principal Account password (optional, browser auth is used if not specified)
        :param pulumi.Input[str] custom_data: Path to file with custom-data
        :param pulumi.Input[str] disk_size: Disk size if using managed disk
        :param pulumi.Input[str] dns: A unique DNS label for the public IP adddress
        :param pulumi.Input[str] docker_port: Port number for Docker engine
        :param pulumi.Input[str] environment: Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        :param pulumi.Input[str] fault_domain_count: Fault domain count to use for availability set
        :param pulumi.Input[str] image: Azure virtual machine OS image
        :param pulumi.Input[str] location: Azure region to create the virtual machine
        :param pulumi.Input[bool] managed_disks: Configures VM and availability set for managed disks
        :param pulumi.Input[bool] no_public_ip: Do not create a public IP address for the machine
        :param pulumi.Input[str] nsg: Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] open_ports: Make the specified port number accessible from the Internet
        :param pulumi.Input[str] plan: Purchase plan for Azure Virtual Machine (in <publisher>:<product>:<plan> format)
        :param pulumi.Input[str] private_ip_address: Specify a static private IP address for the machine
        :param pulumi.Input[str] resource_group: Azure Resource Group name (will be created if missing)
        :param pulumi.Input[str] size: Size for Azure Virtual Machine
        :param pulumi.Input[str] ssh_user: Username for SSH login
        :param pulumi.Input[bool] static_public_ip: Assign a static public IP address to the machine
        :param pulumi.Input[str] storage_type: Type of Storage Account to host the OS Disk for the machine
        :param pulumi.Input[str] subnet: Azure Subnet Name to be used within the Virtual Network
        :param pulumi.Input[str] subnet_prefix: Private CIDR block to be used for the new subnet, should comply RFC 1918
        :param pulumi.Input[str] subscription_id: Azure Subscription ID
        :param pulumi.Input[str] tags: Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        :param pulumi.Input[str] update_domain_count: Update domain count to use for availability set
        :param pulumi.Input[bool] use_private_ip: Use private IP address of the machine to connect
        :param pulumi.Input[bool] use_public_ip_standard_sku: Use the Standard SKU when creating a public IP for an Azure VM
        :param pulumi.Input[str] vnet: Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if availability_set is not None:
            pulumi.set(__self__, "availability_set", availability_set)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if fault_domain_count is not None:
            pulumi.set(__self__, "fault_domain_count", fault_domain_count)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if managed_disks is not None:
            pulumi.set(__self__, "managed_disks", managed_disks)
        if no_public_ip is not None:
            pulumi.set(__self__, "no_public_ip", no_public_ip)
        if nsg is not None:
            pulumi.set(__self__, "nsg", nsg)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if static_public_ip is not None:
            pulumi.set(__self__, "static_public_ip", static_public_ip)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_prefix is not None:
            pulumi.set(__self__, "subnet_prefix", subnet_prefix)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if update_domain_count is not None:
            pulumi.set(__self__, "update_domain_count", update_domain_count)
        if use_private_ip is not None:
            pulumi.set(__self__, "use_private_ip", use_private_ip)
        if use_public_ip_standard_sku is not None:
            pulumi.set(__self__, "use_public_ip_standard_sku", use_public_ip_standard_sku)
        if vnet is not None:
            pulumi.set(__self__, "vnet", vnet)

    @property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Accelerated Networking when creating an Azure Network Interface
        """
        return pulumi.get(self, "accelerated_networking")

    @accelerated_networking.setter
    def accelerated_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "accelerated_networking", value)

    @property
    @pulumi.getter(name="availabilitySet")
    def availability_set(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Availability Set to place the virtual machine into
        """
        return pulumi.get(self, "availability_set")

    @availability_set.setter
    def availability_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_set", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Availability Zone the VM should be created in
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Service Principal Account ID (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Service Principal Account password (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_secret", value)

    @property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with custom-data
        """
        return pulumi.get(self, "custom_data")

    @custom_data.setter
    def custom_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_data", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Disk size if using managed disk
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter
    def dns(self) -> Optional[pulumi.Input[str]]:
        """
        A unique DNS label for the public IP adddress
        """
        return pulumi.get(self, "dns")

    @dns.setter
    def dns(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns", value)

    @property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[pulumi.Input[str]]:
        """
        Port number for Docker engine
        """
        return pulumi.get(self, "docker_port")

    @docker_port.setter
    def docker_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_port", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="faultDomainCount")
    def fault_domain_count(self) -> Optional[pulumi.Input[str]]:
        """
        Fault domain count to use for availability set
        """
        return pulumi.get(self, "fault_domain_count")

    @fault_domain_count.setter
    def fault_domain_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fault_domain_count", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Azure virtual machine OS image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Azure region to create the virtual machine
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="managedDisks")
    def managed_disks(self) -> Optional[pulumi.Input[bool]]:
        """
        Configures VM and availability set for managed disks
        """
        return pulumi.get(self, "managed_disks")

    @managed_disks.setter
    def managed_disks(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "managed_disks", value)

    @property
    @pulumi.getter(name="noPublicIp")
    def no_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Do not create a public IP address for the machine
        """
        return pulumi.get(self, "no_public_ip")

    @no_public_ip.setter
    def no_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "no_public_ip", value)

    @property
    @pulumi.getter
    def nsg(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        """
        return pulumi.get(self, "nsg")

    @nsg.setter
    def nsg(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nsg", value)

    @property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @open_ports.setter
    def open_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "open_ports", value)

    @property
    @pulumi.getter
    def plan(self) -> Optional[pulumi.Input[str]]:
        """
        Purchase plan for Azure Virtual Machine (in <publisher>:<product>:<plan> format)
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[str]]:
        """
        Specify a static private IP address for the machine
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_ip_address", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Resource Group name (will be created if missing)
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Size for Azure Virtual Machine
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        Username for SSH login
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="staticPublicIp")
    def static_public_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Assign a static public IP address to the machine
        """
        return pulumi.get(self, "static_public_ip")

    @static_public_ip.setter
    def static_public_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "static_public_ip", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of Storage Account to host the OS Disk for the machine
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Subnet Name to be used within the Virtual Network
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="subnetPrefix")
    def subnet_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Private CIDR block to be used for the new subnet, should comply RFC 1918
        """
        return pulumi.get(self, "subnet_prefix")

    @subnet_prefix.setter
    def subnet_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_prefix", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Subscription ID
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updateDomainCount")
    def update_domain_count(self) -> Optional[pulumi.Input[str]]:
        """
        Update domain count to use for availability set
        """
        return pulumi.get(self, "update_domain_count")

    @update_domain_count.setter
    def update_domain_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_domain_count", value)

    @property
    @pulumi.getter(name="usePrivateIp")
    def use_private_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Use private IP address of the machine to connect
        """
        return pulumi.get(self, "use_private_ip")

    @use_private_ip.setter
    def use_private_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_private_ip", value)

    @property
    @pulumi.getter(name="usePublicIpStandardSku")
    def use_public_ip_standard_sku(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the Standard SKU when creating a public IP for an Azure VM
        """
        return pulumi.get(self, "use_public_ip_standard_sku")

    @use_public_ip_standard_sku.setter
    def use_public_ip_standard_sku(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_public_ip_standard_sku", value)

    @property
    @pulumi.getter
    def vnet(self) -> Optional[pulumi.Input[str]]:
        """
        Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        return pulumi.get(self, "vnet")

    @vnet.setter
    def vnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vnet", value)


if not MYPY:
    class NodeTemplateDigitaloceanConfigArgsDict(TypedDict):
        access_token: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean access token
        """
        backups: NotRequired[pulumi.Input[bool]]
        """
        Enable backups for droplet
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean Image
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        """
        Enable ipv6 for droplet
        """
        monitoring: NotRequired[pulumi.Input[bool]]
        """
        Enable monitoring for droplet
        """
        private_networking: NotRequired[pulumi.Input[bool]]
        """
        Enable private networking for droplet
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean region
        """
        size: NotRequired[pulumi.Input[str]]
        """
        Digital Ocean size
        """
        ssh_key_fingerprint: NotRequired[pulumi.Input[str]]
        """
        SSH key fingerprint
        """
        ssh_key_path: NotRequired[pulumi.Input[str]]
        """
        SSH private key path
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        SSH port
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        SSH username
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of tags to apply to the Droplet
        """
        userdata: NotRequired[pulumi.Input[str]]
        """
        Path to file with cloud-init user-data
        """
elif False:
    NodeTemplateDigitaloceanConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateDigitaloceanConfigArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[str]] = None,
                 backups: Optional[pulumi.Input[bool]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 monitoring: Optional[pulumi.Input[bool]] = None,
                 private_networking: Optional[pulumi.Input[bool]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 size: Optional[pulumi.Input[str]] = None,
                 ssh_key_fingerprint: Optional[pulumi.Input[str]] = None,
                 ssh_key_path: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 userdata: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_token: Digital Ocean access token
        :param pulumi.Input[bool] backups: Enable backups for droplet
        :param pulumi.Input[str] image: Digital Ocean Image
        :param pulumi.Input[bool] ipv6: Enable ipv6 for droplet
        :param pulumi.Input[bool] monitoring: Enable monitoring for droplet
        :param pulumi.Input[bool] private_networking: Enable private networking for droplet
        :param pulumi.Input[str] region: Digital Ocean region
        :param pulumi.Input[str] size: Digital Ocean size
        :param pulumi.Input[str] ssh_key_fingerprint: SSH key fingerprint
        :param pulumi.Input[str] ssh_key_path: SSH private key path
        :param pulumi.Input[str] ssh_port: SSH port
        :param pulumi.Input[str] ssh_user: SSH username
        :param pulumi.Input[str] tags: Comma-separated list of tags to apply to the Droplet
        :param pulumi.Input[str] userdata: Path to file with cloud-init user-data
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if backups is not None:
            pulumi.set(__self__, "backups", backups)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if private_networking is not None:
            pulumi.set(__self__, "private_networking", private_networking)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_fingerprint is not None:
            pulumi.set(__self__, "ssh_key_fingerprint", ssh_key_fingerprint)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean access token
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter
    def backups(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable backups for droplet
        """
        return pulumi.get(self, "backups")

    @backups.setter
    def backups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "backups", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean Image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable ipv6 for droplet
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable monitoring for droplet
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "monitoring", value)

    @property
    @pulumi.getter(name="privateNetworking")
    def private_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable private networking for droplet
        """
        return pulumi.get(self, "private_networking")

    @private_networking.setter
    def private_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "private_networking", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[str]]:
        """
        Digital Ocean size
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshKeyFingerprint")
    def ssh_key_fingerprint(self) -> Optional[pulumi.Input[str]]:
        """
        SSH key fingerprint
        """
        return pulumi.get(self, "ssh_key_fingerprint")

    @ssh_key_fingerprint.setter
    def ssh_key_fingerprint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_fingerprint", value)

    @property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[pulumi.Input[str]]:
        """
        SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @ssh_key_path.setter
    def ssh_key_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_key_path", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        SSH port
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of tags to apply to the Droplet
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def userdata(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with cloud-init user-data
        """
        return pulumi.get(self, "userdata")

    @userdata.setter
    def userdata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userdata", value)


if not MYPY:
    class NodeTemplateHarvesterConfigArgsDict(TypedDict):
        ssh_user: pulumi.Input[str]
        """
        SSH username
        """
        vm_namespace: pulumi.Input[str]
        """
        Virtual machine namespace
        """
        cpu_count: NotRequired[pulumi.Input[str]]
        """
        CPU count
        """
        disk_bus: NotRequired[pulumi.Input[str]]
        """
        Disk bus
        """
        disk_info: NotRequired[pulumi.Input[str]]
        """
        A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        """
        disk_size: NotRequired[pulumi.Input[str]]
        """
        Disk size (in GiB)
        """
        image_name: NotRequired[pulumi.Input[str]]
        """
        Image name
        """
        memory_size: NotRequired[pulumi.Input[str]]
        """
        Memory size (in GiB)
        """
        network_data: NotRequired[pulumi.Input[str]]
        """
        NetworkData content of cloud-init, base64 is supported
        """
        network_info: NotRequired[pulumi.Input[str]]
        """
        A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        """
        network_model: NotRequired[pulumi.Input[str]]
        """
        Network model
        """
        network_name: NotRequired[pulumi.Input[str]]
        """
        Network name
        """
        ssh_password: NotRequired[pulumi.Input[str]]
        """
        SSH password
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        """
        vm_affinity: NotRequired[pulumi.Input[str]]
        """
        VM affinity, base64 is supported
        """
elif False:
    NodeTemplateHarvesterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateHarvesterConfigArgs:
    def __init__(__self__, *,
                 ssh_user: pulumi.Input[str],
                 vm_namespace: pulumi.Input[str],
                 cpu_count: Optional[pulumi.Input[str]] = None,
                 disk_bus: Optional[pulumi.Input[str]] = None,
                 disk_info: Optional[pulumi.Input[str]] = None,
                 disk_size: Optional[pulumi.Input[str]] = None,
                 image_name: Optional[pulumi.Input[str]] = None,
                 memory_size: Optional[pulumi.Input[str]] = None,
                 network_data: Optional[pulumi.Input[str]] = None,
                 network_info: Optional[pulumi.Input[str]] = None,
                 network_model: Optional[pulumi.Input[str]] = None,
                 network_name: Optional[pulumi.Input[str]] = None,
                 ssh_password: Optional[pulumi.Input[str]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vm_affinity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ssh_user: SSH username
        :param pulumi.Input[str] vm_namespace: Virtual machine namespace
        :param pulumi.Input[str] cpu_count: CPU count
        :param pulumi.Input[str] disk_bus: Disk bus
        :param pulumi.Input[str] disk_info: A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        :param pulumi.Input[str] disk_size: Disk size (in GiB)
        :param pulumi.Input[str] image_name: Image name
        :param pulumi.Input[str] memory_size: Memory size (in GiB)
        :param pulumi.Input[str] network_data: NetworkData content of cloud-init, base64 is supported
        :param pulumi.Input[str] network_info: A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        :param pulumi.Input[str] network_model: Network model
        :param pulumi.Input[str] network_name: Network name
        :param pulumi.Input[str] ssh_password: SSH password
        :param pulumi.Input[str] user_data: UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        :param pulumi.Input[str] vm_affinity: VM affinity, base64 is supported
        """
        pulumi.set(__self__, "ssh_user", ssh_user)
        pulumi.set(__self__, "vm_namespace", vm_namespace)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if disk_bus is not None:
            warnings.warn("""Use disk_info instead""", DeprecationWarning)
            pulumi.log.warn("""disk_bus is deprecated: Use disk_info instead""")
        if disk_bus is not None:
            pulumi.set(__self__, "disk_bus", disk_bus)
        if disk_info is not None:
            pulumi.set(__self__, "disk_info", disk_info)
        if disk_size is not None:
            warnings.warn("""Use disk_info instead""", DeprecationWarning)
            pulumi.log.warn("""disk_size is deprecated: Use disk_info instead""")
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if image_name is not None:
            warnings.warn("""Use disk_info instead""", DeprecationWarning)
            pulumi.log.warn("""image_name is deprecated: Use disk_info instead""")
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if network_data is not None:
            pulumi.set(__self__, "network_data", network_data)
        if network_info is not None:
            pulumi.set(__self__, "network_info", network_info)
        if network_model is not None:
            warnings.warn("""Use network_info instead""", DeprecationWarning)
            pulumi.log.warn("""network_model is deprecated: Use network_info instead""")
        if network_model is not None:
            pulumi.set(__self__, "network_model", network_model)
        if network_name is not None:
            warnings.warn("""Use network_info instead""", DeprecationWarning)
            pulumi.log.warn("""network_name is deprecated: Use network_info instead""")
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vm_affinity is not None:
            pulumi.set(__self__, "vm_affinity", vm_affinity)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> pulumi.Input[str]:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: pulumi.Input[str]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="vmNamespace")
    def vm_namespace(self) -> pulumi.Input[str]:
        """
        Virtual machine namespace
        """
        return pulumi.get(self, "vm_namespace")

    @vm_namespace.setter
    def vm_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "vm_namespace", value)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[str]]:
        """
        CPU count
        """
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="diskBus")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_bus(self) -> Optional[pulumi.Input[str]]:
        """
        Disk bus
        """
        return pulumi.get(self, "disk_bus")

    @disk_bus.setter
    def disk_bus(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_bus", value)

    @property
    @pulumi.getter(name="diskInfo")
    def disk_info(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        """
        return pulumi.get(self, "disk_info")

    @disk_info.setter
    def disk_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_info", value)

    @property
    @pulumi.getter(name="diskSize")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Disk size (in GiB)
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter(name="imageName")
    @_utilities.deprecated("""Use disk_info instead""")
    def image_name(self) -> Optional[pulumi.Input[str]]:
        """
        Image name
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[pulumi.Input[str]]:
        """
        Memory size (in GiB)
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_size", value)

    @property
    @pulumi.getter(name="networkData")
    def network_data(self) -> Optional[pulumi.Input[str]]:
        """
        NetworkData content of cloud-init, base64 is supported
        """
        return pulumi.get(self, "network_data")

    @network_data.setter
    def network_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_data", value)

    @property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        """
        return pulumi.get(self, "network_info")

    @network_info.setter
    def network_info(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_info", value)

    @property
    @pulumi.getter(name="networkModel")
    @_utilities.deprecated("""Use network_info instead""")
    def network_model(self) -> Optional[pulumi.Input[str]]:
        """
        Network model
        """
        return pulumi.get(self, "network_model")

    @network_model.setter
    def network_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_model", value)

    @property
    @pulumi.getter(name="networkName")
    @_utilities.deprecated("""Use network_info instead""")
    def network_name(self) -> Optional[pulumi.Input[str]]:
        """
        Network name
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[pulumi.Input[str]]:
        """
        SSH password
        """
        return pulumi.get(self, "ssh_password")

    @ssh_password.setter
    def ssh_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_password", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="vmAffinity")
    def vm_affinity(self) -> Optional[pulumi.Input[str]]:
        """
        VM affinity, base64 is supported
        """
        return pulumi.get(self, "vm_affinity")

    @vm_affinity.setter
    def vm_affinity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vm_affinity", value)


if not MYPY:
    class NodeTemplateHetznerConfigArgsDict(TypedDict):
        api_token: pulumi.Input[str]
        """
        Hetzner Cloud project API token
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Hetzner Cloud server image
        """
        networks: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of network IDs or names which should be attached to the server private network interface
        """
        server_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Map of the labels which will be assigned to the server
        """
        server_location: NotRequired[pulumi.Input[str]]
        """
        Hetzner Cloud datacenter
        """
        server_type: NotRequired[pulumi.Input[str]]
        """
        Hetzner Cloud server type
        """
        use_private_network: NotRequired[pulumi.Input[bool]]
        """
        Use private network
        """
        userdata: NotRequired[pulumi.Input[str]]
        """
        Path to file with cloud-init user-data
        """
        volumes: NotRequired[pulumi.Input[str]]
        """
        Comma-separated list of volume IDs or names which should be attached to the server
        """
elif False:
    NodeTemplateHetznerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateHetznerConfigArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input[str],
                 image: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[str]] = None,
                 server_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 server_location: Optional[pulumi.Input[str]] = None,
                 server_type: Optional[pulumi.Input[str]] = None,
                 use_private_network: Optional[pulumi.Input[bool]] = None,
                 userdata: Optional[pulumi.Input[str]] = None,
                 volumes: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_token: Hetzner Cloud project API token
        :param pulumi.Input[str] image: Hetzner Cloud server image
        :param pulumi.Input[str] networks: Comma-separated list of network IDs or names which should be attached to the server private network interface
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] server_labels: Map of the labels which will be assigned to the server
        :param pulumi.Input[str] server_location: Hetzner Cloud datacenter
        :param pulumi.Input[str] server_type: Hetzner Cloud server type
        :param pulumi.Input[bool] use_private_network: Use private network
        :param pulumi.Input[str] userdata: Path to file with cloud-init user-data
        :param pulumi.Input[str] volumes: Comma-separated list of volume IDs or names which should be attached to the server
        """
        pulumi.set(__self__, "api_token", api_token)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if server_labels is not None:
            pulumi.set(__self__, "server_labels", server_labels)
        if server_location is not None:
            pulumi.set(__self__, "server_location", server_location)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if use_private_network is not None:
            pulumi.set(__self__, "use_private_network", use_private_network)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input[str]:
        """
        Hetzner Cloud project API token
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_token", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Hetzner Cloud server image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of network IDs or names which should be attached to the server private network interface
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter(name="serverLabels")
    def server_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Map of the labels which will be assigned to the server
        """
        return pulumi.get(self, "server_labels")

    @server_labels.setter
    def server_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "server_labels", value)

    @property
    @pulumi.getter(name="serverLocation")
    def server_location(self) -> Optional[pulumi.Input[str]]:
        """
        Hetzner Cloud datacenter
        """
        return pulumi.get(self, "server_location")

    @server_location.setter
    def server_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_location", value)

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[pulumi.Input[str]]:
        """
        Hetzner Cloud server type
        """
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_type", value)

    @property
    @pulumi.getter(name="usePrivateNetwork")
    def use_private_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Use private network
        """
        return pulumi.get(self, "use_private_network")

    @use_private_network.setter
    def use_private_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_private_network", value)

    @property
    @pulumi.getter
    def userdata(self) -> Optional[pulumi.Input[str]]:
        """
        Path to file with cloud-init user-data
        """
        return pulumi.get(self, "userdata")

    @userdata.setter
    def userdata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "userdata", value)

    @property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[str]]:
        """
        Comma-separated list of volume IDs or names which should be attached to the server
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class NodeTemplateLinodeConfigArgsDict(TypedDict):
        authorized_users: NotRequired[pulumi.Input[str]]
        """
        Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        """
        create_private_ip: NotRequired[pulumi.Input[bool]]
        """
        Create private IP for the instance
        """
        docker_port: NotRequired[pulumi.Input[str]]
        """
        Docker Port
        """
        image: NotRequired[pulumi.Input[str]]
        """
        Specifies the Linode Instance image which determines the OS distribution and base files
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        Linode Instance Label
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Specifies the region (location) of the Linode instance
        """
        root_pass: NotRequired[pulumi.Input[str]]
        """
        Root Password
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        Linode Instance SSH Port
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        """
        stackscript: NotRequired[pulumi.Input[str]]
        """
        Specifies the Linode StackScript to use to create the instance
        """
        stackscript_data: NotRequired[pulumi.Input[str]]
        """
        A JSON string specifying data for the selected StackScript
        """
        swap_size: NotRequired[pulumi.Input[str]]
        """
        Linode Instance Swap Size (MB)
        """
        tags: NotRequired[pulumi.Input[str]]
        """
        A comma separated list of tags to apply to the the Linode resource
        """
        token: NotRequired[pulumi.Input[str]]
        """
        Linode API Token
        """
        ua_prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix the User-Agent in Linode API calls with some 'product/version'
        """
elif False:
    NodeTemplateLinodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateLinodeConfigArgs:
    def __init__(__self__, *,
                 authorized_users: Optional[pulumi.Input[str]] = None,
                 create_private_ip: Optional[pulumi.Input[bool]] = None,
                 docker_port: Optional[pulumi.Input[str]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 root_pass: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 stackscript: Optional[pulumi.Input[str]] = None,
                 stackscript_data: Optional[pulumi.Input[str]] = None,
                 swap_size: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None,
                 ua_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authorized_users: Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        :param pulumi.Input[bool] create_private_ip: Create private IP for the instance
        :param pulumi.Input[str] docker_port: Docker Port
        :param pulumi.Input[str] image: Specifies the Linode Instance image which determines the OS distribution and base files
        :param pulumi.Input[str] instance_type: Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        :param pulumi.Input[str] label: Linode Instance Label
        :param pulumi.Input[str] region: Specifies the region (location) of the Linode instance
        :param pulumi.Input[str] root_pass: Root Password
        :param pulumi.Input[str] ssh_port: Linode Instance SSH Port
        :param pulumi.Input[str] ssh_user: Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        :param pulumi.Input[str] stackscript: Specifies the Linode StackScript to use to create the instance
        :param pulumi.Input[str] stackscript_data: A JSON string specifying data for the selected StackScript
        :param pulumi.Input[str] swap_size: Linode Instance Swap Size (MB)
        :param pulumi.Input[str] tags: A comma separated list of tags to apply to the the Linode resource
        :param pulumi.Input[str] token: Linode API Token
        :param pulumi.Input[str] ua_prefix: Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        if authorized_users is not None:
            pulumi.set(__self__, "authorized_users", authorized_users)
        if create_private_ip is not None:
            pulumi.set(__self__, "create_private_ip", create_private_ip)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if root_pass is not None:
            pulumi.set(__self__, "root_pass", root_pass)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if stackscript is not None:
            pulumi.set(__self__, "stackscript", stackscript)
        if stackscript_data is not None:
            pulumi.set(__self__, "stackscript_data", stackscript_data)
        if swap_size is not None:
            pulumi.set(__self__, "swap_size", swap_size)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if ua_prefix is not None:
            pulumi.set(__self__, "ua_prefix", ua_prefix)

    @property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[pulumi.Input[str]]:
        """
        Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        """
        return pulumi.get(self, "authorized_users")

    @authorized_users.setter
    def authorized_users(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authorized_users", value)

    @property
    @pulumi.getter(name="createPrivateIp")
    def create_private_ip(self) -> Optional[pulumi.Input[bool]]:
        """
        Create private IP for the instance
        """
        return pulumi.get(self, "create_private_ip")

    @create_private_ip.setter
    def create_private_ip(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_private_ip", value)

    @property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[pulumi.Input[str]]:
        """
        Docker Port
        """
        return pulumi.get(self, "docker_port")

    @docker_port.setter
    def docker_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "docker_port", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Linode Instance image which determines the OS distribution and base files
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Linode Instance Label
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the region (location) of the Linode instance
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="rootPass")
    def root_pass(self) -> Optional[pulumi.Input[str]]:
        """
        Root Password
        """
        return pulumi.get(self, "root_pass")

    @root_pass.setter
    def root_pass(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_pass", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        Linode Instance SSH Port
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter
    def stackscript(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the Linode StackScript to use to create the instance
        """
        return pulumi.get(self, "stackscript")

    @stackscript.setter
    def stackscript(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stackscript", value)

    @property
    @pulumi.getter(name="stackscriptData")
    def stackscript_data(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON string specifying data for the selected StackScript
        """
        return pulumi.get(self, "stackscript_data")

    @stackscript_data.setter
    def stackscript_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stackscript_data", value)

    @property
    @pulumi.getter(name="swapSize")
    def swap_size(self) -> Optional[pulumi.Input[str]]:
        """
        Linode Instance Swap Size (MB)
        """
        return pulumi.get(self, "swap_size")

    @swap_size.setter
    def swap_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "swap_size", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[str]]:
        """
        A comma separated list of tags to apply to the the Linode resource
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        Linode API Token
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="uaPrefix")
    def ua_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        return pulumi.get(self, "ua_prefix")

    @ua_prefix.setter
    def ua_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ua_prefix", value)


if not MYPY:
    class NodeTemplateNodeTaintArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Taint key (string)
        """
        value: pulumi.Input[str]
        """
        Taint value (string)
        """
        effect: NotRequired[pulumi.Input[str]]
        """
        Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        """
        time_added: NotRequired[pulumi.Input[str]]
        """
        Taint time added (string)
        """
elif False:
    NodeTemplateNodeTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateNodeTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None,
                 time_added: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Taint key (string)
        :param pulumi.Input[str] value: Taint value (string)
        :param pulumi.Input[str] effect: Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        :param pulumi.Input[str] time_added: Taint time added (string)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if time_added is not None:
            pulumi.set(__self__, "time_added", time_added)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Taint key (string)
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Taint value (string)
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> Optional[pulumi.Input[str]]:
        """
        Taint time added (string)
        """
        return pulumi.get(self, "time_added")

    @time_added.setter
    def time_added(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_added", value)


if not MYPY:
    class NodeTemplateOpennebulaConfigArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        user: pulumi.Input[str]
        """
        Set the user for the XML-RPC API authentication (string)
        """
        xml_rpc_url: pulumi.Input[str]
        """
        Set the url for the Opennebula XML-RPC API (string)
        """
        b2d_size: NotRequired[pulumi.Input[str]]
        """
        Size of the Volatile disk in MB - only for b2d (string)
        """
        cpu: NotRequired[pulumi.Input[str]]
        """
        CPU value for the VM (string)
        """
        dev_prefix: NotRequired[pulumi.Input[str]]
        """
        Dev prefix to use for the images. E.g.: 'vd', 'sd', 'hd' (string)
        """
        disable_vnc: NotRequired[pulumi.Input[bool]]
        """
        VNC is enabled by default. Disable it with this flag (bool)
        """
        disk_resize: NotRequired[pulumi.Input[str]]
        """
        Size of the disk for the VM in MB (string)
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        image_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        image_owner: NotRequired[pulumi.Input[str]]
        """
        Owner of the image to use as the VM OS (string)
        """
        memory: NotRequired[pulumi.Input[str]]
        """
        Size of the memory for the VM in MB (string)
        """
        network_id: NotRequired[pulumi.Input[str]]
        """
        Opennebula network ID to connect the machine to. Conflicts with `network_name` (string)
        """
        network_name: NotRequired[pulumi.Input[str]]
        """
        Opennebula network to connect the machine to. Conflicts with `network_id` (string)
        """
        network_owner: NotRequired[pulumi.Input[str]]
        """
        Opennebula user ID of the Network to connect the machine to (string)
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        """
        template_id: NotRequired[pulumi.Input[str]]
        """
        Opennebula template ID to use. Conflicts with `template_name` (string)
        """
        template_name: NotRequired[pulumi.Input[str]]
        """
        Name of the Opennbula template to use. Conflicts with `template_id` (string)
        """
        vcpu: NotRequired[pulumi.Input[str]]
        """
        VCPUs for the VM (string)

        > **Note:**: `Required*` denotes that one of image_name / image_id or template_name / template_id is required but you cannot combine them.
        """
elif False:
    NodeTemplateOpennebulaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateOpennebulaConfigArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 user: pulumi.Input[str],
                 xml_rpc_url: pulumi.Input[str],
                 b2d_size: Optional[pulumi.Input[str]] = None,
                 cpu: Optional[pulumi.Input[str]] = None,
                 dev_prefix: Optional[pulumi.Input[str]] = None,
                 disable_vnc: Optional[pulumi.Input[bool]] = None,
                 disk_resize: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 image_name: Optional[pulumi.Input[str]] = None,
                 image_owner: Optional[pulumi.Input[str]] = None,
                 memory: Optional[pulumi.Input[str]] = None,
                 network_id: Optional[pulumi.Input[str]] = None,
                 network_name: Optional[pulumi.Input[str]] = None,
                 network_owner: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 template_id: Optional[pulumi.Input[str]] = None,
                 template_name: Optional[pulumi.Input[str]] = None,
                 vcpu: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param pulumi.Input[str] user: Set the user for the XML-RPC API authentication (string)
        :param pulumi.Input[str] xml_rpc_url: Set the url for the Opennebula XML-RPC API (string)
        :param pulumi.Input[str] b2d_size: Size of the Volatile disk in MB - only for b2d (string)
        :param pulumi.Input[str] cpu: CPU value for the VM (string)
        :param pulumi.Input[str] dev_prefix: Dev prefix to use for the images. E.g.: 'vd', 'sd', 'hd' (string)
        :param pulumi.Input[bool] disable_vnc: VNC is enabled by default. Disable it with this flag (bool)
        :param pulumi.Input[str] disk_resize: Size of the disk for the VM in MB (string)
        :param pulumi.Input[str] image_id: OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        :param pulumi.Input[str] image_name: OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        :param pulumi.Input[str] image_owner: Owner of the image to use as the VM OS (string)
        :param pulumi.Input[str] memory: Size of the memory for the VM in MB (string)
        :param pulumi.Input[str] network_id: Opennebula network ID to connect the machine to. Conflicts with `network_name` (string)
        :param pulumi.Input[str] network_name: Opennebula network to connect the machine to. Conflicts with `network_id` (string)
        :param pulumi.Input[str] network_owner: Opennebula user ID of the Network to connect the machine to (string)
        :param pulumi.Input[str] ssh_user: If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        :param pulumi.Input[str] template_id: Opennebula template ID to use. Conflicts with `template_name` (string)
        :param pulumi.Input[str] template_name: Name of the Opennbula template to use. Conflicts with `template_id` (string)
        :param pulumi.Input[str] vcpu: VCPUs for the VM (string)
               
               > **Note:**: `Required*` denotes that one of image_name / image_id or template_name / template_id is required but you cannot combine them.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)
        pulumi.set(__self__, "xml_rpc_url", xml_rpc_url)
        if b2d_size is not None:
            pulumi.set(__self__, "b2d_size", b2d_size)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if dev_prefix is not None:
            pulumi.set(__self__, "dev_prefix", dev_prefix)
        if disable_vnc is not None:
            pulumi.set(__self__, "disable_vnc", disable_vnc)
        if disk_resize is not None:
            pulumi.set(__self__, "disk_resize", disk_resize)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if image_owner is not None:
            pulumi.set(__self__, "image_owner", image_owner)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if network_owner is not None:
            pulumi.set(__self__, "network_owner", network_owner)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)
        if vcpu is not None:
            pulumi.set(__self__, "vcpu", vcpu)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> pulumi.Input[str]:
        """
        Set the user for the XML-RPC API authentication (string)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[str]):
        pulumi.set(self, "user", value)

    @property
    @pulumi.getter(name="xmlRpcUrl")
    def xml_rpc_url(self) -> pulumi.Input[str]:
        """
        Set the url for the Opennebula XML-RPC API (string)
        """
        return pulumi.get(self, "xml_rpc_url")

    @xml_rpc_url.setter
    def xml_rpc_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "xml_rpc_url", value)

    @property
    @pulumi.getter(name="b2dSize")
    def b2d_size(self) -> Optional[pulumi.Input[str]]:
        """
        Size of the Volatile disk in MB - only for b2d (string)
        """
        return pulumi.get(self, "b2d_size")

    @b2d_size.setter
    def b2d_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "b2d_size", value)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[str]]:
        """
        CPU value for the VM (string)
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter(name="devPrefix")
    def dev_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Dev prefix to use for the images. E.g.: 'vd', 'sd', 'hd' (string)
        """
        return pulumi.get(self, "dev_prefix")

    @dev_prefix.setter
    def dev_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dev_prefix", value)

    @property
    @pulumi.getter(name="disableVnc")
    def disable_vnc(self) -> Optional[pulumi.Input[bool]]:
        """
        VNC is enabled by default. Disable it with this flag (bool)
        """
        return pulumi.get(self, "disable_vnc")

    @disable_vnc.setter
    def disable_vnc(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_vnc", value)

    @property
    @pulumi.getter(name="diskResize")
    def disk_resize(self) -> Optional[pulumi.Input[str]]:
        """
        Size of the disk for the VM in MB (string)
        """
        return pulumi.get(self, "disk_resize")

    @disk_resize.setter
    def disk_resize(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_resize", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="imageOwner")
    def image_owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of the image to use as the VM OS (string)
        """
        return pulumi.get(self, "image_owner")

    @image_owner.setter
    def image_owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_owner", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[str]]:
        """
        Size of the memory for the VM in MB (string)
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[pulumi.Input[str]]:
        """
        Opennebula network ID to connect the machine to. Conflicts with `network_name` (string)
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_id", value)

    @property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[pulumi.Input[str]]:
        """
        Opennebula network to connect the machine to. Conflicts with `network_id` (string)
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_name", value)

    @property
    @pulumi.getter(name="networkOwner")
    def network_owner(self) -> Optional[pulumi.Input[str]]:
        """
        Opennebula user ID of the Network to connect the machine to (string)
        """
        return pulumi.get(self, "network_owner")

    @network_owner.setter
    def network_owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network_owner", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[pulumi.Input[str]]:
        """
        Opennebula template ID to use. Conflicts with `template_name` (string)
        """
        return pulumi.get(self, "template_id")

    @template_id.setter
    def template_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_id", value)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Opennbula template to use. Conflicts with `template_id` (string)
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_name", value)

    @property
    @pulumi.getter
    def vcpu(self) -> Optional[pulumi.Input[str]]:
        """
        VCPUs for the VM (string)

        > **Note:**: `Required*` denotes that one of image_name / image_id or template_name / template_id is required but you cannot combine them.
        """
        return pulumi.get(self, "vcpu")

    @vcpu.setter
    def vcpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcpu", value)


if not MYPY:
    class NodeTemplateOpenstackConfigArgsDict(TypedDict):
        auth_url: pulumi.Input[str]
        """
        OpenStack authentication URL (string)
        """
        availability_zone: pulumi.Input[str]
        """
        OpenStack availability zone (string)
        """
        region: pulumi.Input[str]
        """
        AWS region. Default `eu-west-2` (string)
        """
        active_timeout: NotRequired[pulumi.Input[str]]
        """
        OpenStack active timeout Default `200` (string)
        """
        application_credential_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack application credential id. Conflicts with `application_credential_name` (string)
        """
        application_credential_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack application credential name. Conflicts with `application_credential_id` (string)
        """
        application_credential_secret: NotRequired[pulumi.Input[str]]
        """
        OpenStack application credential secret (string)
        """
        boot_from_volume: NotRequired[pulumi.Input[bool]]
        """
        Enable booting from volume. Default is `false` (bool)
        """
        cacert: NotRequired[pulumi.Input[str]]
        """
        CA certificate bundle to verify against (string)
        """
        config_drive: NotRequired[pulumi.Input[bool]]
        """
        Enables the OpenStack config drive for the instance. Default `false` (bool)
        """
        domain_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        """
        domain_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        """
        endpoint_type: NotRequired[pulumi.Input[str]]
        """
        OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        """
        flavor_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        """
        flavor_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        """
        floating_ip_pool: NotRequired[pulumi.Input[str]]
        """
        OpenStack floating IP pool to get an IP from to assign to the instance (string)
        """
        image_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        image_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        insecure: NotRequired[pulumi.Input[bool]]
        """
        Disable TLS credential checking. Default `false` (bool)
        """
        ip_version: NotRequired[pulumi.Input[str]]
        """
        OpenStack version of IP address assigned for the machine Default `4` (string)
        """
        keypair_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack keypair to use to SSH to the instance (string)
        """
        net_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        """
        net_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        """
        nova_network: NotRequired[pulumi.Input[bool]]
        """
        Use the nova networking services instead of neutron (string)
        """
        password: NotRequired[pulumi.Input[str]]
        """
        vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        private_key_file: NotRequired[pulumi.Input[str]]
        """
        Private key content to use for SSH (string)
        """
        sec_groups: NotRequired[pulumi.Input[str]]
        """
        OpenStack comma separated security groups for the machine (string)
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh port. Default `22`. From Rancher v2.3.3 (string)
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        """
        tenant_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack tenant id. Conflicts with `tenant_name` (string)
        """
        tenant_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack tenant name. Conflicts with `tenant_id` (string)
        """
        user_data_file: NotRequired[pulumi.Input[str]]
        """
        File containing an openstack userdata script (string)
        """
        username: NotRequired[pulumi.Input[str]]
        """
        vSphere username. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        volume_device_path: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)

        > **Note:**: `Required*` denotes that either the _name or _id is required but you cannot use both.

        > **Note:**: `Required**` denotes that either the _name or _id is required unless `application_credential_id` is defined.

        > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        """
        volume_id: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        volume_name: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        volume_size: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        """
        volume_type: NotRequired[pulumi.Input[str]]
        """
        OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
elif False:
    NodeTemplateOpenstackConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateOpenstackConfigArgs:
    def __init__(__self__, *,
                 auth_url: pulumi.Input[str],
                 availability_zone: pulumi.Input[str],
                 region: pulumi.Input[str],
                 active_timeout: Optional[pulumi.Input[str]] = None,
                 application_credential_id: Optional[pulumi.Input[str]] = None,
                 application_credential_name: Optional[pulumi.Input[str]] = None,
                 application_credential_secret: Optional[pulumi.Input[str]] = None,
                 boot_from_volume: Optional[pulumi.Input[bool]] = None,
                 cacert: Optional[pulumi.Input[str]] = None,
                 config_drive: Optional[pulumi.Input[bool]] = None,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 domain_name: Optional[pulumi.Input[str]] = None,
                 endpoint_type: Optional[pulumi.Input[str]] = None,
                 flavor_id: Optional[pulumi.Input[str]] = None,
                 flavor_name: Optional[pulumi.Input[str]] = None,
                 floating_ip_pool: Optional[pulumi.Input[str]] = None,
                 image_id: Optional[pulumi.Input[str]] = None,
                 image_name: Optional[pulumi.Input[str]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 ip_version: Optional[pulumi.Input[str]] = None,
                 keypair_name: Optional[pulumi.Input[str]] = None,
                 net_id: Optional[pulumi.Input[str]] = None,
                 net_name: Optional[pulumi.Input[str]] = None,
                 nova_network: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 private_key_file: Optional[pulumi.Input[str]] = None,
                 sec_groups: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 tenant_id: Optional[pulumi.Input[str]] = None,
                 tenant_name: Optional[pulumi.Input[str]] = None,
                 user_data_file: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 volume_device_path: Optional[pulumi.Input[str]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_name: Optional[pulumi.Input[str]] = None,
                 volume_size: Optional[pulumi.Input[str]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] auth_url: OpenStack authentication URL (string)
        :param pulumi.Input[str] availability_zone: OpenStack availability zone (string)
        :param pulumi.Input[str] region: AWS region. Default `eu-west-2` (string)
        :param pulumi.Input[str] active_timeout: OpenStack active timeout Default `200` (string)
        :param pulumi.Input[str] application_credential_id: OpenStack application credential id. Conflicts with `application_credential_name` (string)
        :param pulumi.Input[str] application_credential_name: OpenStack application credential name. Conflicts with `application_credential_id` (string)
        :param pulumi.Input[str] application_credential_secret: OpenStack application credential secret (string)
        :param pulumi.Input[bool] boot_from_volume: Enable booting from volume. Default is `false` (bool)
        :param pulumi.Input[str] cacert: CA certificate bundle to verify against (string)
        :param pulumi.Input[bool] config_drive: Enables the OpenStack config drive for the instance. Default `false` (bool)
        :param pulumi.Input[str] domain_id: OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        :param pulumi.Input[str] domain_name: OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        :param pulumi.Input[str] endpoint_type: OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        :param pulumi.Input[str] flavor_id: OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        :param pulumi.Input[str] flavor_name: OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        :param pulumi.Input[str] floating_ip_pool: OpenStack floating IP pool to get an IP from to assign to the instance (string)
        :param pulumi.Input[str] image_id: OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        :param pulumi.Input[str] image_name: OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        :param pulumi.Input[bool] insecure: Disable TLS credential checking. Default `false` (bool)
        :param pulumi.Input[str] ip_version: OpenStack version of IP address assigned for the machine Default `4` (string)
        :param pulumi.Input[str] keypair_name: OpenStack keypair to use to SSH to the instance (string)
        :param pulumi.Input[str] net_id: OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        :param pulumi.Input[str] net_name: OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        :param pulumi.Input[bool] nova_network: Use the nova networking services instead of neutron (string)
        :param pulumi.Input[str] password: vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param pulumi.Input[str] private_key_file: Private key content to use for SSH (string)
        :param pulumi.Input[str] sec_groups: OpenStack comma separated security groups for the machine (string)
        :param pulumi.Input[str] ssh_port: If using a non-B2D image you can specify the ssh port. Default `22`. From Rancher v2.3.3 (string)
        :param pulumi.Input[str] ssh_user: If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        :param pulumi.Input[str] tenant_id: OpenStack tenant id. Conflicts with `tenant_name` (string)
        :param pulumi.Input[str] tenant_name: OpenStack tenant name. Conflicts with `tenant_id` (string)
        :param pulumi.Input[str] user_data_file: File containing an openstack userdata script (string)
        :param pulumi.Input[str] username: vSphere username. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param pulumi.Input[str] volume_device_path: OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
               
               > **Note:**: `Required*` denotes that either the _name or _id is required but you cannot use both.
               
               > **Note:**: `Required**` denotes that either the _name or _id is required unless `application_credential_id` is defined.
               
               > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        :param pulumi.Input[str] volume_id: OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param pulumi.Input[str] volume_name: OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param pulumi.Input[str] volume_size: OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        :param pulumi.Input[str] volume_type: OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "region", region)
        if active_timeout is not None:
            pulumi.set(__self__, "active_timeout", active_timeout)
        if application_credential_id is not None:
            pulumi.set(__self__, "application_credential_id", application_credential_id)
        if application_credential_name is not None:
            pulumi.set(__self__, "application_credential_name", application_credential_name)
        if application_credential_secret is not None:
            pulumi.set(__self__, "application_credential_secret", application_credential_secret)
        if boot_from_volume is not None:
            pulumi.set(__self__, "boot_from_volume", boot_from_volume)
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if config_drive is not None:
            pulumi.set(__self__, "config_drive", config_drive)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if flavor_name is not None:
            pulumi.set(__self__, "flavor_name", flavor_name)
        if floating_ip_pool is not None:
            pulumi.set(__self__, "floating_ip_pool", floating_ip_pool)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if keypair_name is not None:
            pulumi.set(__self__, "keypair_name", keypair_name)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if net_name is not None:
            pulumi.set(__self__, "net_name", net_name)
        if nova_network is not None:
            pulumi.set(__self__, "nova_network", nova_network)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key_file is not None:
            pulumi.set(__self__, "private_key_file", private_key_file)
        if sec_groups is not None:
            pulumi.set(__self__, "sec_groups", sec_groups)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if user_data_file is not None:
            pulumi.set(__self__, "user_data_file", user_data_file)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if volume_device_path is not None:
            pulumi.set(__self__, "volume_device_path", volume_device_path)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> pulumi.Input[str]:
        """
        OpenStack authentication URL (string)
        """
        return pulumi.get(self, "auth_url")

    @auth_url.setter
    def auth_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "auth_url", value)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> pulumi.Input[str]:
        """
        OpenStack availability zone (string)
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "availability_zone", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        AWS region. Default `eu-west-2` (string)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="activeTimeout")
    def active_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack active timeout Default `200` (string)
        """
        return pulumi.get(self, "active_timeout")

    @active_timeout.setter
    def active_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_timeout", value)

    @property
    @pulumi.getter(name="applicationCredentialId")
    def application_credential_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack application credential id. Conflicts with `application_credential_name` (string)
        """
        return pulumi.get(self, "application_credential_id")

    @application_credential_id.setter
    def application_credential_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_credential_id", value)

    @property
    @pulumi.getter(name="applicationCredentialName")
    def application_credential_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack application credential name. Conflicts with `application_credential_id` (string)
        """
        return pulumi.get(self, "application_credential_name")

    @application_credential_name.setter
    def application_credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_credential_name", value)

    @property
    @pulumi.getter(name="applicationCredentialSecret")
    def application_credential_secret(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack application credential secret (string)
        """
        return pulumi.get(self, "application_credential_secret")

    @application_credential_secret.setter
    def application_credential_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_credential_secret", value)

    @property
    @pulumi.getter(name="bootFromVolume")
    def boot_from_volume(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable booting from volume. Default is `false` (bool)
        """
        return pulumi.get(self, "boot_from_volume")

    @boot_from_volume.setter
    def boot_from_volume(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot_from_volume", value)

    @property
    @pulumi.getter
    def cacert(self) -> Optional[pulumi.Input[str]]:
        """
        CA certificate bundle to verify against (string)
        """
        return pulumi.get(self, "cacert")

    @cacert.setter
    def cacert(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cacert", value)

    @property
    @pulumi.getter(name="configDrive")
    def config_drive(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the OpenStack config drive for the instance. Default `false` (bool)
        """
        return pulumi.get(self, "config_drive")

    @config_drive.setter
    def config_drive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "config_drive", value)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        """
        return pulumi.get(self, "domain_name")

    @domain_name.setter
    def domain_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_name", value)

    @property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        """
        return pulumi.get(self, "endpoint_type")

    @endpoint_type.setter
    def endpoint_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_type", value)

    @property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        """
        return pulumi.get(self, "flavor_id")

    @flavor_id.setter
    def flavor_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flavor_id", value)

    @property
    @pulumi.getter(name="flavorName")
    def flavor_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        """
        return pulumi.get(self, "flavor_name")

    @flavor_name.setter
    def flavor_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flavor_name", value)

    @property
    @pulumi.getter(name="floatingIpPool")
    def floating_ip_pool(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack floating IP pool to get an IP from to assign to the instance (string)
        """
        return pulumi.get(self, "floating_ip_pool")

    @floating_ip_pool.setter
    def floating_ip_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "floating_ip_pool", value)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_id", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS credential checking. Default `false` (bool)
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack version of IP address assigned for the machine Default `4` (string)
        """
        return pulumi.get(self, "ip_version")

    @ip_version.setter
    def ip_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_version", value)

    @property
    @pulumi.getter(name="keypairName")
    def keypair_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack keypair to use to SSH to the instance (string)
        """
        return pulumi.get(self, "keypair_name")

    @keypair_name.setter
    def keypair_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keypair_name", value)

    @property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        """
        return pulumi.get(self, "net_id")

    @net_id.setter
    def net_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_id", value)

    @property
    @pulumi.getter(name="netName")
    def net_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        """
        return pulumi.get(self, "net_name")

    @net_name.setter
    def net_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "net_name", value)

    @property
    @pulumi.getter(name="novaNetwork")
    def nova_network(self) -> Optional[pulumi.Input[bool]]:
        """
        Use the nova networking services instead of neutron (string)
        """
        return pulumi.get(self, "nova_network")

    @nova_network.setter
    def nova_network(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nova_network", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="privateKeyFile")
    def private_key_file(self) -> Optional[pulumi.Input[str]]:
        """
        Private key content to use for SSH (string)
        """
        return pulumi.get(self, "private_key_file")

    @private_key_file.setter
    def private_key_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_file", value)

    @property
    @pulumi.getter(name="secGroups")
    def sec_groups(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack comma separated security groups for the machine (string)
        """
        return pulumi.get(self, "sec_groups")

    @sec_groups.setter
    def sec_groups(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sec_groups", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh port. Default `22`. From Rancher v2.3.3 (string)
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack tenant id. Conflicts with `tenant_name` (string)
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)

    @property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack tenant name. Conflicts with `tenant_id` (string)
        """
        return pulumi.get(self, "tenant_name")

    @tenant_name.setter
    def tenant_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_name", value)

    @property
    @pulumi.getter(name="userDataFile")
    def user_data_file(self) -> Optional[pulumi.Input[str]]:
        """
        File containing an openstack userdata script (string)
        """
        return pulumi.get(self, "user_data_file")

    @user_data_file.setter
    def user_data_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data_file", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere username. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="volumeDevicePath")
    def volume_device_path(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)

        > **Note:**: `Required*` denotes that either the _name or _id is required but you cannot use both.

        > **Note:**: `Required**` denotes that either the _name or _id is required unless `application_credential_id` is defined.

        > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        """
        return pulumi.get(self, "volume_device_path")

    @volume_device_path.setter
    def volume_device_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_device_path", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_name")

    @volume_name.setter
    def volume_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_name", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_size", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class NodeTemplateOutscaleConfigArgsDict(TypedDict):
        access_key: pulumi.Input[str]
        """
        Outscale Access Key
        """
        secret_key: pulumi.Input[str]
        """
        Outscale Secret Key
        """
        extra_tags_alls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra tags for all created resources (e.g. key1=value1,key2=value2)
        """
        extra_tags_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Extra tags only for instances (e.g. key1=value1,key2=value2)
        """
        instance_type: NotRequired[pulumi.Input[str]]
        """
        Outscale VM type
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Outscale Region
        """
        root_disk_iops: NotRequired[pulumi.Input[int]]
        """
        Iops for io1 Root Disk. From 1 to 13000.
        """
        root_disk_size: NotRequired[pulumi.Input[int]]
        """
        Size of the Root Disk (in GB). From 1 to 14901.
        """
        root_disk_type: NotRequired[pulumi.Input[str]]
        """
        Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Ids of user defined Security Groups to add to the machine
        """
        source_omi: NotRequired[pulumi.Input[str]]
        """
        Outscale Machine Image to use as bootstrap for the VM
        """
elif False:
    NodeTemplateOutscaleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateOutscaleConfigArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 extra_tags_alls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 extra_tags_instances: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 instance_type: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 root_disk_iops: Optional[pulumi.Input[int]] = None,
                 root_disk_size: Optional[pulumi.Input[int]] = None,
                 root_disk_type: Optional[pulumi.Input[str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_omi: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: Outscale Access Key
        :param pulumi.Input[str] secret_key: Outscale Secret Key
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_tags_alls: Extra tags for all created resources (e.g. key1=value1,key2=value2)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] extra_tags_instances: Extra tags only for instances (e.g. key1=value1,key2=value2)
        :param pulumi.Input[str] instance_type: Outscale VM type
        :param pulumi.Input[str] region: Outscale Region
        :param pulumi.Input[int] root_disk_iops: Iops for io1 Root Disk. From 1 to 13000.
        :param pulumi.Input[int] root_disk_size: Size of the Root Disk (in GB). From 1 to 14901.
        :param pulumi.Input[str] root_disk_type: Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: Ids of user defined Security Groups to add to the machine
        :param pulumi.Input[str] source_omi: Outscale Machine Image to use as bootstrap for the VM
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if extra_tags_alls is not None:
            pulumi.set(__self__, "extra_tags_alls", extra_tags_alls)
        if extra_tags_instances is not None:
            pulumi.set(__self__, "extra_tags_instances", extra_tags_instances)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if root_disk_iops is not None:
            pulumi.set(__self__, "root_disk_iops", root_disk_iops)
        if root_disk_size is not None:
            pulumi.set(__self__, "root_disk_size", root_disk_size)
        if root_disk_type is not None:
            pulumi.set(__self__, "root_disk_type", root_disk_type)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if source_omi is not None:
            pulumi.set(__self__, "source_omi", source_omi)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        """
        Outscale Access Key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        """
        Outscale Secret Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="extraTagsAlls")
    def extra_tags_alls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra tags for all created resources (e.g. key1=value1,key2=value2)
        """
        return pulumi.get(self, "extra_tags_alls")

    @extra_tags_alls.setter
    def extra_tags_alls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_tags_alls", value)

    @property
    @pulumi.getter(name="extraTagsInstances")
    def extra_tags_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Extra tags only for instances (e.g. key1=value1,key2=value2)
        """
        return pulumi.get(self, "extra_tags_instances")

    @extra_tags_instances.setter
    def extra_tags_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "extra_tags_instances", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[str]]:
        """
        Outscale VM type
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Outscale Region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="rootDiskIops")
    def root_disk_iops(self) -> Optional[pulumi.Input[int]]:
        """
        Iops for io1 Root Disk. From 1 to 13000.
        """
        return pulumi.get(self, "root_disk_iops")

    @root_disk_iops.setter
    def root_disk_iops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "root_disk_iops", value)

    @property
    @pulumi.getter(name="rootDiskSize")
    def root_disk_size(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the Root Disk (in GB). From 1 to 14901.
        """
        return pulumi.get(self, "root_disk_size")

    @root_disk_size.setter
    def root_disk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "root_disk_size", value)

    @property
    @pulumi.getter(name="rootDiskType")
    def root_disk_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
        """
        return pulumi.get(self, "root_disk_type")

    @root_disk_type.setter
    def root_disk_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_disk_type", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Ids of user defined Security Groups to add to the machine
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="sourceOmi")
    def source_omi(self) -> Optional[pulumi.Input[str]]:
        """
        Outscale Machine Image to use as bootstrap for the VM
        """
        return pulumi.get(self, "source_omi")

    @source_omi.setter
    def source_omi(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_omi", value)


if not MYPY:
    class NodeTemplateVsphereConfigArgsDict(TypedDict):
        boot2docker_url: NotRequired[pulumi.Input[str]]
        """
        vSphere URL for boot2docker image
        """
        cfgparams: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere vm configuration parameters (used for guestinfo)
        """
        clone_from: NotRequired[pulumi.Input[str]]
        """
        If you choose creation type clone a name of what you want to clone is required
        """
        cloud_config: NotRequired[pulumi.Input[str]]
        """
        Filepath to a cloud-config yaml file to put into the ISO user-data
        """
        cloudinit: NotRequired[pulumi.Input[str]]
        """
        vSphere cloud-init filepath or url to add to guestinfo
        """
        content_library: NotRequired[pulumi.Input[str]]
        """
        If you choose to clone from a content library template specify the name of the library
        """
        cpu_count: NotRequired[pulumi.Input[str]]
        """
        vSphere CPU number for docker VM
        """
        creation_type: NotRequired[pulumi.Input[str]]
        """
        Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        """
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere custom attributes, format key/value e.g. '200=my custom value'
        """
        datacenter: NotRequired[pulumi.Input[str]]
        """
        vSphere datacenter for virtual machine
        """
        datastore: NotRequired[pulumi.Input[str]]
        """
        vSphere datastore for virtual machine
        """
        datastore_cluster: NotRequired[pulumi.Input[str]]
        """
        vSphere datastore cluster for virtual machine
        """
        disk_size: NotRequired[pulumi.Input[str]]
        """
        vSphere size of disk for docker VM (in MB)
        """
        folder: NotRequired[pulumi.Input[str]]
        """
        vSphere folder for the docker VM. This folder must already exist in the datacenter
        """
        graceful_shutdown_timeout: NotRequired[pulumi.Input[str]]
        """
        Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        """
        hostsystem: NotRequired[pulumi.Input[str]]
        """
        vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        """
        memory_size: NotRequired[pulumi.Input[str]]
        """
        vSphere size of memory for docker VM (in MB)
        """
        networks: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere network where the virtual machine will be attached
        """
        password: NotRequired[pulumi.Input[str]]
        """
        vSphere password
        """
        pool: NotRequired[pulumi.Input[str]]
        """
        vSphere resource pool for docker VM
        """
        ssh_password: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh password
        """
        ssh_port: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh port
        """
        ssh_user: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image you can specify the ssh user
        """
        ssh_user_group: NotRequired[pulumi.Input[str]]
        """
        If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere tags id e.g. urn:xxx
        """
        username: NotRequired[pulumi.Input[str]]
        """
        vSphere username
        """
        vapp_ip_allocation_policy: NotRequired[pulumi.Input[str]]
        """
        vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        """
        vapp_ip_protocol: NotRequired[pulumi.Input[str]]
        """
        vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        """
        vapp_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        vSphere vApp properties
        """
        vapp_transport: NotRequired[pulumi.Input[str]]
        """
        vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        """
        vcenter: NotRequired[pulumi.Input[str]]
        """
        vSphere IP/hostname for vCenter
        """
        vcenter_port: NotRequired[pulumi.Input[str]]
        """
        vSphere Port for vCenter
        """
elif False:
    NodeTemplateVsphereConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NodeTemplateVsphereConfigArgs:
    def __init__(__self__, *,
                 boot2docker_url: Optional[pulumi.Input[str]] = None,
                 cfgparams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 clone_from: Optional[pulumi.Input[str]] = None,
                 cloud_config: Optional[pulumi.Input[str]] = None,
                 cloudinit: Optional[pulumi.Input[str]] = None,
                 content_library: Optional[pulumi.Input[str]] = None,
                 cpu_count: Optional[pulumi.Input[str]] = None,
                 creation_type: Optional[pulumi.Input[str]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 datacenter: Optional[pulumi.Input[str]] = None,
                 datastore: Optional[pulumi.Input[str]] = None,
                 datastore_cluster: Optional[pulumi.Input[str]] = None,
                 disk_size: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 graceful_shutdown_timeout: Optional[pulumi.Input[str]] = None,
                 hostsystem: Optional[pulumi.Input[str]] = None,
                 memory_size: Optional[pulumi.Input[str]] = None,
                 networks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 pool: Optional[pulumi.Input[str]] = None,
                 ssh_password: Optional[pulumi.Input[str]] = None,
                 ssh_port: Optional[pulumi.Input[str]] = None,
                 ssh_user: Optional[pulumi.Input[str]] = None,
                 ssh_user_group: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 username: Optional[pulumi.Input[str]] = None,
                 vapp_ip_allocation_policy: Optional[pulumi.Input[str]] = None,
                 vapp_ip_protocol: Optional[pulumi.Input[str]] = None,
                 vapp_properties: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vapp_transport: Optional[pulumi.Input[str]] = None,
                 vcenter: Optional[pulumi.Input[str]] = None,
                 vcenter_port: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boot2docker_url: vSphere URL for boot2docker image
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cfgparams: vSphere vm configuration parameters (used for guestinfo)
        :param pulumi.Input[str] clone_from: If you choose creation type clone a name of what you want to clone is required
        :param pulumi.Input[str] cloud_config: Filepath to a cloud-config yaml file to put into the ISO user-data
        :param pulumi.Input[str] cloudinit: vSphere cloud-init filepath or url to add to guestinfo
        :param pulumi.Input[str] content_library: If you choose to clone from a content library template specify the name of the library
        :param pulumi.Input[str] cpu_count: vSphere CPU number for docker VM
        :param pulumi.Input[str] creation_type: Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_attributes: vSphere custom attributes, format key/value e.g. '200=my custom value'
        :param pulumi.Input[str] datacenter: vSphere datacenter for virtual machine
        :param pulumi.Input[str] datastore: vSphere datastore for virtual machine
        :param pulumi.Input[str] datastore_cluster: vSphere datastore cluster for virtual machine
        :param pulumi.Input[str] disk_size: vSphere size of disk for docker VM (in MB)
        :param pulumi.Input[str] folder: vSphere folder for the docker VM. This folder must already exist in the datacenter
        :param pulumi.Input[str] graceful_shutdown_timeout: Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        :param pulumi.Input[str] hostsystem: vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        :param pulumi.Input[str] memory_size: vSphere size of memory for docker VM (in MB)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] networks: vSphere network where the virtual machine will be attached
        :param pulumi.Input[str] password: vSphere password
        :param pulumi.Input[str] pool: vSphere resource pool for docker VM
        :param pulumi.Input[str] ssh_password: If using a non-B2D image you can specify the ssh password
        :param pulumi.Input[str] ssh_port: If using a non-B2D image you can specify the ssh port
        :param pulumi.Input[str] ssh_user: If using a non-B2D image you can specify the ssh user
        :param pulumi.Input[str] ssh_user_group: If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: vSphere tags id e.g. urn:xxx
        :param pulumi.Input[str] username: vSphere username
        :param pulumi.Input[str] vapp_ip_allocation_policy: vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        :param pulumi.Input[str] vapp_ip_protocol: vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vapp_properties: vSphere vApp properties
        :param pulumi.Input[str] vapp_transport: vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        :param pulumi.Input[str] vcenter: vSphere IP/hostname for vCenter
        :param pulumi.Input[str] vcenter_port: vSphere Port for vCenter
        """
        if boot2docker_url is not None:
            pulumi.set(__self__, "boot2docker_url", boot2docker_url)
        if cfgparams is not None:
            pulumi.set(__self__, "cfgparams", cfgparams)
        if clone_from is not None:
            pulumi.set(__self__, "clone_from", clone_from)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloudinit is not None:
            pulumi.set(__self__, "cloudinit", cloudinit)
        if content_library is not None:
            pulumi.set(__self__, "content_library", content_library)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if datastore_cluster is not None:
            pulumi.set(__self__, "datastore_cluster", datastore_cluster)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if hostsystem is not None:
            pulumi.set(__self__, "hostsystem", hostsystem)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if ssh_user_group is not None:
            pulumi.set(__self__, "ssh_user_group", ssh_user_group)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vapp_ip_allocation_policy is not None:
            pulumi.set(__self__, "vapp_ip_allocation_policy", vapp_ip_allocation_policy)
        if vapp_ip_protocol is not None:
            pulumi.set(__self__, "vapp_ip_protocol", vapp_ip_protocol)
        if vapp_properties is not None:
            pulumi.set(__self__, "vapp_properties", vapp_properties)
        if vapp_transport is not None:
            pulumi.set(__self__, "vapp_transport", vapp_transport)
        if vcenter is not None:
            pulumi.set(__self__, "vcenter", vcenter)
        if vcenter_port is not None:
            pulumi.set(__self__, "vcenter_port", vcenter_port)

    @property
    @pulumi.getter(name="boot2dockerUrl")
    def boot2docker_url(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere URL for boot2docker image
        """
        return pulumi.get(self, "boot2docker_url")

    @boot2docker_url.setter
    def boot2docker_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boot2docker_url", value)

    @property
    @pulumi.getter
    def cfgparams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere vm configuration parameters (used for guestinfo)
        """
        return pulumi.get(self, "cfgparams")

    @cfgparams.setter
    def cfgparams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cfgparams", value)

    @property
    @pulumi.getter(name="cloneFrom")
    def clone_from(self) -> Optional[pulumi.Input[str]]:
        """
        If you choose creation type clone a name of what you want to clone is required
        """
        return pulumi.get(self, "clone_from")

    @clone_from.setter
    def clone_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "clone_from", value)

    @property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[pulumi.Input[str]]:
        """
        Filepath to a cloud-config yaml file to put into the ISO user-data
        """
        return pulumi.get(self, "cloud_config")

    @cloud_config.setter
    def cloud_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloud_config", value)

    @property
    @pulumi.getter
    def cloudinit(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere cloud-init filepath or url to add to guestinfo
        """
        return pulumi.get(self, "cloudinit")

    @cloudinit.setter
    def cloudinit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cloudinit", value)

    @property
    @pulumi.getter(name="contentLibrary")
    def content_library(self) -> Optional[pulumi.Input[str]]:
        """
        If you choose to clone from a content library template specify the name of the library
        """
        return pulumi.get(self, "content_library")

    @content_library.setter
    def content_library(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_library", value)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere CPU number for docker VM
        """
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cpu_count", value)

    @property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[pulumi.Input[str]]:
        """
        Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        """
        return pulumi.get(self, "creation_type")

    @creation_type.setter
    def creation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_type", value)

    @property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere custom attributes, format key/value e.g. '200=my custom value'
        """
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "custom_attributes", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere datacenter for virtual machine
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere datastore for virtual machine
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter(name="datastoreCluster")
    def datastore_cluster(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere datastore cluster for virtual machine
        """
        return pulumi.get(self, "datastore_cluster")

    @datastore_cluster.setter
    def datastore_cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore_cluster", value)

    @property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere size of disk for docker VM (in MB)
        """
        return pulumi.get(self, "disk_size")

    @disk_size.setter
    def disk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "disk_size", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere folder for the docker VM. This folder must already exist in the datacenter
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        """
        return pulumi.get(self, "graceful_shutdown_timeout")

    @graceful_shutdown_timeout.setter
    def graceful_shutdown_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "graceful_shutdown_timeout", value)

    @property
    @pulumi.getter
    def hostsystem(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        """
        return pulumi.get(self, "hostsystem")

    @hostsystem.setter
    def hostsystem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostsystem", value)

    @property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere size of memory for docker VM (in MB)
        """
        return pulumi.get(self, "memory_size")

    @memory_size.setter
    def memory_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_size", value)

    @property
    @pulumi.getter
    def networks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere network where the virtual machine will be attached
        """
        return pulumi.get(self, "networks")

    @networks.setter
    def networks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "networks", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere password
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def pool(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere resource pool for docker VM
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh password
        """
        return pulumi.get(self, "ssh_password")

    @ssh_password.setter
    def ssh_password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_password", value)

    @property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh port
        """
        return pulumi.get(self, "ssh_port")

    @ssh_port.setter
    def ssh_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_port", value)

    @property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image you can specify the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @ssh_user.setter
    def ssh_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user", value)

    @property
    @pulumi.getter(name="sshUserGroup")
    def ssh_user_group(self) -> Optional[pulumi.Input[str]]:
        """
        If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        """
        return pulumi.get(self, "ssh_user_group")

    @ssh_user_group.setter
    def ssh_user_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssh_user_group", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere tags id e.g. urn:xxx
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere username
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="vappIpAllocationPolicy")
    def vapp_ip_allocation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        """
        return pulumi.get(self, "vapp_ip_allocation_policy")

    @vapp_ip_allocation_policy.setter
    def vapp_ip_allocation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_ip_allocation_policy", value)

    @property
    @pulumi.getter(name="vappIpProtocol")
    def vapp_ip_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        """
        return pulumi.get(self, "vapp_ip_protocol")

    @vapp_ip_protocol.setter
    def vapp_ip_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_ip_protocol", value)

    @property
    @pulumi.getter(name="vappProperties")
    def vapp_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        vSphere vApp properties
        """
        return pulumi.get(self, "vapp_properties")

    @vapp_properties.setter
    def vapp_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vapp_properties", value)

    @property
    @pulumi.getter(name="vappTransport")
    def vapp_transport(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        """
        return pulumi.get(self, "vapp_transport")

    @vapp_transport.setter
    def vapp_transport(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vapp_transport", value)

    @property
    @pulumi.getter
    def vcenter(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere IP/hostname for vCenter
        """
        return pulumi.get(self, "vcenter")

    @vcenter.setter
    def vcenter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter", value)

    @property
    @pulumi.getter(name="vcenterPort")
    def vcenter_port(self) -> Optional[pulumi.Input[str]]:
        """
        vSphere Port for vCenter
        """
        return pulumi.get(self, "vcenter_port")

    @vcenter_port.setter
    def vcenter_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter_port", value)


if not MYPY:
    class PodSecurityAdmissionConfigurationTemplateDefaultsArgsDict(TypedDict):
        audit: NotRequired[pulumi.Input[str]]
        """
        Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        audit_version: NotRequired[pulumi.Input[str]]
        """
        Pod Security Admission Configuration audit version (default: latest)
        """
        enforce: NotRequired[pulumi.Input[str]]
        """
        Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        enforce_version: NotRequired[pulumi.Input[str]]
        """
        Pod Security Admission Configuration enforce version (default: latest)
        """
        warn: NotRequired[pulumi.Input[str]]
        """
        Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        warn_version: NotRequired[pulumi.Input[str]]
        """
        Pod Security Admission Configuration warn version (default: latest)
        """
elif False:
    PodSecurityAdmissionConfigurationTemplateDefaultsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodSecurityAdmissionConfigurationTemplateDefaultsArgs:
    def __init__(__self__, *,
                 audit: Optional[pulumi.Input[str]] = None,
                 audit_version: Optional[pulumi.Input[str]] = None,
                 enforce: Optional[pulumi.Input[str]] = None,
                 enforce_version: Optional[pulumi.Input[str]] = None,
                 warn: Optional[pulumi.Input[str]] = None,
                 warn_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] audit: Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param pulumi.Input[str] audit_version: Pod Security Admission Configuration audit version (default: latest)
        :param pulumi.Input[str] enforce: Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param pulumi.Input[str] enforce_version: Pod Security Admission Configuration enforce version (default: latest)
        :param pulumi.Input[str] warn: Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param pulumi.Input[str] warn_version: Pod Security Admission Configuration warn version (default: latest)
        """
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if audit_version is not None:
            pulumi.set(__self__, "audit_version", audit_version)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if enforce_version is not None:
            pulumi.set(__self__, "enforce_version", enforce_version)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)
        if warn_version is not None:
            pulumi.set(__self__, "warn_version", warn_version)

    @property
    @pulumi.getter
    def audit(self) -> Optional[pulumi.Input[str]]:
        """
        Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "audit")

    @audit.setter
    def audit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audit", value)

    @property
    @pulumi.getter(name="auditVersion")
    def audit_version(self) -> Optional[pulumi.Input[str]]:
        """
        Pod Security Admission Configuration audit version (default: latest)
        """
        return pulumi.get(self, "audit_version")

    @audit_version.setter
    def audit_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "audit_version", value)

    @property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[str]]:
        """
        Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enforce", value)

    @property
    @pulumi.getter(name="enforceVersion")
    def enforce_version(self) -> Optional[pulumi.Input[str]]:
        """
        Pod Security Admission Configuration enforce version (default: latest)
        """
        return pulumi.get(self, "enforce_version")

    @enforce_version.setter
    def enforce_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enforce_version", value)

    @property
    @pulumi.getter
    def warn(self) -> Optional[pulumi.Input[str]]:
        """
        Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "warn")

    @warn.setter
    def warn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warn", value)

    @property
    @pulumi.getter(name="warnVersion")
    def warn_version(self) -> Optional[pulumi.Input[str]]:
        """
        Pod Security Admission Configuration warn version (default: latest)
        """
        return pulumi.get(self, "warn_version")

    @warn_version.setter
    def warn_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "warn_version", value)


if not MYPY:
    class PodSecurityAdmissionConfigurationTemplateExemptionsArgsDict(TypedDict):
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Pod Security Admission Configuration namespace exemptions
        """
        runtime_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Pod Security Admission Configuration runtime class exemptions
        """
        usernames: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Pod Security Admission Configuration username exemptions
        """
elif False:
    PodSecurityAdmissionConfigurationTemplateExemptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PodSecurityAdmissionConfigurationTemplateExemptionsArgs:
    def __init__(__self__, *,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 runtime_classes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 usernames: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] namespaces: Pod Security Admission Configuration namespace exemptions
        :param pulumi.Input[Sequence[pulumi.Input[str]]] runtime_classes: Pod Security Admission Configuration runtime class exemptions
        :param pulumi.Input[Sequence[pulumi.Input[str]]] usernames: Pod Security Admission Configuration username exemptions
        """
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if runtime_classes is not None:
            pulumi.set(__self__, "runtime_classes", runtime_classes)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pod Security Admission Configuration namespace exemptions
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter(name="runtimeClasses")
    def runtime_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pod Security Admission Configuration runtime class exemptions
        """
        return pulumi.get(self, "runtime_classes")

    @runtime_classes.setter
    def runtime_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "runtime_classes", value)

    @property
    @pulumi.getter
    def usernames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Pod Security Admission Configuration username exemptions
        """
        return pulumi.get(self, "usernames")

    @usernames.setter
    def usernames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "usernames", value)


if not MYPY:
    class ProjectContainerResourceLimitArgsDict(TypedDict):
        limits_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for limits cpu in project (string)
        """
        limits_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for limits memory in project (string)
        """
        requests_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for requests cpu in project (string)
        """
        requests_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for requests memory in project (string)
        """
elif False:
    ProjectContainerResourceLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectContainerResourceLimitArgs:
    def __init__(__self__, *,
                 limits_cpu: Optional[pulumi.Input[str]] = None,
                 limits_memory: Optional[pulumi.Input[str]] = None,
                 requests_cpu: Optional[pulumi.Input[str]] = None,
                 requests_memory: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] limits_cpu: Limit for limits cpu in project (string)
        :param pulumi.Input[str] limits_memory: Limit for limits memory in project (string)
        :param pulumi.Input[str] requests_cpu: Limit for requests cpu in project (string)
        :param pulumi.Input[str] requests_memory: Limit for requests memory in project (string)
        """
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)

    @property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits cpu in project (string)
        """
        return pulumi.get(self, "limits_cpu")

    @limits_cpu.setter
    def limits_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_cpu", value)

    @property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits memory in project (string)
        """
        return pulumi.get(self, "limits_memory")

    @limits_memory.setter
    def limits_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_memory", value)

    @property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests cpu in project (string)
        """
        return pulumi.get(self, "requests_cpu")

    @requests_cpu.setter
    def requests_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_cpu", value)

    @property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests memory in project (string)
        """
        return pulumi.get(self, "requests_memory")

    @requests_memory.setter
    def requests_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_memory", value)


if not MYPY:
    class ProjectResourceQuotaArgsDict(TypedDict):
        namespace_default_limit: pulumi.Input['ProjectResourceQuotaNamespaceDefaultLimitArgsDict']
        """
        Default resource quota limit for  namespaces in project (list maxitems:1)
        """
        project_limit: pulumi.Input['ProjectResourceQuotaProjectLimitArgsDict']
        """
        Resource quota limit for project (list maxitems:1)
        """
elif False:
    ProjectResourceQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectResourceQuotaArgs:
    def __init__(__self__, *,
                 namespace_default_limit: pulumi.Input['ProjectResourceQuotaNamespaceDefaultLimitArgs'],
                 project_limit: pulumi.Input['ProjectResourceQuotaProjectLimitArgs']):
        """
        :param pulumi.Input['ProjectResourceQuotaNamespaceDefaultLimitArgs'] namespace_default_limit: Default resource quota limit for  namespaces in project (list maxitems:1)
        :param pulumi.Input['ProjectResourceQuotaProjectLimitArgs'] project_limit: Resource quota limit for project (list maxitems:1)
        """
        pulumi.set(__self__, "namespace_default_limit", namespace_default_limit)
        pulumi.set(__self__, "project_limit", project_limit)

    @property
    @pulumi.getter(name="namespaceDefaultLimit")
    def namespace_default_limit(self) -> pulumi.Input['ProjectResourceQuotaNamespaceDefaultLimitArgs']:
        """
        Default resource quota limit for  namespaces in project (list maxitems:1)
        """
        return pulumi.get(self, "namespace_default_limit")

    @namespace_default_limit.setter
    def namespace_default_limit(self, value: pulumi.Input['ProjectResourceQuotaNamespaceDefaultLimitArgs']):
        pulumi.set(self, "namespace_default_limit", value)

    @property
    @pulumi.getter(name="projectLimit")
    def project_limit(self) -> pulumi.Input['ProjectResourceQuotaProjectLimitArgs']:
        """
        Resource quota limit for project (list maxitems:1)
        """
        return pulumi.get(self, "project_limit")

    @project_limit.setter
    def project_limit(self, value: pulumi.Input['ProjectResourceQuotaProjectLimitArgs']):
        pulumi.set(self, "project_limit", value)


if not MYPY:
    class ProjectResourceQuotaNamespaceDefaultLimitArgsDict(TypedDict):
        config_maps: NotRequired[pulumi.Input[str]]
        """
        Limit for config maps in project (string)
        """
        limits_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for limits cpu in project (string)
        """
        limits_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for limits memory in project (string)
        """
        persistent_volume_claims: NotRequired[pulumi.Input[str]]
        """
        Limit for persistent volume claims in project (string)
        """
        pods: NotRequired[pulumi.Input[str]]
        """
        Limit for pods in project (string)
        """
        replication_controllers: NotRequired[pulumi.Input[str]]
        """
        Limit for replication controllers in project (string)
        """
        requests_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for requests cpu in project (string)
        """
        requests_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for requests memory in project (string)
        """
        requests_storage: NotRequired[pulumi.Input[str]]
        """
        Limit for requests storage in project (string)
        """
        secrets: NotRequired[pulumi.Input[str]]
        """
        Limit for secrets in project (string)
        """
        services: NotRequired[pulumi.Input[str]]
        services_load_balancers: NotRequired[pulumi.Input[str]]
        """
        Limit for services load balancers in project (string)
        """
        services_node_ports: NotRequired[pulumi.Input[str]]
        """
        Limit for services node ports in project (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
elif False:
    ProjectResourceQuotaNamespaceDefaultLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectResourceQuotaNamespaceDefaultLimitArgs:
    def __init__(__self__, *,
                 config_maps: Optional[pulumi.Input[str]] = None,
                 limits_cpu: Optional[pulumi.Input[str]] = None,
                 limits_memory: Optional[pulumi.Input[str]] = None,
                 persistent_volume_claims: Optional[pulumi.Input[str]] = None,
                 pods: Optional[pulumi.Input[str]] = None,
                 replication_controllers: Optional[pulumi.Input[str]] = None,
                 requests_cpu: Optional[pulumi.Input[str]] = None,
                 requests_memory: Optional[pulumi.Input[str]] = None,
                 requests_storage: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[str]] = None,
                 services_load_balancers: Optional[pulumi.Input[str]] = None,
                 services_node_ports: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_maps: Limit for config maps in project (string)
        :param pulumi.Input[str] limits_cpu: Limit for limits cpu in project (string)
        :param pulumi.Input[str] limits_memory: Limit for limits memory in project (string)
        :param pulumi.Input[str] persistent_volume_claims: Limit for persistent volume claims in project (string)
        :param pulumi.Input[str] pods: Limit for pods in project (string)
        :param pulumi.Input[str] replication_controllers: Limit for replication controllers in project (string)
        :param pulumi.Input[str] requests_cpu: Limit for requests cpu in project (string)
        :param pulumi.Input[str] requests_memory: Limit for requests memory in project (string)
        :param pulumi.Input[str] requests_storage: Limit for requests storage in project (string)
        :param pulumi.Input[str] secrets: Limit for secrets in project (string)
        :param pulumi.Input[str] services_load_balancers: Limit for services load balancers in project (string)
        :param pulumi.Input[str] services_node_ports: Limit for services node ports in project (string)
               
               More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for config maps in project (string)
        """
        return pulumi.get(self, "config_maps")

    @config_maps.setter
    def config_maps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_maps", value)

    @property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits cpu in project (string)
        """
        return pulumi.get(self, "limits_cpu")

    @limits_cpu.setter
    def limits_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_cpu", value)

    @property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits memory in project (string)
        """
        return pulumi.get(self, "limits_memory")

    @limits_memory.setter
    def limits_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_memory", value)

    @property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for persistent volume claims in project (string)
        """
        return pulumi.get(self, "persistent_volume_claims")

    @persistent_volume_claims.setter
    def persistent_volume_claims(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "persistent_volume_claims", value)

    @property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for pods in project (string)
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pods", value)

    @property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for replication controllers in project (string)
        """
        return pulumi.get(self, "replication_controllers")

    @replication_controllers.setter
    def replication_controllers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_controllers", value)

    @property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests cpu in project (string)
        """
        return pulumi.get(self, "requests_cpu")

    @requests_cpu.setter
    def requests_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_cpu", value)

    @property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests memory in project (string)
        """
        return pulumi.get(self, "requests_memory")

    @requests_memory.setter
    def requests_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_memory", value)

    @property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests storage in project (string)
        """
        return pulumi.get(self, "requests_storage")

    @requests_storage.setter
    def requests_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_storage", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for secrets in project (string)
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for services load balancers in project (string)
        """
        return pulumi.get(self, "services_load_balancers")

    @services_load_balancers.setter
    def services_load_balancers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_load_balancers", value)

    @property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for services node ports in project (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        return pulumi.get(self, "services_node_ports")

    @services_node_ports.setter
    def services_node_ports(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_node_ports", value)


if not MYPY:
    class ProjectResourceQuotaProjectLimitArgsDict(TypedDict):
        config_maps: NotRequired[pulumi.Input[str]]
        """
        Limit for config maps in project (string)
        """
        limits_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for limits cpu in project (string)
        """
        limits_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for limits memory in project (string)
        """
        persistent_volume_claims: NotRequired[pulumi.Input[str]]
        """
        Limit for persistent volume claims in project (string)
        """
        pods: NotRequired[pulumi.Input[str]]
        """
        Limit for pods in project (string)
        """
        replication_controllers: NotRequired[pulumi.Input[str]]
        """
        Limit for replication controllers in project (string)
        """
        requests_cpu: NotRequired[pulumi.Input[str]]
        """
        Limit for requests cpu in project (string)
        """
        requests_memory: NotRequired[pulumi.Input[str]]
        """
        Limit for requests memory in project (string)
        """
        requests_storage: NotRequired[pulumi.Input[str]]
        """
        Limit for requests storage in project (string)
        """
        secrets: NotRequired[pulumi.Input[str]]
        """
        Limit for secrets in project (string)
        """
        services: NotRequired[pulumi.Input[str]]
        services_load_balancers: NotRequired[pulumi.Input[str]]
        """
        Limit for services load balancers in project (string)
        """
        services_node_ports: NotRequired[pulumi.Input[str]]
        """
        Limit for services node ports in project (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
elif False:
    ProjectResourceQuotaProjectLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectResourceQuotaProjectLimitArgs:
    def __init__(__self__, *,
                 config_maps: Optional[pulumi.Input[str]] = None,
                 limits_cpu: Optional[pulumi.Input[str]] = None,
                 limits_memory: Optional[pulumi.Input[str]] = None,
                 persistent_volume_claims: Optional[pulumi.Input[str]] = None,
                 pods: Optional[pulumi.Input[str]] = None,
                 replication_controllers: Optional[pulumi.Input[str]] = None,
                 requests_cpu: Optional[pulumi.Input[str]] = None,
                 requests_memory: Optional[pulumi.Input[str]] = None,
                 requests_storage: Optional[pulumi.Input[str]] = None,
                 secrets: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[str]] = None,
                 services_load_balancers: Optional[pulumi.Input[str]] = None,
                 services_node_ports: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] config_maps: Limit for config maps in project (string)
        :param pulumi.Input[str] limits_cpu: Limit for limits cpu in project (string)
        :param pulumi.Input[str] limits_memory: Limit for limits memory in project (string)
        :param pulumi.Input[str] persistent_volume_claims: Limit for persistent volume claims in project (string)
        :param pulumi.Input[str] pods: Limit for pods in project (string)
        :param pulumi.Input[str] replication_controllers: Limit for replication controllers in project (string)
        :param pulumi.Input[str] requests_cpu: Limit for requests cpu in project (string)
        :param pulumi.Input[str] requests_memory: Limit for requests memory in project (string)
        :param pulumi.Input[str] requests_storage: Limit for requests storage in project (string)
        :param pulumi.Input[str] secrets: Limit for secrets in project (string)
        :param pulumi.Input[str] services_load_balancers: Limit for services load balancers in project (string)
        :param pulumi.Input[str] services_node_ports: Limit for services node ports in project (string)
               
               More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for config maps in project (string)
        """
        return pulumi.get(self, "config_maps")

    @config_maps.setter
    def config_maps(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_maps", value)

    @property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits cpu in project (string)
        """
        return pulumi.get(self, "limits_cpu")

    @limits_cpu.setter
    def limits_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_cpu", value)

    @property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for limits memory in project (string)
        """
        return pulumi.get(self, "limits_memory")

    @limits_memory.setter
    def limits_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limits_memory", value)

    @property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for persistent volume claims in project (string)
        """
        return pulumi.get(self, "persistent_volume_claims")

    @persistent_volume_claims.setter
    def persistent_volume_claims(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "persistent_volume_claims", value)

    @property
    @pulumi.getter
    def pods(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for pods in project (string)
        """
        return pulumi.get(self, "pods")

    @pods.setter
    def pods(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pods", value)

    @property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for replication controllers in project (string)
        """
        return pulumi.get(self, "replication_controllers")

    @replication_controllers.setter
    def replication_controllers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replication_controllers", value)

    @property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests cpu in project (string)
        """
        return pulumi.get(self, "requests_cpu")

    @requests_cpu.setter
    def requests_cpu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_cpu", value)

    @property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests memory in project (string)
        """
        return pulumi.get(self, "requests_memory")

    @requests_memory.setter
    def requests_memory(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_memory", value)

    @property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for requests storage in project (string)
        """
        return pulumi.get(self, "requests_storage")

    @requests_storage.setter
    def requests_storage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "requests_storage", value)

    @property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for secrets in project (string)
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secrets", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for services load balancers in project (string)
        """
        return pulumi.get(self, "services_load_balancers")

    @services_load_balancers.setter
    def services_load_balancers(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_load_balancers", value)

    @property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[pulumi.Input[str]]:
        """
        Limit for services node ports in project (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        return pulumi.get(self, "services_node_ports")

    @services_node_ports.setter
    def services_node_ports(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "services_node_ports", value)


if not MYPY:
    class RegistryRegistryArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        Address for registry.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        Password for the registry (string)
        """
        username: NotRequired[pulumi.Input[str]]
        """
        Username for the registry (string)
        """
elif False:
    RegistryRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RegistryRegistryArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: Address for registry.
        :param pulumi.Input[str] password: Password for the registry (string)
        :param pulumi.Input[str] username: Username for the registry (string)
        """
        pulumi.set(__self__, "address", address)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        Address for registry.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for the registry (string)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        Username for the registry (string)
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class RoleTemplateExternalRuleArgsDict(TypedDict):
        api_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule api groups
        """
        non_resource_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule non resource urls
        """
        resource_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule resource names
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule resources
        """
        verbs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule verbs
        """
elif False:
    RoleTemplateExternalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleTemplateExternalRuleArgs:
    def __init__(__self__, *,
                 api_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 non_resource_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verbs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] api_groups: Policy rule api groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_resource_urls: Policy rule non resource urls
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_names: Policy rule resource names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resources: Policy rule resources
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @api_groups.setter
    def api_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "api_groups", value)

    @property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @non_resource_urls.setter
    def non_resource_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_resource_urls", value)

    @property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @resource_names.setter
    def resource_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_names", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def verbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")

    @verbs.setter
    def verbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verbs", value)


if not MYPY:
    class RoleTemplateRuleArgsDict(TypedDict):
        api_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule api groups
        """
        non_resource_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule non resource urls
        """
        resource_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule resource names
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule resources
        """
        verbs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Policy rule verbs
        """
elif False:
    RoleTemplateRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleTemplateRuleArgs:
    def __init__(__self__, *,
                 api_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 non_resource_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resource_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verbs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] api_groups: Policy rule api groups
        :param pulumi.Input[Sequence[pulumi.Input[str]]] non_resource_urls: Policy rule non resource urls
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resource_names: Policy rule resource names
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resources: Policy rule resources
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @api_groups.setter
    def api_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "api_groups", value)

    @property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @non_resource_urls.setter
    def non_resource_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "non_resource_urls", value)

    @property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @resource_names.setter
    def resource_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resource_names", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def verbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")

    @verbs.setter
    def verbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verbs", value)


if not MYPY:
    class GetRoleTemplateExternalRuleArgsDict(TypedDict):
        api_groups: NotRequired[Sequence[str]]
        """
        Policy rule api groups
        """
        non_resource_urls: NotRequired[Sequence[str]]
        """
        Policy rule non resource urls
        """
        resource_names: NotRequired[Sequence[str]]
        """
        Policy rule resource names
        """
        resources: NotRequired[Sequence[str]]
        """
        Policy rule resources
        """
        verbs: NotRequired[Sequence[str]]
        """
        Policy rule verbs
        """
elif False:
    GetRoleTemplateExternalRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRoleTemplateExternalRuleArgs:
    def __init__(__self__, *,
                 api_groups: Optional[Sequence[str]] = None,
                 non_resource_urls: Optional[Sequence[str]] = None,
                 resource_names: Optional[Sequence[str]] = None,
                 resources: Optional[Sequence[str]] = None,
                 verbs: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] api_groups: Policy rule api groups
        :param Sequence[str] non_resource_urls: Policy rule non resource urls
        :param Sequence[str] resource_names: Policy rule resource names
        :param Sequence[str] resources: Policy rule resources
        :param Sequence[str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @api_groups.setter
    def api_groups(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "api_groups", value)

    @property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @non_resource_urls.setter
    def non_resource_urls(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "non_resource_urls", value)

    @property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @resource_names.setter
    def resource_names(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "resource_names", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "resources", value)

    @property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")

    @verbs.setter
    def verbs(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "verbs", value)


