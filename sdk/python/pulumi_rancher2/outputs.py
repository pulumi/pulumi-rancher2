# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'CloudCredentialAmazonec2CredentialConfig',
    'CloudCredentialAzureCredentialConfig',
    'CloudCredentialDigitaloceanCredentialConfig',
    'CloudCredentialGoogleCredentialConfig',
    'CloudCredentialHarvesterCredentialConfig',
    'CloudCredentialLinodeCredentialConfig',
    'CloudCredentialOpenstackCredentialConfig',
    'CloudCredentialS3CredentialConfig',
    'CloudCredentialVsphereCredentialConfig',
    'ClusterAgentEnvVar',
    'ClusterAksConfigV2',
    'ClusterAksConfigV2NodePool',
    'ClusterClusterAgentDeploymentCustomization',
    'ClusterClusterAgentDeploymentCustomizationAppendToleration',
    'ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement',
    'ClusterClusterAgentDeploymentCustomizationSchedulingCustomization',
    'ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget',
    'ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass',
    'ClusterClusterAuthEndpoint',
    'ClusterClusterRegistrationToken',
    'ClusterClusterTemplateAnswers',
    'ClusterClusterTemplateQuestion',
    'ClusterEksConfigV2',
    'ClusterEksConfigV2NodeGroup',
    'ClusterEksConfigV2NodeGroupLaunchTemplate',
    'ClusterFleetAgentDeploymentCustomization',
    'ClusterFleetAgentDeploymentCustomizationAppendToleration',
    'ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement',
    'ClusterGkeConfigV2',
    'ClusterGkeConfigV2ClusterAddons',
    'ClusterGkeConfigV2IpAllocationPolicy',
    'ClusterGkeConfigV2MasterAuthorizedNetworksConfig',
    'ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock',
    'ClusterGkeConfigV2NodePool',
    'ClusterGkeConfigV2NodePoolAutoscaling',
    'ClusterGkeConfigV2NodePoolConfig',
    'ClusterGkeConfigV2NodePoolConfigTaint',
    'ClusterGkeConfigV2NodePoolManagement',
    'ClusterGkeConfigV2PrivateClusterConfig',
    'ClusterImportedConfig',
    'ClusterK3sConfig',
    'ClusterK3sConfigUpgradeStrategy',
    'ClusterOkeConfig',
    'ClusterRke2Config',
    'ClusterRke2ConfigUpgradeStrategy',
    'ClusterRkeConfig',
    'ClusterRkeConfigAuthentication',
    'ClusterRkeConfigAuthorization',
    'ClusterRkeConfigBastionHost',
    'ClusterRkeConfigCloudProvider',
    'ClusterRkeConfigCloudProviderAwsCloudProvider',
    'ClusterRkeConfigCloudProviderAwsCloudProviderGlobal',
    'ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride',
    'ClusterRkeConfigCloudProviderAzureCloudProvider',
    'ClusterRkeConfigCloudProviderOpenstackCloudProvider',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata',
    'ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute',
    'ClusterRkeConfigCloudProviderVsphereCloudProvider',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderDisk',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter',
    'ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace',
    'ClusterRkeConfigDns',
    'ClusterRkeConfigDnsLinearAutoscalerParams',
    'ClusterRkeConfigDnsNodelocal',
    'ClusterRkeConfigDnsToleration',
    'ClusterRkeConfigDnsUpdateStrategy',
    'ClusterRkeConfigDnsUpdateStrategyRollingUpdate',
    'ClusterRkeConfigIngress',
    'ClusterRkeConfigIngressToleration',
    'ClusterRkeConfigIngressUpdateStrategy',
    'ClusterRkeConfigIngressUpdateStrategyRollingUpdate',
    'ClusterRkeConfigMonitoring',
    'ClusterRkeConfigMonitoringToleration',
    'ClusterRkeConfigMonitoringUpdateStrategy',
    'ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate',
    'ClusterRkeConfigNetwork',
    'ClusterRkeConfigNetworkAciNetworkProvider',
    'ClusterRkeConfigNetworkCalicoNetworkProvider',
    'ClusterRkeConfigNetworkCanalNetworkProvider',
    'ClusterRkeConfigNetworkFlannelNetworkProvider',
    'ClusterRkeConfigNetworkToleration',
    'ClusterRkeConfigNetworkWeaveNetworkProvider',
    'ClusterRkeConfigNode',
    'ClusterRkeConfigPrivateRegistry',
    'ClusterRkeConfigPrivateRegistryEcrCredentialPlugin',
    'ClusterRkeConfigServices',
    'ClusterRkeConfigServicesEtcd',
    'ClusterRkeConfigServicesEtcdBackupConfig',
    'ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig',
    'ClusterRkeConfigServicesKubeApi',
    'ClusterRkeConfigServicesKubeApiAdmissionConfiguration',
    'ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugin',
    'ClusterRkeConfigServicesKubeApiAuditLog',
    'ClusterRkeConfigServicesKubeApiAuditLogConfiguration',
    'ClusterRkeConfigServicesKubeApiEventRateLimit',
    'ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig',
    'ClusterRkeConfigServicesKubeController',
    'ClusterRkeConfigServicesKubelet',
    'ClusterRkeConfigServicesKubeproxy',
    'ClusterRkeConfigServicesScheduler',
    'ClusterRkeConfigUpgradeStrategy',
    'ClusterRkeConfigUpgradeStrategyDrainInput',
    'ClusterSyncNode',
    'ClusterTemplateMember',
    'ClusterTemplateTemplateRevision',
    'ClusterTemplateTemplateRevisionClusterConfig',
    'ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfig',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPlugin',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy',
    'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput',
    'ClusterTemplateTemplateRevisionQuestion',
    'ClusterV2AgentEnvVar',
    'ClusterV2ClusterAgentDeploymentCustomization',
    'ClusterV2ClusterAgentDeploymentCustomizationAppendToleration',
    'ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement',
    'ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization',
    'ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget',
    'ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass',
    'ClusterV2ClusterRegistrationToken',
    'ClusterV2FleetAgentDeploymentCustomization',
    'ClusterV2FleetAgentDeploymentCustomizationAppendToleration',
    'ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement',
    'ClusterV2LocalAuthEndpoint',
    'ClusterV2RkeConfig',
    'ClusterV2RkeConfigEtcd',
    'ClusterV2RkeConfigEtcdS3Config',
    'ClusterV2RkeConfigEtcdSnapshotCreate',
    'ClusterV2RkeConfigEtcdSnapshotRestore',
    'ClusterV2RkeConfigLocalAuthEndpoint',
    'ClusterV2RkeConfigMachinePool',
    'ClusterV2RkeConfigMachinePoolDefault',
    'ClusterV2RkeConfigMachinePoolMachineConfig',
    'ClusterV2RkeConfigMachinePoolRollingUpdate',
    'ClusterV2RkeConfigMachinePoolTaint',
    'ClusterV2RkeConfigMachineSelectorConfig',
    'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector',
    'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression',
    'ClusterV2RkeConfigMachineSelectorFile',
    'ClusterV2RkeConfigMachineSelectorFileFileSource',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceSecret',
    'ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem',
    'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector',
    'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression',
    'ClusterV2RkeConfigRegistries',
    'ClusterV2RkeConfigRegistriesConfig',
    'ClusterV2RkeConfigRegistriesMirror',
    'ClusterV2RkeConfigRotateCertificates',
    'ClusterV2RkeConfigUpgradeStrategy',
    'ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions',
    'ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions',
    'EtcdBackupBackupConfig',
    'EtcdBackupBackupConfigS3BackupConfig',
    'GlobalRoleRule',
    'MachineConfigV2Amazonec2Config',
    'MachineConfigV2AzureConfig',
    'MachineConfigV2DigitaloceanConfig',
    'MachineConfigV2GoogleConfig',
    'MachineConfigV2HarvesterConfig',
    'MachineConfigV2LinodeConfig',
    'MachineConfigV2OpenstackConfig',
    'MachineConfigV2VsphereConfig',
    'NamespaceContainerResourceLimit',
    'NamespaceResourceQuota',
    'NamespaceResourceQuotaLimit',
    'NodePoolNodeTaint',
    'NodeTemplateAmazonec2Config',
    'NodeTemplateAzureConfig',
    'NodeTemplateDigitaloceanConfig',
    'NodeTemplateHarvesterConfig',
    'NodeTemplateHetznerConfig',
    'NodeTemplateLinodeConfig',
    'NodeTemplateNodeTaint',
    'NodeTemplateOpennebulaConfig',
    'NodeTemplateOpenstackConfig',
    'NodeTemplateOutscaleConfig',
    'NodeTemplateVsphereConfig',
    'PodSecurityAdmissionConfigurationTemplateDefaults',
    'PodSecurityAdmissionConfigurationTemplateExemptions',
    'ProjectContainerResourceLimit',
    'ProjectResourceQuota',
    'ProjectResourceQuotaNamespaceDefaultLimit',
    'ProjectResourceQuotaProjectLimit',
    'RegistryRegistry',
    'RoleTemplateExternalRule',
    'RoleTemplateRule',
    'GetClusterAksConfigV2Result',
    'GetClusterAksConfigV2NodePoolResult',
    'GetClusterClusterAuthEndpointResult',
    'GetClusterClusterRegistrationTokenResult',
    'GetClusterClusterTemplateAnswersResult',
    'GetClusterClusterTemplateQuestionResult',
    'GetClusterEksConfigV2Result',
    'GetClusterEksConfigV2NodeGroupResult',
    'GetClusterEksConfigV2NodeGroupLaunchTemplateResult',
    'GetClusterGkeConfigV2Result',
    'GetClusterGkeConfigV2ClusterAddonsResult',
    'GetClusterGkeConfigV2IpAllocationPolicyResult',
    'GetClusterGkeConfigV2MasterAuthorizedNetworksConfigResult',
    'GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockResult',
    'GetClusterGkeConfigV2NodePoolResult',
    'GetClusterGkeConfigV2NodePoolAutoscalingResult',
    'GetClusterGkeConfigV2NodePoolConfigResult',
    'GetClusterGkeConfigV2NodePoolConfigTaintResult',
    'GetClusterGkeConfigV2NodePoolManagementResult',
    'GetClusterGkeConfigV2PrivateClusterConfigResult',
    'GetClusterImportedConfigResult',
    'GetClusterK3sConfigResult',
    'GetClusterK3sConfigUpgradeStrategyResult',
    'GetClusterOkeConfigResult',
    'GetClusterRke2ConfigResult',
    'GetClusterRke2ConfigUpgradeStrategyResult',
    'GetClusterRkeConfigResult',
    'GetClusterRkeConfigAuthenticationResult',
    'GetClusterRkeConfigAuthorizationResult',
    'GetClusterRkeConfigBastionHostResult',
    'GetClusterRkeConfigCloudProviderResult',
    'GetClusterRkeConfigCloudProviderAwsCloudProviderResult',
    'GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult',
    'GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult',
    'GetClusterRkeConfigCloudProviderAzureCloudProviderResult',
    'GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult',
    'GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult',
    'GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult',
    'GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult',
    'GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult',
    'GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult',
    'GetClusterRkeConfigCloudProviderVsphereCloudProviderResult',
    'GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult',
    'GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult',
    'GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult',
    'GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult',
    'GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult',
    'GetClusterRkeConfigDnsResult',
    'GetClusterRkeConfigDnsLinearAutoscalerParamsResult',
    'GetClusterRkeConfigDnsNodelocalResult',
    'GetClusterRkeConfigDnsTolerationResult',
    'GetClusterRkeConfigDnsUpdateStrategyResult',
    'GetClusterRkeConfigDnsUpdateStrategyRollingUpdateResult',
    'GetClusterRkeConfigIngressResult',
    'GetClusterRkeConfigIngressTolerationResult',
    'GetClusterRkeConfigIngressUpdateStrategyResult',
    'GetClusterRkeConfigIngressUpdateStrategyRollingUpdateResult',
    'GetClusterRkeConfigMonitoringResult',
    'GetClusterRkeConfigMonitoringTolerationResult',
    'GetClusterRkeConfigMonitoringUpdateStrategyResult',
    'GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdateResult',
    'GetClusterRkeConfigNetworkResult',
    'GetClusterRkeConfigNetworkAciNetworkProviderResult',
    'GetClusterRkeConfigNetworkCalicoNetworkProviderResult',
    'GetClusterRkeConfigNetworkCanalNetworkProviderResult',
    'GetClusterRkeConfigNetworkFlannelNetworkProviderResult',
    'GetClusterRkeConfigNetworkTolerationResult',
    'GetClusterRkeConfigNetworkWeaveNetworkProviderResult',
    'GetClusterRkeConfigNodeResult',
    'GetClusterRkeConfigPrivateRegistryResult',
    'GetClusterRkeConfigPrivateRegistryEcrCredentialPluginResult',
    'GetClusterRkeConfigServicesResult',
    'GetClusterRkeConfigServicesEtcdResult',
    'GetClusterRkeConfigServicesEtcdBackupConfigResult',
    'GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult',
    'GetClusterRkeConfigServicesKubeApiResult',
    'GetClusterRkeConfigServicesKubeApiAdmissionConfigurationResult',
    'GetClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginResult',
    'GetClusterRkeConfigServicesKubeApiAuditLogResult',
    'GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult',
    'GetClusterRkeConfigServicesKubeApiEventRateLimitResult',
    'GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult',
    'GetClusterRkeConfigServicesKubeControllerResult',
    'GetClusterRkeConfigServicesKubeletResult',
    'GetClusterRkeConfigServicesKubeproxyResult',
    'GetClusterRkeConfigServicesSchedulerResult',
    'GetClusterRkeConfigUpgradeStrategyResult',
    'GetClusterRkeConfigUpgradeStrategyDrainInputResult',
    'GetClusterTemplateMemberResult',
    'GetClusterTemplateTemplateRevisionResult',
    'GetClusterTemplateTemplateRevisionClusterConfigResult',
    'GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyResult',
    'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputResult',
    'GetClusterTemplateTemplateRevisionQuestionResult',
    'GetClusterV2AgentEnvVarResult',
    'GetClusterV2ClusterRegistrationTokenResult',
    'GetClusterV2RkeConfigResult',
    'GetClusterV2RkeConfigEtcdResult',
    'GetClusterV2RkeConfigEtcdS3ConfigResult',
    'GetClusterV2RkeConfigEtcdSnapshotCreateResult',
    'GetClusterV2RkeConfigEtcdSnapshotRestoreResult',
    'GetClusterV2RkeConfigLocalAuthEndpointResult',
    'GetClusterV2RkeConfigMachinePoolResult',
    'GetClusterV2RkeConfigMachinePoolDefaultResult',
    'GetClusterV2RkeConfigMachinePoolMachineConfigResult',
    'GetClusterV2RkeConfigMachinePoolRollingUpdateResult',
    'GetClusterV2RkeConfigMachinePoolTaintResult',
    'GetClusterV2RkeConfigMachineSelectorConfigResult',
    'GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorResult',
    'GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionResult',
    'GetClusterV2RkeConfigMachineSelectorFileResult',
    'GetClusterV2RkeConfigMachineSelectorFileFileSourceResult',
    'GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapResult',
    'GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemResult',
    'GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretResult',
    'GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemResult',
    'GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorResult',
    'GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionResult',
    'GetClusterV2RkeConfigRegistriesResult',
    'GetClusterV2RkeConfigRegistriesConfigResult',
    'GetClusterV2RkeConfigRegistriesMirrorResult',
    'GetClusterV2RkeConfigRotateCertificatesResult',
    'GetClusterV2RkeConfigUpgradeStrategyResult',
    'GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsResult',
    'GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsResult',
    'GetEtcdBackupBackupConfigResult',
    'GetEtcdBackupBackupConfigS3BackupConfigResult',
    'GetGlobalRoleRuleResult',
    'GetNamespaceContainerResourceLimitResult',
    'GetNamespaceResourceQuotaResult',
    'GetNamespaceResourceQuotaLimitResult',
    'GetNodePoolNodeTaintResult',
    'GetNodeTemplateNodeTaintResult',
    'GetPodSecurityAdmissionConfigurationTemplateDefaultsResult',
    'GetPodSecurityAdmissionConfigurationTemplateExemptionsResult',
    'GetProjectContainerResourceLimitResult',
    'GetProjectResourceQuotaResult',
    'GetProjectResourceQuotaNamespaceDefaultLimitResult',
    'GetProjectResourceQuotaProjectLimitResult',
    'GetRegistryRegistryResult',
    'GetRoleTemplateExternalRuleResult',
    'GetRoleTemplateRuleResult',
]

@pulumi.output_type
class CloudCredentialAmazonec2CredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "defaultRegion":
            suggest = "default_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialAmazonec2CredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialAmazonec2CredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialAmazonec2CredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 secret_key: _builtins.str,
                 default_region: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key: AWS Access Key
        :param _builtins.str secret_key: AWS Secret Key
        :param _builtins.str default_region: AWS default region
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if default_region is not None:
            pulumi.set(__self__, "default_region", default_region)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="defaultRegion")
    def default_region(self) -> Optional[_builtins.str]:
        """
        AWS default region
        """
        return pulumi.get(self, "default_region")


@pulumi.output_type
class CloudCredentialAzureCredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialAzureCredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialAzureCredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialAzureCredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret: _builtins.str,
                 subscription_id: _builtins.str,
                 environment: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Azure Service Principal Account ID
        :param _builtins.str client_secret: Azure Service Principal Account password
        :param _builtins.str subscription_id: Azure Subscription ID
        :param _builtins.str environment: Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        :param _builtins.str tenant_id: Azure Tenant ID
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret", client_secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        Azure Service Principal Account ID
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> _builtins.str:
        """
        Azure Service Principal Account password
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        Azure Subscription ID
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Azure Tenant ID
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class CloudCredentialDigitaloceanCredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialDigitaloceanCredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialDigitaloceanCredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialDigitaloceanCredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: _builtins.str):
        """
        :param _builtins.str access_token: Digital Ocean access token
        """
        pulumi.set(__self__, "access_token", access_token)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> _builtins.str:
        """
        Digital Ocean access token
        """
        return pulumi.get(self, "access_token")


@pulumi.output_type
class CloudCredentialGoogleCredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authEncodedJson":
            suggest = "auth_encoded_json"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialGoogleCredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialGoogleCredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialGoogleCredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_encoded_json: _builtins.str):
        """
        :param _builtins.str auth_encoded_json: Google auth encoded json
        """
        pulumi.set(__self__, "auth_encoded_json", auth_encoded_json)

    @_builtins.property
    @pulumi.getter(name="authEncodedJson")
    def auth_encoded_json(self) -> _builtins.str:
        """
        Google auth encoded json
        """
        return pulumi.get(self, "auth_encoded_json")


@pulumi.output_type
class CloudCredentialHarvesterCredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterType":
            suggest = "cluster_type"
        elif key == "kubeconfigContent":
            suggest = "kubeconfig_content"
        elif key == "clusterId":
            suggest = "cluster_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialHarvesterCredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialHarvesterCredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialHarvesterCredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_type: _builtins.str,
                 kubeconfig_content: _builtins.str,
                 cluster_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_type: Harvester cluster type. must be imported or external
        :param _builtins.str kubeconfig_content: Harvester cluster kubeconfig content
        :param _builtins.str cluster_id: The cluster id of imported Harvester cluster
        """
        pulumi.set(__self__, "cluster_type", cluster_type)
        pulumi.set(__self__, "kubeconfig_content", kubeconfig_content)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> _builtins.str:
        """
        Harvester cluster type. must be imported or external
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="kubeconfigContent")
    def kubeconfig_content(self) -> _builtins.str:
        """
        Harvester cluster kubeconfig content
        """
        return pulumi.get(self, "kubeconfig_content")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        The cluster id of imported Harvester cluster
        """
        return pulumi.get(self, "cluster_id")


@pulumi.output_type
class CloudCredentialLinodeCredentialConfig(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Linode API token
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Linode API token
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class CloudCredentialOpenstackCredentialConfig(dict):
    def __init__(__self__, *,
                 password: _builtins.str):
        """
        :param _builtins.str password: OpenStack password
        """
        pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        OpenStack password
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class CloudCredentialS3CredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "defaultBucket":
            suggest = "default_bucket"
        elif key == "defaultEndpoint":
            suggest = "default_endpoint"
        elif key == "defaultEndpointCa":
            suggest = "default_endpoint_ca"
        elif key == "defaultFolder":
            suggest = "default_folder"
        elif key == "defaultRegion":
            suggest = "default_region"
        elif key == "defaultSkipSslVerify":
            suggest = "default_skip_ssl_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialS3CredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialS3CredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialS3CredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 secret_key: _builtins.str,
                 default_bucket: Optional[_builtins.str] = None,
                 default_endpoint: Optional[_builtins.str] = None,
                 default_endpoint_ca: Optional[_builtins.str] = None,
                 default_folder: Optional[_builtins.str] = None,
                 default_region: Optional[_builtins.str] = None,
                 default_skip_ssl_verify: Optional[_builtins.bool] = None):
        """
        :param _builtins.str access_key: AWS Access Key
        :param _builtins.str secret_key: AWS Secret Key
        :param _builtins.str default_bucket: AWS default bucket
        :param _builtins.str default_endpoint: AWS default endpoint
        :param _builtins.str default_endpoint_ca: AWS default endpoint CA
        :param _builtins.str default_folder: AWS default folder
        :param _builtins.str default_region: AWS default region
        :param _builtins.bool default_skip_ssl_verify: AWS default skip ssl verify
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if default_bucket is not None:
            pulumi.set(__self__, "default_bucket", default_bucket)
        if default_endpoint is not None:
            pulumi.set(__self__, "default_endpoint", default_endpoint)
        if default_endpoint_ca is not None:
            pulumi.set(__self__, "default_endpoint_ca", default_endpoint_ca)
        if default_folder is not None:
            pulumi.set(__self__, "default_folder", default_folder)
        if default_region is not None:
            pulumi.set(__self__, "default_region", default_region)
        if default_skip_ssl_verify is not None:
            pulumi.set(__self__, "default_skip_ssl_verify", default_skip_ssl_verify)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="defaultBucket")
    def default_bucket(self) -> Optional[_builtins.str]:
        """
        AWS default bucket
        """
        return pulumi.get(self, "default_bucket")

    @_builtins.property
    @pulumi.getter(name="defaultEndpoint")
    def default_endpoint(self) -> Optional[_builtins.str]:
        """
        AWS default endpoint
        """
        return pulumi.get(self, "default_endpoint")

    @_builtins.property
    @pulumi.getter(name="defaultEndpointCa")
    def default_endpoint_ca(self) -> Optional[_builtins.str]:
        """
        AWS default endpoint CA
        """
        return pulumi.get(self, "default_endpoint_ca")

    @_builtins.property
    @pulumi.getter(name="defaultFolder")
    def default_folder(self) -> Optional[_builtins.str]:
        """
        AWS default folder
        """
        return pulumi.get(self, "default_folder")

    @_builtins.property
    @pulumi.getter(name="defaultRegion")
    def default_region(self) -> Optional[_builtins.str]:
        """
        AWS default region
        """
        return pulumi.get(self, "default_region")

    @_builtins.property
    @pulumi.getter(name="defaultSkipSslVerify")
    def default_skip_ssl_verify(self) -> Optional[_builtins.bool]:
        """
        AWS default skip ssl verify
        """
        return pulumi.get(self, "default_skip_ssl_verify")


@pulumi.output_type
class CloudCredentialVsphereCredentialConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vcenterPort":
            suggest = "vcenter_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudCredentialVsphereCredentialConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudCredentialVsphereCredentialConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudCredentialVsphereCredentialConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str,
                 vcenter: _builtins.str,
                 vcenter_port: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: vSphere password
        :param _builtins.str username: vSphere username
        :param _builtins.str vcenter: vSphere IP/hostname for vCenter
        :param _builtins.str vcenter_port: vSphere Port for vCenter
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "vcenter", vcenter)
        if vcenter_port is not None:
            pulumi.set(__self__, "vcenter_port", vcenter_port)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        vSphere password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        vSphere username
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def vcenter(self) -> _builtins.str:
        """
        vSphere IP/hostname for vCenter
        """
        return pulumi.get(self, "vcenter")

    @_builtins.property
    @pulumi.getter(name="vcenterPort")
    def vcenter_port(self) -> Optional[_builtins.str]:
        """
        vSphere Port for vCenter
        """
        return pulumi.get(self, "vcenter_port")


@pulumi.output_type
class ClusterAgentEnvVar(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterAksConfigV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudCredentialId":
            suggest = "cloud_credential_id"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "resourceLocation":
            suggest = "resource_location"
        elif key == "authBaseUrl":
            suggest = "auth_base_url"
        elif key == "authorizedIpRanges":
            suggest = "authorized_ip_ranges"
        elif key == "baseUrl":
            suggest = "base_url"
        elif key == "dnsPrefix":
            suggest = "dns_prefix"
        elif key == "httpApplicationRouting":
            suggest = "http_application_routing"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "linuxAdminUsername":
            suggest = "linux_admin_username"
        elif key == "linuxSshPublicKey":
            suggest = "linux_ssh_public_key"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "logAnalyticsWorkspaceGroup":
            suggest = "log_analytics_workspace_group"
        elif key == "logAnalyticsWorkspaceName":
            suggest = "log_analytics_workspace_name"
        elif key == "networkDnsServiceIp":
            suggest = "network_dns_service_ip"
        elif key == "networkDockerBridgeCidr":
            suggest = "network_docker_bridge_cidr"
        elif key == "networkPlugin":
            suggest = "network_plugin"
        elif key == "networkPodCidr":
            suggest = "network_pod_cidr"
        elif key == "networkPolicy":
            suggest = "network_policy"
        elif key == "networkServiceCidr":
            suggest = "network_service_cidr"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "nodeResourceGroup":
            suggest = "node_resource_group"
        elif key == "outboundType":
            suggest = "outbound_type"
        elif key == "privateCluster":
            suggest = "private_cluster"
        elif key == "virtualNetwork":
            suggest = "virtual_network"
        elif key == "virtualNetworkResourceGroup":
            suggest = "virtual_network_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAksConfigV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAksConfigV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAksConfigV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_credential_id: _builtins.str,
                 resource_group: _builtins.str,
                 resource_location: _builtins.str,
                 auth_base_url: Optional[_builtins.str] = None,
                 authorized_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 base_url: Optional[_builtins.str] = None,
                 dns_prefix: Optional[_builtins.str] = None,
                 http_application_routing: Optional[_builtins.bool] = None,
                 imported: Optional[_builtins.bool] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 linux_admin_username: Optional[_builtins.str] = None,
                 linux_ssh_public_key: Optional[_builtins.str] = None,
                 load_balancer_sku: Optional[_builtins.str] = None,
                 log_analytics_workspace_group: Optional[_builtins.str] = None,
                 log_analytics_workspace_name: Optional[_builtins.str] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 network_dns_service_ip: Optional[_builtins.str] = None,
                 network_docker_bridge_cidr: Optional[_builtins.str] = None,
                 network_plugin: Optional[_builtins.str] = None,
                 network_pod_cidr: Optional[_builtins.str] = None,
                 network_policy: Optional[_builtins.str] = None,
                 network_service_cidr: Optional[_builtins.str] = None,
                 node_pools: Optional[Sequence['outputs.ClusterAksConfigV2NodePool']] = None,
                 node_resource_group: Optional[_builtins.str] = None,
                 outbound_type: Optional[_builtins.str] = None,
                 private_cluster: Optional[_builtins.bool] = None,
                 subnet: Optional[_builtins.str] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 virtual_network: Optional[_builtins.str] = None,
                 virtual_network_resource_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_credential_id: The AKS Cloud Credential ID to use
        :param _builtins.str resource_group: The AKS resource group
        :param _builtins.str resource_location: The AKS resource location
        :param _builtins.str auth_base_url: The AKS auth base url
        :param Sequence[_builtins.str] authorized_ip_ranges: The AKS authorized ip ranges
        :param _builtins.str base_url: The AKS base url
        :param _builtins.str dns_prefix: The AKS dns prefix. Required if `import=false`
        :param _builtins.bool http_application_routing: Enable AKS http application routing?
        :param _builtins.bool imported: Is AKS cluster imported?
        :param _builtins.str kubernetes_version: The kubernetes master version. Required if `import=false`
        :param _builtins.str linux_admin_username: The AKS linux admin username
        :param _builtins.str linux_ssh_public_key: The AKS linux ssh public key
        :param _builtins.str load_balancer_sku: The AKS load balancer sku
        :param _builtins.str log_analytics_workspace_group: The AKS log analytics workspace group
        :param _builtins.str log_analytics_workspace_name: The AKS log analytics workspace name
        :param _builtins.bool monitoring: Is AKS cluster monitoring enabled?
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str network_dns_service_ip: The AKS network dns service ip
        :param _builtins.str network_docker_bridge_cidr: The AKS network docker bridge cidr
        :param _builtins.str network_plugin: The AKS network plugin. Required if `import=false`
        :param _builtins.str network_pod_cidr: The AKS network pod cidr
        :param _builtins.str network_policy: The AKS network policy
        :param _builtins.str network_service_cidr: The AKS network service cidr
        :param Sequence['ClusterAksConfigV2NodePoolArgs'] node_pools: The AKS node pools to use. Required if `import=false`
        :param _builtins.str node_resource_group: The AKS node resource group name
        :param _builtins.str outbound_type: The AKS outbound type for the egress traffic
        :param _builtins.bool private_cluster: Is AKS cluster private?
        :param _builtins.str subnet: The AKS subnet
        :param Mapping[str, _builtins.str] tags: The AKS cluster tags
        :param _builtins.str virtual_network: The AKS virtual network
        :param _builtins.str virtual_network_resource_group: The AKS virtual network resource group
        """
        pulumi.set(__self__, "cloud_credential_id", cloud_credential_id)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "resource_location", resource_location)
        if auth_base_url is not None:
            pulumi.set(__self__, "auth_base_url", auth_base_url)
        if authorized_ip_ranges is not None:
            pulumi.set(__self__, "authorized_ip_ranges", authorized_ip_ranges)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)
        if http_application_routing is not None:
            pulumi.set(__self__, "http_application_routing", http_application_routing)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if linux_admin_username is not None:
            pulumi.set(__self__, "linux_admin_username", linux_admin_username)
        if linux_ssh_public_key is not None:
            pulumi.set(__self__, "linux_ssh_public_key", linux_ssh_public_key)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if log_analytics_workspace_group is not None:
            pulumi.set(__self__, "log_analytics_workspace_group", log_analytics_workspace_group)
        if log_analytics_workspace_name is not None:
            pulumi.set(__self__, "log_analytics_workspace_name", log_analytics_workspace_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network_dns_service_ip is not None:
            pulumi.set(__self__, "network_dns_service_ip", network_dns_service_ip)
        if network_docker_bridge_cidr is not None:
            pulumi.set(__self__, "network_docker_bridge_cidr", network_docker_bridge_cidr)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if network_pod_cidr is not None:
            pulumi.set(__self__, "network_pod_cidr", network_pod_cidr)
        if network_policy is not None:
            pulumi.set(__self__, "network_policy", network_policy)
        if network_service_cidr is not None:
            pulumi.set(__self__, "network_service_cidr", network_service_cidr)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if node_resource_group is not None:
            pulumi.set(__self__, "node_resource_group", node_resource_group)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)
        if private_cluster is not None:
            pulumi.set(__self__, "private_cluster", private_cluster)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if virtual_network is not None:
            pulumi.set(__self__, "virtual_network", virtual_network)
        if virtual_network_resource_group is not None:
            pulumi.set(__self__, "virtual_network_resource_group", virtual_network_resource_group)

    @_builtins.property
    @pulumi.getter(name="cloudCredentialId")
    def cloud_credential_id(self) -> _builtins.str:
        """
        The AKS Cloud Credential ID to use
        """
        return pulumi.get(self, "cloud_credential_id")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        """
        The AKS resource group
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> _builtins.str:
        """
        The AKS resource location
        """
        return pulumi.get(self, "resource_location")

    @_builtins.property
    @pulumi.getter(name="authBaseUrl")
    def auth_base_url(self) -> Optional[_builtins.str]:
        """
        The AKS auth base url
        """
        return pulumi.get(self, "auth_base_url")

    @_builtins.property
    @pulumi.getter(name="authorizedIpRanges")
    def authorized_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AKS authorized ip ranges
        """
        return pulumi.get(self, "authorized_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        The AKS base url
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[_builtins.str]:
        """
        The AKS dns prefix. Required if `import=false`
        """
        return pulumi.get(self, "dns_prefix")

    @_builtins.property
    @pulumi.getter(name="httpApplicationRouting")
    def http_application_routing(self) -> Optional[_builtins.bool]:
        """
        Enable AKS http application routing?
        """
        return pulumi.get(self, "http_application_routing")

    @_builtins.property
    @pulumi.getter
    def imported(self) -> Optional[_builtins.bool]:
        """
        Is AKS cluster imported?
        """
        return pulumi.get(self, "imported")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        The kubernetes master version. Required if `import=false`
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter(name="linuxAdminUsername")
    def linux_admin_username(self) -> Optional[_builtins.str]:
        """
        The AKS linux admin username
        """
        return pulumi.get(self, "linux_admin_username")

    @_builtins.property
    @pulumi.getter(name="linuxSshPublicKey")
    def linux_ssh_public_key(self) -> Optional[_builtins.str]:
        """
        The AKS linux ssh public key
        """
        return pulumi.get(self, "linux_ssh_public_key")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        The AKS load balancer sku
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceGroup")
    def log_analytics_workspace_group(self) -> Optional[_builtins.str]:
        """
        The AKS log analytics workspace group
        """
        return pulumi.get(self, "log_analytics_workspace_group")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceName")
    def log_analytics_workspace_name(self) -> Optional[_builtins.str]:
        """
        The AKS log analytics workspace name
        """
        return pulumi.get(self, "log_analytics_workspace_name")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        """
        Is AKS cluster monitoring enabled?
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkDnsServiceIp")
    def network_dns_service_ip(self) -> Optional[_builtins.str]:
        """
        The AKS network dns service ip
        """
        return pulumi.get(self, "network_dns_service_ip")

    @_builtins.property
    @pulumi.getter(name="networkDockerBridgeCidr")
    def network_docker_bridge_cidr(self) -> Optional[_builtins.str]:
        """
        The AKS network docker bridge cidr
        """
        return pulumi.get(self, "network_docker_bridge_cidr")

    @_builtins.property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[_builtins.str]:
        """
        The AKS network plugin. Required if `import=false`
        """
        return pulumi.get(self, "network_plugin")

    @_builtins.property
    @pulumi.getter(name="networkPodCidr")
    def network_pod_cidr(self) -> Optional[_builtins.str]:
        """
        The AKS network pod cidr
        """
        return pulumi.get(self, "network_pod_cidr")

    @_builtins.property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> Optional[_builtins.str]:
        """
        The AKS network policy
        """
        return pulumi.get(self, "network_policy")

    @_builtins.property
    @pulumi.getter(name="networkServiceCidr")
    def network_service_cidr(self) -> Optional[_builtins.str]:
        """
        The AKS network service cidr
        """
        return pulumi.get(self, "network_service_cidr")

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.ClusterAksConfigV2NodePool']]:
        """
        The AKS node pools to use. Required if `import=false`
        """
        return pulumi.get(self, "node_pools")

    @_builtins.property
    @pulumi.getter(name="nodeResourceGroup")
    def node_resource_group(self) -> Optional[_builtins.str]:
        """
        The AKS node resource group name
        """
        return pulumi.get(self, "node_resource_group")

    @_builtins.property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[_builtins.str]:
        """
        The AKS outbound type for the egress traffic
        """
        return pulumi.get(self, "outbound_type")

    @_builtins.property
    @pulumi.getter(name="privateCluster")
    def private_cluster(self) -> Optional[_builtins.bool]:
        """
        Is AKS cluster private?
        """
        return pulumi.get(self, "private_cluster")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        The AKS subnet
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The AKS cluster tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="virtualNetwork")
    def virtual_network(self) -> Optional[_builtins.str]:
        """
        The AKS virtual network
        """
        return pulumi.get(self, "virtual_network")

    @_builtins.property
    @pulumi.getter(name="virtualNetworkResourceGroup")
    def virtual_network_resource_group(self) -> Optional[_builtins.str]:
        """
        The AKS virtual network resource group
        """
        return pulumi.get(self, "virtual_network_resource_group")


@pulumi.output_type
class ClusterAksConfigV2NodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "enableAutoScaling":
            suggest = "enable_auto_scaling"
        elif key == "maxCount":
            suggest = "max_count"
        elif key == "maxPods":
            suggest = "max_pods"
        elif key == "maxSurge":
            suggest = "max_surge"
        elif key == "minCount":
            suggest = "min_count"
        elif key == "orchestratorVersion":
            suggest = "orchestrator_version"
        elif key == "osDiskSizeGb":
            suggest = "os_disk_size_gb"
        elif key == "osDiskType":
            suggest = "os_disk_type"
        elif key == "osType":
            suggest = "os_type"
        elif key == "vmSize":
            suggest = "vm_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAksConfigV2NodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAksConfigV2NodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAksConfigV2NodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 count: Optional[_builtins.int] = None,
                 enable_auto_scaling: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 max_count: Optional[_builtins.int] = None,
                 max_pods: Optional[_builtins.int] = None,
                 max_surge: Optional[_builtins.str] = None,
                 min_count: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 orchestrator_version: Optional[_builtins.str] = None,
                 os_disk_size_gb: Optional[_builtins.int] = None,
                 os_disk_type: Optional[_builtins.str] = None,
                 os_type: Optional[_builtins.str] = None,
                 taints: Optional[Sequence[_builtins.str]] = None,
                 vm_size: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the Cluster (string)
        :param Sequence[_builtins.str] availability_zones: The AKS node pool availability zones
        :param _builtins.int count: The AKS node pool count
        :param _builtins.bool enable_auto_scaling: Is AKS node pool auto scaling enabled?
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster (map)
        :param _builtins.int max_count: The AKS node pool max count
        :param _builtins.int max_pods: The AKS node pool max pods
        :param _builtins.str max_surge: The AKS node pool max surge
        :param _builtins.int min_count: The AKS node pool min count
        :param _builtins.str mode: The AKS node pool mode
        :param _builtins.str orchestrator_version: The AKS node pool orchestrator version
        :param _builtins.int os_disk_size_gb: The AKS node pool os disk size gb
        :param _builtins.str os_disk_type: The AKS node pool os disk type
        :param _builtins.str os_type: Enable AKS node pool os type
        :param Sequence[_builtins.str] taints: The AKS node pool taints
        :param _builtins.str vm_size: The AKS node pool vm size
        """
        pulumi.set(__self__, "name", name)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enable_auto_scaling is not None:
            pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if vm_size is not None:
            pulumi.set(__self__, "vm_size", vm_size)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AKS node pool availability zones
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The AKS node pool count
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> Optional[_builtins.bool]:
        """
        Is AKS node pool auto scaling enabled?
        """
        return pulumi.get(self, "enable_auto_scaling")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        The AKS node pool max count
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        """
        The AKS node pool max pods
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        The AKS node pool max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[_builtins.int]:
        """
        The AKS node pool min count
        """
        return pulumi.get(self, "min_count")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The AKS node pool mode
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[_builtins.str]:
        """
        The AKS node pool orchestrator version
        """
        return pulumi.get(self, "orchestrator_version")

    @_builtins.property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The AKS node pool os disk size gb
        """
        return pulumi.get(self, "os_disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[_builtins.str]:
        """
        The AKS node pool os disk type
        """
        return pulumi.get(self, "os_disk_type")

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[_builtins.str]:
        """
        Enable AKS node pool os type
        """
        return pulumi.get(self, "os_type")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AKS node pool taints
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> Optional[_builtins.str]:
        """
        The AKS node pool vm size
        """
        return pulumi.get(self, "vm_size")


@pulumi.output_type
class ClusterClusterAgentDeploymentCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendTolerations":
            suggest = "append_tolerations"
        elif key == "overrideAffinity":
            suggest = "override_affinity"
        elif key == "overrideResourceRequirements":
            suggest = "override_resource_requirements"
        elif key == "schedulingCustomizations":
            suggest = "scheduling_customizations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAgentDeploymentCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAgentDeploymentCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAgentDeploymentCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_tolerations: Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationAppendToleration']] = None,
                 override_affinity: Optional[_builtins.str] = None,
                 override_resource_requirements: Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement']] = None,
                 scheduling_customizations: Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationSchedulingCustomization']] = None):
        """
        :param Sequence['ClusterClusterAgentDeploymentCustomizationAppendTolerationArgs'] append_tolerations: User defined tolerations to append to agent
        :param _builtins.str override_affinity: User defined affinity to override default agent affinity
        :param Sequence['ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs'] override_resource_requirements: User defined resource requirements to set on the agent
        :param Sequence['ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationArgs'] scheduling_customizations: User defined scheduling customization for the cattle cluster agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)
        if scheduling_customizations is not None:
            pulumi.set(__self__, "scheduling_customizations", scheduling_customizations)

    @_builtins.property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationAppendToleration']]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @_builtins.property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[_builtins.str]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @_builtins.property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement']]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")

    @_builtins.property
    @pulumi.getter(name="schedulingCustomizations")
    def scheduling_customizations(self) -> Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationSchedulingCustomization']]:
        """
        User defined scheduling customization for the cattle cluster agent
        """
        return pulumi.get(self, "scheduling_customizations")


@pulumi.output_type
class ClusterClusterAgentDeploymentCustomizationAppendToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param _builtins.int seconds: The toleration seconds (int)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit: Optional[_builtins.str] = None,
                 cpu_request: Optional[_builtins.str] = None,
                 memory_limit: Optional[_builtins.str] = None,
                 memory_request: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_limit: The maximum CPU limit for agent
        :param _builtins.str cpu_request: The minimum CPU required for agent
        :param _builtins.str memory_limit: The maximum memory limit for agent
        :param _builtins.str memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @_builtins.property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[_builtins.str]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @_builtins.property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[_builtins.str]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.str]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @_builtins.property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[_builtins.str]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ClusterClusterAgentDeploymentCustomizationSchedulingCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podDisruptionBudgets":
            suggest = "pod_disruption_budgets"
        elif key == "priorityClasses":
            suggest = "priority_classes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAgentDeploymentCustomizationSchedulingCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAgentDeploymentCustomizationSchedulingCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAgentDeploymentCustomizationSchedulingCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_disruption_budgets: Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget']] = None,
                 priority_classes: Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass']] = None):
        """
        :param Sequence['ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetArgs'] pod_disruption_budgets: The Pod Disruption Budget created for the cattle cluster agent
        :param Sequence['ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassArgs'] priority_classes: The Priority Class created for the cattle cluster agent
        """
        if pod_disruption_budgets is not None:
            pulumi.set(__self__, "pod_disruption_budgets", pod_disruption_budgets)
        if priority_classes is not None:
            pulumi.set(__self__, "priority_classes", priority_classes)

    @_builtins.property
    @pulumi.getter(name="podDisruptionBudgets")
    def pod_disruption_budgets(self) -> Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget']]:
        """
        The Pod Disruption Budget created for the cattle cluster agent
        """
        return pulumi.get(self, "pod_disruption_budgets")

    @_builtins.property
    @pulumi.getter(name="priorityClasses")
    def priority_classes(self) -> Optional[Sequence['outputs.ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass']]:
        """
        The Priority Class created for the cattle cluster agent
        """
        return pulumi.get(self, "priority_classes")


@pulumi.output_type
class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "minAvailable":
            suggest = "min_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: Optional[_builtins.str] = None,
                 min_available: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_unavailable: The maximum number of cattle cluster agent replicas that can be down at a given time.
        :param _builtins.str min_available: The minimum number of cattle cluster agent replicas that must be running at a given time.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if min_available is not None:
            pulumi.set(__self__, "min_available", min_available)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        The maximum number of cattle cluster agent replicas that can be down at a given time.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> Optional[_builtins.str]:
        """
        The minimum number of cattle cluster agent replicas that must be running at a given time.
        """
        return pulumi.get(self, "min_available")


@pulumi.output_type
class ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preemptionPolicy":
            suggest = "preemption_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: _builtins.int,
                 preemption_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.int value: The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
        :param _builtins.str preemption_policy: The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
        """
        pulumi.set(__self__, "value", value)
        if preemption_policy is not None:
            pulumi.set(__self__, "preemption_policy", preemption_policy)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="preemptionPolicy")
    def preemption_policy(self) -> Optional[_builtins.str]:
        """
        The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
        """
        return pulumi.get(self, "preemption_policy")


@pulumi.output_type
class ClusterClusterAuthEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterAuthEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterAuthEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterAuthEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certs: CA certs for the authorized cluster endpoint (string)
        :param _builtins.bool enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        :param _builtins.str fqdn: FQDN for the authorized cluster endpoint (string)
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        """
        CA certs for the authorized cluster endpoint (string)
        """
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        FQDN for the authorized cluster endpoint (string)
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class ClusterClusterRegistrationToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "insecureCommand":
            suggest = "insecure_command"
        elif key == "insecureNodeCommand":
            suggest = "insecure_node_command"
        elif key == "insecureWindowsNodeCommand":
            suggest = "insecure_windows_node_command"
        elif key == "manifestUrl":
            suggest = "manifest_url"
        elif key == "nodeCommand":
            suggest = "node_command"
        elif key == "windowsNodeCommand":
            suggest = "windows_node_command"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterRegistrationToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterRegistrationToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterRegistrationToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 command: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 insecure_command: Optional[_builtins.str] = None,
                 insecure_node_command: Optional[_builtins.str] = None,
                 insecure_windows_node_command: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 manifest_url: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 node_command: Optional[_builtins.str] = None,
                 token: Optional[_builtins.str] = None,
                 windows_node_command: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] annotations: Annotations for the Cluster (map)
        :param _builtins.str command: Command to execute in a imported k8s cluster (string)
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param _builtins.str insecure_command: Insecure command to execute in a imported k8s cluster (string)
        :param _builtins.str insecure_node_command: Insecure node command to execute in a imported k8s cluster (string)
        :param _builtins.str insecure_windows_node_command: Insecure windows command to execute in a imported k8s cluster (string)
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster (map)
        :param _builtins.str manifest_url: K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str node_command: Node command to execute in linux nodes for custom k8s cluster (string)
        :param _builtins.str windows_node_command: Node command to execute in windows nodes for custom k8s cluster (string)
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure_command is not None:
            pulumi.set(__self__, "insecure_command", insecure_command)
        if insecure_node_command is not None:
            pulumi.set(__self__, "insecure_node_command", insecure_node_command)
        if insecure_windows_node_command is not None:
            pulumi.set(__self__, "insecure_windows_node_command", insecure_windows_node_command)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if manifest_url is not None:
            pulumi.set(__self__, "manifest_url", manifest_url)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_command is not None:
            pulumi.set(__self__, "node_command", node_command)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if windows_node_command is not None:
            pulumi.set(__self__, "windows_node_command", windows_node_command)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations for the Cluster (map)
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        """
        Command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="insecureCommand")
    def insecure_command(self) -> Optional[_builtins.str]:
        """
        Insecure command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "insecure_command")

    @_builtins.property
    @pulumi.getter(name="insecureNodeCommand")
    def insecure_node_command(self) -> Optional[_builtins.str]:
        """
        Insecure node command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "insecure_node_command")

    @_builtins.property
    @pulumi.getter(name="insecureWindowsNodeCommand")
    def insecure_windows_node_command(self) -> Optional[_builtins.str]:
        """
        Insecure windows command to execute in a imported k8s cluster (string)
        """
        return pulumi.get(self, "insecure_windows_node_command")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="manifestUrl")
    def manifest_url(self) -> Optional[_builtins.str]:
        """
        K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
        """
        return pulumi.get(self, "manifest_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCommand")
    def node_command(self) -> Optional[_builtins.str]:
        """
        Node command to execute in linux nodes for custom k8s cluster (string)
        """
        return pulumi.get(self, "node_command")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="windowsNodeCommand")
    def windows_node_command(self) -> Optional[_builtins.str]:
        """
        Node command to execute in windows nodes for custom k8s cluster (string)
        """
        return pulumi.get(self, "windows_node_command")


@pulumi.output_type
class ClusterClusterTemplateAnswers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterClusterTemplateAnswers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterClusterTemplateAnswers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterClusterTemplateAnswers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 values: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cluster_id: Cluster ID for answer
        :param _builtins.str project_id: Project ID for answer
        :param Mapping[str, _builtins.str] values: Key/values for answer
        """
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        Cluster ID for answer
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID for answer
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key/values for answer
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterClusterTemplateQuestion(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 variable: _builtins.str,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str default: Default variable value
        :param _builtins.str variable: Variable name
        :param _builtins.bool required: Required variable
        :param _builtins.str type: Variable type
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "variable", variable)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        """
        Default variable value
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Variable name
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Required variable
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Variable type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterEksConfigV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudCredentialId":
            suggest = "cloud_credential_id"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "loggingTypes":
            suggest = "logging_types"
        elif key == "nodeGroups":
            suggest = "node_groups"
        elif key == "privateAccess":
            suggest = "private_access"
        elif key == "publicAccess":
            suggest = "public_access"
        elif key == "publicAccessSources":
            suggest = "public_access_sources"
        elif key == "secretsEncryption":
            suggest = "secrets_encryption"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "serviceRole":
            suggest = "service_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEksConfigV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEksConfigV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEksConfigV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_credential_id: _builtins.str,
                 imported: Optional[_builtins.bool] = None,
                 kms_key: Optional[_builtins.str] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 logging_types: Optional[Sequence[_builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 node_groups: Optional[Sequence['outputs.ClusterEksConfigV2NodeGroup']] = None,
                 private_access: Optional[_builtins.bool] = None,
                 public_access: Optional[_builtins.bool] = None,
                 public_access_sources: Optional[Sequence[_builtins.str]] = None,
                 region: Optional[_builtins.str] = None,
                 secrets_encryption: Optional[_builtins.bool] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_role: Optional[_builtins.str] = None,
                 subnets: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cloud_credential_id: The AWS Cloud Credential ID to use
        :param _builtins.bool imported: Is EKS cluster imported?
        :param _builtins.str kms_key: The AWS kms key to use
        :param _builtins.str kubernetes_version: The kubernetes master version
        :param Sequence[_builtins.str] logging_types: The AWS logging types
        :param _builtins.str name: The name of the Cluster (string)
        :param Sequence['ClusterEksConfigV2NodeGroupArgs'] node_groups: The AWS node groups to use
        :param _builtins.bool private_access: The EKS cluster has private access
        :param _builtins.bool public_access: The EKS cluster has public access
        :param Sequence[_builtins.str] public_access_sources: The EKS cluster public access sources
        :param _builtins.str region: The AWS Region to create the EKS cluster in
        :param _builtins.bool secrets_encryption: Enable EKS cluster secret encryption
        :param Sequence[_builtins.str] security_groups: List of security groups to use for the cluster
        :param _builtins.str service_role: The AWS service role to use
        :param Sequence[_builtins.str] subnets: List of subnets in the virtual network to use
        :param Mapping[str, _builtins.str] tags: The EKS cluster tags
        """
        pulumi.set(__self__, "cloud_credential_id", cloud_credential_id)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if logging_types is not None:
            pulumi.set(__self__, "logging_types", logging_types)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_groups is not None:
            pulumi.set(__self__, "node_groups", node_groups)
        if private_access is not None:
            pulumi.set(__self__, "private_access", private_access)
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if public_access_sources is not None:
            pulumi.set(__self__, "public_access_sources", public_access_sources)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secrets_encryption is not None:
            pulumi.set(__self__, "secrets_encryption", secrets_encryption)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="cloudCredentialId")
    def cloud_credential_id(self) -> _builtins.str:
        """
        The AWS Cloud Credential ID to use
        """
        return pulumi.get(self, "cloud_credential_id")

    @_builtins.property
    @pulumi.getter
    def imported(self) -> Optional[_builtins.bool]:
        """
        Is EKS cluster imported?
        """
        return pulumi.get(self, "imported")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        The AWS kms key to use
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter(name="loggingTypes")
    def logging_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AWS logging types
        """
        return pulumi.get(self, "logging_types")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeGroups")
    def node_groups(self) -> Optional[Sequence['outputs.ClusterEksConfigV2NodeGroup']]:
        """
        The AWS node groups to use
        """
        return pulumi.get(self, "node_groups")

    @_builtins.property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> Optional[_builtins.bool]:
        """
        The EKS cluster has private access
        """
        return pulumi.get(self, "private_access")

    @_builtins.property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[_builtins.bool]:
        """
        The EKS cluster has public access
        """
        return pulumi.get(self, "public_access")

    @_builtins.property
    @pulumi.getter(name="publicAccessSources")
    def public_access_sources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The EKS cluster public access sources
        """
        return pulumi.get(self, "public_access_sources")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS Region to create the EKS cluster in
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretsEncryption")
    def secrets_encryption(self) -> Optional[_builtins.bool]:
        """
        Enable EKS cluster secret encryption
        """
        return pulumi.get(self, "secrets_encryption")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups to use for the cluster
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[_builtins.str]:
        """
        The AWS service role to use
        """
        return pulumi.get(self, "service_role")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of subnets in the virtual network to use
        """
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The EKS cluster tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ClusterEksConfigV2NodeGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "desiredSize":
            suggest = "desired_size"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "ec2SshKey":
            suggest = "ec2_ssh_key"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "launchTemplates":
            suggest = "launch_templates"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "nodeRole":
            suggest = "node_role"
        elif key == "requestSpotInstances":
            suggest = "request_spot_instances"
        elif key == "resourceTags":
            suggest = "resource_tags"
        elif key == "spotInstanceTypes":
            suggest = "spot_instance_types"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEksConfigV2NodeGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEksConfigV2NodeGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEksConfigV2NodeGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 desired_size: Optional[_builtins.int] = None,
                 disk_size: Optional[_builtins.int] = None,
                 ec2_ssh_key: Optional[_builtins.str] = None,
                 gpu: Optional[_builtins.bool] = None,
                 image_id: Optional[_builtins.str] = None,
                 instance_type: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 launch_templates: Optional[Sequence['outputs.ClusterEksConfigV2NodeGroupLaunchTemplate']] = None,
                 max_size: Optional[_builtins.int] = None,
                 min_size: Optional[_builtins.int] = None,
                 node_role: Optional[_builtins.str] = None,
                 request_spot_instances: Optional[_builtins.bool] = None,
                 resource_tags: Optional[Mapping[str, _builtins.str]] = None,
                 spot_instance_types: Optional[Sequence[_builtins.str]] = None,
                 subnets: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None,
                 user_data: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.int desired_size: The EKS node group desired size
        :param _builtins.int disk_size: The EKS node group disk size
        :param _builtins.str ec2_ssh_key: The EKS node group ssh key
        :param _builtins.bool gpu: Is EKS cluster using gpu?
        :param _builtins.str image_id: The EKS node group image ID
        :param _builtins.str instance_type: The EKS node group instance type
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster (map)
        :param Sequence['ClusterEksConfigV2NodeGroupLaunchTemplateArgs'] launch_templates: The EKS node groups launch template
        :param _builtins.int max_size: The EKS node group maximum size
        :param _builtins.int min_size: The EKS node group minimum size
        :param _builtins.str node_role: The EKS node group node role ARN
        :param _builtins.bool request_spot_instances: Enable EKS node group request spot instances
        :param Mapping[str, _builtins.str] resource_tags: The EKS node group resource tags
        :param Sequence[_builtins.str] spot_instance_types: The EKS node group spot instance types
        :param Sequence[_builtins.str] subnets: The EKS node group subnets
        :param Mapping[str, _builtins.str] tags: The EKS node group tags
        :param _builtins.str user_data: The EKS node group user data
        :param _builtins.str version: The EKS node group k8s version
        """
        pulumi.set(__self__, "name", name)
        if desired_size is not None:
            pulumi.set(__self__, "desired_size", desired_size)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if ec2_ssh_key is not None:
            pulumi.set(__self__, "ec2_ssh_key", ec2_ssh_key)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if launch_templates is not None:
            pulumi.set(__self__, "launch_templates", launch_templates)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if node_role is not None:
            pulumi.set(__self__, "node_role", node_role)
        if request_spot_instances is not None:
            pulumi.set(__self__, "request_spot_instances", request_spot_instances)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)
        if spot_instance_types is not None:
            pulumi.set(__self__, "spot_instance_types", spot_instance_types)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="desiredSize")
    def desired_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group desired size
        """
        return pulumi.get(self, "desired_size")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group disk size
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="ec2SshKey")
    def ec2_ssh_key(self) -> Optional[_builtins.str]:
        """
        The EKS node group ssh key
        """
        return pulumi.get(self, "ec2_ssh_key")

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> Optional[_builtins.bool]:
        """
        Is EKS cluster using gpu?
        """
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        The EKS node group image ID
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The EKS node group instance type
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="launchTemplates")
    def launch_templates(self) -> Optional[Sequence['outputs.ClusterEksConfigV2NodeGroupLaunchTemplate']]:
        """
        The EKS node groups launch template
        """
        return pulumi.get(self, "launch_templates")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group maximum size
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group minimum size
        """
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter(name="nodeRole")
    def node_role(self) -> Optional[_builtins.str]:
        """
        The EKS node group node role ARN
        """
        return pulumi.get(self, "node_role")

    @_builtins.property
    @pulumi.getter(name="requestSpotInstances")
    def request_spot_instances(self) -> Optional[_builtins.bool]:
        """
        Enable EKS node group request spot instances
        """
        return pulumi.get(self, "request_spot_instances")

    @_builtins.property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The EKS node group resource tags
        """
        return pulumi.get(self, "resource_tags")

    @_builtins.property
    @pulumi.getter(name="spotInstanceTypes")
    def spot_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The EKS node group spot instance types
        """
        return pulumi.get(self, "spot_instance_types")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        The EKS node group subnets
        """
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The EKS node group tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        The EKS node group user data
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The EKS node group k8s version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterEksConfigV2NodeGroupLaunchTemplate(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.int version: The EKS node group launch template version
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The EKS node group launch template version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterFleetAgentDeploymentCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendTolerations":
            suggest = "append_tolerations"
        elif key == "overrideAffinity":
            suggest = "override_affinity"
        elif key == "overrideResourceRequirements":
            suggest = "override_resource_requirements"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterFleetAgentDeploymentCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterFleetAgentDeploymentCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterFleetAgentDeploymentCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_tolerations: Optional[Sequence['outputs.ClusterFleetAgentDeploymentCustomizationAppendToleration']] = None,
                 override_affinity: Optional[_builtins.str] = None,
                 override_resource_requirements: Optional[Sequence['outputs.ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement']] = None):
        """
        :param Sequence['ClusterFleetAgentDeploymentCustomizationAppendTolerationArgs'] append_tolerations: User defined tolerations to append to agent
        :param _builtins.str override_affinity: User defined affinity to override default agent affinity
        :param Sequence['ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirementArgs'] override_resource_requirements: User defined resource requirements to set on the agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)

    @_builtins.property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[Sequence['outputs.ClusterFleetAgentDeploymentCustomizationAppendToleration']]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @_builtins.property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[_builtins.str]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @_builtins.property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[Sequence['outputs.ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement']]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")


@pulumi.output_type
class ClusterFleetAgentDeploymentCustomizationAppendToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param _builtins.int seconds: The toleration seconds (int)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterFleetAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit: Optional[_builtins.str] = None,
                 cpu_request: Optional[_builtins.str] = None,
                 memory_limit: Optional[_builtins.str] = None,
                 memory_request: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_limit: The maximum CPU limit for agent
        :param _builtins.str cpu_request: The minimum CPU required for agent
        :param _builtins.str memory_limit: The maximum memory limit for agent
        :param _builtins.str memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @_builtins.property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[_builtins.str]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @_builtins.property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[_builtins.str]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.str]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @_builtins.property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[_builtins.str]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ClusterGkeConfigV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "googleCredentialSecret":
            suggest = "google_credential_secret"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "clusterAddons":
            suggest = "cluster_addons"
        elif key == "clusterIpv4CidrBlock":
            suggest = "cluster_ipv4_cidr_block"
        elif key == "enableKubernetesAlpha":
            suggest = "enable_kubernetes_alpha"
        elif key == "ipAllocationPolicy":
            suggest = "ip_allocation_policy"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "loggingService":
            suggest = "logging_service"
        elif key == "maintenanceWindow":
            suggest = "maintenance_window"
        elif key == "masterAuthorizedNetworksConfig":
            suggest = "master_authorized_networks_config"
        elif key == "monitoringService":
            suggest = "monitoring_service"
        elif key == "networkPolicyEnabled":
            suggest = "network_policy_enabled"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "privateClusterConfig":
            suggest = "private_cluster_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 google_credential_secret: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 cluster_addons: Optional['outputs.ClusterGkeConfigV2ClusterAddons'] = None,
                 cluster_ipv4_cidr_block: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enable_kubernetes_alpha: Optional[_builtins.bool] = None,
                 imported: Optional[_builtins.bool] = None,
                 ip_allocation_policy: Optional['outputs.ClusterGkeConfigV2IpAllocationPolicy'] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 locations: Optional[Sequence[_builtins.str]] = None,
                 logging_service: Optional[_builtins.str] = None,
                 maintenance_window: Optional[_builtins.str] = None,
                 master_authorized_networks_config: Optional['outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfig'] = None,
                 monitoring_service: Optional[_builtins.str] = None,
                 network: Optional[_builtins.str] = None,
                 network_policy_enabled: Optional[_builtins.bool] = None,
                 node_pools: Optional[Sequence['outputs.ClusterGkeConfigV2NodePool']] = None,
                 private_cluster_config: Optional['outputs.ClusterGkeConfigV2PrivateClusterConfig'] = None,
                 region: Optional[_builtins.str] = None,
                 subnetwork: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str google_credential_secret: Google credential secret
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str project_id: The GKE project id
        :param 'ClusterGkeConfigV2ClusterAddonsArgs' cluster_addons: The GKE cluster addons
        :param _builtins.str cluster_ipv4_cidr_block: The GKE ip v4 cidr block
        :param _builtins.str description: The description for Cluster (string)
        :param _builtins.bool enable_kubernetes_alpha: Enable Kubernetes alpha
        :param _builtins.bool imported: Is GKE cluster imported?
        :param 'ClusterGkeConfigV2IpAllocationPolicyArgs' ip_allocation_policy: The GKE ip allocation policy
        :param _builtins.str kubernetes_version: The kubernetes master version
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster (map)
        :param Sequence[_builtins.str] locations: The GKE cluster locations
        :param _builtins.str logging_service: The GKE cluster logging service
        :param _builtins.str maintenance_window: The GKE cluster maintenance window
        :param 'ClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs' master_authorized_networks_config: The GKE cluster master authorized networks config
        :param _builtins.str monitoring_service: The GKE cluster monitoring service
        :param _builtins.str network: The GKE cluster network
        :param _builtins.bool network_policy_enabled: Is GKE cluster network policy enabled?
        :param Sequence['ClusterGkeConfigV2NodePoolArgs'] node_pools: The GKE cluster node pools
        :param 'ClusterGkeConfigV2PrivateClusterConfigArgs' private_cluster_config: The GKE private cluster config
        :param _builtins.str region: The GKE cluster region. Required if `zone` is empty
        :param _builtins.str subnetwork: The GKE cluster subnetwork
        :param _builtins.str zone: The GKE cluster zone. Required if `region` is empty
        """
        pulumi.set(__self__, "google_credential_secret", google_credential_secret)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        if cluster_addons is not None:
            pulumi.set(__self__, "cluster_addons", cluster_addons)
        if cluster_ipv4_cidr_block is not None:
            pulumi.set(__self__, "cluster_ipv4_cidr_block", cluster_ipv4_cidr_block)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_kubernetes_alpha is not None:
            pulumi.set(__self__, "enable_kubernetes_alpha", enable_kubernetes_alpha)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if ip_allocation_policy is not None:
            pulumi.set(__self__, "ip_allocation_policy", ip_allocation_policy)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if logging_service is not None:
            pulumi.set(__self__, "logging_service", logging_service)
        if maintenance_window is not None:
            pulumi.set(__self__, "maintenance_window", maintenance_window)
        if master_authorized_networks_config is not None:
            pulumi.set(__self__, "master_authorized_networks_config", master_authorized_networks_config)
        if monitoring_service is not None:
            pulumi.set(__self__, "monitoring_service", monitoring_service)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if network_policy_enabled is not None:
            pulumi.set(__self__, "network_policy_enabled", network_policy_enabled)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if private_cluster_config is not None:
            pulumi.set(__self__, "private_cluster_config", private_cluster_config)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnetwork is not None:
            pulumi.set(__self__, "subnetwork", subnetwork)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="googleCredentialSecret")
    def google_credential_secret(self) -> _builtins.str:
        """
        Google credential secret
        """
        return pulumi.get(self, "google_credential_secret")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The GKE project id
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter(name="clusterAddons")
    def cluster_addons(self) -> Optional['outputs.ClusterGkeConfigV2ClusterAddons']:
        """
        The GKE cluster addons
        """
        return pulumi.get(self, "cluster_addons")

    @_builtins.property
    @pulumi.getter(name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> Optional[_builtins.str]:
        """
        The GKE ip v4 cidr block
        """
        return pulumi.get(self, "cluster_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enableKubernetesAlpha")
    def enable_kubernetes_alpha(self) -> Optional[_builtins.bool]:
        """
        Enable Kubernetes alpha
        """
        return pulumi.get(self, "enable_kubernetes_alpha")

    @_builtins.property
    @pulumi.getter
    def imported(self) -> Optional[_builtins.bool]:
        """
        Is GKE cluster imported?
        """
        return pulumi.get(self, "imported")

    @_builtins.property
    @pulumi.getter(name="ipAllocationPolicy")
    def ip_allocation_policy(self) -> Optional['outputs.ClusterGkeConfigV2IpAllocationPolicy']:
        """
        The GKE ip allocation policy
        """
        return pulumi.get(self, "ip_allocation_policy")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[_builtins.str]]:
        """
        The GKE cluster locations
        """
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter(name="loggingService")
    def logging_service(self) -> Optional[_builtins.str]:
        """
        The GKE cluster logging service
        """
        return pulumi.get(self, "logging_service")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> Optional[_builtins.str]:
        """
        The GKE cluster maintenance window
        """
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="masterAuthorizedNetworksConfig")
    def master_authorized_networks_config(self) -> Optional['outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfig']:
        """
        The GKE cluster master authorized networks config
        """
        return pulumi.get(self, "master_authorized_networks_config")

    @_builtins.property
    @pulumi.getter(name="monitoringService")
    def monitoring_service(self) -> Optional[_builtins.str]:
        """
        The GKE cluster monitoring service
        """
        return pulumi.get(self, "monitoring_service")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        The GKE cluster network
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkPolicyEnabled")
    def network_policy_enabled(self) -> Optional[_builtins.bool]:
        """
        Is GKE cluster network policy enabled?
        """
        return pulumi.get(self, "network_policy_enabled")

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.ClusterGkeConfigV2NodePool']]:
        """
        The GKE cluster node pools
        """
        return pulumi.get(self, "node_pools")

    @_builtins.property
    @pulumi.getter(name="privateClusterConfig")
    def private_cluster_config(self) -> Optional['outputs.ClusterGkeConfigV2PrivateClusterConfig']:
        """
        The GKE private cluster config
        """
        return pulumi.get(self, "private_cluster_config")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The GKE cluster region. Required if `zone` is empty
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> Optional[_builtins.str]:
        """
        The GKE cluster subnetwork
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        The GKE cluster zone. Required if `region` is empty
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ClusterGkeConfigV2ClusterAddons(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "horizontalPodAutoscaling":
            suggest = "horizontal_pod_autoscaling"
        elif key == "httpLoadBalancing":
            suggest = "http_load_balancing"
        elif key == "networkPolicyConfig":
            suggest = "network_policy_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2ClusterAddons. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2ClusterAddons.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2ClusterAddons.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 horizontal_pod_autoscaling: Optional[_builtins.bool] = None,
                 http_load_balancing: Optional[_builtins.bool] = None,
                 network_policy_config: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool horizontal_pod_autoscaling: Enable GKE horizontal pod autoscaling
        :param _builtins.bool http_load_balancing: Enable GKE HTTP load balancing
        :param _builtins.bool network_policy_config: Enable GKE network policy config
        """
        if horizontal_pod_autoscaling is not None:
            pulumi.set(__self__, "horizontal_pod_autoscaling", horizontal_pod_autoscaling)
        if http_load_balancing is not None:
            pulumi.set(__self__, "http_load_balancing", http_load_balancing)
        if network_policy_config is not None:
            pulumi.set(__self__, "network_policy_config", network_policy_config)

    @_builtins.property
    @pulumi.getter(name="horizontalPodAutoscaling")
    def horizontal_pod_autoscaling(self) -> Optional[_builtins.bool]:
        """
        Enable GKE horizontal pod autoscaling
        """
        return pulumi.get(self, "horizontal_pod_autoscaling")

    @_builtins.property
    @pulumi.getter(name="httpLoadBalancing")
    def http_load_balancing(self) -> Optional[_builtins.bool]:
        """
        Enable GKE HTTP load balancing
        """
        return pulumi.get(self, "http_load_balancing")

    @_builtins.property
    @pulumi.getter(name="networkPolicyConfig")
    def network_policy_config(self) -> Optional[_builtins.bool]:
        """
        Enable GKE network policy config
        """
        return pulumi.get(self, "network_policy_config")


@pulumi.output_type
class ClusterGkeConfigV2IpAllocationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterIpv4CidrBlock":
            suggest = "cluster_ipv4_cidr_block"
        elif key == "clusterSecondaryRangeName":
            suggest = "cluster_secondary_range_name"
        elif key == "createSubnetwork":
            suggest = "create_subnetwork"
        elif key == "nodeIpv4CidrBlock":
            suggest = "node_ipv4_cidr_block"
        elif key == "servicesIpv4CidrBlock":
            suggest = "services_ipv4_cidr_block"
        elif key == "servicesSecondaryRangeName":
            suggest = "services_secondary_range_name"
        elif key == "subnetworkName":
            suggest = "subnetwork_name"
        elif key == "useIpAliases":
            suggest = "use_ip_aliases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2IpAllocationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2IpAllocationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2IpAllocationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ipv4_cidr_block: Optional[_builtins.str] = None,
                 cluster_secondary_range_name: Optional[_builtins.str] = None,
                 create_subnetwork: Optional[_builtins.bool] = None,
                 node_ipv4_cidr_block: Optional[_builtins.str] = None,
                 services_ipv4_cidr_block: Optional[_builtins.str] = None,
                 services_secondary_range_name: Optional[_builtins.str] = None,
                 subnetwork_name: Optional[_builtins.str] = None,
                 use_ip_aliases: Optional[_builtins.bool] = None):
        """
        :param _builtins.str cluster_ipv4_cidr_block: The GKE cluster ip v4 allocation cidr block
        :param _builtins.str cluster_secondary_range_name: The GKE cluster ip v4 allocation secondary range name
        :param _builtins.bool create_subnetwork: Create GKE subnetwork?
        :param _builtins.str node_ipv4_cidr_block: The GKE node ip v4 allocation cidr block
        :param _builtins.str services_ipv4_cidr_block: The GKE services ip v4 allocation cidr block
        :param _builtins.str services_secondary_range_name: The GKE services ip v4 allocation secondary range name
        :param _builtins.str subnetwork_name: The GKE cluster subnetwork name
        :param _builtins.bool use_ip_aliases: Use GKE ip aliases?
        """
        if cluster_ipv4_cidr_block is not None:
            pulumi.set(__self__, "cluster_ipv4_cidr_block", cluster_ipv4_cidr_block)
        if cluster_secondary_range_name is not None:
            pulumi.set(__self__, "cluster_secondary_range_name", cluster_secondary_range_name)
        if create_subnetwork is not None:
            pulumi.set(__self__, "create_subnetwork", create_subnetwork)
        if node_ipv4_cidr_block is not None:
            pulumi.set(__self__, "node_ipv4_cidr_block", node_ipv4_cidr_block)
        if services_ipv4_cidr_block is not None:
            pulumi.set(__self__, "services_ipv4_cidr_block", services_ipv4_cidr_block)
        if services_secondary_range_name is not None:
            pulumi.set(__self__, "services_secondary_range_name", services_secondary_range_name)
        if subnetwork_name is not None:
            pulumi.set(__self__, "subnetwork_name", subnetwork_name)
        if use_ip_aliases is not None:
            pulumi.set(__self__, "use_ip_aliases", use_ip_aliases)

    @_builtins.property
    @pulumi.getter(name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> Optional[_builtins.str]:
        """
        The GKE cluster ip v4 allocation cidr block
        """
        return pulumi.get(self, "cluster_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="clusterSecondaryRangeName")
    def cluster_secondary_range_name(self) -> Optional[_builtins.str]:
        """
        The GKE cluster ip v4 allocation secondary range name
        """
        return pulumi.get(self, "cluster_secondary_range_name")

    @_builtins.property
    @pulumi.getter(name="createSubnetwork")
    def create_subnetwork(self) -> Optional[_builtins.bool]:
        """
        Create GKE subnetwork?
        """
        return pulumi.get(self, "create_subnetwork")

    @_builtins.property
    @pulumi.getter(name="nodeIpv4CidrBlock")
    def node_ipv4_cidr_block(self) -> Optional[_builtins.str]:
        """
        The GKE node ip v4 allocation cidr block
        """
        return pulumi.get(self, "node_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="servicesIpv4CidrBlock")
    def services_ipv4_cidr_block(self) -> Optional[_builtins.str]:
        """
        The GKE services ip v4 allocation cidr block
        """
        return pulumi.get(self, "services_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="servicesSecondaryRangeName")
    def services_secondary_range_name(self) -> Optional[_builtins.str]:
        """
        The GKE services ip v4 allocation secondary range name
        """
        return pulumi.get(self, "services_secondary_range_name")

    @_builtins.property
    @pulumi.getter(name="subnetworkName")
    def subnetwork_name(self) -> Optional[_builtins.str]:
        """
        The GKE cluster subnetwork name
        """
        return pulumi.get(self, "subnetwork_name")

    @_builtins.property
    @pulumi.getter(name="useIpAliases")
    def use_ip_aliases(self) -> Optional[_builtins.bool]:
        """
        Use GKE ip aliases?
        """
        return pulumi.get(self, "use_ip_aliases")


@pulumi.output_type
class ClusterGkeConfigV2MasterAuthorizedNetworksConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlocks":
            suggest = "cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2MasterAuthorizedNetworksConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2MasterAuthorizedNetworksConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2MasterAuthorizedNetworksConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_blocks: Sequence['outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock'],
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence['ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs'] cidr_blocks: The GKE master authorized network config cidr blocks
        :param _builtins.bool enabled: Enable GKE master authorized network config
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Sequence['outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock']:
        """
        The GKE master authorized network config cidr blocks
        """
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable GKE master authorized network config
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr_block: The GKE master authorized network config cidr block
        :param _builtins.str display_name: The GKE master authorized network config cidr block dispaly name
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        The GKE master authorized network config cidr block
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The GKE master authorized network config cidr block dispaly name
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ClusterGkeConfigV2NodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "initialNodeCount":
            suggest = "initial_node_count"
        elif key == "maxPodsConstraint":
            suggest = "max_pods_constraint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2NodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2NodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2NodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 initial_node_count: _builtins.int,
                 name: _builtins.str,
                 version: _builtins.str,
                 autoscaling: Optional['outputs.ClusterGkeConfigV2NodePoolAutoscaling'] = None,
                 config: Optional['outputs.ClusterGkeConfigV2NodePoolConfig'] = None,
                 management: Optional['outputs.ClusterGkeConfigV2NodePoolManagement'] = None,
                 max_pods_constraint: Optional[_builtins.int] = None):
        """
        :param _builtins.int initial_node_count: The GKE node pool config initial node count
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str version: The GKE node pool config version
        :param 'ClusterGkeConfigV2NodePoolAutoscalingArgs' autoscaling: The GKE node pool config autoscaling
        :param 'ClusterGkeConfigV2NodePoolConfigArgs' config: The GKE node pool node config
        :param 'ClusterGkeConfigV2NodePoolManagementArgs' management: The GKE node pool config management
        :param _builtins.int max_pods_constraint: The GKE node pool config max pods constraint
        """
        pulumi.set(__self__, "initial_node_count", initial_node_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if management is not None:
            pulumi.set(__self__, "management", management)
        if max_pods_constraint is not None:
            pulumi.set(__self__, "max_pods_constraint", max_pods_constraint)

    @_builtins.property
    @pulumi.getter(name="initialNodeCount")
    def initial_node_count(self) -> _builtins.int:
        """
        The GKE node pool config initial node count
        """
        return pulumi.get(self, "initial_node_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The GKE node pool config version
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.ClusterGkeConfigV2NodePoolAutoscaling']:
        """
        The GKE node pool config autoscaling
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.ClusterGkeConfigV2NodePoolConfig']:
        """
        The GKE node pool node config
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def management(self) -> Optional['outputs.ClusterGkeConfigV2NodePoolManagement']:
        """
        The GKE node pool config management
        """
        return pulumi.get(self, "management")

    @_builtins.property
    @pulumi.getter(name="maxPodsConstraint")
    def max_pods_constraint(self) -> Optional[_builtins.int]:
        """
        The GKE node pool config max pods constraint
        """
        return pulumi.get(self, "max_pods_constraint")


@pulumi.output_type
class ClusterGkeConfigV2NodePoolAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNodeCount":
            suggest = "max_node_count"
        elif key == "minNodeCount":
            suggest = "min_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2NodePoolAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2NodePoolAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2NodePoolAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 max_node_count: Optional[_builtins.int] = None,
                 min_node_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enable GKE node pool config autoscaling
        :param _builtins.int max_node_count: The GKE node pool config max node count
        :param _builtins.int min_node_count: The GKE node pool config min node count
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable GKE node pool config autoscaling
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[_builtins.int]:
        """
        The GKE node pool config max node count
        """
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[_builtins.int]:
        """
        The GKE node pool config min node count
        """
        return pulumi.get(self, "min_node_count")


@pulumi.output_type
class ClusterGkeConfigV2NodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSizeGb":
            suggest = "disk_size_gb"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "imageType":
            suggest = "image_type"
        elif key == "localSsdCount":
            suggest = "local_ssd_count"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "oauthScopes":
            suggest = "oauth_scopes"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2NodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2NodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2NodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size_gb: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 image_type: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 machine_type: Optional[_builtins.str] = None,
                 oauth_scopes: Optional[Sequence[_builtins.str]] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 service_account: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 taints: Optional[Sequence['outputs.ClusterGkeConfigV2NodePoolConfigTaint']] = None):
        """
        :param _builtins.int disk_size_gb: The GKE node config disk size (Gb)
        :param _builtins.str disk_type: The GKE node config disk type
        :param _builtins.str image_type: The GKE node config image type
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster (map)
        :param _builtins.int local_ssd_count: The GKE node config local ssd count
        :param _builtins.str machine_type: The GKE node config machine type
        :param Sequence[_builtins.str] oauth_scopes: The GKE node config oauth scopes
        :param _builtins.bool preemptible: Enable GKE node config preemptible
        :param _builtins.str service_account: The GKE node config service account
        :param Sequence[_builtins.str] tags: The GKE node config tags
        :param Sequence['ClusterGkeConfigV2NodePoolConfigTaintArgs'] taints: The GKE node config taints
        """
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if oauth_scopes is not None:
            pulumi.set(__self__, "oauth_scopes", oauth_scopes)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The GKE node config disk size (Gb)
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The GKE node config disk type
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[_builtins.str]:
        """
        The GKE node config image type
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        """
        The GKE node config local ssd count
        """
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[_builtins.str]:
        """
        The GKE node config machine type
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The GKE node config oauth scopes
        """
        return pulumi.get(self, "oauth_scopes")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Enable GKE node config preemptible
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        The GKE node config service account
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        The GKE node config tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ClusterGkeConfigV2NodePoolConfigTaint']]:
        """
        The GKE node config taints
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class ClusterGkeConfigV2NodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterGkeConfigV2NodePoolManagement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRepair":
            suggest = "auto_repair"
        elif key == "autoUpgrade":
            suggest = "auto_upgrade"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2NodePoolManagement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2NodePoolManagement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2NodePoolManagement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_repair: Optional[_builtins.bool] = None,
                 auto_upgrade: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool auto_repair: Enable GKE node pool config management auto repair
        :param _builtins.bool auto_upgrade: Enable GKE node pool config management auto upgrade
        """
        if auto_repair is not None:
            pulumi.set(__self__, "auto_repair", auto_repair)
        if auto_upgrade is not None:
            pulumi.set(__self__, "auto_upgrade", auto_upgrade)

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> Optional[_builtins.bool]:
        """
        Enable GKE node pool config management auto repair
        """
        return pulumi.get(self, "auto_repair")

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> Optional[_builtins.bool]:
        """
        Enable GKE node pool config management auto upgrade
        """
        return pulumi.get(self, "auto_upgrade")


@pulumi.output_type
class ClusterGkeConfigV2PrivateClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterIpv4CidrBlock":
            suggest = "master_ipv4_cidr_block"
        elif key == "enablePrivateEndpoint":
            suggest = "enable_private_endpoint"
        elif key == "enablePrivateNodes":
            suggest = "enable_private_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterGkeConfigV2PrivateClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterGkeConfigV2PrivateClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterGkeConfigV2PrivateClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_ipv4_cidr_block: _builtins.str,
                 enable_private_endpoint: Optional[_builtins.bool] = None,
                 enable_private_nodes: Optional[_builtins.bool] = None):
        """
        :param _builtins.str master_ipv4_cidr_block: The GKE cluster private master ip v4 cidr block
        :param _builtins.bool enable_private_endpoint: Enable GKE cluster private endpoint
        :param _builtins.bool enable_private_nodes: Enable GKE cluster private nodes
        """
        pulumi.set(__self__, "master_ipv4_cidr_block", master_ipv4_cidr_block)
        if enable_private_endpoint is not None:
            pulumi.set(__self__, "enable_private_endpoint", enable_private_endpoint)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)

    @_builtins.property
    @pulumi.getter(name="masterIpv4CidrBlock")
    def master_ipv4_cidr_block(self) -> _builtins.str:
        """
        The GKE cluster private master ip v4 cidr block
        """
        return pulumi.get(self, "master_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="enablePrivateEndpoint")
    def enable_private_endpoint(self) -> Optional[_builtins.bool]:
        """
        Enable GKE cluster private endpoint
        """
        return pulumi.get(self, "enable_private_endpoint")

    @_builtins.property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[_builtins.bool]:
        """
        Enable GKE cluster private nodes
        """
        return pulumi.get(self, "enable_private_nodes")


@pulumi.output_type
class ClusterImportedConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateRegistryUrl":
            suggest = "private_registry_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterImportedConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterImportedConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterImportedConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_registry_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str private_registry_url: Private registry URL
        """
        if private_registry_url is not None:
            pulumi.set(__self__, "private_registry_url", private_registry_url)

    @_builtins.property
    @pulumi.getter(name="privateRegistryUrl")
    def private_registry_url(self) -> Optional[_builtins.str]:
        """
        Private registry URL
        """
        return pulumi.get(self, "private_registry_url")


@pulumi.output_type
class ClusterK3sConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upgradeStrategy":
            suggest = "upgrade_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterK3sConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterK3sConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterK3sConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upgrade_strategy: Optional['outputs.ClusterK3sConfigUpgradeStrategy'] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param 'ClusterK3sConfigUpgradeStrategyArgs' upgrade_strategy: The K3S upgrade strategy
        :param _builtins.str version: The K3S kubernetes version
        """
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional['outputs.ClusterK3sConfigUpgradeStrategy']:
        """
        The K3S upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The K3S kubernetes version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterK3sConfigUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainServerNodes":
            suggest = "drain_server_nodes"
        elif key == "drainWorkerNodes":
            suggest = "drain_worker_nodes"
        elif key == "serverConcurrency":
            suggest = "server_concurrency"
        elif key == "workerConcurrency":
            suggest = "worker_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterK3sConfigUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterK3sConfigUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterK3sConfigUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_server_nodes: Optional[_builtins.bool] = None,
                 drain_worker_nodes: Optional[_builtins.bool] = None,
                 server_concurrency: Optional[_builtins.int] = None,
                 worker_concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.bool drain_server_nodes: Drain server nodes
        :param _builtins.bool drain_worker_nodes: Drain worker nodes
        :param _builtins.int server_concurrency: Server concurrency
        :param _builtins.int worker_concurrency: Worker concurrency
        """
        if drain_server_nodes is not None:
            pulumi.set(__self__, "drain_server_nodes", drain_server_nodes)
        if drain_worker_nodes is not None:
            pulumi.set(__self__, "drain_worker_nodes", drain_worker_nodes)
        if server_concurrency is not None:
            pulumi.set(__self__, "server_concurrency", server_concurrency)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)

    @_builtins.property
    @pulumi.getter(name="drainServerNodes")
    def drain_server_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain server nodes
        """
        return pulumi.get(self, "drain_server_nodes")

    @_builtins.property
    @pulumi.getter(name="drainWorkerNodes")
    def drain_worker_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain worker nodes
        """
        return pulumi.get(self, "drain_worker_nodes")

    @_builtins.property
    @pulumi.getter(name="serverConcurrency")
    def server_concurrency(self) -> Optional[_builtins.int]:
        """
        Server concurrency
        """
        return pulumi.get(self, "server_concurrency")

    @_builtins.property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[_builtins.int]:
        """
        Worker concurrency
        """
        return pulumi.get(self, "worker_concurrency")


@pulumi.output_type
class ClusterOkeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "compartmentId":
            suggest = "compartment_id"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "nodeImage":
            suggest = "node_image"
        elif key == "nodeShape":
            suggest = "node_shape"
        elif key == "tenancyId":
            suggest = "tenancy_id"
        elif key == "clusterType":
            suggest = "cluster_type"
        elif key == "controlPlaneSubnetName":
            suggest = "control_plane_subnet_name"
        elif key == "customBootVolumeSize":
            suggest = "custom_boot_volume_size"
        elif key == "enableKubernetesDashboard":
            suggest = "enable_kubernetes_dashboard"
        elif key == "enablePrivateControlPlane":
            suggest = "enable_private_control_plane"
        elif key == "enablePrivateNodes":
            suggest = "enable_private_nodes"
        elif key == "evictionGraceDuration":
            suggest = "eviction_grace_duration"
        elif key == "flexMemoryInGbs":
            suggest = "flex_memory_in_gbs"
        elif key == "flexOcpus":
            suggest = "flex_ocpus"
        elif key == "forceDeleteAfterGraceDuration":
            suggest = "force_delete_after_grace_duration"
        elif key == "imageVerificationKmsKeyId":
            suggest = "image_verification_kms_key_id"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "limitNodeCount":
            suggest = "limit_node_count"
        elif key == "loadBalancerSubnetName1":
            suggest = "load_balancer_subnet_name1"
        elif key == "loadBalancerSubnetName2":
            suggest = "load_balancer_subnet_name2"
        elif key == "nodePoolDnsDomainName":
            suggest = "node_pool_dns_domain_name"
        elif key == "nodePoolSubnetName":
            suggest = "node_pool_subnet_name"
        elif key == "nodePublicKeyContents":
            suggest = "node_public_key_contents"
        elif key == "nodeUserDataContents":
            suggest = "node_user_data_contents"
        elif key == "podCidr":
            suggest = "pod_cidr"
        elif key == "podNetwork":
            suggest = "pod_network"
        elif key == "podSubnetName":
            suggest = "pod_subnet_name"
        elif key == "privateKeyContents":
            suggest = "private_key_contents"
        elif key == "privateKeyPassphrase":
            suggest = "private_key_passphrase"
        elif key == "quantityOfNodeSubnets":
            suggest = "quantity_of_node_subnets"
        elif key == "quantityPerSubnet":
            suggest = "quantity_per_subnet"
        elif key == "serviceCidr":
            suggest = "service_cidr"
        elif key == "serviceDnsDomainName":
            suggest = "service_dns_domain_name"
        elif key == "skipVcnDelete":
            suggest = "skip_vcn_delete"
        elif key == "userOcid":
            suggest = "user_ocid"
        elif key == "vcnCompartmentId":
            suggest = "vcn_compartment_id"
        elif key == "vcnName":
            suggest = "vcn_name"
        elif key == "workerNodeIngressCidr":
            suggest = "worker_node_ingress_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterOkeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterOkeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterOkeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 kubernetes_version: _builtins.str,
                 node_image: _builtins.str,
                 node_shape: _builtins.str,
                 region: _builtins.str,
                 tenancy_id: _builtins.str,
                 cluster_type: Optional[_builtins.str] = None,
                 control_plane_subnet_name: Optional[_builtins.str] = None,
                 custom_boot_volume_size: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 enable_kubernetes_dashboard: Optional[_builtins.bool] = None,
                 enable_private_control_plane: Optional[_builtins.bool] = None,
                 enable_private_nodes: Optional[_builtins.bool] = None,
                 eviction_grace_duration: Optional[_builtins.str] = None,
                 fingerprint: Optional[_builtins.str] = None,
                 flex_memory_in_gbs: Optional[_builtins.int] = None,
                 flex_ocpus: Optional[_builtins.int] = None,
                 force_delete_after_grace_duration: Optional[_builtins.bool] = None,
                 image_verification_kms_key_id: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 limit_node_count: Optional[_builtins.int] = None,
                 load_balancer_subnet_name1: Optional[_builtins.str] = None,
                 load_balancer_subnet_name2: Optional[_builtins.str] = None,
                 node_pool_dns_domain_name: Optional[_builtins.str] = None,
                 node_pool_subnet_name: Optional[_builtins.str] = None,
                 node_public_key_contents: Optional[_builtins.str] = None,
                 node_user_data_contents: Optional[_builtins.str] = None,
                 pod_cidr: Optional[_builtins.str] = None,
                 pod_network: Optional[_builtins.str] = None,
                 pod_subnet_name: Optional[_builtins.str] = None,
                 private_key_contents: Optional[_builtins.str] = None,
                 private_key_passphrase: Optional[_builtins.str] = None,
                 quantity_of_node_subnets: Optional[_builtins.int] = None,
                 quantity_per_subnet: Optional[_builtins.int] = None,
                 service_cidr: Optional[_builtins.str] = None,
                 service_dns_domain_name: Optional[_builtins.str] = None,
                 skip_vcn_delete: Optional[_builtins.bool] = None,
                 user_ocid: Optional[_builtins.str] = None,
                 vcn_compartment_id: Optional[_builtins.str] = None,
                 vcn_name: Optional[_builtins.str] = None,
                 worker_node_ingress_cidr: Optional[_builtins.str] = None):
        """
        :param _builtins.str compartment_id: The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        :param _builtins.str kubernetes_version: The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
        :param _builtins.str node_image: The OS for the node image
        :param _builtins.str node_shape: The shape of the node (determines number of CPUs and  amount of memory on each node)
        :param _builtins.str region: The availability domain within the region to host the OKE cluster
        :param _builtins.str tenancy_id: The OCID of the tenancy in which to create resources
        :param _builtins.str cluster_type: Optionally specify a cluster type of basic or enhanced
        :param _builtins.str control_plane_subnet_name: The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
        :param _builtins.int custom_boot_volume_size: An optional custom boot volume size (in GB) for the nodes
        :param _builtins.str description: The description for Cluster (string)
        :param _builtins.bool enable_kubernetes_dashboard: Enable the kubernetes dashboard
        :param _builtins.bool enable_private_control_plane: Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        :param _builtins.bool enable_private_nodes: Whether worker nodes are deployed into a new private subnet
        :param _builtins.str eviction_grace_duration: The optional grace period in minutes to allow cordon and drain to complete successfuly
        :param _builtins.str fingerprint: The fingerprint corresponding to the specified user's private API Key
        :param _builtins.int flex_memory_in_gbs: Optional amount of memory in GB for nodes (requires flexible node_shape)
        :param _builtins.int flex_ocpus: Optional number of OCPUs for nodes (requires flexible node_shape)
        :param _builtins.bool force_delete_after_grace_duration: Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
        :param _builtins.str image_verification_kms_key_id: Optional specify a comma separated list of master encryption key OCID(s) to verify images
        :param _builtins.str kms_key_id: Optional specify the OCID of the KMS Vault master key
        :param _builtins.int limit_node_count: Optional limit on the total number of nodes in the pool
        :param _builtins.str load_balancer_subnet_name1: The name of the first existing subnet to use for Kubernetes services / LB
        :param _builtins.str load_balancer_subnet_name2: The (optional) name of a second existing subnet to use for Kubernetes services / LB
        :param _builtins.str node_pool_dns_domain_name: Optional name for DNS domain of node pool subnet
        :param _builtins.str node_pool_subnet_name: Optional pre-existing subnet (public or private) for nodes
        :param _builtins.str node_public_key_contents: The contents of the SSH public key file to use for the nodes
        :param _builtins.str node_user_data_contents: The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
        :param _builtins.str pod_cidr: Optional specify the pod CIDR, defaults to 10.244.0.0/16
        :param _builtins.str pod_network: Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
        :param _builtins.str pod_subnet_name: The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
        :param _builtins.str private_key_contents: The private API key file contents for the specified user, in PEM format
        :param _builtins.str private_key_passphrase: The passphrase of the private key for the OKE cluster
        :param _builtins.int quantity_of_node_subnets: Number of node subnets (defaults to creating 1 regional subnet)
        :param _builtins.int quantity_per_subnet: Number of worker nodes in each subnet / availability domain
        :param _builtins.str service_cidr: Optional specify the service CIDR, defaults to 10.96.0.0/16
        :param _builtins.str service_dns_domain_name: Optional name for DNS domain of service subnet
        :param _builtins.bool skip_vcn_delete: Whether to skip deleting VCN
        :param _builtins.str user_ocid: The OCID of a user who has access to the tenancy/compartment
        :param _builtins.str vcn_compartment_id: The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        :param _builtins.str vcn_name: The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        :param _builtins.str worker_node_ingress_cidr: Additional CIDR from which to allow ingress to worker nodes
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "node_image", node_image)
        pulumi.set(__self__, "node_shape", node_shape)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tenancy_id", tenancy_id)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if control_plane_subnet_name is not None:
            pulumi.set(__self__, "control_plane_subnet_name", control_plane_subnet_name)
        if custom_boot_volume_size is not None:
            pulumi.set(__self__, "custom_boot_volume_size", custom_boot_volume_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_kubernetes_dashboard is not None:
            pulumi.set(__self__, "enable_kubernetes_dashboard", enable_kubernetes_dashboard)
        if enable_private_control_plane is not None:
            pulumi.set(__self__, "enable_private_control_plane", enable_private_control_plane)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)
        if eviction_grace_duration is not None:
            pulumi.set(__self__, "eviction_grace_duration", eviction_grace_duration)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flex_memory_in_gbs is not None:
            pulumi.set(__self__, "flex_memory_in_gbs", flex_memory_in_gbs)
        if flex_ocpus is not None:
            pulumi.set(__self__, "flex_ocpus", flex_ocpus)
        if force_delete_after_grace_duration is not None:
            pulumi.set(__self__, "force_delete_after_grace_duration", force_delete_after_grace_duration)
        if image_verification_kms_key_id is not None:
            pulumi.set(__self__, "image_verification_kms_key_id", image_verification_kms_key_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if limit_node_count is not None:
            pulumi.set(__self__, "limit_node_count", limit_node_count)
        if load_balancer_subnet_name1 is not None:
            pulumi.set(__self__, "load_balancer_subnet_name1", load_balancer_subnet_name1)
        if load_balancer_subnet_name2 is not None:
            pulumi.set(__self__, "load_balancer_subnet_name2", load_balancer_subnet_name2)
        if node_pool_dns_domain_name is not None:
            pulumi.set(__self__, "node_pool_dns_domain_name", node_pool_dns_domain_name)
        if node_pool_subnet_name is not None:
            pulumi.set(__self__, "node_pool_subnet_name", node_pool_subnet_name)
        if node_public_key_contents is not None:
            pulumi.set(__self__, "node_public_key_contents", node_public_key_contents)
        if node_user_data_contents is not None:
            pulumi.set(__self__, "node_user_data_contents", node_user_data_contents)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if pod_subnet_name is not None:
            pulumi.set(__self__, "pod_subnet_name", pod_subnet_name)
        if private_key_contents is not None:
            pulumi.set(__self__, "private_key_contents", private_key_contents)
        if private_key_passphrase is not None:
            pulumi.set(__self__, "private_key_passphrase", private_key_passphrase)
        if quantity_of_node_subnets is not None:
            pulumi.set(__self__, "quantity_of_node_subnets", quantity_of_node_subnets)
        if quantity_per_subnet is not None:
            pulumi.set(__self__, "quantity_per_subnet", quantity_per_subnet)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_dns_domain_name is not None:
            pulumi.set(__self__, "service_dns_domain_name", service_dns_domain_name)
        if skip_vcn_delete is not None:
            pulumi.set(__self__, "skip_vcn_delete", skip_vcn_delete)
        if user_ocid is not None:
            pulumi.set(__self__, "user_ocid", user_ocid)
        if vcn_compartment_id is not None:
            pulumi.set(__self__, "vcn_compartment_id", vcn_compartment_id)
        if vcn_name is not None:
            pulumi.set(__self__, "vcn_name", vcn_name)
        if worker_node_ingress_cidr is not None:
            pulumi.set(__self__, "worker_node_ingress_cidr", worker_node_ingress_cidr)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter(name="nodeImage")
    def node_image(self) -> _builtins.str:
        """
        The OS for the node image
        """
        return pulumi.get(self, "node_image")

    @_builtins.property
    @pulumi.getter(name="nodeShape")
    def node_shape(self) -> _builtins.str:
        """
        The shape of the node (determines number of CPUs and  amount of memory on each node)
        """
        return pulumi.get(self, "node_shape")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The availability domain within the region to host the OKE cluster
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tenancyId")
    def tenancy_id(self) -> _builtins.str:
        """
        The OCID of the tenancy in which to create resources
        """
        return pulumi.get(self, "tenancy_id")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[_builtins.str]:
        """
        Optionally specify a cluster type of basic or enhanced
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="controlPlaneSubnetName")
    def control_plane_subnet_name(self) -> Optional[_builtins.str]:
        """
        The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
        """
        return pulumi.get(self, "control_plane_subnet_name")

    @_builtins.property
    @pulumi.getter(name="customBootVolumeSize")
    def custom_boot_volume_size(self) -> Optional[_builtins.int]:
        """
        An optional custom boot volume size (in GB) for the nodes
        """
        return pulumi.get(self, "custom_boot_volume_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enableKubernetesDashboard")
    def enable_kubernetes_dashboard(self) -> Optional[_builtins.bool]:
        """
        Enable the kubernetes dashboard
        """
        return pulumi.get(self, "enable_kubernetes_dashboard")

    @_builtins.property
    @pulumi.getter(name="enablePrivateControlPlane")
    def enable_private_control_plane(self) -> Optional[_builtins.bool]:
        """
        Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        """
        return pulumi.get(self, "enable_private_control_plane")

    @_builtins.property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[_builtins.bool]:
        """
        Whether worker nodes are deployed into a new private subnet
        """
        return pulumi.get(self, "enable_private_nodes")

    @_builtins.property
    @pulumi.getter(name="evictionGraceDuration")
    def eviction_grace_duration(self) -> Optional[_builtins.str]:
        """
        The optional grace period in minutes to allow cordon and drain to complete successfuly
        """
        return pulumi.get(self, "eviction_grace_duration")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[_builtins.str]:
        """
        The fingerprint corresponding to the specified user's private API Key
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter(name="flexMemoryInGbs")
    def flex_memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        Optional amount of memory in GB for nodes (requires flexible node_shape)
        """
        return pulumi.get(self, "flex_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="flexOcpus")
    def flex_ocpus(self) -> Optional[_builtins.int]:
        """
        Optional number of OCPUs for nodes (requires flexible node_shape)
        """
        return pulumi.get(self, "flex_ocpus")

    @_builtins.property
    @pulumi.getter(name="forceDeleteAfterGraceDuration")
    def force_delete_after_grace_duration(self) -> Optional[_builtins.bool]:
        """
        Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
        """
        return pulumi.get(self, "force_delete_after_grace_duration")

    @_builtins.property
    @pulumi.getter(name="imageVerificationKmsKeyId")
    def image_verification_kms_key_id(self) -> Optional[_builtins.str]:
        """
        Optional specify a comma separated list of master encryption key OCID(s) to verify images
        """
        return pulumi.get(self, "image_verification_kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Optional specify the OCID of the KMS Vault master key
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="limitNodeCount")
    def limit_node_count(self) -> Optional[_builtins.int]:
        """
        Optional limit on the total number of nodes in the pool
        """
        return pulumi.get(self, "limit_node_count")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSubnetName1")
    def load_balancer_subnet_name1(self) -> Optional[_builtins.str]:
        """
        The name of the first existing subnet to use for Kubernetes services / LB
        """
        return pulumi.get(self, "load_balancer_subnet_name1")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSubnetName2")
    def load_balancer_subnet_name2(self) -> Optional[_builtins.str]:
        """
        The (optional) name of a second existing subnet to use for Kubernetes services / LB
        """
        return pulumi.get(self, "load_balancer_subnet_name2")

    @_builtins.property
    @pulumi.getter(name="nodePoolDnsDomainName")
    def node_pool_dns_domain_name(self) -> Optional[_builtins.str]:
        """
        Optional name for DNS domain of node pool subnet
        """
        return pulumi.get(self, "node_pool_dns_domain_name")

    @_builtins.property
    @pulumi.getter(name="nodePoolSubnetName")
    def node_pool_subnet_name(self) -> Optional[_builtins.str]:
        """
        Optional pre-existing subnet (public or private) for nodes
        """
        return pulumi.get(self, "node_pool_subnet_name")

    @_builtins.property
    @pulumi.getter(name="nodePublicKeyContents")
    def node_public_key_contents(self) -> Optional[_builtins.str]:
        """
        The contents of the SSH public key file to use for the nodes
        """
        return pulumi.get(self, "node_public_key_contents")

    @_builtins.property
    @pulumi.getter(name="nodeUserDataContents")
    def node_user_data_contents(self) -> Optional[_builtins.str]:
        """
        The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
        """
        return pulumi.get(self, "node_user_data_contents")

    @_builtins.property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[_builtins.str]:
        """
        Optional specify the pod CIDR, defaults to 10.244.0.0/16
        """
        return pulumi.get(self, "pod_cidr")

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[_builtins.str]:
        """
        Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
        """
        return pulumi.get(self, "pod_network")

    @_builtins.property
    @pulumi.getter(name="podSubnetName")
    def pod_subnet_name(self) -> Optional[_builtins.str]:
        """
        The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
        """
        return pulumi.get(self, "pod_subnet_name")

    @_builtins.property
    @pulumi.getter(name="privateKeyContents")
    def private_key_contents(self) -> Optional[_builtins.str]:
        """
        The private API key file contents for the specified user, in PEM format
        """
        return pulumi.get(self, "private_key_contents")

    @_builtins.property
    @pulumi.getter(name="privateKeyPassphrase")
    def private_key_passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase of the private key for the OKE cluster
        """
        return pulumi.get(self, "private_key_passphrase")

    @_builtins.property
    @pulumi.getter(name="quantityOfNodeSubnets")
    def quantity_of_node_subnets(self) -> Optional[_builtins.int]:
        """
        Number of node subnets (defaults to creating 1 regional subnet)
        """
        return pulumi.get(self, "quantity_of_node_subnets")

    @_builtins.property
    @pulumi.getter(name="quantityPerSubnet")
    def quantity_per_subnet(self) -> Optional[_builtins.int]:
        """
        Number of worker nodes in each subnet / availability domain
        """
        return pulumi.get(self, "quantity_per_subnet")

    @_builtins.property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[_builtins.str]:
        """
        Optional specify the service CIDR, defaults to 10.96.0.0/16
        """
        return pulumi.get(self, "service_cidr")

    @_builtins.property
    @pulumi.getter(name="serviceDnsDomainName")
    def service_dns_domain_name(self) -> Optional[_builtins.str]:
        """
        Optional name for DNS domain of service subnet
        """
        return pulumi.get(self, "service_dns_domain_name")

    @_builtins.property
    @pulumi.getter(name="skipVcnDelete")
    def skip_vcn_delete(self) -> Optional[_builtins.bool]:
        """
        Whether to skip deleting VCN
        """
        return pulumi.get(self, "skip_vcn_delete")

    @_builtins.property
    @pulumi.getter(name="userOcid")
    def user_ocid(self) -> Optional[_builtins.str]:
        """
        The OCID of a user who has access to the tenancy/compartment
        """
        return pulumi.get(self, "user_ocid")

    @_builtins.property
    @pulumi.getter(name="vcnCompartmentId")
    def vcn_compartment_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        """
        return pulumi.get(self, "vcn_compartment_id")

    @_builtins.property
    @pulumi.getter(name="vcnName")
    def vcn_name(self) -> Optional[_builtins.str]:
        """
        The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        """
        return pulumi.get(self, "vcn_name")

    @_builtins.property
    @pulumi.getter(name="workerNodeIngressCidr")
    def worker_node_ingress_cidr(self) -> Optional[_builtins.str]:
        """
        Additional CIDR from which to allow ingress to worker nodes
        """
        return pulumi.get(self, "worker_node_ingress_cidr")


@pulumi.output_type
class ClusterRke2Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "upgradeStrategy":
            suggest = "upgrade_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRke2Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRke2Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRke2Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 upgrade_strategy: Optional['outputs.ClusterRke2ConfigUpgradeStrategy'] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param 'ClusterRke2ConfigUpgradeStrategyArgs' upgrade_strategy: The RKE2 upgrade strategy
        :param _builtins.str version: The RKE2 kubernetes version
        """
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional['outputs.ClusterRke2ConfigUpgradeStrategy']:
        """
        The RKE2 upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The RKE2 kubernetes version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterRke2ConfigUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainServerNodes":
            suggest = "drain_server_nodes"
        elif key == "drainWorkerNodes":
            suggest = "drain_worker_nodes"
        elif key == "serverConcurrency":
            suggest = "server_concurrency"
        elif key == "workerConcurrency":
            suggest = "worker_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRke2ConfigUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRke2ConfigUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRke2ConfigUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_server_nodes: Optional[_builtins.bool] = None,
                 drain_worker_nodes: Optional[_builtins.bool] = None,
                 server_concurrency: Optional[_builtins.int] = None,
                 worker_concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.bool drain_server_nodes: Drain server nodes
        :param _builtins.bool drain_worker_nodes: Drain worker nodes
        :param _builtins.int server_concurrency: Server concurrency
        :param _builtins.int worker_concurrency: Worker concurrency
        """
        if drain_server_nodes is not None:
            pulumi.set(__self__, "drain_server_nodes", drain_server_nodes)
        if drain_worker_nodes is not None:
            pulumi.set(__self__, "drain_worker_nodes", drain_worker_nodes)
        if server_concurrency is not None:
            pulumi.set(__self__, "server_concurrency", server_concurrency)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)

    @_builtins.property
    @pulumi.getter(name="drainServerNodes")
    def drain_server_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain server nodes
        """
        return pulumi.get(self, "drain_server_nodes")

    @_builtins.property
    @pulumi.getter(name="drainWorkerNodes")
    def drain_worker_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain worker nodes
        """
        return pulumi.get(self, "drain_worker_nodes")

    @_builtins.property
    @pulumi.getter(name="serverConcurrency")
    def server_concurrency(self) -> Optional[_builtins.int]:
        """
        Server concurrency
        """
        return pulumi.get(self, "server_concurrency")

    @_builtins.property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[_builtins.int]:
        """
        Worker concurrency
        """
        return pulumi.get(self, "worker_concurrency")


@pulumi.output_type
class ClusterRkeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addonJobTimeout":
            suggest = "addon_job_timeout"
        elif key == "addonsIncludes":
            suggest = "addons_includes"
        elif key == "bastionHost":
            suggest = "bastion_host"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "enableCriDockerd":
            suggest = "enable_cri_dockerd"
        elif key == "ignoreDockerVersion":
            suggest = "ignore_docker_version"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "prefixPath":
            suggest = "prefix_path"
        elif key == "privateRegistries":
            suggest = "private_registries"
        elif key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshCertPath":
            suggest = "ssh_cert_path"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"
        elif key == "upgradeStrategy":
            suggest = "upgrade_strategy"
        elif key == "winPrefixPath":
            suggest = "win_prefix_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addon_job_timeout: Optional[_builtins.int] = None,
                 addons: Optional[_builtins.str] = None,
                 addons_includes: Optional[Sequence[_builtins.str]] = None,
                 authentication: Optional['outputs.ClusterRkeConfigAuthentication'] = None,
                 authorization: Optional['outputs.ClusterRkeConfigAuthorization'] = None,
                 bastion_host: Optional['outputs.ClusterRkeConfigBastionHost'] = None,
                 cloud_provider: Optional['outputs.ClusterRkeConfigCloudProvider'] = None,
                 dns: Optional['outputs.ClusterRkeConfigDns'] = None,
                 enable_cri_dockerd: Optional[_builtins.bool] = None,
                 ignore_docker_version: Optional[_builtins.bool] = None,
                 ingress: Optional['outputs.ClusterRkeConfigIngress'] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 monitoring: Optional['outputs.ClusterRkeConfigMonitoring'] = None,
                 network: Optional['outputs.ClusterRkeConfigNetwork'] = None,
                 nodes: Optional[Sequence['outputs.ClusterRkeConfigNode']] = None,
                 prefix_path: Optional[_builtins.str] = None,
                 private_registries: Optional[Sequence['outputs.ClusterRkeConfigPrivateRegistry']] = None,
                 services: Optional['outputs.ClusterRkeConfigServices'] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None,
                 ssh_cert_path: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None,
                 upgrade_strategy: Optional['outputs.ClusterRkeConfigUpgradeStrategy'] = None,
                 win_prefix_path: Optional[_builtins.str] = None):
        """
        :param _builtins.int addon_job_timeout: Optional duration in seconds of addon job.
        :param _builtins.str addons: Optional addons descripton to deploy on rke cluster.
        :param Sequence[_builtins.str] addons_includes: Optional addons yaml manisfest to deploy on rke cluster.
        :param 'ClusterRkeConfigAuthenticationArgs' authentication: Kubernetes cluster authentication
        :param 'ClusterRkeConfigAuthorizationArgs' authorization: Kubernetes cluster authorization
        :param 'ClusterRkeConfigBastionHostArgs' bastion_host: RKE bastion host
        :param 'ClusterRkeConfigCloudProviderArgs' cloud_provider: RKE options for Calico network provider (string)
        :param 'ClusterRkeConfigDnsArgs' dns: RKE dns add-on. For Rancher v2.2.x (list maxitems:1)
        :param _builtins.bool enable_cri_dockerd: Enable/disable using cri-dockerd
        :param _builtins.bool ignore_docker_version: Optional ignore docker version on nodes
        :param 'ClusterRkeConfigIngressArgs' ingress: Kubernetes ingress configuration
        :param _builtins.str kubernetes_version: Optional kubernetes version to deploy
        :param 'ClusterRkeConfigMonitoringArgs' monitoring: Kubernetes cluster monitoring
        :param 'ClusterRkeConfigNetworkArgs' network: Kubernetes cluster networking
        :param Sequence['ClusterRkeConfigNodeArgs'] nodes: Optional RKE cluster nodes
        :param _builtins.str prefix_path: Optional prefix to customize kubernetes path
        :param Sequence['ClusterRkeConfigPrivateRegistryArgs'] private_registries: Optional private registries for docker images
        :param 'ClusterRkeConfigServicesArgs' services: Kubernetes cluster services
        :param _builtins.bool ssh_agent_auth: Optional use ssh agent auth
        :param _builtins.str ssh_cert_path: Optional cluster level SSH certificate path
        :param _builtins.str ssh_key_path: Optional cluster level SSH private key path
        :param 'ClusterRkeConfigUpgradeStrategyArgs' upgrade_strategy: RKE upgrade strategy
        :param _builtins.str win_prefix_path: Optional prefix to customize kubernetes path for windows
        """
        if addon_job_timeout is not None:
            pulumi.set(__self__, "addon_job_timeout", addon_job_timeout)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if addons_includes is not None:
            pulumi.set(__self__, "addons_includes", addons_includes)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if bastion_host is not None:
            pulumi.set(__self__, "bastion_host", bastion_host)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if enable_cri_dockerd is not None:
            pulumi.set(__self__, "enable_cri_dockerd", enable_cri_dockerd)
        if ignore_docker_version is not None:
            pulumi.set(__self__, "ignore_docker_version", ignore_docker_version)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if private_registries is not None:
            pulumi.set(__self__, "private_registries", private_registries)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_cert_path is not None:
            pulumi.set(__self__, "ssh_cert_path", ssh_cert_path)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if win_prefix_path is not None:
            pulumi.set(__self__, "win_prefix_path", win_prefix_path)

    @_builtins.property
    @pulumi.getter(name="addonJobTimeout")
    def addon_job_timeout(self) -> Optional[_builtins.int]:
        """
        Optional duration in seconds of addon job.
        """
        return pulumi.get(self, "addon_job_timeout")

    @_builtins.property
    @pulumi.getter
    def addons(self) -> Optional[_builtins.str]:
        """
        Optional addons descripton to deploy on rke cluster.
        """
        return pulumi.get(self, "addons")

    @_builtins.property
    @pulumi.getter(name="addonsIncludes")
    def addons_includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        return pulumi.get(self, "addons_includes")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ClusterRkeConfigAuthentication']:
        """
        Kubernetes cluster authentication
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.ClusterRkeConfigAuthorization']:
        """
        Kubernetes cluster authorization
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="bastionHost")
    def bastion_host(self) -> Optional['outputs.ClusterRkeConfigBastionHost']:
        """
        RKE bastion host
        """
        return pulumi.get(self, "bastion_host")

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional['outputs.ClusterRkeConfigCloudProvider']:
        """
        RKE options for Calico network provider (string)
        """
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional['outputs.ClusterRkeConfigDns']:
        """
        RKE dns add-on. For Rancher v2.2.x (list maxitems:1)
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="enableCriDockerd")
    def enable_cri_dockerd(self) -> Optional[_builtins.bool]:
        """
        Enable/disable using cri-dockerd
        """
        return pulumi.get(self, "enable_cri_dockerd")

    @_builtins.property
    @pulumi.getter(name="ignoreDockerVersion")
    def ignore_docker_version(self) -> Optional[_builtins.bool]:
        """
        Optional ignore docker version on nodes
        """
        return pulumi.get(self, "ignore_docker_version")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.ClusterRkeConfigIngress']:
        """
        Kubernetes ingress configuration
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        Optional kubernetes version to deploy
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.ClusterRkeConfigMonitoring']:
        """
        Kubernetes cluster monitoring
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterRkeConfigNetwork']:
        """
        Kubernetes cluster networking
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.ClusterRkeConfigNode']]:
        """
        Optional RKE cluster nodes
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[_builtins.str]:
        """
        Optional prefix to customize kubernetes path
        """
        return pulumi.get(self, "prefix_path")

    @_builtins.property
    @pulumi.getter(name="privateRegistries")
    def private_registries(self) -> Optional[Sequence['outputs.ClusterRkeConfigPrivateRegistry']]:
        """
        Optional private registries for docker images
        """
        return pulumi.get(self, "private_registries")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional['outputs.ClusterRkeConfigServices']:
        """
        Kubernetes cluster services
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        """
        Optional use ssh agent auth
        """
        return pulumi.get(self, "ssh_agent_auth")

    @_builtins.property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> Optional[_builtins.str]:
        """
        Optional cluster level SSH certificate path
        """
        return pulumi.get(self, "ssh_cert_path")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        """
        Optional cluster level SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional['outputs.ClusterRkeConfigUpgradeStrategy']:
        """
        RKE upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter(name="winPrefixPath")
    def win_prefix_path(self) -> Optional[_builtins.str]:
        """
        Optional prefix to customize kubernetes path for windows
        """
        return pulumi.get(self, "win_prefix_path")


@pulumi.output_type
class ClusterRkeConfigAuthentication(dict):
    def __init__(__self__, *,
                 sans: Optional[Sequence[_builtins.str]] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] sans: RKE sans for authentication ([]string)
        :param _builtins.str strategy: Monitoring deployment update strategy (string)
        """
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        RKE sans for authentication ([]string)
        """
        return pulumi.get(self, "sans")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Monitoring deployment update strategy (string)
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterRkeConfigAuthorization(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str mode: The AKS node group mode. Default: `System` (string)
        :param Mapping[str, _builtins.str] options: RKE options for network (map)
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The AKS node group mode. Default: `System` (string)
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class ClusterRkeConfigBastionHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshKey":
            suggest = "ssh_key"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigBastionHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigBastionHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigBastionHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 user: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None,
                 ssh_key: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Address ip for node (string)
        :param _builtins.str user: Registry user (string)
        :param _builtins.str port: Port for node. Default `22` (string)
        :param _builtins.bool ssh_agent_auth: Use ssh agent auth. Default `false` (bool)
        :param _builtins.str ssh_key: Node SSH private key (string)
        :param _builtins.str ssh_key_path: Node SSH private key path (string)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        """
        Use ssh agent auth. Default `false` (bool)
        """
        return pulumi.get(self, "ssh_agent_auth")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[_builtins.str]:
        """
        Node SSH private key (string)
        """
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        """
        Node SSH private key path (string)
        """
        return pulumi.get(self, "ssh_key_path")


@pulumi.output_type
class ClusterRkeConfigCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsCloudProvider":
            suggest = "aws_cloud_provider"
        elif key == "azureCloudProvider":
            suggest = "azure_cloud_provider"
        elif key == "customCloudProvider":
            suggest = "custom_cloud_provider"
        elif key == "openstackCloudProvider":
            suggest = "openstack_cloud_provider"
        elif key == "vsphereCloudProvider":
            suggest = "vsphere_cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_cloud_provider: Optional['outputs.ClusterRkeConfigCloudProviderAwsCloudProvider'] = None,
                 azure_cloud_provider: Optional['outputs.ClusterRkeConfigCloudProviderAzureCloudProvider'] = None,
                 custom_cloud_provider: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 openstack_cloud_provider: Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProvider'] = None,
                 vsphere_cloud_provider: Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProvider'] = None):
        """
        :param 'ClusterRkeConfigCloudProviderAwsCloudProviderArgs' aws_cloud_provider: RKE AWS Cloud Provider config for Cloud Provider [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderAzureCloudProviderArgs' azure_cloud_provider: RKE Azure Cloud Provider config for Cloud Provider [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        :param _builtins.str custom_cloud_provider: RKE Custom Cloud Provider config for Cloud Provider (string)
        :param _builtins.str name: The name of the Cluster (string)
        :param 'ClusterRkeConfigCloudProviderOpenstackCloudProviderArgs' openstack_cloud_provider: RKE Openstack Cloud Provider config for Cloud Provider [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderVsphereCloudProviderArgs' vsphere_cloud_provider: RKE Vsphere Cloud Provider config for Cloud Provider [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
        if aws_cloud_provider is not None:
            pulumi.set(__self__, "aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_provider is not None:
            pulumi.set(__self__, "azure_cloud_provider", azure_cloud_provider)
        if custom_cloud_provider is not None:
            pulumi.set(__self__, "custom_cloud_provider", custom_cloud_provider)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if openstack_cloud_provider is not None:
            pulumi.set(__self__, "openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_provider is not None:
            pulumi.set(__self__, "vsphere_cloud_provider", vsphere_cloud_provider)

    @_builtins.property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional['outputs.ClusterRkeConfigCloudProviderAwsCloudProvider']:
        """
        RKE AWS Cloud Provider config for Cloud Provider [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
        """
        return pulumi.get(self, "aws_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional['outputs.ClusterRkeConfigCloudProviderAzureCloudProvider']:
        """
        RKE Azure Cloud Provider config for Cloud Provider [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
        """
        return pulumi.get(self, "azure_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> Optional[_builtins.str]:
        """
        RKE Custom Cloud Provider config for Cloud Provider (string)
        """
        return pulumi.get(self, "custom_cloud_provider")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProvider']:
        """
        RKE Openstack Cloud Provider config for Cloud Provider [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
        """
        return pulumi.get(self, "openstack_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProvider']:
        """
        RKE Vsphere Cloud Provider config for Cloud Provider [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtual_center` configuration. (list maxitems:1)
        """
        return pulumi.get(self, "vsphere_cloud_provider")


@pulumi.output_type
class ClusterRkeConfigCloudProviderAwsCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "serviceOverrides":
            suggest = "service_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderAwsCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderAwsCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderAwsCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: Optional['outputs.ClusterRkeConfigCloudProviderAwsCloudProviderGlobal'] = None,
                 service_overrides: Optional[Sequence['outputs.ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride']] = None):
        """
        :param 'ClusterRkeConfigCloudProviderAwsCloudProviderGlobalArgs' global_: (list maxitems:1)
        :param Sequence['ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideArgs'] service_overrides: (list)
        """
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if service_overrides is not None:
            pulumi.set(__self__, "service_overrides", service_overrides)

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterRkeConfigCloudProviderAwsCloudProviderGlobal']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[Sequence['outputs.ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride']]:
        """
        (list)
        """
        return pulumi.get(self, "service_overrides")


@pulumi.output_type
class ClusterRkeConfigCloudProviderAwsCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSecurityGroupIngress":
            suggest = "disable_security_group_ingress"
        elif key == "disableStrictZoneCheck":
            suggest = "disable_strict_zone_check"
        elif key == "elbSecurityGroup":
            suggest = "elb_security_group"
        elif key == "kubernetesClusterId":
            suggest = "kubernetes_cluster_id"
        elif key == "kubernetesClusterTag":
            suggest = "kubernetes_cluster_tag"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "routeTableId":
            suggest = "route_table_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderAwsCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderAwsCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderAwsCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_security_group_ingress: Optional[_builtins.bool] = None,
                 disable_strict_zone_check: Optional[_builtins.bool] = None,
                 elb_security_group: Optional[_builtins.str] = None,
                 kubernetes_cluster_id: Optional[_builtins.str] = None,
                 kubernetes_cluster_tag: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 route_table_id: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 vpc: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_security_group_ingress: Default `false` (bool)
        :param _builtins.bool disable_strict_zone_check: Default `false` (bool)
        :param _builtins.str elb_security_group: (string)
        :param _builtins.str kubernetes_cluster_id: (string)
        :param _builtins.str kubernetes_cluster_tag: (string)
        :param _builtins.str role_arn: (string)
        :param _builtins.str route_table_id: (string)
        :param _builtins.str subnet_id: (string)
        :param _builtins.str vpc: (string)
        :param _builtins.str zone: The GKE cluster zone. Required if `region` not set (string)
        """
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            pulumi.set(__self__, "disable_strict_zone_check", disable_strict_zone_check)
        if elb_security_group is not None:
            pulumi.set(__self__, "elb_security_group", elb_security_group)
        if kubernetes_cluster_id is not None:
            pulumi.set(__self__, "kubernetes_cluster_id", kubernetes_cluster_id)
        if kubernetes_cluster_tag is not None:
            pulumi.set(__self__, "kubernetes_cluster_tag", kubernetes_cluster_tag)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[_builtins.bool]:
        """
        Default `false` (bool)
        """
        return pulumi.get(self, "disable_security_group_ingress")

    @_builtins.property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[_builtins.bool]:
        """
        Default `false` (bool)
        """
        return pulumi.get(self, "disable_strict_zone_check")

    @_builtins.property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "elb_security_group")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "kubernetes_cluster_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "kubernetes_cluster_tag")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "route_table_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "vpc")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        The GKE cluster zone. Required if `region` not set (string)
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingMethod":
            suggest = "signing_method"
        elif key == "signingName":
            suggest = "signing_name"
        elif key == "signingRegion":
            suggest = "signing_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: _builtins.str,
                 region: Optional[_builtins.str] = None,
                 signing_method: Optional[_builtins.str] = None,
                 signing_name: Optional[_builtins.str] = None,
                 signing_region: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: (string)
        :param _builtins.str region: The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        :param _builtins.str signing_method: (string)
        :param _builtins.str signing_name: (string)
        :param _builtins.str signing_region: (string)
        :param _builtins.str url: Registry URL (string)
        """
        pulumi.set(__self__, "service", service)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if signing_method is not None:
            pulumi.set(__self__, "signing_method", signing_method)
        if signing_name is not None:
            pulumi.set(__self__, "signing_name", signing_name)
        if signing_region is not None:
            pulumi.set(__self__, "signing_region", signing_region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_method")

    @_builtins.property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_name")

    @_builtins.property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "signing_region")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ClusterRkeConfigCloudProviderAzureCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aadClientId":
            suggest = "aad_client_id"
        elif key == "aadClientSecret":
            suggest = "aad_client_secret"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "aadClientCertPassword":
            suggest = "aad_client_cert_password"
        elif key == "aadClientCertPath":
            suggest = "aad_client_cert_path"
        elif key == "cloudProviderBackoff":
            suggest = "cloud_provider_backoff"
        elif key == "cloudProviderBackoffDuration":
            suggest = "cloud_provider_backoff_duration"
        elif key == "cloudProviderBackoffExponent":
            suggest = "cloud_provider_backoff_exponent"
        elif key == "cloudProviderBackoffJitter":
            suggest = "cloud_provider_backoff_jitter"
        elif key == "cloudProviderBackoffRetries":
            suggest = "cloud_provider_backoff_retries"
        elif key == "cloudProviderRateLimit":
            suggest = "cloud_provider_rate_limit"
        elif key == "cloudProviderRateLimitBucket":
            suggest = "cloud_provider_rate_limit_bucket"
        elif key == "cloudProviderRateLimitQps":
            suggest = "cloud_provider_rate_limit_qps"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "maximumLoadBalancerRuleCount":
            suggest = "maximum_load_balancer_rule_count"
        elif key == "primaryAvailabilitySetName":
            suggest = "primary_availability_set_name"
        elif key == "primaryScaleSetName":
            suggest = "primary_scale_set_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "routeTableName":
            suggest = "route_table_name"
        elif key == "securityGroupName":
            suggest = "security_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "useInstanceMetadata":
            suggest = "use_instance_metadata"
        elif key == "useManagedIdentityExtension":
            suggest = "use_managed_identity_extension"
        elif key == "vmType":
            suggest = "vm_type"
        elif key == "vnetName":
            suggest = "vnet_name"
        elif key == "vnetResourceGroup":
            suggest = "vnet_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderAzureCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderAzureCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderAzureCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aad_client_id: _builtins.str,
                 aad_client_secret: _builtins.str,
                 subscription_id: _builtins.str,
                 tenant_id: _builtins.str,
                 aad_client_cert_password: Optional[_builtins.str] = None,
                 aad_client_cert_path: Optional[_builtins.str] = None,
                 cloud: Optional[_builtins.str] = None,
                 cloud_provider_backoff: Optional[_builtins.bool] = None,
                 cloud_provider_backoff_duration: Optional[_builtins.int] = None,
                 cloud_provider_backoff_exponent: Optional[_builtins.int] = None,
                 cloud_provider_backoff_jitter: Optional[_builtins.int] = None,
                 cloud_provider_backoff_retries: Optional[_builtins.int] = None,
                 cloud_provider_rate_limit: Optional[_builtins.bool] = None,
                 cloud_provider_rate_limit_bucket: Optional[_builtins.int] = None,
                 cloud_provider_rate_limit_qps: Optional[_builtins.int] = None,
                 load_balancer_sku: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 maximum_load_balancer_rule_count: Optional[_builtins.int] = None,
                 primary_availability_set_name: Optional[_builtins.str] = None,
                 primary_scale_set_name: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 route_table_name: Optional[_builtins.str] = None,
                 security_group_name: Optional[_builtins.str] = None,
                 subnet_name: Optional[_builtins.str] = None,
                 use_instance_metadata: Optional[_builtins.bool] = None,
                 use_managed_identity_extension: Optional[_builtins.bool] = None,
                 vm_type: Optional[_builtins.str] = None,
                 vnet_name: Optional[_builtins.str] = None,
                 vnet_resource_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str aad_client_id: (string)
        :param _builtins.str aad_client_secret: (string)
        :param _builtins.str subscription_id: (string)
        :param _builtins.str tenant_id: Required if `tenant_name` not provided. (string)
        :param _builtins.str aad_client_cert_password: (string)
        :param _builtins.str aad_client_cert_path: (string)
        :param _builtins.str cloud: (string)
        :param _builtins.bool cloud_provider_backoff: (bool)
        :param _builtins.int cloud_provider_backoff_duration: (int)
        :param _builtins.int cloud_provider_backoff_exponent: (int)
        :param _builtins.int cloud_provider_backoff_jitter: (int)
        :param _builtins.int cloud_provider_backoff_retries: (int)
        :param _builtins.bool cloud_provider_rate_limit: (bool)
        :param _builtins.int cloud_provider_rate_limit_bucket: (int)
        :param _builtins.int cloud_provider_rate_limit_qps: (int)
        :param _builtins.str load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        :param _builtins.str location: (string)
        :param _builtins.int maximum_load_balancer_rule_count: (int)
        :param _builtins.str primary_availability_set_name: (string)
        :param _builtins.str primary_scale_set_name: (string)
        :param _builtins.str resource_group: The AKS resource group (string)
        :param _builtins.str route_table_name: (string)
        :param _builtins.str security_group_name: (string)
        :param _builtins.str subnet_name: (string)
        :param _builtins.bool use_instance_metadata: (bool)
        :param _builtins.bool use_managed_identity_extension: (bool)
        :param _builtins.str vm_type: (string)
        :param _builtins.str vnet_name: (string)
        :param _builtins.str vnet_resource_group: (string)
        """
        pulumi.set(__self__, "aad_client_id", aad_client_id)
        pulumi.set(__self__, "aad_client_secret", aad_client_secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if aad_client_cert_password is not None:
            pulumi.set(__self__, "aad_client_cert_password", aad_client_cert_password)
        if aad_client_cert_path is not None:
            pulumi.set(__self__, "aad_client_cert_path", aad_client_cert_path)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if cloud_provider_backoff is not None:
            pulumi.set(__self__, "cloud_provider_backoff", cloud_provider_backoff)
        if cloud_provider_backoff_duration is not None:
            pulumi.set(__self__, "cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        if cloud_provider_backoff_exponent is not None:
            pulumi.set(__self__, "cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        if cloud_provider_backoff_jitter is not None:
            pulumi.set(__self__, "cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        if cloud_provider_backoff_retries is not None:
            pulumi.set(__self__, "cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        if cloud_provider_rate_limit is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit", cloud_provider_rate_limit)
        if cloud_provider_rate_limit_bucket is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        if cloud_provider_rate_limit_qps is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_load_balancer_rule_count is not None:
            pulumi.set(__self__, "maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        if primary_availability_set_name is not None:
            pulumi.set(__self__, "primary_availability_set_name", primary_availability_set_name)
        if primary_scale_set_name is not None:
            pulumi.set(__self__, "primary_scale_set_name", primary_scale_set_name)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if route_table_name is not None:
            pulumi.set(__self__, "route_table_name", route_table_name)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if use_instance_metadata is not None:
            pulumi.set(__self__, "use_instance_metadata", use_instance_metadata)
        if use_managed_identity_extension is not None:
            pulumi.set(__self__, "use_managed_identity_extension", use_managed_identity_extension)
        if vm_type is not None:
            pulumi.set(__self__, "vm_type", vm_type)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)
        if vnet_resource_group is not None:
            pulumi.set(__self__, "vnet_resource_group", vnet_resource_group)

    @_builtins.property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_id")

    @_builtins.property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_secret")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        """
        Required if `tenant_name` not provided. (string)
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_password")

    @_builtins.property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "aad_client_cert_path")

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_backoff")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "cloud_provider_rate_limit")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "primary_availability_set_name")

    @_builtins.property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "primary_scale_set_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        The AKS resource group (string)
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "route_table_name")

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "security_group_name")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_instance_metadata")

    @_builtins.property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_managed_identity_extension")

    @_builtins.property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "vm_type")

    @_builtins.property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_name")

    @_builtins.property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "vnet_resource_group")


@pulumi.output_type
class ClusterRkeConfigCloudProviderOpenstackCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "blockStorage":
            suggest = "block_storage"
        elif key == "loadBalancer":
            suggest = "load_balancer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderOpenstackCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: 'outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal',
                 block_storage: Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage'] = None,
                 load_balancer: Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer'] = None,
                 metadata: Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata'] = None,
                 route: Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute'] = None):
        """
        :param 'ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalArgs' global_: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageArgs' block_storage: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerArgs' load_balancer: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataArgs' metadata: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderOpenstackCloudProviderRouteArgs' route: (list maxitems:1)
        """
        pulumi.set(__self__, "global_", global_)
        if block_storage is not None:
            pulumi.set(__self__, "block_storage", block_storage)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal':
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "block_storage")

    @_builtins.property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "load_balancer")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional['outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bsVersion":
            suggest = "bs_version"
        elif key == "ignoreVolumeAz":
            suggest = "ignore_volume_az"
        elif key == "trustDevicePath":
            suggest = "trust_device_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bs_version: Optional[_builtins.str] = None,
                 ignore_volume_az: Optional[_builtins.bool] = None,
                 trust_device_path: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bs_version: (string)
        :param _builtins.bool ignore_volume_az: (string)
        :param _builtins.bool trust_device_path: (string)
        """
        if bs_version is not None:
            pulumi.set(__self__, "bs_version", bs_version)
        if ignore_volume_az is not None:
            pulumi.set(__self__, "ignore_volume_az", ignore_volume_az)
        if trust_device_path is not None:
            pulumi.set(__self__, "trust_device_path", trust_device_path)

    @_builtins.property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "bs_version")

    @_builtins.property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> Optional[_builtins.bool]:
        """
        (string)
        """
        return pulumi.get(self, "ignore_volume_az")

    @_builtins.property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> Optional[_builtins.bool]:
        """
        (string)
        """
        return pulumi.get(self, "trust_device_path")


@pulumi.output_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "caFile":
            suggest = "ca_file"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "trustId":
            suggest = "trust_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str,
                 ca_file: Optional[_builtins.str] = None,
                 domain_id: Optional[_builtins.str] = None,
                 domain_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 tenant_name: Optional[_builtins.str] = None,
                 trust_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_url: (string)
        :param _builtins.str password: Registry password (string)
        :param _builtins.str username: (string)
        :param _builtins.str ca_file: (string)
        :param _builtins.str domain_id: Required if `domain_name` not provided. (string)
        :param _builtins.str domain_name: Required if `domain_id` not provided. (string)
        :param _builtins.str region: The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        :param _builtins.str tenant_id: Required if `tenant_name` not provided. (string)
        :param _builtins.str tenant_name: Required if `tenant_id` not provided. (string)
        :param _builtins.str trust_id: (string)
        """
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if trust_id is not None:
            pulumi.set(__self__, "trust_id", trust_id)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "ca_file")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[_builtins.str]:
        """
        Required if `domain_name` not provided. (string)
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        Required if `domain_id` not provided. (string)
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Required if `tenant_name` not provided. (string)
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[_builtins.str]:
        """
        Required if `tenant_id` not provided. (string)
        """
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "trust_id")


@pulumi.output_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createMonitor":
            suggest = "create_monitor"
        elif key == "floatingNetworkId":
            suggest = "floating_network_id"
        elif key == "lbMethod":
            suggest = "lb_method"
        elif key == "lbProvider":
            suggest = "lb_provider"
        elif key == "lbVersion":
            suggest = "lb_version"
        elif key == "manageSecurityGroups":
            suggest = "manage_security_groups"
        elif key == "monitorDelay":
            suggest = "monitor_delay"
        elif key == "monitorMaxRetries":
            suggest = "monitor_max_retries"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "useOctavia":
            suggest = "use_octavia"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_monitor: Optional[_builtins.bool] = None,
                 floating_network_id: Optional[_builtins.str] = None,
                 lb_method: Optional[_builtins.str] = None,
                 lb_provider: Optional[_builtins.str] = None,
                 lb_version: Optional[_builtins.str] = None,
                 manage_security_groups: Optional[_builtins.bool] = None,
                 monitor_delay: Optional[_builtins.str] = None,
                 monitor_max_retries: Optional[_builtins.int] = None,
                 monitor_timeout: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 use_octavia: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool create_monitor: (bool)
        :param _builtins.str floating_network_id: (string)
        :param _builtins.str lb_method: (string)
        :param _builtins.str lb_provider: (string)
        :param _builtins.str lb_version: (string)
        :param _builtins.bool manage_security_groups: (bool)
        :param _builtins.str monitor_delay: Default `60s` (string)
        :param _builtins.int monitor_max_retries: Default 5 (int)
        :param _builtins.str monitor_timeout: Default `30s` (string)
        :param _builtins.str subnet_id: (string)
        :param _builtins.bool use_octavia: (bool)
        """
        if create_monitor is not None:
            pulumi.set(__self__, "create_monitor", create_monitor)
        if floating_network_id is not None:
            pulumi.set(__self__, "floating_network_id", floating_network_id)
        if lb_method is not None:
            pulumi.set(__self__, "lb_method", lb_method)
        if lb_provider is not None:
            pulumi.set(__self__, "lb_provider", lb_provider)
        if lb_version is not None:
            pulumi.set(__self__, "lb_version", lb_version)
        if manage_security_groups is not None:
            pulumi.set(__self__, "manage_security_groups", manage_security_groups)
        if monitor_delay is not None:
            pulumi.set(__self__, "monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            pulumi.set(__self__, "monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if use_octavia is not None:
            pulumi.set(__self__, "use_octavia", use_octavia)

    @_builtins.property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "create_monitor")

    @_builtins.property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "floating_network_id")

    @_builtins.property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_method")

    @_builtins.property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_provider")

    @_builtins.property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "lb_version")

    @_builtins.property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "manage_security_groups")

    @_builtins.property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[_builtins.str]:
        """
        Default `60s` (string)
        """
        return pulumi.get(self, "monitor_delay")

    @_builtins.property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[_builtins.int]:
        """
        Default 5 (int)
        """
        return pulumi.get(self, "monitor_max_retries")

    @_builtins.property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[_builtins.str]:
        """
        Default `30s` (string)
        """
        return pulumi.get(self, "monitor_timeout")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "use_octavia")


@pulumi.output_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "searchOrder":
            suggest = "search_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_timeout: Optional[_builtins.int] = None,
                 search_order: Optional[_builtins.str] = None):
        """
        :param _builtins.int request_timeout: (int)
        :param _builtins.str search_order: (string)
        """
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if search_order is not None:
            pulumi.set(__self__, "search_order", search_order)

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "search_order")


@pulumi.output_type
class ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routerId":
            suggest = "router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 router_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str router_id: (string)
        """
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "router_id")


@pulumi.output_type
class ClusterRkeConfigCloudProviderVsphereCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualCenters":
            suggest = "virtual_centers"
        elif key == "global":
            suggest = "global_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderVsphereCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_centers: Sequence['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter'],
                 workspace: 'outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace',
                 disk: Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderDisk'] = None,
                 global_: Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal'] = None,
                 network: Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork'] = None):
        """
        :param Sequence['ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterArgs'] virtual_centers: (List)
        :param 'ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceArgs' workspace: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderVsphereCloudProviderDiskArgs' disk: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderVsphereCloudProviderGlobalArgs' global_: (list maxitems:1)
        :param 'ClusterRkeConfigCloudProviderVsphereCloudProviderNetworkArgs' network: The GKE cluster network. Required for create new cluster (string)
        """
        pulumi.set(__self__, "virtual_centers", virtual_centers)
        pulumi.set(__self__, "workspace", workspace)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> Sequence['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter']:
        """
        (List)
        """
        return pulumi.get(self, "virtual_centers")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> 'outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace':
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "workspace")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderDisk']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal']:
        """
        (list maxitems:1)
        """
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork']:
        """
        The GKE cluster network. Required for create new cluster (string)
        """
        return pulumi.get(self, "network")


@pulumi.output_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scsiControllerType":
            suggest = "scsi_controller_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderVsphereCloudProviderDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scsi_controller_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str scsi_controller_type: (string)
        """
        if scsi_controller_type is not None:
            pulumi.set(__self__, "scsi_controller_type", scsi_controller_type)

    @_builtins.property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "scsi_controller_type")


@pulumi.output_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracefulShutdownTimeout":
            suggest = "graceful_shutdown_timeout"
        elif key == "insecureFlag":
            suggest = "insecure_flag"
        elif key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: Optional[_builtins.str] = None,
                 graceful_shutdown_timeout: Optional[_builtins.str] = None,
                 insecure_flag: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 soap_roundtrip_count: Optional[_builtins.int] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str datacenters: (string)
        :param _builtins.bool insecure_flag: (bool)
        :param _builtins.str password: Registry password (string)
        :param _builtins.str port: Port for node. Default `22` (string)
        :param _builtins.int soap_roundtrip_count: (int)
        :param _builtins.str user: Registry user (string)
        """
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if insecure_flag is not None:
            pulumi.set(__self__, "insecure_flag", insecure_flag)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "graceful_shutdown_timeout")

    @_builtins.property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> Optional[_builtins.bool]:
        """
        (bool)
        """
        return pulumi.get(self, "insecure_flag")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicNetwork":
            suggest = "public_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_network: Optional[_builtins.str] = None):
        """
        :param _builtins.str public_network: (string)
        """
        if public_network is not None:
            pulumi.set(__self__, "public_network", public_network)

    @_builtins.property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "public_network")


@pulumi.output_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: _builtins.str,
                 name: _builtins.str,
                 password: _builtins.str,
                 user: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 soap_roundtrip_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str datacenters: (string)
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str password: Registry password (string)
        :param _builtins.str user: Registry user (string)
        :param _builtins.str port: Port for node. Default `22` (string)
        :param _builtins.int soap_roundtrip_count: (int)
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[_builtins.int]:
        """
        (int)
        """
        return pulumi.get(self, "soap_roundtrip_count")


@pulumi.output_type
class ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDatastore":
            suggest = "default_datastore"
        elif key == "resourcepoolPath":
            suggest = "resourcepool_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 folder: _builtins.str,
                 server: _builtins.str,
                 default_datastore: Optional[_builtins.str] = None,
                 resourcepool_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str datacenter: (string)
        :param _builtins.str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param _builtins.str server: (string)
        :param _builtins.str default_datastore: (string)
        :param _builtins.str resourcepool_path: (string)
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "server", server)
        if default_datastore is not None:
            pulumi.set(__self__, "default_datastore", default_datastore)
        if resourcepool_path is not None:
            pulumi.set(__self__, "resourcepool_path", resourcepool_path)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> _builtins.str:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        """
        (string)
        """
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "default_datastore")

    @_builtins.property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> Optional[_builtins.str]:
        """
        (string)
        """
        return pulumi.get(self, "resourcepool_path")


@pulumi.output_type
class ClusterRkeConfigDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linearAutoscalerParams":
            suggest = "linear_autoscaler_params"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "reverseCidrs":
            suggest = "reverse_cidrs"
        elif key == "updateStrategy":
            suggest = "update_strategy"
        elif key == "upstreamNameservers":
            suggest = "upstream_nameservers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linear_autoscaler_params: Optional['outputs.ClusterRkeConfigDnsLinearAutoscalerParams'] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 nodelocal: Optional['outputs.ClusterRkeConfigDnsNodelocal'] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 provider: Optional[_builtins.str] = None,
                 reverse_cidrs: Optional[Sequence[_builtins.str]] = None,
                 tolerations: Optional[Sequence['outputs.ClusterRkeConfigDnsToleration']] = None,
                 update_strategy: Optional['outputs.ClusterRkeConfigDnsUpdateStrategy'] = None,
                 upstream_nameservers: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'ClusterRkeConfigDnsLinearAutoscalerParamsArgs' linear_autoscaler_params: Linear Autoscaler Params
        :param Mapping[str, _builtins.str] node_selector: RKE monitoring node selector (map)
        :param 'ClusterRkeConfigDnsNodelocalArgs' nodelocal: Nodelocal dns
        :param Mapping[str, _builtins.str] options: RKE options for network (map)
        :param _builtins.str provider: RKE monitoring provider (string)
        :param Sequence[_builtins.str] reverse_cidrs: DNS add-on reverse cidr  (list)
        :param Sequence['ClusterRkeConfigDnsTolerationArgs'] tolerations: DNS service tolerations
        :param 'ClusterRkeConfigDnsUpdateStrategyArgs' update_strategy: Update deployment strategy
        :param Sequence[_builtins.str] upstream_nameservers: DNS add-on upstream nameservers  (list)
        """
        if linear_autoscaler_params is not None:
            pulumi.set(__self__, "linear_autoscaler_params", linear_autoscaler_params)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if nodelocal is not None:
            pulumi.set(__self__, "nodelocal", nodelocal)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if reverse_cidrs is not None:
            pulumi.set(__self__, "reverse_cidrs", reverse_cidrs)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)
        if upstream_nameservers is not None:
            pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)

    @_builtins.property
    @pulumi.getter(name="linearAutoscalerParams")
    def linear_autoscaler_params(self) -> Optional['outputs.ClusterRkeConfigDnsLinearAutoscalerParams']:
        """
        Linear Autoscaler Params
        """
        return pulumi.get(self, "linear_autoscaler_params")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE monitoring node selector (map)
        """
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def nodelocal(self) -> Optional['outputs.ClusterRkeConfigDnsNodelocal']:
        """
        Nodelocal dns
        """
        return pulumi.get(self, "nodelocal")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        RKE monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        DNS add-on reverse cidr  (list)
        """
        return pulumi.get(self, "reverse_cidrs")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterRkeConfigDnsToleration']]:
        """
        DNS service tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.ClusterRkeConfigDnsUpdateStrategy']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")

    @_builtins.property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Optional[Sequence[_builtins.str]]:
        """
        DNS add-on upstream nameservers  (list)
        """
        return pulumi.get(self, "upstream_nameservers")


@pulumi.output_type
class ClusterRkeConfigDnsLinearAutoscalerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coresPerReplica":
            suggest = "cores_per_replica"
        elif key == "nodesPerReplica":
            suggest = "nodes_per_replica"
        elif key == "preventSinglePointFailure":
            suggest = "prevent_single_point_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigDnsLinearAutoscalerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigDnsLinearAutoscalerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigDnsLinearAutoscalerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores_per_replica: Optional[_builtins.float] = None,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 nodes_per_replica: Optional[_builtins.float] = None,
                 prevent_single_point_failure: Optional[_builtins.bool] = None):
        """
        :param _builtins.float cores_per_replica: number of replicas per cluster cores (float64)
        :param _builtins.int max: maximum number of replicas (int64)
        :param _builtins.int min: minimum number of replicas (int64)
        :param _builtins.float nodes_per_replica: number of replica per cluster nodes (float64)
        :param _builtins.bool prevent_single_point_failure: prevent single point of failure
        """
        if cores_per_replica is not None:
            pulumi.set(__self__, "cores_per_replica", cores_per_replica)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if nodes_per_replica is not None:
            pulumi.set(__self__, "nodes_per_replica", nodes_per_replica)
        if prevent_single_point_failure is not None:
            pulumi.set(__self__, "prevent_single_point_failure", prevent_single_point_failure)

    @_builtins.property
    @pulumi.getter(name="coresPerReplica")
    def cores_per_replica(self) -> Optional[_builtins.float]:
        """
        number of replicas per cluster cores (float64)
        """
        return pulumi.get(self, "cores_per_replica")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        maximum number of replicas (int64)
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        minimum number of replicas (int64)
        """
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="nodesPerReplica")
    def nodes_per_replica(self) -> Optional[_builtins.float]:
        """
        number of replica per cluster nodes (float64)
        """
        return pulumi.get(self, "nodes_per_replica")

    @_builtins.property
    @pulumi.getter(name="preventSinglePointFailure")
    def prevent_single_point_failure(self) -> Optional[_builtins.bool]:
        """
        prevent single point of failure
        """
        return pulumi.get(self, "prevent_single_point_failure")


@pulumi.output_type
class ClusterRkeConfigDnsNodelocal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "nodeSelector":
            suggest = "node_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigDnsNodelocal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigDnsNodelocal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigDnsNodelocal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[_builtins.str] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str ip_address: Nodelocal dns ip address (string)
        :param Mapping[str, _builtins.str] node_selector: Node selector key pair
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        Nodelocal dns ip address (string)
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Node selector key pair
        """
        return pulumi.get(self, "node_selector")


@pulumi.output_type
class ClusterRkeConfigDnsToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param _builtins.int seconds: The toleration seconds (int)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterRkeConfigDnsUpdateStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigDnsUpdateStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigDnsUpdateStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigDnsUpdateStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.ClusterRkeConfigDnsUpdateStrategyRollingUpdate'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'ClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterRkeConfigDnsUpdateStrategyRollingUpdate']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterRkeConfigDnsUpdateStrategyRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigDnsUpdateStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigDnsUpdateStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigDnsUpdateStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterRkeConfigIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBackend":
            suggest = "default_backend"
        elif key == "dnsPolicy":
            suggest = "dns_policy"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "updateStrategy":
            suggest = "update_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_backend: Optional[_builtins.bool] = None,
                 dns_policy: Optional[_builtins.str] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 network_mode: Optional[_builtins.str] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 provider: Optional[_builtins.str] = None,
                 tolerations: Optional[Sequence['outputs.ClusterRkeConfigIngressToleration']] = None,
                 update_strategy: Optional['outputs.ClusterRkeConfigIngressUpdateStrategy'] = None):
        """
        :param _builtins.bool default_backend: Enable ingress default backend. Default: `true` (bool)
        :param _builtins.str dns_policy: Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param _builtins.int http_port: HTTP port for RKE Ingress (int)
        :param _builtins.int https_port: HTTPS port for RKE Ingress (int)
        :param _builtins.str network_mode: Network mode for RKE Ingress (string)
        :param Mapping[str, _builtins.str] node_selector: RKE monitoring node selector (map)
        :param Mapping[str, _builtins.str] options: RKE options for network (map)
        :param _builtins.str provider: RKE monitoring provider (string)
        :param Sequence['ClusterRkeConfigIngressTolerationArgs'] tolerations: Ingress add-on tolerations
        :param 'ClusterRkeConfigIngressUpdateStrategyArgs' update_strategy: Update daemon set strategy
        """
        if default_backend is not None:
            pulumi.set(__self__, "default_backend", default_backend)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[_builtins.bool]:
        """
        Enable ingress default backend. Default: `true` (bool)
        """
        return pulumi.get(self, "default_backend")

    @_builtins.property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[_builtins.str]:
        """
        Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
        """
        return pulumi.get(self, "dns_policy")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        HTTP port for RKE Ingress (int)
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        """
        HTTPS port for RKE Ingress (int)
        """
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[_builtins.str]:
        """
        Network mode for RKE Ingress (string)
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE monitoring node selector (map)
        """
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        RKE monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterRkeConfigIngressToleration']]:
        """
        Ingress add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.ClusterRkeConfigIngressUpdateStrategy']:
        """
        Update daemon set strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class ClusterRkeConfigIngressToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param _builtins.int seconds: The toleration seconds (int)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterRkeConfigIngressUpdateStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigIngressUpdateStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigIngressUpdateStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigIngressUpdateStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.ClusterRkeConfigIngressUpdateStrategyRollingUpdate'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'ClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterRkeConfigIngressUpdateStrategyRollingUpdate']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterRkeConfigIngressUpdateStrategyRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigIngressUpdateStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigIngressUpdateStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigIngressUpdateStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterRkeConfigMonitoring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelector":
            suggest = "node_selector"
        elif key == "updateStrategy":
            suggest = "update_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigMonitoring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigMonitoring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigMonitoring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 provider: Optional[_builtins.str] = None,
                 replicas: Optional[_builtins.int] = None,
                 tolerations: Optional[Sequence['outputs.ClusterRkeConfigMonitoringToleration']] = None,
                 update_strategy: Optional['outputs.ClusterRkeConfigMonitoringUpdateStrategy'] = None):
        """
        :param Mapping[str, _builtins.str] node_selector: RKE monitoring node selector (map)
        :param Mapping[str, _builtins.str] options: RKE options for network (map)
        :param _builtins.str provider: RKE monitoring provider (string)
        :param _builtins.int replicas: RKE monitoring replicas (int)
        :param Sequence['ClusterRkeConfigMonitoringTolerationArgs'] tolerations: Monitoring add-on tolerations
        :param 'ClusterRkeConfigMonitoringUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE monitoring node selector (map)
        """
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        RKE monitoring provider (string)
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.int]:
        """
        RKE monitoring replicas (int)
        """
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterRkeConfigMonitoringToleration']]:
        """
        Monitoring add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.ClusterRkeConfigMonitoringUpdateStrategy']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class ClusterRkeConfigMonitoringToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param _builtins.int seconds: The toleration seconds (int)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterRkeConfigMonitoringUpdateStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigMonitoringUpdateStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigMonitoringUpdateStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigMonitoringUpdateStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'ClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterRkeConfigNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aciNetworkProvider":
            suggest = "aci_network_provider"
        elif key == "calicoNetworkProvider":
            suggest = "calico_network_provider"
        elif key == "canalNetworkProvider":
            suggest = "canal_network_provider"
        elif key == "flannelNetworkProvider":
            suggest = "flannel_network_provider"
        elif key == "weaveNetworkProvider":
            suggest = "weave_network_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aci_network_provider: Optional['outputs.ClusterRkeConfigNetworkAciNetworkProvider'] = None,
                 calico_network_provider: Optional['outputs.ClusterRkeConfigNetworkCalicoNetworkProvider'] = None,
                 canal_network_provider: Optional['outputs.ClusterRkeConfigNetworkCanalNetworkProvider'] = None,
                 flannel_network_provider: Optional['outputs.ClusterRkeConfigNetworkFlannelNetworkProvider'] = None,
                 mtu: Optional[_builtins.int] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 plugin: Optional[_builtins.str] = None,
                 tolerations: Optional[Sequence['outputs.ClusterRkeConfigNetworkToleration']] = None,
                 weave_network_provider: Optional['outputs.ClusterRkeConfigNetworkWeaveNetworkProvider'] = None):
        """
        :param 'ClusterRkeConfigNetworkAciNetworkProviderArgs' aci_network_provider: ACI provider config for RKE network (list maxitems:63)
        :param 'ClusterRkeConfigNetworkCalicoNetworkProviderArgs' calico_network_provider: Calico provider config for RKE network (list maxitems:1)
        :param 'ClusterRkeConfigNetworkCanalNetworkProviderArgs' canal_network_provider: Canal provider config for RKE network (list maxitems:1)
        :param 'ClusterRkeConfigNetworkFlannelNetworkProviderArgs' flannel_network_provider: Flannel provider config for RKE network (list maxitems:1)
        :param _builtins.int mtu: Network provider MTU. Default `0` (int)
        :param Mapping[str, _builtins.str] options: RKE options for network (map)
        :param _builtins.str plugin: Plugin for RKE network. `canal` (default), `flannel`, `calico`, `none` and `weave` are supported. (string)
        :param Sequence['ClusterRkeConfigNetworkTolerationArgs'] tolerations: Network add-on tolerations
        :param 'ClusterRkeConfigNetworkWeaveNetworkProviderArgs' weave_network_provider: Weave provider config for RKE network (list maxitems:1)
        """
        if aci_network_provider is not None:
            pulumi.set(__self__, "aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            pulumi.set(__self__, "calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            pulumi.set(__self__, "canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            pulumi.set(__self__, "flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if weave_network_provider is not None:
            pulumi.set(__self__, "weave_network_provider", weave_network_provider)

    @_builtins.property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional['outputs.ClusterRkeConfigNetworkAciNetworkProvider']:
        """
        ACI provider config for RKE network (list maxitems:63)
        """
        return pulumi.get(self, "aci_network_provider")

    @_builtins.property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional['outputs.ClusterRkeConfigNetworkCalicoNetworkProvider']:
        """
        Calico provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "calico_network_provider")

    @_builtins.property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional['outputs.ClusterRkeConfigNetworkCanalNetworkProvider']:
        """
        Canal provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "canal_network_provider")

    @_builtins.property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional['outputs.ClusterRkeConfigNetworkFlannelNetworkProvider']:
        """
        Flannel provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "flannel_network_provider")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        """
        Network provider MTU. Default `0` (int)
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        RKE options for network (map)
        """
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def plugin(self) -> Optional[_builtins.str]:
        """
        Plugin for RKE network. `canal` (default), `flannel`, `calico`, `none` and `weave` are supported. (string)
        """
        return pulumi.get(self, "plugin")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterRkeConfigNetworkToleration']]:
        """
        Network add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional['outputs.ClusterRkeConfigNetworkWeaveNetworkProvider']:
        """
        Weave provider config for RKE network (list maxitems:1)
        """
        return pulumi.get(self, "weave_network_provider")


@pulumi.output_type
class ClusterRkeConfigNetworkAciNetworkProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apicHosts":
            suggest = "apic_hosts"
        elif key == "apicUserCrt":
            suggest = "apic_user_crt"
        elif key == "apicUserKey":
            suggest = "apic_user_key"
        elif key == "apicUserName":
            suggest = "apic_user_name"
        elif key == "encapType":
            suggest = "encap_type"
        elif key == "externDynamic":
            suggest = "extern_dynamic"
        elif key == "externStatic":
            suggest = "extern_static"
        elif key == "kubeApiVlan":
            suggest = "kube_api_vlan"
        elif key == "l3outExternalNetworks":
            suggest = "l3out_external_networks"
        elif key == "mcastRangeEnd":
            suggest = "mcast_range_end"
        elif key == "mcastRangeStart":
            suggest = "mcast_range_start"
        elif key == "nodeSubnet":
            suggest = "node_subnet"
        elif key == "nodeSvcSubnet":
            suggest = "node_svc_subnet"
        elif key == "serviceVlan":
            suggest = "service_vlan"
        elif key == "systemId":
            suggest = "system_id"
        elif key == "vrfName":
            suggest = "vrf_name"
        elif key == "vrfTenant":
            suggest = "vrf_tenant"
        elif key == "apicRefreshTickerAdjust":
            suggest = "apic_refresh_ticker_adjust"
        elif key == "apicRefreshTime":
            suggest = "apic_refresh_time"
        elif key == "apicSubscriptionDelay":
            suggest = "apic_subscription_delay"
        elif key == "controllerLogLevel":
            suggest = "controller_log_level"
        elif key == "disablePeriodicSnatGlobalInfoSync":
            suggest = "disable_periodic_snat_global_info_sync"
        elif key == "disableWaitForNetwork":
            suggest = "disable_wait_for_network"
        elif key == "dropLogEnable":
            suggest = "drop_log_enable"
        elif key == "durationWaitForNetwork":
            suggest = "duration_wait_for_network"
        elif key == "enableEndpointSlice":
            suggest = "enable_endpoint_slice"
        elif key == "epRegistry":
            suggest = "ep_registry"
        elif key == "gbpPodSubnet":
            suggest = "gbp_pod_subnet"
        elif key == "hostAgentLogLevel":
            suggest = "host_agent_log_level"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "imagePullSecret":
            suggest = "image_pull_secret"
        elif key == "infraVlan":
            suggest = "infra_vlan"
        elif key == "installIstio":
            suggest = "install_istio"
        elif key == "istioProfile":
            suggest = "istio_profile"
        elif key == "kafkaBrokers":
            suggest = "kafka_brokers"
        elif key == "kafkaClientCrt":
            suggest = "kafka_client_crt"
        elif key == "kafkaClientKey":
            suggest = "kafka_client_key"
        elif key == "maxNodesSvcGraph":
            suggest = "max_nodes_svc_graph"
        elif key == "mtuHeadRoom":
            suggest = "mtu_head_room"
        elif key == "multusDisable":
            suggest = "multus_disable"
        elif key == "noPriorityClass":
            suggest = "no_priority_class"
        elif key == "nodePodIfEnable":
            suggest = "node_pod_if_enable"
        elif key == "opflexClientSsl":
            suggest = "opflex_client_ssl"
        elif key == "opflexDeviceDeleteTimeout":
            suggest = "opflex_device_delete_timeout"
        elif key == "opflexLogLevel":
            suggest = "opflex_log_level"
        elif key == "opflexMode":
            suggest = "opflex_mode"
        elif key == "opflexServerPort":
            suggest = "opflex_server_port"
        elif key == "overlayVrfName":
            suggest = "overlay_vrf_name"
        elif key == "ovsMemoryLimit":
            suggest = "ovs_memory_limit"
        elif key == "pbrTrackingNonSnat":
            suggest = "pbr_tracking_non_snat"
        elif key == "podSubnetChunkSize":
            suggest = "pod_subnet_chunk_size"
        elif key == "runGbpContainer":
            suggest = "run_gbp_container"
        elif key == "runOpflexServerContainer":
            suggest = "run_opflex_server_container"
        elif key == "serviceMonitorInterval":
            suggest = "service_monitor_interval"
        elif key == "snatContractScope":
            suggest = "snat_contract_scope"
        elif key == "snatNamespace":
            suggest = "snat_namespace"
        elif key == "snatPortRangeEnd":
            suggest = "snat_port_range_end"
        elif key == "snatPortRangeStart":
            suggest = "snat_port_range_start"
        elif key == "snatPortsPerNode":
            suggest = "snat_ports_per_node"
        elif key == "sriovEnable":
            suggest = "sriov_enable"
        elif key == "subnetDomainName":
            suggest = "subnet_domain_name"
        elif key == "useAciAnywhereCrd":
            suggest = "use_aci_anywhere_crd"
        elif key == "useAciCniPriorityClass":
            suggest = "use_aci_cni_priority_class"
        elif key == "useClusterRole":
            suggest = "use_cluster_role"
        elif key == "useHostNetnsVolume":
            suggest = "use_host_netns_volume"
        elif key == "useOpflexServerVolume":
            suggest = "use_opflex_server_volume"
        elif key == "usePrivilegedContainer":
            suggest = "use_privileged_container"
        elif key == "vmmController":
            suggest = "vmm_controller"
        elif key == "vmmDomain":
            suggest = "vmm_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigNetworkAciNetworkProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigNetworkAciNetworkProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigNetworkAciNetworkProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aep: _builtins.str,
                 apic_hosts: Sequence[_builtins.str],
                 apic_user_crt: _builtins.str,
                 apic_user_key: _builtins.str,
                 apic_user_name: _builtins.str,
                 encap_type: _builtins.str,
                 extern_dynamic: _builtins.str,
                 extern_static: _builtins.str,
                 kube_api_vlan: _builtins.str,
                 l3out: _builtins.str,
                 l3out_external_networks: Sequence[_builtins.str],
                 mcast_range_end: _builtins.str,
                 mcast_range_start: _builtins.str,
                 node_subnet: _builtins.str,
                 node_svc_subnet: _builtins.str,
                 service_vlan: _builtins.str,
                 system_id: _builtins.str,
                 token: _builtins.str,
                 vrf_name: _builtins.str,
                 vrf_tenant: _builtins.str,
                 apic_refresh_ticker_adjust: Optional[_builtins.str] = None,
                 apic_refresh_time: Optional[_builtins.str] = None,
                 apic_subscription_delay: Optional[_builtins.str] = None,
                 capic: Optional[_builtins.str] = None,
                 controller_log_level: Optional[_builtins.str] = None,
                 disable_periodic_snat_global_info_sync: Optional[_builtins.str] = None,
                 disable_wait_for_network: Optional[_builtins.str] = None,
                 drop_log_enable: Optional[_builtins.str] = None,
                 duration_wait_for_network: Optional[_builtins.str] = None,
                 enable_endpoint_slice: Optional[_builtins.str] = None,
                 ep_registry: Optional[_builtins.str] = None,
                 gbp_pod_subnet: Optional[_builtins.str] = None,
                 host_agent_log_level: Optional[_builtins.str] = None,
                 image_pull_policy: Optional[_builtins.str] = None,
                 image_pull_secret: Optional[_builtins.str] = None,
                 infra_vlan: Optional[_builtins.str] = None,
                 install_istio: Optional[_builtins.str] = None,
                 istio_profile: Optional[_builtins.str] = None,
                 kafka_brokers: Optional[Sequence[_builtins.str]] = None,
                 kafka_client_crt: Optional[_builtins.str] = None,
                 kafka_client_key: Optional[_builtins.str] = None,
                 max_nodes_svc_graph: Optional[_builtins.str] = None,
                 mtu_head_room: Optional[_builtins.str] = None,
                 multus_disable: Optional[_builtins.str] = None,
                 no_priority_class: Optional[_builtins.str] = None,
                 node_pod_if_enable: Optional[_builtins.str] = None,
                 opflex_client_ssl: Optional[_builtins.str] = None,
                 opflex_device_delete_timeout: Optional[_builtins.str] = None,
                 opflex_log_level: Optional[_builtins.str] = None,
                 opflex_mode: Optional[_builtins.str] = None,
                 opflex_server_port: Optional[_builtins.str] = None,
                 overlay_vrf_name: Optional[_builtins.str] = None,
                 ovs_memory_limit: Optional[_builtins.str] = None,
                 pbr_tracking_non_snat: Optional[_builtins.str] = None,
                 pod_subnet_chunk_size: Optional[_builtins.str] = None,
                 run_gbp_container: Optional[_builtins.str] = None,
                 run_opflex_server_container: Optional[_builtins.str] = None,
                 service_monitor_interval: Optional[_builtins.str] = None,
                 snat_contract_scope: Optional[_builtins.str] = None,
                 snat_namespace: Optional[_builtins.str] = None,
                 snat_port_range_end: Optional[_builtins.str] = None,
                 snat_port_range_start: Optional[_builtins.str] = None,
                 snat_ports_per_node: Optional[_builtins.str] = None,
                 sriov_enable: Optional[_builtins.str] = None,
                 subnet_domain_name: Optional[_builtins.str] = None,
                 tenant: Optional[_builtins.str] = None,
                 use_aci_anywhere_crd: Optional[_builtins.str] = None,
                 use_aci_cni_priority_class: Optional[_builtins.str] = None,
                 use_cluster_role: Optional[_builtins.str] = None,
                 use_host_netns_volume: Optional[_builtins.str] = None,
                 use_opflex_server_volume: Optional[_builtins.str] = None,
                 use_privileged_container: Optional[_builtins.str] = None,
                 vmm_controller: Optional[_builtins.str] = None,
                 vmm_domain: Optional[_builtins.str] = None):
        """
        :param _builtins.str aep: Attachable entity profile (string)
        :param Sequence[_builtins.str] apic_hosts: List of APIC hosts to connect for APIC API (list)
        :param _builtins.str apic_user_crt: APIC user certificate (string)
        :param _builtins.str apic_user_key: APIC user key (string)
        :param _builtins.str apic_user_name: APIC user name (string)
        :param _builtins.str encap_type: Encap type: vxlan or vlan (string)
        :param _builtins.str extern_dynamic: Subnet to use for dynamic external IPs (string)
        :param _builtins.str extern_static: Subnet to use for static external IPs (string)
        :param _builtins.str kube_api_vlan: The VLAN used by the physdom for nodes (string)
        :param _builtins.str l3out: L3out (string)
        :param Sequence[_builtins.str] l3out_external_networks: L3out external networks (list)
        :param _builtins.str mcast_range_end: End of mcast range (string)
        :param _builtins.str mcast_range_start: Start of mcast range (string)
        :param _builtins.str node_subnet: Subnet to use for nodes (string)
        :param _builtins.str node_svc_subnet: Subnet to use for service graph (string)
        :param _builtins.str service_vlan: The VLAN used by LoadBalancer services (string)
        :param _builtins.str system_id: ACI system ID (string)
        :param _builtins.str vrf_name: VRF name (string)
        :param _builtins.str vrf_tenant: VRF tenant (string)
        :param _builtins.str apic_refresh_ticker_adjust: APIC refresh ticker adjust amount (string)
        :param _builtins.str apic_refresh_time: APIC refresh time in seconds (string)
        :param _builtins.str apic_subscription_delay: APIC subscription delay amount (string)
        :param _builtins.str capic: cAPIC cloud (string)
        :param _builtins.str controller_log_level: Log level for ACI controller (string)
        :param _builtins.str disable_periodic_snat_global_info_sync: Whether to disable periodic SNAT global info sync (string)
        :param _builtins.str disable_wait_for_network: Whether to disable waiting for network (string)
        :param _builtins.str drop_log_enable: Whether to enable drop log (string)
        :param _builtins.str duration_wait_for_network: The duration to wait for network (string)
        :param _builtins.str enable_endpoint_slice: Whether to enable endpoint slices (string)
        :param _builtins.str ep_registry: EP registry (string)
        :param _builtins.str gbp_pod_subnet: GBH pod subnet (string)
        :param _builtins.str host_agent_log_level: Log level for ACI host agent (string)
        :param _builtins.str image_pull_policy: Image pull policy (string)
        :param _builtins.str image_pull_secret: Image pull policy (string)
        :param _builtins.str infra_vlan: The VLAN used by ACI infra (string)
        :param _builtins.str install_istio: Whether to install Istio (string)
        :param _builtins.str istio_profile: Istio profile name (string)
        :param Sequence[_builtins.str] kafka_brokers: List of Kafka broker hosts (list)
        :param _builtins.str kafka_client_crt: Kafka client certificate (string)
        :param _builtins.str kafka_client_key: Kafka client key (string)
        :param _builtins.str max_nodes_svc_graph: Max nodes in service graph (string)
        :param _builtins.str mtu_head_room: MTU head room amount (string)
        :param _builtins.str multus_disable: Whether to disable Multus (string)
        :param _builtins.str no_priority_class: Whether to use priority class (string)
        :param _builtins.str node_pod_if_enable: Whether to enable node pod interface (string)
        :param _builtins.str opflex_client_ssl: Whether to use client SSL for Opflex (string)
        :param _builtins.str opflex_device_delete_timeout: Opflex device delete timeout (string)
        :param _builtins.str opflex_log_level: Log level for ACI opflex (string)
        :param _builtins.str opflex_mode: Opflex mode (string)
        :param _builtins.str opflex_server_port: Opflex server port (string)
        :param _builtins.str overlay_vrf_name: Overlay VRF name (string)
        :param _builtins.str ovs_memory_limit: OVS memory limit (string)
        :param _builtins.str pbr_tracking_non_snat: Policy-based routing tracking non snat (string)
        :param _builtins.str pod_subnet_chunk_size: Pod subnet chunk size (string)
        :param _builtins.str run_gbp_container: Whether to run GBP container (string)
        :param _builtins.str run_opflex_server_container: Whether to run Opflex server container (string)
        :param _builtins.str service_monitor_interval: Service monitor interval (string)
        :param _builtins.str snat_contract_scope: Snat contract scope (string)
        :param _builtins.str snat_namespace: Snat namespace (string)
        :param _builtins.str snat_port_range_end: End of snat port range (string)
        :param _builtins.str snat_port_range_start: End of snat port range (string)
        :param _builtins.str snat_ports_per_node: Snat ports per node (string)
        :param _builtins.str sriov_enable: Whether to enable SR-IOV (string)
        :param _builtins.str subnet_domain_name: Subnet domain name (string)
        :param _builtins.str tenant: ACI tenant (string)
        :param _builtins.str use_aci_anywhere_crd: Whether to use ACI anywhere CRD (string)
        :param _builtins.str use_aci_cni_priority_class: Whether to use ACI CNI priority class (string)
        :param _builtins.str use_cluster_role: Whether to use cluster role (string)
        :param _builtins.str use_host_netns_volume: Whether to use host netns volume (string)
        :param _builtins.str use_opflex_server_volume: Whether use Opflex server volume (string)
        :param _builtins.str use_privileged_container: Whether ACI containers should run as privileged (string)
        :param _builtins.str vmm_controller: VMM controller configuration (string)
        :param _builtins.str vmm_domain: VMM domain configuration (string)
        """
        pulumi.set(__self__, "aep", aep)
        pulumi.set(__self__, "apic_hosts", apic_hosts)
        pulumi.set(__self__, "apic_user_crt", apic_user_crt)
        pulumi.set(__self__, "apic_user_key", apic_user_key)
        pulumi.set(__self__, "apic_user_name", apic_user_name)
        pulumi.set(__self__, "encap_type", encap_type)
        pulumi.set(__self__, "extern_dynamic", extern_dynamic)
        pulumi.set(__self__, "extern_static", extern_static)
        pulumi.set(__self__, "kube_api_vlan", kube_api_vlan)
        pulumi.set(__self__, "l3out", l3out)
        pulumi.set(__self__, "l3out_external_networks", l3out_external_networks)
        pulumi.set(__self__, "mcast_range_end", mcast_range_end)
        pulumi.set(__self__, "mcast_range_start", mcast_range_start)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "node_svc_subnet", node_svc_subnet)
        pulumi.set(__self__, "service_vlan", service_vlan)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "vrf_name", vrf_name)
        pulumi.set(__self__, "vrf_tenant", vrf_tenant)
        if apic_refresh_ticker_adjust is not None:
            pulumi.set(__self__, "apic_refresh_ticker_adjust", apic_refresh_ticker_adjust)
        if apic_refresh_time is not None:
            pulumi.set(__self__, "apic_refresh_time", apic_refresh_time)
        if apic_subscription_delay is not None:
            pulumi.set(__self__, "apic_subscription_delay", apic_subscription_delay)
        if capic is not None:
            pulumi.set(__self__, "capic", capic)
        if controller_log_level is not None:
            pulumi.set(__self__, "controller_log_level", controller_log_level)
        if disable_periodic_snat_global_info_sync is not None:
            pulumi.set(__self__, "disable_periodic_snat_global_info_sync", disable_periodic_snat_global_info_sync)
        if disable_wait_for_network is not None:
            pulumi.set(__self__, "disable_wait_for_network", disable_wait_for_network)
        if drop_log_enable is not None:
            pulumi.set(__self__, "drop_log_enable", drop_log_enable)
        if duration_wait_for_network is not None:
            pulumi.set(__self__, "duration_wait_for_network", duration_wait_for_network)
        if enable_endpoint_slice is not None:
            pulumi.set(__self__, "enable_endpoint_slice", enable_endpoint_slice)
        if ep_registry is not None:
            pulumi.set(__self__, "ep_registry", ep_registry)
        if gbp_pod_subnet is not None:
            pulumi.set(__self__, "gbp_pod_subnet", gbp_pod_subnet)
        if host_agent_log_level is not None:
            pulumi.set(__self__, "host_agent_log_level", host_agent_log_level)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if infra_vlan is not None:
            pulumi.set(__self__, "infra_vlan", infra_vlan)
        if install_istio is not None:
            pulumi.set(__self__, "install_istio", install_istio)
        if istio_profile is not None:
            pulumi.set(__self__, "istio_profile", istio_profile)
        if kafka_brokers is not None:
            pulumi.set(__self__, "kafka_brokers", kafka_brokers)
        if kafka_client_crt is not None:
            pulumi.set(__self__, "kafka_client_crt", kafka_client_crt)
        if kafka_client_key is not None:
            pulumi.set(__self__, "kafka_client_key", kafka_client_key)
        if max_nodes_svc_graph is not None:
            pulumi.set(__self__, "max_nodes_svc_graph", max_nodes_svc_graph)
        if mtu_head_room is not None:
            pulumi.set(__self__, "mtu_head_room", mtu_head_room)
        if multus_disable is not None:
            pulumi.set(__self__, "multus_disable", multus_disable)
        if no_priority_class is not None:
            pulumi.set(__self__, "no_priority_class", no_priority_class)
        if node_pod_if_enable is not None:
            pulumi.set(__self__, "node_pod_if_enable", node_pod_if_enable)
        if opflex_client_ssl is not None:
            pulumi.set(__self__, "opflex_client_ssl", opflex_client_ssl)
        if opflex_device_delete_timeout is not None:
            pulumi.set(__self__, "opflex_device_delete_timeout", opflex_device_delete_timeout)
        if opflex_log_level is not None:
            pulumi.set(__self__, "opflex_log_level", opflex_log_level)
        if opflex_mode is not None:
            pulumi.set(__self__, "opflex_mode", opflex_mode)
        if opflex_server_port is not None:
            pulumi.set(__self__, "opflex_server_port", opflex_server_port)
        if overlay_vrf_name is not None:
            pulumi.set(__self__, "overlay_vrf_name", overlay_vrf_name)
        if ovs_memory_limit is not None:
            pulumi.set(__self__, "ovs_memory_limit", ovs_memory_limit)
        if pbr_tracking_non_snat is not None:
            pulumi.set(__self__, "pbr_tracking_non_snat", pbr_tracking_non_snat)
        if pod_subnet_chunk_size is not None:
            pulumi.set(__self__, "pod_subnet_chunk_size", pod_subnet_chunk_size)
        if run_gbp_container is not None:
            pulumi.set(__self__, "run_gbp_container", run_gbp_container)
        if run_opflex_server_container is not None:
            pulumi.set(__self__, "run_opflex_server_container", run_opflex_server_container)
        if service_monitor_interval is not None:
            pulumi.set(__self__, "service_monitor_interval", service_monitor_interval)
        if snat_contract_scope is not None:
            pulumi.set(__self__, "snat_contract_scope", snat_contract_scope)
        if snat_namespace is not None:
            pulumi.set(__self__, "snat_namespace", snat_namespace)
        if snat_port_range_end is not None:
            pulumi.set(__self__, "snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            pulumi.set(__self__, "snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            pulumi.set(__self__, "snat_ports_per_node", snat_ports_per_node)
        if sriov_enable is not None:
            pulumi.set(__self__, "sriov_enable", sriov_enable)
        if subnet_domain_name is not None:
            pulumi.set(__self__, "subnet_domain_name", subnet_domain_name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if use_aci_anywhere_crd is not None:
            pulumi.set(__self__, "use_aci_anywhere_crd", use_aci_anywhere_crd)
        if use_aci_cni_priority_class is not None:
            pulumi.set(__self__, "use_aci_cni_priority_class", use_aci_cni_priority_class)
        if use_cluster_role is not None:
            pulumi.set(__self__, "use_cluster_role", use_cluster_role)
        if use_host_netns_volume is not None:
            pulumi.set(__self__, "use_host_netns_volume", use_host_netns_volume)
        if use_opflex_server_volume is not None:
            pulumi.set(__self__, "use_opflex_server_volume", use_opflex_server_volume)
        if use_privileged_container is not None:
            pulumi.set(__self__, "use_privileged_container", use_privileged_container)
        if vmm_controller is not None:
            pulumi.set(__self__, "vmm_controller", vmm_controller)
        if vmm_domain is not None:
            pulumi.set(__self__, "vmm_domain", vmm_domain)

    @_builtins.property
    @pulumi.getter
    def aep(self) -> _builtins.str:
        """
        Attachable entity profile (string)
        """
        return pulumi.get(self, "aep")

    @_builtins.property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> Sequence[_builtins.str]:
        """
        List of APIC hosts to connect for APIC API (list)
        """
        return pulumi.get(self, "apic_hosts")

    @_builtins.property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> _builtins.str:
        """
        APIC user certificate (string)
        """
        return pulumi.get(self, "apic_user_crt")

    @_builtins.property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> _builtins.str:
        """
        APIC user key (string)
        """
        return pulumi.get(self, "apic_user_key")

    @_builtins.property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> _builtins.str:
        """
        APIC user name (string)
        """
        return pulumi.get(self, "apic_user_name")

    @_builtins.property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> _builtins.str:
        """
        Encap type: vxlan or vlan (string)
        """
        return pulumi.get(self, "encap_type")

    @_builtins.property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> _builtins.str:
        """
        Subnet to use for dynamic external IPs (string)
        """
        return pulumi.get(self, "extern_dynamic")

    @_builtins.property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> _builtins.str:
        """
        Subnet to use for static external IPs (string)
        """
        return pulumi.get(self, "extern_static")

    @_builtins.property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> _builtins.str:
        """
        The VLAN used by the physdom for nodes (string)
        """
        return pulumi.get(self, "kube_api_vlan")

    @_builtins.property
    @pulumi.getter
    def l3out(self) -> _builtins.str:
        """
        L3out (string)
        """
        return pulumi.get(self, "l3out")

    @_builtins.property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> Sequence[_builtins.str]:
        """
        L3out external networks (list)
        """
        return pulumi.get(self, "l3out_external_networks")

    @_builtins.property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> _builtins.str:
        """
        End of mcast range (string)
        """
        return pulumi.get(self, "mcast_range_end")

    @_builtins.property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> _builtins.str:
        """
        Start of mcast range (string)
        """
        return pulumi.get(self, "mcast_range_start")

    @_builtins.property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> _builtins.str:
        """
        Subnet to use for nodes (string)
        """
        return pulumi.get(self, "node_subnet")

    @_builtins.property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> _builtins.str:
        """
        Subnet to use for service graph (string)
        """
        return pulumi.get(self, "node_svc_subnet")

    @_builtins.property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> _builtins.str:
        """
        The VLAN used by LoadBalancer services (string)
        """
        return pulumi.get(self, "service_vlan")

    @_builtins.property
    @pulumi.getter(name="systemId")
    def system_id(self) -> _builtins.str:
        """
        ACI system ID (string)
        """
        return pulumi.get(self, "system_id")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> _builtins.str:
        """
        VRF name (string)
        """
        return pulumi.get(self, "vrf_name")

    @_builtins.property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> _builtins.str:
        """
        VRF tenant (string)
        """
        return pulumi.get(self, "vrf_tenant")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTickerAdjust")
    def apic_refresh_ticker_adjust(self) -> Optional[_builtins.str]:
        """
        APIC refresh ticker adjust amount (string)
        """
        return pulumi.get(self, "apic_refresh_ticker_adjust")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTime")
    def apic_refresh_time(self) -> Optional[_builtins.str]:
        """
        APIC refresh time in seconds (string)
        """
        return pulumi.get(self, "apic_refresh_time")

    @_builtins.property
    @pulumi.getter(name="apicSubscriptionDelay")
    def apic_subscription_delay(self) -> Optional[_builtins.str]:
        """
        APIC subscription delay amount (string)
        """
        return pulumi.get(self, "apic_subscription_delay")

    @_builtins.property
    @pulumi.getter
    def capic(self) -> Optional[_builtins.str]:
        """
        cAPIC cloud (string)
        """
        return pulumi.get(self, "capic")

    @_builtins.property
    @pulumi.getter(name="controllerLogLevel")
    def controller_log_level(self) -> Optional[_builtins.str]:
        """
        Log level for ACI controller (string)
        """
        return pulumi.get(self, "controller_log_level")

    @_builtins.property
    @pulumi.getter(name="disablePeriodicSnatGlobalInfoSync")
    def disable_periodic_snat_global_info_sync(self) -> Optional[_builtins.str]:
        """
        Whether to disable periodic SNAT global info sync (string)
        """
        return pulumi.get(self, "disable_periodic_snat_global_info_sync")

    @_builtins.property
    @pulumi.getter(name="disableWaitForNetwork")
    def disable_wait_for_network(self) -> Optional[_builtins.str]:
        """
        Whether to disable waiting for network (string)
        """
        return pulumi.get(self, "disable_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="dropLogEnable")
    def drop_log_enable(self) -> Optional[_builtins.str]:
        """
        Whether to enable drop log (string)
        """
        return pulumi.get(self, "drop_log_enable")

    @_builtins.property
    @pulumi.getter(name="durationWaitForNetwork")
    def duration_wait_for_network(self) -> Optional[_builtins.str]:
        """
        The duration to wait for network (string)
        """
        return pulumi.get(self, "duration_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="enableEndpointSlice")
    def enable_endpoint_slice(self) -> Optional[_builtins.str]:
        """
        Whether to enable endpoint slices (string)
        """
        return pulumi.get(self, "enable_endpoint_slice")

    @_builtins.property
    @pulumi.getter(name="epRegistry")
    def ep_registry(self) -> Optional[_builtins.str]:
        """
        EP registry (string)
        """
        return pulumi.get(self, "ep_registry")

    @_builtins.property
    @pulumi.getter(name="gbpPodSubnet")
    def gbp_pod_subnet(self) -> Optional[_builtins.str]:
        """
        GBH pod subnet (string)
        """
        return pulumi.get(self, "gbp_pod_subnet")

    @_builtins.property
    @pulumi.getter(name="hostAgentLogLevel")
    def host_agent_log_level(self) -> Optional[_builtins.str]:
        """
        Log level for ACI host agent (string)
        """
        return pulumi.get(self, "host_agent_log_level")

    @_builtins.property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[_builtins.str]:
        """
        Image pull policy (string)
        """
        return pulumi.get(self, "image_pull_policy")

    @_builtins.property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[_builtins.str]:
        """
        Image pull policy (string)
        """
        return pulumi.get(self, "image_pull_secret")

    @_builtins.property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> Optional[_builtins.str]:
        """
        The VLAN used by ACI infra (string)
        """
        return pulumi.get(self, "infra_vlan")

    @_builtins.property
    @pulumi.getter(name="installIstio")
    def install_istio(self) -> Optional[_builtins.str]:
        """
        Whether to install Istio (string)
        """
        return pulumi.get(self, "install_istio")

    @_builtins.property
    @pulumi.getter(name="istioProfile")
    def istio_profile(self) -> Optional[_builtins.str]:
        """
        Istio profile name (string)
        """
        return pulumi.get(self, "istio_profile")

    @_builtins.property
    @pulumi.getter(name="kafkaBrokers")
    def kafka_brokers(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Kafka broker hosts (list)
        """
        return pulumi.get(self, "kafka_brokers")

    @_builtins.property
    @pulumi.getter(name="kafkaClientCrt")
    def kafka_client_crt(self) -> Optional[_builtins.str]:
        """
        Kafka client certificate (string)
        """
        return pulumi.get(self, "kafka_client_crt")

    @_builtins.property
    @pulumi.getter(name="kafkaClientKey")
    def kafka_client_key(self) -> Optional[_builtins.str]:
        """
        Kafka client key (string)
        """
        return pulumi.get(self, "kafka_client_key")

    @_builtins.property
    @pulumi.getter(name="maxNodesSvcGraph")
    def max_nodes_svc_graph(self) -> Optional[_builtins.str]:
        """
        Max nodes in service graph (string)
        """
        return pulumi.get(self, "max_nodes_svc_graph")

    @_builtins.property
    @pulumi.getter(name="mtuHeadRoom")
    def mtu_head_room(self) -> Optional[_builtins.str]:
        """
        MTU head room amount (string)
        """
        return pulumi.get(self, "mtu_head_room")

    @_builtins.property
    @pulumi.getter(name="multusDisable")
    def multus_disable(self) -> Optional[_builtins.str]:
        """
        Whether to disable Multus (string)
        """
        return pulumi.get(self, "multus_disable")

    @_builtins.property
    @pulumi.getter(name="noPriorityClass")
    def no_priority_class(self) -> Optional[_builtins.str]:
        """
        Whether to use priority class (string)
        """
        return pulumi.get(self, "no_priority_class")

    @_builtins.property
    @pulumi.getter(name="nodePodIfEnable")
    def node_pod_if_enable(self) -> Optional[_builtins.str]:
        """
        Whether to enable node pod interface (string)
        """
        return pulumi.get(self, "node_pod_if_enable")

    @_builtins.property
    @pulumi.getter(name="opflexClientSsl")
    def opflex_client_ssl(self) -> Optional[_builtins.str]:
        """
        Whether to use client SSL for Opflex (string)
        """
        return pulumi.get(self, "opflex_client_ssl")

    @_builtins.property
    @pulumi.getter(name="opflexDeviceDeleteTimeout")
    def opflex_device_delete_timeout(self) -> Optional[_builtins.str]:
        """
        Opflex device delete timeout (string)
        """
        return pulumi.get(self, "opflex_device_delete_timeout")

    @_builtins.property
    @pulumi.getter(name="opflexLogLevel")
    def opflex_log_level(self) -> Optional[_builtins.str]:
        """
        Log level for ACI opflex (string)
        """
        return pulumi.get(self, "opflex_log_level")

    @_builtins.property
    @pulumi.getter(name="opflexMode")
    def opflex_mode(self) -> Optional[_builtins.str]:
        """
        Opflex mode (string)
        """
        return pulumi.get(self, "opflex_mode")

    @_builtins.property
    @pulumi.getter(name="opflexServerPort")
    def opflex_server_port(self) -> Optional[_builtins.str]:
        """
        Opflex server port (string)
        """
        return pulumi.get(self, "opflex_server_port")

    @_builtins.property
    @pulumi.getter(name="overlayVrfName")
    def overlay_vrf_name(self) -> Optional[_builtins.str]:
        """
        Overlay VRF name (string)
        """
        return pulumi.get(self, "overlay_vrf_name")

    @_builtins.property
    @pulumi.getter(name="ovsMemoryLimit")
    def ovs_memory_limit(self) -> Optional[_builtins.str]:
        """
        OVS memory limit (string)
        """
        return pulumi.get(self, "ovs_memory_limit")

    @_builtins.property
    @pulumi.getter(name="pbrTrackingNonSnat")
    def pbr_tracking_non_snat(self) -> Optional[_builtins.str]:
        """
        Policy-based routing tracking non snat (string)
        """
        return pulumi.get(self, "pbr_tracking_non_snat")

    @_builtins.property
    @pulumi.getter(name="podSubnetChunkSize")
    def pod_subnet_chunk_size(self) -> Optional[_builtins.str]:
        """
        Pod subnet chunk size (string)
        """
        return pulumi.get(self, "pod_subnet_chunk_size")

    @_builtins.property
    @pulumi.getter(name="runGbpContainer")
    def run_gbp_container(self) -> Optional[_builtins.str]:
        """
        Whether to run GBP container (string)
        """
        return pulumi.get(self, "run_gbp_container")

    @_builtins.property
    @pulumi.getter(name="runOpflexServerContainer")
    def run_opflex_server_container(self) -> Optional[_builtins.str]:
        """
        Whether to run Opflex server container (string)
        """
        return pulumi.get(self, "run_opflex_server_container")

    @_builtins.property
    @pulumi.getter(name="serviceMonitorInterval")
    def service_monitor_interval(self) -> Optional[_builtins.str]:
        """
        Service monitor interval (string)
        """
        return pulumi.get(self, "service_monitor_interval")

    @_builtins.property
    @pulumi.getter(name="snatContractScope")
    def snat_contract_scope(self) -> Optional[_builtins.str]:
        """
        Snat contract scope (string)
        """
        return pulumi.get(self, "snat_contract_scope")

    @_builtins.property
    @pulumi.getter(name="snatNamespace")
    def snat_namespace(self) -> Optional[_builtins.str]:
        """
        Snat namespace (string)
        """
        return pulumi.get(self, "snat_namespace")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[_builtins.str]:
        """
        End of snat port range (string)
        """
        return pulumi.get(self, "snat_port_range_end")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[_builtins.str]:
        """
        End of snat port range (string)
        """
        return pulumi.get(self, "snat_port_range_start")

    @_builtins.property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[_builtins.str]:
        """
        Snat ports per node (string)
        """
        return pulumi.get(self, "snat_ports_per_node")

    @_builtins.property
    @pulumi.getter(name="sriovEnable")
    def sriov_enable(self) -> Optional[_builtins.str]:
        """
        Whether to enable SR-IOV (string)
        """
        return pulumi.get(self, "sriov_enable")

    @_builtins.property
    @pulumi.getter(name="subnetDomainName")
    def subnet_domain_name(self) -> Optional[_builtins.str]:
        """
        Subnet domain name (string)
        """
        return pulumi.get(self, "subnet_domain_name")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[_builtins.str]:
        """
        ACI tenant (string)
        """
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter(name="useAciAnywhereCrd")
    def use_aci_anywhere_crd(self) -> Optional[_builtins.str]:
        """
        Whether to use ACI anywhere CRD (string)
        """
        return pulumi.get(self, "use_aci_anywhere_crd")

    @_builtins.property
    @pulumi.getter(name="useAciCniPriorityClass")
    def use_aci_cni_priority_class(self) -> Optional[_builtins.str]:
        """
        Whether to use ACI CNI priority class (string)
        """
        return pulumi.get(self, "use_aci_cni_priority_class")

    @_builtins.property
    @pulumi.getter(name="useClusterRole")
    def use_cluster_role(self) -> Optional[_builtins.str]:
        """
        Whether to use cluster role (string)
        """
        return pulumi.get(self, "use_cluster_role")

    @_builtins.property
    @pulumi.getter(name="useHostNetnsVolume")
    def use_host_netns_volume(self) -> Optional[_builtins.str]:
        """
        Whether to use host netns volume (string)
        """
        return pulumi.get(self, "use_host_netns_volume")

    @_builtins.property
    @pulumi.getter(name="useOpflexServerVolume")
    def use_opflex_server_volume(self) -> Optional[_builtins.str]:
        """
        Whether use Opflex server volume (string)
        """
        return pulumi.get(self, "use_opflex_server_volume")

    @_builtins.property
    @pulumi.getter(name="usePrivilegedContainer")
    def use_privileged_container(self) -> Optional[_builtins.str]:
        """
        Whether ACI containers should run as privileged (string)
        """
        return pulumi.get(self, "use_privileged_container")

    @_builtins.property
    @pulumi.getter(name="vmmController")
    def vmm_controller(self) -> Optional[_builtins.str]:
        """
        VMM controller configuration (string)
        """
        return pulumi.get(self, "vmm_controller")

    @_builtins.property
    @pulumi.getter(name="vmmDomain")
    def vmm_domain(self) -> Optional[_builtins.str]:
        """
        VMM domain configuration (string)
        """
        return pulumi.get(self, "vmm_domain")


@pulumi.output_type
class ClusterRkeConfigNetworkCalicoNetworkProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigNetworkCalicoNetworkProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigNetworkCalicoNetworkProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigNetworkCalicoNetworkProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_provider: RKE options for Calico network provider (string)
        """
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[_builtins.str]:
        """
        RKE options for Calico network provider (string)
        """
        return pulumi.get(self, "cloud_provider")


@pulumi.output_type
class ClusterRkeConfigNetworkCanalNetworkProvider(dict):
    def __init__(__self__, *,
                 iface: Optional[_builtins.str] = None):
        """
        :param _builtins.str iface: Iface config Flannel network provider (string)
        """
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> Optional[_builtins.str]:
        """
        Iface config Flannel network provider (string)
        """
        return pulumi.get(self, "iface")


@pulumi.output_type
class ClusterRkeConfigNetworkFlannelNetworkProvider(dict):
    def __init__(__self__, *,
                 iface: Optional[_builtins.str] = None):
        """
        :param _builtins.str iface: Iface config Flannel network provider (string)
        """
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> Optional[_builtins.str]:
        """
        Iface config Flannel network provider (string)
        """
        return pulumi.get(self, "iface")


@pulumi.output_type
class ClusterRkeConfigNetworkToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str effect: The GKE taint effect (string)
        :param _builtins.str operator: The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        :param _builtins.int seconds: The toleration seconds (int)
        :param _builtins.str value: The GKE taint value (string)
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The GKE taint effect (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The toleration seconds (int)
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The GKE taint value (string)
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterRkeConfigNetworkWeaveNetworkProvider(dict):
    def __init__(__self__, *,
                 password: _builtins.str):
        """
        :param _builtins.str password: Registry password (string)
        """
        pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class ClusterRkeConfigNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerSocket":
            suggest = "docker_socket"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "internalAddress":
            suggest = "internal_address"
        elif key == "nodeId":
            suggest = "node_id"
        elif key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshKey":
            suggest = "ssh_key"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 roles: Sequence[_builtins.str],
                 user: _builtins.str,
                 docker_socket: Optional[_builtins.str] = None,
                 hostname_override: Optional[_builtins.str] = None,
                 internal_address: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 node_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None,
                 ssh_key: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Address ip for node (string)
        :param Sequence[_builtins.str] roles: Roles for the node. `controlplane`, `etcd` and `worker` are supported. (list)
        :param _builtins.str user: Registry user (string)
        :param _builtins.str docker_socket: Docker socket for node (string)
        :param _builtins.str hostname_override: Hostname override for node (string)
        :param _builtins.str internal_address: Internal ip for node (string)
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster (map)
        :param _builtins.str node_id: Id for the node (string)
        :param _builtins.str port: Port for node. Default `22` (string)
        :param _builtins.bool ssh_agent_auth: Use ssh agent auth. Default `false` (bool)
        :param _builtins.str ssh_key: Node SSH private key (string)
        :param _builtins.str ssh_key_path: Node SSH private key path (string)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "user", user)
        if docker_socket is not None:
            pulumi.set(__self__, "docker_socket", docker_socket)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if internal_address is not None:
            pulumi.set(__self__, "internal_address", internal_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Address ip for node (string)
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        """
        Roles for the node. `controlplane`, `etcd` and `worker` are supported. (list)
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> Optional[_builtins.str]:
        """
        Docker socket for node (string)
        """
        return pulumi.get(self, "docker_socket")

    @_builtins.property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[_builtins.str]:
        """
        Hostname override for node (string)
        """
        return pulumi.get(self, "hostname_override")

    @_builtins.property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[_builtins.str]:
        """
        Internal ip for node (string)
        """
        return pulumi.get(self, "internal_address")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        """
        Id for the node (string)
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        """
        Port for node. Default `22` (string)
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        """
        Use ssh agent auth. Default `false` (bool)
        """
        return pulumi.get(self, "ssh_agent_auth")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[_builtins.str]:
        """
        Node SSH private key (string)
        """
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        """
        Node SSH private key path (string)
        """
        return pulumi.get(self, "ssh_key_path")


@pulumi.output_type
class ClusterRkeConfigPrivateRegistry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ecrCredentialPlugin":
            suggest = "ecr_credential_plugin"
        elif key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigPrivateRegistry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigPrivateRegistry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigPrivateRegistry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 ecr_credential_plugin: Optional['outputs.ClusterRkeConfigPrivateRegistryEcrCredentialPlugin'] = None,
                 is_default: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Registry URL (string)
        :param 'ClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs' ecr_credential_plugin: ECR credential plugin config
        :param _builtins.bool is_default: Set as default registry. Default `false` (bool)
        :param _builtins.str password: Registry password (string)
        :param _builtins.str user: Registry user (string)
        """
        pulumi.set(__self__, "url", url)
        if ecr_credential_plugin is not None:
            pulumi.set(__self__, "ecr_credential_plugin", ecr_credential_plugin)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Registry URL (string)
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="ecrCredentialPlugin")
    def ecr_credential_plugin(self) -> Optional['outputs.ClusterRkeConfigPrivateRegistryEcrCredentialPlugin']:
        """
        ECR credential plugin config
        """
        return pulumi.get(self, "ecr_credential_plugin")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Set as default registry. Default `false` (bool)
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Registry password (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Registry user (string)
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class ClusterRkeConfigPrivateRegistryEcrCredentialPlugin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "awsSessionToken":
            suggest = "aws_session_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigPrivateRegistryEcrCredentialPlugin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigPrivateRegistryEcrCredentialPlugin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigPrivateRegistryEcrCredentialPlugin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: Optional[_builtins.str] = None,
                 aws_secret_access_key: Optional[_builtins.str] = None,
                 aws_session_token: Optional[_builtins.str] = None):
        """
        :param _builtins.str aws_access_key_id: AWS access key ID (string)
        :param _builtins.str aws_secret_access_key: AWS secret access key (string)
        :param _builtins.str aws_session_token: AWS session token (string)
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[_builtins.str]:
        """
        AWS access key ID (string)
        """
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[_builtins.str]:
        """
        AWS secret access key (string)
        """
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[_builtins.str]:
        """
        AWS session token (string)
        """
        return pulumi.get(self, "aws_session_token")


@pulumi.output_type
class ClusterRkeConfigServices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeApi":
            suggest = "kube_api"
        elif key == "kubeController":
            suggest = "kube_controller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etcd: Optional['outputs.ClusterRkeConfigServicesEtcd'] = None,
                 kube_api: Optional['outputs.ClusterRkeConfigServicesKubeApi'] = None,
                 kube_controller: Optional['outputs.ClusterRkeConfigServicesKubeController'] = None,
                 kubelet: Optional['outputs.ClusterRkeConfigServicesKubelet'] = None,
                 kubeproxy: Optional['outputs.ClusterRkeConfigServicesKubeproxy'] = None,
                 scheduler: Optional['outputs.ClusterRkeConfigServicesScheduler'] = None):
        """
        :param 'ClusterRkeConfigServicesEtcdArgs' etcd: Etcd options for RKE services (list maxitems:1)
        :param 'ClusterRkeConfigServicesKubeApiArgs' kube_api: Kube API options for RKE services (list maxitems:1)
        :param 'ClusterRkeConfigServicesKubeControllerArgs' kube_controller: Kube Controller options for RKE services (list maxitems:1)
        :param 'ClusterRkeConfigServicesKubeletArgs' kubelet: Kubelet options for RKE services (list maxitems:1)
        :param 'ClusterRkeConfigServicesKubeproxyArgs' kubeproxy: Kubeproxy options for RKE services (list maxitems:1)
        :param 'ClusterRkeConfigServicesSchedulerArgs' scheduler: Scheduler options for RKE services (list maxitems:1)
        """
        if etcd is not None:
            pulumi.set(__self__, "etcd", etcd)
        if kube_api is not None:
            pulumi.set(__self__, "kube_api", kube_api)
        if kube_controller is not None:
            pulumi.set(__self__, "kube_controller", kube_controller)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if kubeproxy is not None:
            pulumi.set(__self__, "kubeproxy", kubeproxy)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> Optional['outputs.ClusterRkeConfigServicesEtcd']:
        """
        Etcd options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "etcd")

    @_builtins.property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> Optional['outputs.ClusterRkeConfigServicesKubeApi']:
        """
        Kube API options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kube_api")

    @_builtins.property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> Optional['outputs.ClusterRkeConfigServicesKubeController']:
        """
        Kube Controller options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kube_controller")

    @_builtins.property
    @pulumi.getter
    def kubelet(self) -> Optional['outputs.ClusterRkeConfigServicesKubelet']:
        """
        Kubelet options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kubelet")

    @_builtins.property
    @pulumi.getter
    def kubeproxy(self) -> Optional['outputs.ClusterRkeConfigServicesKubeproxy']:
        """
        Kubeproxy options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "kubeproxy")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional['outputs.ClusterRkeConfigServicesScheduler']:
        """
        Scheduler options for RKE services (list maxitems:1)
        """
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class ClusterRkeConfigServicesEtcd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupConfig":
            suggest = "backup_config"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "externalUrls":
            suggest = "external_urls"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesEtcd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesEtcd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesEtcd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_config: Optional['outputs.ClusterRkeConfigServicesEtcdBackupConfig'] = None,
                 ca_cert: Optional[_builtins.str] = None,
                 cert: Optional[_builtins.str] = None,
                 creation: Optional[_builtins.str] = None,
                 external_urls: Optional[Sequence[_builtins.str]] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 gid: Optional[_builtins.int] = None,
                 image: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 retention: Optional[_builtins.str] = None,
                 snapshot: Optional[_builtins.bool] = None,
                 uid: Optional[_builtins.int] = None):
        """
        :param 'ClusterRkeConfigServicesEtcdBackupConfigArgs' backup_config: Backup options for etcd service. For Rancher v2.2.x (list maxitems:1)
        :param _builtins.str ca_cert: (Computed/Sensitive) K8s cluster ca cert (string)
        :param _builtins.str cert: TLS certificate for etcd service (string)
        :param _builtins.str creation: Creation option for etcd service (string)
        :param Sequence[_builtins.str] external_urls: External urls for etcd service (list)
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[_builtins.str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[_builtins.str] extra_envs: Extra environment for scheduler service (list)
        :param _builtins.int gid: Etcd service GID. Default: `0`. For Rancher v2.3.x and above (int)
        :param _builtins.str image: Docker image for scheduler service (string)
        :param _builtins.str key: The GKE taint key (string)
        :param _builtins.str path: (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param _builtins.str retention: Retention for etcd backup. Default `6` (int)
        :param _builtins.bool snapshot: Snapshot option for etcd service (bool)
        :param _builtins.int uid: Etcd service UID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        if backup_config is not None:
            pulumi.set(__self__, "backup_config", backup_config)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if creation is not None:
            pulumi.set(__self__, "creation", creation)
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> Optional['outputs.ClusterRkeConfigServicesEtcdBackupConfig']:
        """
        Backup options for etcd service. For Rancher v2.2.x (list maxitems:1)
        """
        return pulumi.get(self, "backup_config")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[_builtins.str]:
        """
        (Computed/Sensitive) K8s cluster ca cert (string)
        """
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[_builtins.str]:
        """
        TLS certificate for etcd service (string)
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def creation(self) -> Optional[_builtins.str]:
        """
        Creation option for etcd service (string)
        """
        return pulumi.get(self, "creation")

    @_builtins.property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        External urls for etcd service (list)
        """
        return pulumi.get(self, "external_urls")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[_builtins.int]:
        """
        Etcd service GID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        return pulumi.get(self, "gid")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The GKE taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.str]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.bool]:
        """
        Snapshot option for etcd service (bool)
        """
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.int]:
        """
        Etcd service UID. Default: `0`. For Rancher v2.3.x and above (int)
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterRkeConfigServicesEtcdBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalHours":
            suggest = "interval_hours"
        elif key == "s3BackupConfig":
            suggest = "s3_backup_config"
        elif key == "safeTimestamp":
            suggest = "safe_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesEtcdBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesEtcdBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesEtcdBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None,
                 retention: Optional[_builtins.int] = None,
                 s3_backup_config: Optional['outputs.ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig'] = None,
                 safe_timestamp: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        :param _builtins.int interval_hours: Interval hours for etcd backup. Default `12` (int)
        :param _builtins.int retention: Retention for etcd backup. Default `6` (int)
        :param 'ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigArgs' s3_backup_config: S3 config options for etcd backup (list maxitems:1)
        :param _builtins.bool safe_timestamp: Safe timestamp for etcd backup. Default: `false` (bool)
        :param _builtins.int timeout: RKE node drain timeout. Default: `60` (int)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        return pulumi.get(self, "interval_hours")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.int]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig']:
        """
        S3 config options for etcd backup (list maxitems:1)
        """
        return pulumi.get(self, "s3_backup_config")

    @_builtins.property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[_builtins.bool]:
        """
        Safe timestamp for etcd backup. Default: `false` (bool)
        """
        return pulumi.get(self, "safe_timestamp")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        RKE node drain timeout. Default: `60` (int)
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "customCa":
            suggest = "custom_ca"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 endpoint: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 custom_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: Bucket name for S3 service (string)
        :param _builtins.str endpoint: Endpoint for S3 service (string)
        :param _builtins.str access_key: Access key for S3 service (string)
        :param _builtins.str custom_ca: Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        :param _builtins.str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param _builtins.str region: The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        :param _builtins.str secret_key: Secret key for S3 service (string)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Bucket name for S3 service (string)
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Endpoint for S3 service (string)
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access key for S3 service (string)
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[_builtins.str]:
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        return pulumi.get(self, "custom_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The availability domain within the region to host the cluster. See [here](https://docs.cloud.oracle.com/en-us/iaas/Content/General/Concepts/regions.htm) for a list of region names. (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Secret key for S3 service (string)
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "admissionConfiguration":
            suggest = "admission_configuration"
        elif key == "alwaysPullImages":
            suggest = "always_pull_images"
        elif key == "auditLog":
            suggest = "audit_log"
        elif key == "eventRateLimit":
            suggest = "event_rate_limit"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "secretsEncryptionConfig":
            suggest = "secrets_encryption_config"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"
        elif key == "serviceNodePortRange":
            suggest = "service_node_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubeApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubeApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubeApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admission_configuration: Optional['outputs.ClusterRkeConfigServicesKubeApiAdmissionConfiguration'] = None,
                 always_pull_images: Optional[_builtins.bool] = None,
                 audit_log: Optional['outputs.ClusterRkeConfigServicesKubeApiAuditLog'] = None,
                 event_rate_limit: Optional['outputs.ClusterRkeConfigServicesKubeApiEventRateLimit'] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None,
                 secrets_encryption_config: Optional['outputs.ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig'] = None,
                 service_cluster_ip_range: Optional[_builtins.str] = None,
                 service_node_port_range: Optional[_builtins.str] = None):
        """
        :param 'ClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs' admission_configuration: Cluster admission configuration
        :param _builtins.bool always_pull_images: Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) Default: `false` (bool)
        :param 'ClusterRkeConfigServicesKubeApiAuditLogArgs' audit_log: K8s audit log configuration. (list maxitems: 1)
        :param 'ClusterRkeConfigServicesKubeApiEventRateLimitArgs' event_rate_limit: K8s event rate limit configuration. (list maxitems: 1)
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[_builtins.str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[_builtins.str] extra_envs: Extra environment for scheduler service (list)
        :param _builtins.str image: Docker image for scheduler service (string)
        :param 'ClusterRkeConfigServicesKubeApiSecretsEncryptionConfigArgs' secrets_encryption_config: [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        :param _builtins.str service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        :param _builtins.str service_node_port_range: Service Node Port Range option for kube API service (string)
        """
        if admission_configuration is not None:
            pulumi.set(__self__, "admission_configuration", admission_configuration)
        if always_pull_images is not None:
            pulumi.set(__self__, "always_pull_images", always_pull_images)
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if event_rate_limit is not None:
            pulumi.set(__self__, "event_rate_limit", event_rate_limit)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if secrets_encryption_config is not None:
            pulumi.set(__self__, "secrets_encryption_config", secrets_encryption_config)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            pulumi.set(__self__, "service_node_port_range", service_node_port_range)

    @_builtins.property
    @pulumi.getter(name="admissionConfiguration")
    def admission_configuration(self) -> Optional['outputs.ClusterRkeConfigServicesKubeApiAdmissionConfiguration']:
        """
        Cluster admission configuration
        """
        return pulumi.get(self, "admission_configuration")

    @_builtins.property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[_builtins.bool]:
        """
        Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) Default: `false` (bool)
        """
        return pulumi.get(self, "always_pull_images")

    @_builtins.property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.ClusterRkeConfigServicesKubeApiAuditLog']:
        """
        K8s audit log configuration. (list maxitems: 1)
        """
        return pulumi.get(self, "audit_log")

    @_builtins.property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional['outputs.ClusterRkeConfigServicesKubeApiEventRateLimit']:
        """
        K8s event rate limit configuration. (list maxitems: 1)
        """
        return pulumi.get(self, "event_rate_limit")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional['outputs.ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig']:
        """
        [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
        """
        return pulumi.get(self, "secrets_encryption_config")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[_builtins.str]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")

    @_builtins.property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[_builtins.str]:
        """
        Service Node Port Range option for kube API service (string)
        """
        return pulumi.get(self, "service_node_port_range")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApiAdmissionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubeApiAdmissionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubeApiAdmissionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubeApiAdmissionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 plugins: Optional[Sequence['outputs.ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugin']] = None):
        """
        :param _builtins.str api_version: Admission configuration ApiVersion
        :param _builtins.str kind: Admission configuration Kind
        :param Sequence['ClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs'] plugins: Admission configuration plugins
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        Admission configuration ApiVersion
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Admission configuration Kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugin']]:
        """
        Admission configuration plugins
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApiAdmissionConfigurationPlugin(dict):
    def __init__(__self__, *,
                 configuration: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str configuration: Plugin configuration
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str path: Plugin path
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[_builtins.str]:
        """
        Plugin configuration
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Plugin path
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApiAuditLog(dict):
    def __init__(__self__, *,
                 configuration: Optional['outputs.ClusterRkeConfigServicesKubeApiAuditLogConfiguration'] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param 'ClusterRkeConfigServicesKubeApiAuditLogConfigurationArgs' configuration: Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:
               
               ```
               configuration = <<EOF
               apiVersion: eventratelimit.admission.k8s.io/v1alpha1
               kind: Configuration
               limits:
               - type: Server
               burst: 35000
               qps: 6000
               EOF
               ```
        :param _builtins.bool enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ClusterRkeConfigServicesKubeApiAuditLogConfiguration']:
        """
        Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:

        ```
        configuration = <<EOF
        apiVersion: eventratelimit.admission.k8s.io/v1alpha1
        kind: Configuration
        limits:
        - type: Server
        burst: 35000
        qps: 6000
        EOF
        ```
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApiAuditLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "maxBackup":
            suggest = "max_backup"
        elif key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubeApiAuditLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubeApiAuditLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubeApiAuditLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: Optional[_builtins.str] = None,
                 max_age: Optional[_builtins.int] = None,
                 max_backup: Optional[_builtins.int] = None,
                 max_size: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None):
        """
        :param _builtins.str format: Audit log format. Default: 'json' (string)
        :param _builtins.int max_age: Audit log max age. Default: `30` (int)
        :param _builtins.int max_backup: Audit log max backup. Default: `10` (int)
        :param _builtins.int max_size: The EKS node group maximum size. Default `2` (int)
        :param _builtins.str path: (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        :param _builtins.str policy: Audit policy yaml encoded definition. `apiVersion` and `kind: Policy\\nrules:"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string) Ex:
               
               ```
               policy = <<EOF
               apiVersion: audit.k8s.io/v1
               kind: Policy
               rules:
               - level: RequestResponse
               resources:
               - resources:
               - pods
               EOF
               ```
        """
        if format is not None:
            pulumi.set(__self__, "format", format)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_backup is not None:
            pulumi.set(__self__, "max_backup", max_backup)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Audit log format. Default: 'json' (string)
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        """
        Audit log max age. Default: `30` (int)
        """
        return pulumi.get(self, "max_age")

    @_builtins.property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[_builtins.int]:
        """
        Audit log max backup. Default: `10` (int)
        """
        return pulumi.get(self, "max_backup")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group maximum size. Default `2` (int)
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        (Optional) Audit log path. Default: `/var/log/kube-audit/audit-log.json` (string)
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        Audit policy yaml encoded definition. `apiVersion` and `kind: Policy\\nrules:"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string) Ex:

        ```
        policy = <<EOF
        apiVersion: audit.k8s.io/v1
        kind: Policy
        rules:
        - level: RequestResponse
        resources:
        - resources:
        - pods
        EOF
        ```
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApiEventRateLimit(dict):
    def __init__(__self__, *,
                 configuration: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str configuration: Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:
               
               ```
               configuration = <<EOF
               apiVersion: eventratelimit.admission.k8s.io/v1alpha1
               kind: Configuration
               limits:
               - type: Server
               burst: 35000
               qps: 6000
               EOF
               ```
        :param _builtins.bool enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[_builtins.str]:
        """
        Event rate limit configuration yaml encoded definition. `apiVersion` and `kind: Configuration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/rate-limiting/) (string) Ex:

        ```
        configuration = <<EOF
        apiVersion: eventratelimit.admission.k8s.io/v1alpha1
        kind: Configuration
        limits:
        - type: Server
        burst: 35000
        qps: 6000
        EOF
        ```
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConfig":
            suggest = "custom_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_config: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str custom_config: Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string) Ex:
               
               ```
               custom_config = <<EOF
               apiVersion: apiserver.config.k8s.io/v1
               kind: EncryptionConfiguration
               resources:
               - resources:
               - secrets
               providers:
               - aescbc:
               keys:
               - name: k-fw5hn
               secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=
               identity: {}
               EOF
               
               ```
        :param _builtins.bool enabled: Enable the authorized cluster endpoint. Default `true` (bool)
        """
        if custom_config is not None:
            pulumi.set(__self__, "custom_config", custom_config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> Optional[_builtins.str]:
        """
        Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string) Ex:

        ```
        custom_config = <<EOF
        apiVersion: apiserver.config.k8s.io/v1
        kind: EncryptionConfiguration
        resources:
        - resources:
        - secrets
        providers:
        - aescbc:
        keys:
        - name: k-fw5hn
        secret: RTczRjFDODMwQzAyMDVBREU4NDJBMUZFNDhCNzM5N0I=
        identity: {}
        EOF

        ```
        """
        return pulumi.get(self, "custom_config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable the authorized cluster endpoint. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterRkeConfigServicesKubeController(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubeController. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubeController.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubeController.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_cidr: Optional[_builtins.str] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None,
                 service_cluster_ip_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_cidr: Cluster CIDR option for kube controller service (string)
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[_builtins.str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[_builtins.str] extra_envs: Extra environment for scheduler service (list)
        :param _builtins.str image: Docker image for scheduler service (string)
        :param _builtins.str service_cluster_ip_range: Service Cluster ip Range option for kube controller service (string)
        """
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)

    @_builtins.property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[_builtins.str]:
        """
        Cluster CIDR option for kube controller service (string)
        """
        return pulumi.get(self, "cluster_cidr")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[_builtins.str]:
        """
        Service Cluster ip Range option for kube controller service (string)
        """
        return pulumi.get(self, "service_cluster_ip_range")


@pulumi.output_type
class ClusterRkeConfigServicesKubelet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterDnsServer":
            suggest = "cluster_dns_server"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "generateServingCertificate":
            suggest = "generate_serving_certificate"
        elif key == "infraContainerImage":
            suggest = "infra_container_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubelet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubelet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubelet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_dns_server: Optional[_builtins.str] = None,
                 cluster_domain: Optional[_builtins.str] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 fail_swap_on: Optional[_builtins.bool] = None,
                 generate_serving_certificate: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 infra_container_image: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_dns_server: Cluster DNS Server option for kubelet service (string)
        :param _builtins.str cluster_domain: Cluster Domain option for kubelet service (string)
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[_builtins.str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[_builtins.str] extra_envs: Extra environment for scheduler service (list)
        :param _builtins.bool fail_swap_on: Enable or disable failing when swap on is not supported (bool)
        :param _builtins.bool generate_serving_certificate: [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        :param _builtins.str image: Docker image for scheduler service (string)
        :param _builtins.str infra_container_image: Infra container image for kubelet service (string)
        """
        if cluster_dns_server is not None:
            pulumi.set(__self__, "cluster_dns_server", cluster_dns_server)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if generate_serving_certificate is not None:
            pulumi.set(__self__, "generate_serving_certificate", generate_serving_certificate)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra_container_image is not None:
            pulumi.set(__self__, "infra_container_image", infra_container_image)

    @_builtins.property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> Optional[_builtins.str]:
        """
        Cluster DNS Server option for kubelet service (string)
        """
        return pulumi.get(self, "cluster_dns_server")

    @_builtins.property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[_builtins.str]:
        """
        Cluster Domain option for kubelet service (string)
        """
        return pulumi.get(self, "cluster_domain")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[_builtins.bool]:
        """
        Enable or disable failing when swap on is not supported (bool)
        """
        return pulumi.get(self, "fail_swap_on")

    @_builtins.property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[_builtins.bool]:
        """
        [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
        """
        return pulumi.get(self, "generate_serving_certificate")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> Optional[_builtins.str]:
        """
        Infra container image for kubelet service (string)
        """
        return pulumi.get(self, "infra_container_image")


@pulumi.output_type
class ClusterRkeConfigServicesKubeproxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesKubeproxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesKubeproxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesKubeproxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[_builtins.str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[_builtins.str] extra_envs: Extra environment for scheduler service (list)
        :param _builtins.str image: Docker image for scheduler service (string)
        """
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterRkeConfigServicesScheduler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigServicesScheduler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigServicesScheduler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigServicesScheduler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] extra_args: Extra arguments for scheduler service (map)
        :param Sequence[_builtins.str] extra_binds: Extra binds for scheduler service (list)
        :param Sequence[_builtins.str] extra_envs: Extra environment for scheduler service (list)
        :param _builtins.str image: Docker image for scheduler service (string)
        """
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Extra arguments for scheduler service (map)
        """
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra binds for scheduler service (list)
        """
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra environment for scheduler service (list)
        """
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Docker image for scheduler service (string)
        """
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterRkeConfigUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainInput":
            suggest = "drain_input"
        elif key == "maxUnavailableControlplane":
            suggest = "max_unavailable_controlplane"
        elif key == "maxUnavailableWorker":
            suggest = "max_unavailable_worker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain: Optional[_builtins.bool] = None,
                 drain_input: Optional['outputs.ClusterRkeConfigUpgradeStrategyDrainInput'] = None,
                 max_unavailable_controlplane: Optional[_builtins.str] = None,
                 max_unavailable_worker: Optional[_builtins.str] = None):
        """
        :param _builtins.bool drain: RKE drain nodes. Default: `false` (bool)
        :param 'ClusterRkeConfigUpgradeStrategyDrainInputArgs' drain_input: RKE drain node input (list Maxitems: 1)
        :param _builtins.str max_unavailable_controlplane: RKE max unavailable controlplane nodes. Default: `1` (string)
        :param _builtins.str max_unavailable_worker: RKE max unavailable worker nodes. Default: `10%` (string)
        """
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if drain_input is not None:
            pulumi.set(__self__, "drain_input", drain_input)
        if max_unavailable_controlplane is not None:
            pulumi.set(__self__, "max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            pulumi.set(__self__, "max_unavailable_worker", max_unavailable_worker)

    @_builtins.property
    @pulumi.getter
    def drain(self) -> Optional[_builtins.bool]:
        """
        RKE drain nodes. Default: `false` (bool)
        """
        return pulumi.get(self, "drain")

    @_builtins.property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> Optional['outputs.ClusterRkeConfigUpgradeStrategyDrainInput']:
        """
        RKE drain node input (list Maxitems: 1)
        """
        return pulumi.get(self, "drain_input")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[_builtins.str]:
        """
        RKE max unavailable controlplane nodes. Default: `1` (string)
        """
        return pulumi.get(self, "max_unavailable_controlplane")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[_builtins.str]:
        """
        RKE max unavailable worker nodes. Default: `10%` (string)
        """
        return pulumi.get(self, "max_unavailable_worker")


@pulumi.output_type
class ClusterRkeConfigUpgradeStrategyDrainInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteLocalData":
            suggest = "delete_local_data"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "ignoreDaemonSets":
            suggest = "ignore_daemon_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterRkeConfigUpgradeStrategyDrainInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterRkeConfigUpgradeStrategyDrainInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterRkeConfigUpgradeStrategyDrainInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_local_data: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool delete_local_data: Delete RKE node local data. Default: `false` (bool)
        :param _builtins.bool force: Force RKE node drain. Default: `false` (bool)
        :param _builtins.int grace_period: RKE node drain grace period. Default: `-1` (int)
        :param _builtins.bool ignore_daemon_sets: Ignore RKE daemon sets. Default: `true` (bool)
        :param _builtins.int timeout: RKE node drain timeout. Default: `60` (int)
        """
        if delete_local_data is not None:
            pulumi.set(__self__, "delete_local_data", delete_local_data)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[_builtins.bool]:
        """
        Delete RKE node local data. Default: `false` (bool)
        """
        return pulumi.get(self, "delete_local_data")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        Force RKE node drain. Default: `false` (bool)
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        """
        RKE node drain grace period. Default: `-1` (int)
        """
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        """
        Ignore RKE daemon sets. Default: `true` (bool)
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        RKE node drain timeout. Default: `60` (int)
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterSyncNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "externalIpAddress":
            suggest = "external_ip_address"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "nodePoolId":
            suggest = "node_pool_id"
        elif key == "nodeTemplateId":
            suggest = "node_template_id"
        elif key == "providerId":
            suggest = "provider_id"
        elif key == "requestedHostname":
            suggest = "requested_hostname"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "systemInfo":
            suggest = "system_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSyncNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSyncNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSyncNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 capacity: Optional[Mapping[str, _builtins.str]] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 external_ip_address: Optional[_builtins.str] = None,
                 hostname: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 ip_address: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 node_pool_id: Optional[_builtins.str] = None,
                 node_template_id: Optional[_builtins.str] = None,
                 provider_id: Optional[_builtins.str] = None,
                 requested_hostname: Optional[_builtins.str] = None,
                 roles: Optional[Sequence[_builtins.str]] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 system_info: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] annotations: Annotations of the resource
        :param Mapping[str, _builtins.str] capacity: The total resources of a node (map).
        :param _builtins.str cluster_id: The cluster ID that is syncing (string)
        :param _builtins.str external_ip_address: The external IP address of the node (string).
        :param _builtins.str hostname: The hostname of the node (string).
        :param _builtins.str id: (Computed) The ID of the resource. Same as `cluster_id` (string)
        :param _builtins.str ip_address: The private IP address of the node (string).
        :param Mapping[str, _builtins.str] labels: Labels of the resource
        :param _builtins.str name: The name of the node (string).
        :param _builtins.str node_pool_id: The Node Pool ID of the node (string).
        :param _builtins.str node_template_id: The Node Template ID of the node (string).
        :param _builtins.str provider_id: The Provider ID of the node (string).
        :param _builtins.str requested_hostname: The requested hostname (string).
        :param Sequence[_builtins.str] roles: Roles of the node. `controlplane`, `etcd` and `worker`. (list)
        :param _builtins.str ssh_user: The user to connect to the node (string).
        :param Mapping[str, _builtins.str] system_info: General information about the node, such as kernel version, kubelet and kube-proxy version, Docker version (if used), and OS name.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if external_ip_address is not None:
            pulumi.set(__self__, "external_ip_address", external_ip_address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_pool_id is not None:
            pulumi.set(__self__, "node_pool_id", node_pool_id)
        if node_template_id is not None:
            pulumi.set(__self__, "node_template_id", node_template_id)
        if provider_id is not None:
            pulumi.set(__self__, "provider_id", provider_id)
        if requested_hostname is not None:
            pulumi.set(__self__, "requested_hostname", requested_hostname)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if system_info is not None:
            pulumi.set(__self__, "system_info", system_info)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations of the resource
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The total resources of a node (map).
        """
        return pulumi.get(self, "capacity")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        The cluster ID that is syncing (string)
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="externalIpAddress")
    def external_ip_address(self) -> Optional[_builtins.str]:
        """
        The external IP address of the node (string).
        """
        return pulumi.get(self, "external_ip_address")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> Optional[_builtins.str]:
        """
        The hostname of the node (string).
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Computed) The ID of the resource. Same as `cluster_id` (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        The private IP address of the node (string).
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels of the resource
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the node (string).
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodePoolId")
    def node_pool_id(self) -> Optional[_builtins.str]:
        """
        The Node Pool ID of the node (string).
        """
        return pulumi.get(self, "node_pool_id")

    @_builtins.property
    @pulumi.getter(name="nodeTemplateId")
    def node_template_id(self) -> Optional[_builtins.str]:
        """
        The Node Template ID of the node (string).
        """
        return pulumi.get(self, "node_template_id")

    @_builtins.property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> Optional[_builtins.str]:
        """
        The Provider ID of the node (string).
        """
        return pulumi.get(self, "provider_id")

    @_builtins.property
    @pulumi.getter(name="requestedHostname")
    def requested_hostname(self) -> Optional[_builtins.str]:
        """
        The requested hostname (string).
        """
        return pulumi.get(self, "requested_hostname")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[_builtins.str]]:
        """
        Roles of the node. `controlplane`, `etcd` and `worker`. (list)
        """
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        The user to connect to the node (string).
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="systemInfo")
    def system_info(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        General information about the node, such as kernel version, kubelet and kube-proxy version, Docker version (if used), and OS name.
        """
        return pulumi.get(self, "system_info")


@pulumi.output_type
class ClusterTemplateMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessType":
            suggest = "access_type"
        elif key == "groupPrincipalId":
            suggest = "group_principal_id"
        elif key == "userPrincipalId":
            suggest = "user_principal_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_type: Optional[_builtins.str] = None,
                 group_principal_id: Optional[_builtins.str] = None,
                 user_principal_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_type: Member access type: member, owner, read-only
        :param _builtins.str group_principal_id: Member group principal id
        :param _builtins.str user_principal_id: Member user principal id
        """
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if group_principal_id is not None:
            pulumi.set(__self__, "group_principal_id", group_principal_id)
        if user_principal_id is not None:
            pulumi.set(__self__, "user_principal_id", user_principal_id)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[_builtins.str]:
        """
        Member access type: member, owner, read-only
        """
        return pulumi.get(self, "access_type")

    @_builtins.property
    @pulumi.getter(name="groupPrincipalId")
    def group_principal_id(self) -> Optional[_builtins.str]:
        """
        Member group principal id
        """
        return pulumi.get(self, "group_principal_id")

    @_builtins.property
    @pulumi.getter(name="userPrincipalId")
    def user_principal_id(self) -> Optional[_builtins.str]:
        """
        Member user principal id
        """
        return pulumi.get(self, "user_principal_id")


@pulumi.output_type
class ClusterTemplateTemplateRevision(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterConfig":
            suggest = "cluster_config"
        elif key == "clusterTemplateId":
            suggest = "cluster_template_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevision. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevision.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevision.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_config: 'outputs.ClusterTemplateTemplateRevisionClusterConfig',
                 name: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 cluster_template_id: Optional[_builtins.str] = None,
                 default: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 questions: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionQuestion']] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigArgs' cluster_config: Cluster configuration
        :param _builtins.str name: The cluster template name (string)
        :param Mapping[str, _builtins.str] annotations: Annotations for the cluster template (map)
        :param _builtins.str cluster_template_id: Cluster template ID
        :param _builtins.bool default: Default cluster template revision
        :param _builtins.bool enabled: Enable cluster template revision
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param Mapping[str, _builtins.str] labels: Labels for the cluster template (map)
        :param Sequence['ClusterTemplateTemplateRevisionQuestionArgs'] questions: Cluster template questions
        """
        pulumi.set(__self__, "cluster_config", cluster_config)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_template_id is not None:
            pulumi.set(__self__, "cluster_template_id", cluster_template_id)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if questions is not None:
            pulumi.set(__self__, "questions", questions)

    @_builtins.property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> 'outputs.ClusterTemplateTemplateRevisionClusterConfig':
        """
        Cluster configuration
        """
        return pulumi.get(self, "cluster_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations for the cluster template (map)
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterTemplateId")
    def cluster_template_id(self) -> Optional[_builtins.str]:
        """
        Cluster template ID
        """
        return pulumi.get(self, "cluster_template_id")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.bool]:
        """
        Default cluster template revision
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the cluster template (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def questions(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionQuestion']]:
        """
        Cluster template questions
        """
        return pulumi.get(self, "questions")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rkeConfig":
            suggest = "rke_config"
        elif key == "clusterAuthEndpoint":
            suggest = "cluster_auth_endpoint"
        elif key == "defaultClusterRoleForProjectMembers":
            suggest = "default_cluster_role_for_project_members"
        elif key == "defaultPodSecurityAdmissionConfigurationTemplateName":
            suggest = "default_pod_security_admission_configuration_template_name"
        elif key == "desiredAgentImage":
            suggest = "desired_agent_image"
        elif key == "desiredAuthImage":
            suggest = "desired_auth_image"
        elif key == "dockerRootDir":
            suggest = "docker_root_dir"
        elif key == "enableNetworkPolicy":
            suggest = "enable_network_policy"
        elif key == "windowsPreferedCluster":
            suggest = "windows_prefered_cluster"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rke_config: 'outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfig',
                 cluster_auth_endpoint: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint'] = None,
                 default_cluster_role_for_project_members: Optional[_builtins.str] = None,
                 default_pod_security_admission_configuration_template_name: Optional[_builtins.str] = None,
                 desired_agent_image: Optional[_builtins.str] = None,
                 desired_auth_image: Optional[_builtins.str] = None,
                 docker_root_dir: Optional[_builtins.str] = None,
                 enable_network_policy: Optional[_builtins.bool] = None,
                 windows_prefered_cluster: Optional[_builtins.bool] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs' rke_config: Rancher Kubernetes Engine Config
        :param 'ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs' cluster_auth_endpoint: Local cluster auth endpoint
        :param _builtins.str default_cluster_role_for_project_members: Default cluster role for project members
        :param _builtins.str default_pod_security_admission_configuration_template_name: Default pod security admission configuration template name
        :param _builtins.str desired_agent_image: Desired agent image
        :param _builtins.str desired_auth_image: Desired auth image
        :param _builtins.str docker_root_dir: Docker Root Dir
        :param _builtins.bool enable_network_policy: Enable project network isolation
        :param _builtins.bool windows_prefered_cluster: Windows prefered cluster
        """
        pulumi.set(__self__, "rke_config", rke_config)
        if cluster_auth_endpoint is not None:
            pulumi.set(__self__, "cluster_auth_endpoint", cluster_auth_endpoint)
        if default_cluster_role_for_project_members is not None:
            pulumi.set(__self__, "default_cluster_role_for_project_members", default_cluster_role_for_project_members)
        if default_pod_security_admission_configuration_template_name is not None:
            pulumi.set(__self__, "default_pod_security_admission_configuration_template_name", default_pod_security_admission_configuration_template_name)
        if desired_agent_image is not None:
            pulumi.set(__self__, "desired_agent_image", desired_agent_image)
        if desired_auth_image is not None:
            pulumi.set(__self__, "desired_auth_image", desired_auth_image)
        if docker_root_dir is not None:
            pulumi.set(__self__, "docker_root_dir", docker_root_dir)
        if enable_network_policy is not None:
            pulumi.set(__self__, "enable_network_policy", enable_network_policy)
        if windows_prefered_cluster is not None:
            pulumi.set(__self__, "windows_prefered_cluster", windows_prefered_cluster)

    @_builtins.property
    @pulumi.getter(name="rkeConfig")
    def rke_config(self) -> 'outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfig':
        """
        Rancher Kubernetes Engine Config
        """
        return pulumi.get(self, "rke_config")

    @_builtins.property
    @pulumi.getter(name="clusterAuthEndpoint")
    def cluster_auth_endpoint(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint']:
        """
        Local cluster auth endpoint
        """
        return pulumi.get(self, "cluster_auth_endpoint")

    @_builtins.property
    @pulumi.getter(name="defaultClusterRoleForProjectMembers")
    def default_cluster_role_for_project_members(self) -> Optional[_builtins.str]:
        """
        Default cluster role for project members
        """
        return pulumi.get(self, "default_cluster_role_for_project_members")

    @_builtins.property
    @pulumi.getter(name="defaultPodSecurityAdmissionConfigurationTemplateName")
    def default_pod_security_admission_configuration_template_name(self) -> Optional[_builtins.str]:
        """
        Default pod security admission configuration template name
        """
        return pulumi.get(self, "default_pod_security_admission_configuration_template_name")

    @_builtins.property
    @pulumi.getter(name="desiredAgentImage")
    def desired_agent_image(self) -> Optional[_builtins.str]:
        """
        Desired agent image
        """
        return pulumi.get(self, "desired_agent_image")

    @_builtins.property
    @pulumi.getter(name="desiredAuthImage")
    def desired_auth_image(self) -> Optional[_builtins.str]:
        """
        Desired auth image
        """
        return pulumi.get(self, "desired_auth_image")

    @_builtins.property
    @pulumi.getter(name="dockerRootDir")
    def docker_root_dir(self) -> Optional[_builtins.str]:
        """
        Docker Root Dir
        """
        return pulumi.get(self, "docker_root_dir")

    @_builtins.property
    @pulumi.getter(name="enableNetworkPolicy")
    def enable_network_policy(self) -> Optional[_builtins.bool]:
        """
        Enable project network isolation
        """
        return pulumi.get(self, "enable_network_policy")

    @_builtins.property
    @pulumi.getter(name="windowsPreferedCluster")
    def windows_prefered_cluster(self) -> Optional[_builtins.bool]:
        """
        Windows prefered cluster
        """
        return pulumi.get(self, "windows_prefered_cluster")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Enable cluster template revision. Default `true` (bool)
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addonJobTimeout":
            suggest = "addon_job_timeout"
        elif key == "addonsIncludes":
            suggest = "addons_includes"
        elif key == "bastionHost":
            suggest = "bastion_host"
        elif key == "cloudProvider":
            suggest = "cloud_provider"
        elif key == "enableCriDockerd":
            suggest = "enable_cri_dockerd"
        elif key == "ignoreDockerVersion":
            suggest = "ignore_docker_version"
        elif key == "kubernetesVersion":
            suggest = "kubernetes_version"
        elif key == "prefixPath":
            suggest = "prefix_path"
        elif key == "privateRegistries":
            suggest = "private_registries"
        elif key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshCertPath":
            suggest = "ssh_cert_path"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"
        elif key == "upgradeStrategy":
            suggest = "upgrade_strategy"
        elif key == "winPrefixPath":
            suggest = "win_prefix_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addon_job_timeout: Optional[_builtins.int] = None,
                 addons: Optional[_builtins.str] = None,
                 addons_includes: Optional[Sequence[_builtins.str]] = None,
                 authentication: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication'] = None,
                 authorization: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization'] = None,
                 bastion_host: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost'] = None,
                 cloud_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider'] = None,
                 dns: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns'] = None,
                 enable_cri_dockerd: Optional[_builtins.bool] = None,
                 ignore_docker_version: Optional[_builtins.bool] = None,
                 ingress: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress'] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 monitoring: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring'] = None,
                 network: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork'] = None,
                 nodes: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode']] = None,
                 prefix_path: Optional[_builtins.str] = None,
                 private_registries: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry']] = None,
                 services: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices'] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None,
                 ssh_cert_path: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None,
                 upgrade_strategy: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy'] = None,
                 win_prefix_path: Optional[_builtins.str] = None):
        """
        :param _builtins.int addon_job_timeout: Optional duration in seconds of addon job.
        :param _builtins.str addons: Optional addons descripton to deploy on rke cluster.
        :param Sequence[_builtins.str] addons_includes: Optional addons yaml manisfest to deploy on rke cluster.
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs' authentication: Kubernetes cluster authentication
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs' authorization: Kubernetes cluster authorization
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs' bastion_host: RKE bastion host
        :param _builtins.bool enable_cri_dockerd: Enable/disable using cri-dockerd
        :param _builtins.bool ignore_docker_version: Optional ignore docker version on nodes
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs' ingress: Kubernetes ingress configuration
        :param _builtins.str kubernetes_version: Optional kubernetes version to deploy
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs' monitoring: Kubernetes cluster monitoring
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs' network: Kubernetes cluster networking
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs'] nodes: Optional RKE cluster nodes
        :param _builtins.str prefix_path: Optional prefix to customize kubernetes path
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs'] private_registries: Optional private registries for docker images
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs' services: Kubernetes cluster services
        :param _builtins.bool ssh_agent_auth: Optional use ssh agent auth
        :param _builtins.str ssh_cert_path: Optional cluster level SSH certificate path
        :param _builtins.str ssh_key_path: Optional cluster level SSH private key path
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs' upgrade_strategy: RKE upgrade strategy
        :param _builtins.str win_prefix_path: Optional prefix to customize kubernetes path for windows
        """
        if addon_job_timeout is not None:
            pulumi.set(__self__, "addon_job_timeout", addon_job_timeout)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if addons_includes is not None:
            pulumi.set(__self__, "addons_includes", addons_includes)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)
        if bastion_host is not None:
            pulumi.set(__self__, "bastion_host", bastion_host)
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if enable_cri_dockerd is not None:
            pulumi.set(__self__, "enable_cri_dockerd", enable_cri_dockerd)
        if ignore_docker_version is not None:
            pulumi.set(__self__, "ignore_docker_version", ignore_docker_version)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if prefix_path is not None:
            pulumi.set(__self__, "prefix_path", prefix_path)
        if private_registries is not None:
            pulumi.set(__self__, "private_registries", private_registries)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_cert_path is not None:
            pulumi.set(__self__, "ssh_cert_path", ssh_cert_path)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        if win_prefix_path is not None:
            pulumi.set(__self__, "win_prefix_path", win_prefix_path)

    @_builtins.property
    @pulumi.getter(name="addonJobTimeout")
    def addon_job_timeout(self) -> Optional[_builtins.int]:
        """
        Optional duration in seconds of addon job.
        """
        return pulumi.get(self, "addon_job_timeout")

    @_builtins.property
    @pulumi.getter
    def addons(self) -> Optional[_builtins.str]:
        """
        Optional addons descripton to deploy on rke cluster.
        """
        return pulumi.get(self, "addons")

    @_builtins.property
    @pulumi.getter(name="addonsIncludes")
    def addons_includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        return pulumi.get(self, "addons_includes")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication']:
        """
        Kubernetes cluster authentication
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization']:
        """
        Kubernetes cluster authorization
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="bastionHost")
    def bastion_host(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost']:
        """
        RKE bastion host
        """
        return pulumi.get(self, "bastion_host")

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider']:
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns']:
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="enableCriDockerd")
    def enable_cri_dockerd(self) -> Optional[_builtins.bool]:
        """
        Enable/disable using cri-dockerd
        """
        return pulumi.get(self, "enable_cri_dockerd")

    @_builtins.property
    @pulumi.getter(name="ignoreDockerVersion")
    def ignore_docker_version(self) -> Optional[_builtins.bool]:
        """
        Optional ignore docker version on nodes
        """
        return pulumi.get(self, "ignore_docker_version")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress']:
        """
        Kubernetes ingress configuration
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        Optional kubernetes version to deploy
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring']:
        """
        Kubernetes cluster monitoring
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork']:
        """
        Kubernetes cluster networking
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode']]:
        """
        Optional RKE cluster nodes
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> Optional[_builtins.str]:
        """
        Optional prefix to customize kubernetes path
        """
        return pulumi.get(self, "prefix_path")

    @_builtins.property
    @pulumi.getter(name="privateRegistries")
    def private_registries(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry']]:
        """
        Optional private registries for docker images
        """
        return pulumi.get(self, "private_registries")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices']:
        """
        Kubernetes cluster services
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        """
        Optional use ssh agent auth
        """
        return pulumi.get(self, "ssh_agent_auth")

    @_builtins.property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> Optional[_builtins.str]:
        """
        Optional cluster level SSH certificate path
        """
        return pulumi.get(self, "ssh_cert_path")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        """
        Optional cluster level SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy']:
        """
        RKE upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter(name="winPrefixPath")
    def win_prefix_path(self) -> Optional[_builtins.str]:
        """
        Optional prefix to customize kubernetes path for windows
        """
        return pulumi.get(self, "win_prefix_path")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication(dict):
    def __init__(__self__, *,
                 sans: Optional[Sequence[_builtins.str]] = None,
                 strategy: Optional[_builtins.str] = None):
        if sans is not None:
            pulumi.set(__self__, "sans", sans)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def sans(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "sans")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "options")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshKey":
            suggest = "ssh_key"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 user: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None,
                 ssh_key: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ssh_agent_auth")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssh_key_path")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsCloudProvider":
            suggest = "aws_cloud_provider"
        elif key == "azureCloudProvider":
            suggest = "azure_cloud_provider"
        elif key == "customCloudProvider":
            suggest = "custom_cloud_provider"
        elif key == "openstackCloudProvider":
            suggest = "openstack_cloud_provider"
        elif key == "vsphereCloudProvider":
            suggest = "vsphere_cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_cloud_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider'] = None,
                 azure_cloud_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider'] = None,
                 custom_cloud_provider: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 openstack_cloud_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider'] = None,
                 vsphere_cloud_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider'] = None):
        """
        :param _builtins.str name: The cluster template name (string)
        """
        if aws_cloud_provider is not None:
            pulumi.set(__self__, "aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_provider is not None:
            pulumi.set(__self__, "azure_cloud_provider", azure_cloud_provider)
        if custom_cloud_provider is not None:
            pulumi.set(__self__, "custom_cloud_provider", custom_cloud_provider)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if openstack_cloud_provider is not None:
            pulumi.set(__self__, "openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_provider is not None:
            pulumi.set(__self__, "vsphere_cloud_provider", vsphere_cloud_provider)

    @_builtins.property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider']:
        return pulumi.get(self, "aws_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider']:
        return pulumi.get(self, "azure_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_cloud_provider")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider']:
        return pulumi.get(self, "openstack_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider']:
        return pulumi.get(self, "vsphere_cloud_provider")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "serviceOverrides":
            suggest = "service_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal'] = None,
                 service_overrides: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride']] = None):
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if service_overrides is not None:
            pulumi.set(__self__, "service_overrides", service_overrides)

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal']:
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride']]:
        return pulumi.get(self, "service_overrides")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSecurityGroupIngress":
            suggest = "disable_security_group_ingress"
        elif key == "disableStrictZoneCheck":
            suggest = "disable_strict_zone_check"
        elif key == "elbSecurityGroup":
            suggest = "elb_security_group"
        elif key == "kubernetesClusterId":
            suggest = "kubernetes_cluster_id"
        elif key == "kubernetesClusterTag":
            suggest = "kubernetes_cluster_tag"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "routeTableId":
            suggest = "route_table_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_security_group_ingress: Optional[_builtins.bool] = None,
                 disable_strict_zone_check: Optional[_builtins.bool] = None,
                 elb_security_group: Optional[_builtins.str] = None,
                 kubernetes_cluster_id: Optional[_builtins.str] = None,
                 kubernetes_cluster_tag: Optional[_builtins.str] = None,
                 role_arn: Optional[_builtins.str] = None,
                 route_table_id: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 vpc: Optional[_builtins.str] = None,
                 zone: Optional[_builtins.str] = None):
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            pulumi.set(__self__, "disable_strict_zone_check", disable_strict_zone_check)
        if elb_security_group is not None:
            pulumi.set(__self__, "elb_security_group", elb_security_group)
        if kubernetes_cluster_id is not None:
            pulumi.set(__self__, "kubernetes_cluster_id", kubernetes_cluster_id)
        if kubernetes_cluster_tag is not None:
            pulumi.set(__self__, "kubernetes_cluster_tag", kubernetes_cluster_tag)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if route_table_id is not None:
            pulumi.set(__self__, "route_table_id", route_table_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_security_group_ingress")

    @_builtins.property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_strict_zone_check")

    @_builtins.property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "elb_security_group")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kubernetes_cluster_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kubernetes_cluster_tag")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_table_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vpc")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "signingMethod":
            suggest = "signing_method"
        elif key == "signingName":
            suggest = "signing_name"
        elif key == "signingRegion":
            suggest = "signing_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: _builtins.str,
                 region: Optional[_builtins.str] = None,
                 signing_method: Optional[_builtins.str] = None,
                 signing_name: Optional[_builtins.str] = None,
                 signing_region: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        pulumi.set(__self__, "service", service)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if signing_method is not None:
            pulumi.set(__self__, "signing_method", signing_method)
        if signing_name is not None:
            pulumi.set(__self__, "signing_name", signing_name)
        if signing_region is not None:
            pulumi.set(__self__, "signing_region", signing_region)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "signing_method")

    @_builtins.property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "signing_name")

    @_builtins.property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "signing_region")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aadClientId":
            suggest = "aad_client_id"
        elif key == "aadClientSecret":
            suggest = "aad_client_secret"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "aadClientCertPassword":
            suggest = "aad_client_cert_password"
        elif key == "aadClientCertPath":
            suggest = "aad_client_cert_path"
        elif key == "cloudProviderBackoff":
            suggest = "cloud_provider_backoff"
        elif key == "cloudProviderBackoffDuration":
            suggest = "cloud_provider_backoff_duration"
        elif key == "cloudProviderBackoffExponent":
            suggest = "cloud_provider_backoff_exponent"
        elif key == "cloudProviderBackoffJitter":
            suggest = "cloud_provider_backoff_jitter"
        elif key == "cloudProviderBackoffRetries":
            suggest = "cloud_provider_backoff_retries"
        elif key == "cloudProviderRateLimit":
            suggest = "cloud_provider_rate_limit"
        elif key == "cloudProviderRateLimitBucket":
            suggest = "cloud_provider_rate_limit_bucket"
        elif key == "cloudProviderRateLimitQps":
            suggest = "cloud_provider_rate_limit_qps"
        elif key == "loadBalancerSku":
            suggest = "load_balancer_sku"
        elif key == "maximumLoadBalancerRuleCount":
            suggest = "maximum_load_balancer_rule_count"
        elif key == "primaryAvailabilitySetName":
            suggest = "primary_availability_set_name"
        elif key == "primaryScaleSetName":
            suggest = "primary_scale_set_name"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "routeTableName":
            suggest = "route_table_name"
        elif key == "securityGroupName":
            suggest = "security_group_name"
        elif key == "subnetName":
            suggest = "subnet_name"
        elif key == "useInstanceMetadata":
            suggest = "use_instance_metadata"
        elif key == "useManagedIdentityExtension":
            suggest = "use_managed_identity_extension"
        elif key == "vmType":
            suggest = "vm_type"
        elif key == "vnetName":
            suggest = "vnet_name"
        elif key == "vnetResourceGroup":
            suggest = "vnet_resource_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aad_client_id: _builtins.str,
                 aad_client_secret: _builtins.str,
                 subscription_id: _builtins.str,
                 tenant_id: _builtins.str,
                 aad_client_cert_password: Optional[_builtins.str] = None,
                 aad_client_cert_path: Optional[_builtins.str] = None,
                 cloud: Optional[_builtins.str] = None,
                 cloud_provider_backoff: Optional[_builtins.bool] = None,
                 cloud_provider_backoff_duration: Optional[_builtins.int] = None,
                 cloud_provider_backoff_exponent: Optional[_builtins.int] = None,
                 cloud_provider_backoff_jitter: Optional[_builtins.int] = None,
                 cloud_provider_backoff_retries: Optional[_builtins.int] = None,
                 cloud_provider_rate_limit: Optional[_builtins.bool] = None,
                 cloud_provider_rate_limit_bucket: Optional[_builtins.int] = None,
                 cloud_provider_rate_limit_qps: Optional[_builtins.int] = None,
                 load_balancer_sku: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 maximum_load_balancer_rule_count: Optional[_builtins.int] = None,
                 primary_availability_set_name: Optional[_builtins.str] = None,
                 primary_scale_set_name: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 route_table_name: Optional[_builtins.str] = None,
                 security_group_name: Optional[_builtins.str] = None,
                 subnet_name: Optional[_builtins.str] = None,
                 use_instance_metadata: Optional[_builtins.bool] = None,
                 use_managed_identity_extension: Optional[_builtins.bool] = None,
                 vm_type: Optional[_builtins.str] = None,
                 vnet_name: Optional[_builtins.str] = None,
                 vnet_resource_group: Optional[_builtins.str] = None):
        """
        :param _builtins.str load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        pulumi.set(__self__, "aad_client_id", aad_client_id)
        pulumi.set(__self__, "aad_client_secret", aad_client_secret)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if aad_client_cert_password is not None:
            pulumi.set(__self__, "aad_client_cert_password", aad_client_cert_password)
        if aad_client_cert_path is not None:
            pulumi.set(__self__, "aad_client_cert_path", aad_client_cert_path)
        if cloud is not None:
            pulumi.set(__self__, "cloud", cloud)
        if cloud_provider_backoff is not None:
            pulumi.set(__self__, "cloud_provider_backoff", cloud_provider_backoff)
        if cloud_provider_backoff_duration is not None:
            pulumi.set(__self__, "cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        if cloud_provider_backoff_exponent is not None:
            pulumi.set(__self__, "cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        if cloud_provider_backoff_jitter is not None:
            pulumi.set(__self__, "cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        if cloud_provider_backoff_retries is not None:
            pulumi.set(__self__, "cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        if cloud_provider_rate_limit is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit", cloud_provider_rate_limit)
        if cloud_provider_rate_limit_bucket is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        if cloud_provider_rate_limit_qps is not None:
            pulumi.set(__self__, "cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if maximum_load_balancer_rule_count is not None:
            pulumi.set(__self__, "maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        if primary_availability_set_name is not None:
            pulumi.set(__self__, "primary_availability_set_name", primary_availability_set_name)
        if primary_scale_set_name is not None:
            pulumi.set(__self__, "primary_scale_set_name", primary_scale_set_name)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if route_table_name is not None:
            pulumi.set(__self__, "route_table_name", route_table_name)
        if security_group_name is not None:
            pulumi.set(__self__, "security_group_name", security_group_name)
        if subnet_name is not None:
            pulumi.set(__self__, "subnet_name", subnet_name)
        if use_instance_metadata is not None:
            pulumi.set(__self__, "use_instance_metadata", use_instance_metadata)
        if use_managed_identity_extension is not None:
            pulumi.set(__self__, "use_managed_identity_extension", use_managed_identity_extension)
        if vm_type is not None:
            pulumi.set(__self__, "vm_type", vm_type)
        if vnet_name is not None:
            pulumi.set(__self__, "vnet_name", vnet_name)
        if vnet_resource_group is not None:
            pulumi.set(__self__, "vnet_resource_group", vnet_resource_group)

    @_builtins.property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_id")

    @_builtins.property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_secret")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aad_client_cert_password")

    @_builtins.property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aad_client_cert_path")

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cloud_provider_backoff")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "cloud_provider_rate_limit")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_availability_set_name")

    @_builtins.property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "primary_scale_set_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_table_name")

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "security_group_name")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_instance_metadata")

    @_builtins.property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_managed_identity_extension")

    @_builtins.property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vm_type")

    @_builtins.property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vnet_name")

    @_builtins.property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vnet_resource_group")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "global":
            suggest = "global_"
        elif key == "blockStorage":
            suggest = "block_storage"
        elif key == "loadBalancer":
            suggest = "load_balancer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 global_: 'outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal',
                 block_storage: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage'] = None,
                 load_balancer: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer'] = None,
                 metadata: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata'] = None,
                 route: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute'] = None):
        pulumi.set(__self__, "global_", global_)
        if block_storage is not None:
            pulumi.set(__self__, "block_storage", block_storage)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage']:
        return pulumi.get(self, "block_storage")

    @_builtins.property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer']:
        return pulumi.get(self, "load_balancer")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata']:
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def route(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute']:
        return pulumi.get(self, "route")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bsVersion":
            suggest = "bs_version"
        elif key == "ignoreVolumeAz":
            suggest = "ignore_volume_az"
        elif key == "trustDevicePath":
            suggest = "trust_device_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bs_version: Optional[_builtins.str] = None,
                 ignore_volume_az: Optional[_builtins.bool] = None,
                 trust_device_path: Optional[_builtins.bool] = None):
        if bs_version is not None:
            pulumi.set(__self__, "bs_version", bs_version)
        if ignore_volume_az is not None:
            pulumi.set(__self__, "ignore_volume_az", ignore_volume_az)
        if trust_device_path is not None:
            pulumi.set(__self__, "trust_device_path", trust_device_path)

    @_builtins.property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bs_version")

    @_builtins.property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ignore_volume_az")

    @_builtins.property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "trust_device_path")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "caFile":
            suggest = "ca_file"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "trustId":
            suggest = "trust_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str,
                 ca_file: Optional[_builtins.str] = None,
                 domain_id: Optional[_builtins.str] = None,
                 domain_name: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 tenant_name: Optional[_builtins.str] = None,
                 trust_id: Optional[_builtins.str] = None):
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if trust_id is not None:
            pulumi.set(__self__, "trust_id", trust_id)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_file")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "trust_id")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createMonitor":
            suggest = "create_monitor"
        elif key == "floatingNetworkId":
            suggest = "floating_network_id"
        elif key == "lbMethod":
            suggest = "lb_method"
        elif key == "lbProvider":
            suggest = "lb_provider"
        elif key == "lbVersion":
            suggest = "lb_version"
        elif key == "manageSecurityGroups":
            suggest = "manage_security_groups"
        elif key == "monitorDelay":
            suggest = "monitor_delay"
        elif key == "monitorMaxRetries":
            suggest = "monitor_max_retries"
        elif key == "monitorTimeout":
            suggest = "monitor_timeout"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "useOctavia":
            suggest = "use_octavia"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_monitor: Optional[_builtins.bool] = None,
                 floating_network_id: Optional[_builtins.str] = None,
                 lb_method: Optional[_builtins.str] = None,
                 lb_provider: Optional[_builtins.str] = None,
                 lb_version: Optional[_builtins.str] = None,
                 manage_security_groups: Optional[_builtins.bool] = None,
                 monitor_delay: Optional[_builtins.str] = None,
                 monitor_max_retries: Optional[_builtins.int] = None,
                 monitor_timeout: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 use_octavia: Optional[_builtins.bool] = None):
        if create_monitor is not None:
            pulumi.set(__self__, "create_monitor", create_monitor)
        if floating_network_id is not None:
            pulumi.set(__self__, "floating_network_id", floating_network_id)
        if lb_method is not None:
            pulumi.set(__self__, "lb_method", lb_method)
        if lb_provider is not None:
            pulumi.set(__self__, "lb_provider", lb_provider)
        if lb_version is not None:
            pulumi.set(__self__, "lb_version", lb_version)
        if manage_security_groups is not None:
            pulumi.set(__self__, "manage_security_groups", manage_security_groups)
        if monitor_delay is not None:
            pulumi.set(__self__, "monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            pulumi.set(__self__, "monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if use_octavia is not None:
            pulumi.set(__self__, "use_octavia", use_octavia)

    @_builtins.property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "create_monitor")

    @_builtins.property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "floating_network_id")

    @_builtins.property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lb_method")

    @_builtins.property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lb_provider")

    @_builtins.property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "lb_version")

    @_builtins.property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "manage_security_groups")

    @_builtins.property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitor_delay")

    @_builtins.property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "monitor_max_retries")

    @_builtins.property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitor_timeout")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "use_octavia")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "searchOrder":
            suggest = "search_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request_timeout: Optional[_builtins.int] = None,
                 search_order: Optional[_builtins.str] = None):
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if search_order is not None:
            pulumi.set(__self__, "search_order", search_order)

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "search_order")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routerId":
            suggest = "router_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 router_id: Optional[_builtins.str] = None):
        if router_id is not None:
            pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "router_id")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "virtualCenters":
            suggest = "virtual_centers"
        elif key == "global":
            suggest = "global_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 virtual_centers: Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter'],
                 workspace: 'outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace',
                 disk: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk'] = None,
                 global_: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal'] = None,
                 network: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork'] = None):
        pulumi.set(__self__, "virtual_centers", virtual_centers)
        pulumi.set(__self__, "workspace", workspace)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if global_ is not None:
            pulumi.set(__self__, "global_", global_)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter']:
        return pulumi.get(self, "virtual_centers")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> 'outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace':
        return pulumi.get(self, "workspace")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk']:
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal']:
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork']:
        return pulumi.get(self, "network")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scsiControllerType":
            suggest = "scsi_controller_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scsi_controller_type: Optional[_builtins.str] = None):
        if scsi_controller_type is not None:
            pulumi.set(__self__, "scsi_controller_type", scsi_controller_type)

    @_builtins.property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scsi_controller_type")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracefulShutdownTimeout":
            suggest = "graceful_shutdown_timeout"
        elif key == "insecureFlag":
            suggest = "insecure_flag"
        elif key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: Optional[_builtins.str] = None,
                 graceful_shutdown_timeout: Optional[_builtins.str] = None,
                 insecure_flag: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 soap_roundtrip_count: Optional[_builtins.int] = None,
                 user: Optional[_builtins.str] = None):
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if insecure_flag is not None:
            pulumi.set(__self__, "insecure_flag", insecure_flag)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "graceful_shutdown_timeout")

    @_builtins.property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "insecure_flag")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "soap_roundtrip_count")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicNetwork":
            suggest = "public_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_network: Optional[_builtins.str] = None):
        if public_network is not None:
            pulumi.set(__self__, "public_network", public_network)

    @_builtins.property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "public_network")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "soapRoundtripCount":
            suggest = "soap_roundtrip_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: _builtins.str,
                 name: _builtins.str,
                 password: _builtins.str,
                 user: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 soap_roundtrip_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str name: The cluster template name (string)
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if soap_roundtrip_count is not None:
            pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> _builtins.str:
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "soap_roundtrip_count")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultDatastore":
            suggest = "default_datastore"
        elif key == "resourcepoolPath":
            suggest = "resourcepool_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 folder: _builtins.str,
                 server: _builtins.str,
                 default_datastore: Optional[_builtins.str] = None,
                 resourcepool_path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "server", server)
        if default_datastore is not None:
            pulumi.set(__self__, "default_datastore", default_datastore)
        if resourcepool_path is not None:
            pulumi.set(__self__, "resourcepool_path", resourcepool_path)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> _builtins.str:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        return pulumi.get(self, "server")

    @_builtins.property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default_datastore")

    @_builtins.property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "resourcepool_path")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linearAutoscalerParams":
            suggest = "linear_autoscaler_params"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "reverseCidrs":
            suggest = "reverse_cidrs"
        elif key == "updateStrategy":
            suggest = "update_strategy"
        elif key == "upstreamNameservers":
            suggest = "upstream_nameservers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 linear_autoscaler_params: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams'] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 nodelocal: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal'] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 provider: Optional[_builtins.str] = None,
                 reverse_cidrs: Optional[Sequence[_builtins.str]] = None,
                 tolerations: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration']] = None,
                 update_strategy: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy'] = None,
                 upstream_nameservers: Optional[Sequence[_builtins.str]] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs' linear_autoscaler_params: Linear Autoscaler Params
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs' nodelocal: Nodelocal dns
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs'] tolerations: DNS service tolerations
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        if linear_autoscaler_params is not None:
            pulumi.set(__self__, "linear_autoscaler_params", linear_autoscaler_params)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if nodelocal is not None:
            pulumi.set(__self__, "nodelocal", nodelocal)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if reverse_cidrs is not None:
            pulumi.set(__self__, "reverse_cidrs", reverse_cidrs)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)
        if upstream_nameservers is not None:
            pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)

    @_builtins.property
    @pulumi.getter(name="linearAutoscalerParams")
    def linear_autoscaler_params(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams']:
        """
        Linear Autoscaler Params
        """
        return pulumi.get(self, "linear_autoscaler_params")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def nodelocal(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal']:
        """
        Nodelocal dns
        """
        return pulumi.get(self, "nodelocal")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "reverse_cidrs")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration']]:
        """
        DNS service tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")

    @_builtins.property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "upstream_nameservers")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coresPerReplica":
            suggest = "cores_per_replica"
        elif key == "nodesPerReplica":
            suggest = "nodes_per_replica"
        elif key == "preventSinglePointFailure":
            suggest = "prevent_single_point_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cores_per_replica: Optional[_builtins.float] = None,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 nodes_per_replica: Optional[_builtins.float] = None,
                 prevent_single_point_failure: Optional[_builtins.bool] = None):
        if cores_per_replica is not None:
            pulumi.set(__self__, "cores_per_replica", cores_per_replica)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if nodes_per_replica is not None:
            pulumi.set(__self__, "nodes_per_replica", nodes_per_replica)
        if prevent_single_point_failure is not None:
            pulumi.set(__self__, "prevent_single_point_failure", prevent_single_point_failure)

    @_builtins.property
    @pulumi.getter(name="coresPerReplica")
    def cores_per_replica(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cores_per_replica")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="nodesPerReplica")
    def nodes_per_replica(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "nodes_per_replica")

    @_builtins.property
    @pulumi.getter(name="preventSinglePointFailure")
    def prevent_single_point_failure(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "prevent_single_point_failure")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "nodeSelector":
            suggest = "node_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[_builtins.str] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] node_selector: Node selector key pair
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Node selector key pair
        """
        return pulumi.get(self, "node_selector")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBackend":
            suggest = "default_backend"
        elif key == "dnsPolicy":
            suggest = "dns_policy"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "httpsPort":
            suggest = "https_port"
        elif key == "networkMode":
            suggest = "network_mode"
        elif key == "nodeSelector":
            suggest = "node_selector"
        elif key == "updateStrategy":
            suggest = "update_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_backend: Optional[_builtins.bool] = None,
                 dns_policy: Optional[_builtins.str] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 http_port: Optional[_builtins.int] = None,
                 https_port: Optional[_builtins.int] = None,
                 network_mode: Optional[_builtins.str] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 provider: Optional[_builtins.str] = None,
                 tolerations: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration']] = None,
                 update_strategy: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy'] = None):
        """
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs'] tolerations: Ingress add-on tolerations
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs' update_strategy: Update daemon set strategy
        """
        if default_backend is not None:
            pulumi.set(__self__, "default_backend", default_backend)
        if dns_policy is not None:
            pulumi.set(__self__, "dns_policy", dns_policy)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if https_port is not None:
            pulumi.set(__self__, "https_port", https_port)
        if network_mode is not None:
            pulumi.set(__self__, "network_mode", network_mode)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "default_backend")

    @_builtins.property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "dns_policy")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration']]:
        """
        Ingress add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy']:
        """
        Update daemon set strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeSelector":
            suggest = "node_selector"
        elif key == "updateStrategy":
            suggest = "update_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 provider: Optional[_builtins.str] = None,
                 replicas: Optional[_builtins.int] = None,
                 tolerations: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration']] = None,
                 update_strategy: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy'] = None):
        """
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs'] tolerations: Monitoring add-on tolerations
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration']]:
        """
        Monitoring add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rollingUpdate":
            suggest = "rolling_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rolling_update: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aciNetworkProvider":
            suggest = "aci_network_provider"
        elif key == "calicoNetworkProvider":
            suggest = "calico_network_provider"
        elif key == "canalNetworkProvider":
            suggest = "canal_network_provider"
        elif key == "flannelNetworkProvider":
            suggest = "flannel_network_provider"
        elif key == "weaveNetworkProvider":
            suggest = "weave_network_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aci_network_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider'] = None,
                 calico_network_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider'] = None,
                 canal_network_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider'] = None,
                 flannel_network_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider'] = None,
                 mtu: Optional[_builtins.int] = None,
                 options: Optional[Mapping[str, _builtins.str]] = None,
                 plugin: Optional[_builtins.str] = None,
                 tolerations: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration']] = None,
                 weave_network_provider: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider'] = None):
        """
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs'] tolerations: Network add-on tolerations
        """
        if aci_network_provider is not None:
            pulumi.set(__self__, "aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            pulumi.set(__self__, "calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            pulumi.set(__self__, "canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            pulumi.set(__self__, "flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if plugin is not None:
            pulumi.set(__self__, "plugin", plugin)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if weave_network_provider is not None:
            pulumi.set(__self__, "weave_network_provider", weave_network_provider)

    @_builtins.property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider']:
        return pulumi.get(self, "aci_network_provider")

    @_builtins.property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider']:
        return pulumi.get(self, "calico_network_provider")

    @_builtins.property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider']:
        return pulumi.get(self, "canal_network_provider")

    @_builtins.property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider']:
        return pulumi.get(self, "flannel_network_provider")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def plugin(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "plugin")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration']]:
        """
        Network add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider']:
        return pulumi.get(self, "weave_network_provider")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apicHosts":
            suggest = "apic_hosts"
        elif key == "apicUserCrt":
            suggest = "apic_user_crt"
        elif key == "apicUserKey":
            suggest = "apic_user_key"
        elif key == "apicUserName":
            suggest = "apic_user_name"
        elif key == "encapType":
            suggest = "encap_type"
        elif key == "externDynamic":
            suggest = "extern_dynamic"
        elif key == "externStatic":
            suggest = "extern_static"
        elif key == "kubeApiVlan":
            suggest = "kube_api_vlan"
        elif key == "l3outExternalNetworks":
            suggest = "l3out_external_networks"
        elif key == "mcastRangeEnd":
            suggest = "mcast_range_end"
        elif key == "mcastRangeStart":
            suggest = "mcast_range_start"
        elif key == "nodeSubnet":
            suggest = "node_subnet"
        elif key == "nodeSvcSubnet":
            suggest = "node_svc_subnet"
        elif key == "serviceVlan":
            suggest = "service_vlan"
        elif key == "systemId":
            suggest = "system_id"
        elif key == "vrfName":
            suggest = "vrf_name"
        elif key == "vrfTenant":
            suggest = "vrf_tenant"
        elif key == "apicRefreshTickerAdjust":
            suggest = "apic_refresh_ticker_adjust"
        elif key == "apicRefreshTime":
            suggest = "apic_refresh_time"
        elif key == "apicSubscriptionDelay":
            suggest = "apic_subscription_delay"
        elif key == "controllerLogLevel":
            suggest = "controller_log_level"
        elif key == "disablePeriodicSnatGlobalInfoSync":
            suggest = "disable_periodic_snat_global_info_sync"
        elif key == "disableWaitForNetwork":
            suggest = "disable_wait_for_network"
        elif key == "dropLogEnable":
            suggest = "drop_log_enable"
        elif key == "durationWaitForNetwork":
            suggest = "duration_wait_for_network"
        elif key == "enableEndpointSlice":
            suggest = "enable_endpoint_slice"
        elif key == "epRegistry":
            suggest = "ep_registry"
        elif key == "gbpPodSubnet":
            suggest = "gbp_pod_subnet"
        elif key == "hostAgentLogLevel":
            suggest = "host_agent_log_level"
        elif key == "imagePullPolicy":
            suggest = "image_pull_policy"
        elif key == "imagePullSecret":
            suggest = "image_pull_secret"
        elif key == "infraVlan":
            suggest = "infra_vlan"
        elif key == "installIstio":
            suggest = "install_istio"
        elif key == "istioProfile":
            suggest = "istio_profile"
        elif key == "kafkaBrokers":
            suggest = "kafka_brokers"
        elif key == "kafkaClientCrt":
            suggest = "kafka_client_crt"
        elif key == "kafkaClientKey":
            suggest = "kafka_client_key"
        elif key == "maxNodesSvcGraph":
            suggest = "max_nodes_svc_graph"
        elif key == "mtuHeadRoom":
            suggest = "mtu_head_room"
        elif key == "multusDisable":
            suggest = "multus_disable"
        elif key == "noPriorityClass":
            suggest = "no_priority_class"
        elif key == "nodePodIfEnable":
            suggest = "node_pod_if_enable"
        elif key == "opflexClientSsl":
            suggest = "opflex_client_ssl"
        elif key == "opflexDeviceDeleteTimeout":
            suggest = "opflex_device_delete_timeout"
        elif key == "opflexLogLevel":
            suggest = "opflex_log_level"
        elif key == "opflexMode":
            suggest = "opflex_mode"
        elif key == "opflexServerPort":
            suggest = "opflex_server_port"
        elif key == "overlayVrfName":
            suggest = "overlay_vrf_name"
        elif key == "ovsMemoryLimit":
            suggest = "ovs_memory_limit"
        elif key == "pbrTrackingNonSnat":
            suggest = "pbr_tracking_non_snat"
        elif key == "podSubnetChunkSize":
            suggest = "pod_subnet_chunk_size"
        elif key == "runGbpContainer":
            suggest = "run_gbp_container"
        elif key == "runOpflexServerContainer":
            suggest = "run_opflex_server_container"
        elif key == "serviceMonitorInterval":
            suggest = "service_monitor_interval"
        elif key == "snatContractScope":
            suggest = "snat_contract_scope"
        elif key == "snatNamespace":
            suggest = "snat_namespace"
        elif key == "snatPortRangeEnd":
            suggest = "snat_port_range_end"
        elif key == "snatPortRangeStart":
            suggest = "snat_port_range_start"
        elif key == "snatPortsPerNode":
            suggest = "snat_ports_per_node"
        elif key == "sriovEnable":
            suggest = "sriov_enable"
        elif key == "subnetDomainName":
            suggest = "subnet_domain_name"
        elif key == "useAciAnywhereCrd":
            suggest = "use_aci_anywhere_crd"
        elif key == "useAciCniPriorityClass":
            suggest = "use_aci_cni_priority_class"
        elif key == "useClusterRole":
            suggest = "use_cluster_role"
        elif key == "useHostNetnsVolume":
            suggest = "use_host_netns_volume"
        elif key == "useOpflexServerVolume":
            suggest = "use_opflex_server_volume"
        elif key == "usePrivilegedContainer":
            suggest = "use_privileged_container"
        elif key == "vmmController":
            suggest = "vmm_controller"
        elif key == "vmmDomain":
            suggest = "vmm_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aep: _builtins.str,
                 apic_hosts: Sequence[_builtins.str],
                 apic_user_crt: _builtins.str,
                 apic_user_key: _builtins.str,
                 apic_user_name: _builtins.str,
                 encap_type: _builtins.str,
                 extern_dynamic: _builtins.str,
                 extern_static: _builtins.str,
                 kube_api_vlan: _builtins.str,
                 l3out: _builtins.str,
                 l3out_external_networks: Sequence[_builtins.str],
                 mcast_range_end: _builtins.str,
                 mcast_range_start: _builtins.str,
                 node_subnet: _builtins.str,
                 node_svc_subnet: _builtins.str,
                 service_vlan: _builtins.str,
                 system_id: _builtins.str,
                 token: _builtins.str,
                 vrf_name: _builtins.str,
                 vrf_tenant: _builtins.str,
                 apic_refresh_ticker_adjust: Optional[_builtins.str] = None,
                 apic_refresh_time: Optional[_builtins.str] = None,
                 apic_subscription_delay: Optional[_builtins.str] = None,
                 capic: Optional[_builtins.str] = None,
                 controller_log_level: Optional[_builtins.str] = None,
                 disable_periodic_snat_global_info_sync: Optional[_builtins.str] = None,
                 disable_wait_for_network: Optional[_builtins.str] = None,
                 drop_log_enable: Optional[_builtins.str] = None,
                 duration_wait_for_network: Optional[_builtins.str] = None,
                 enable_endpoint_slice: Optional[_builtins.str] = None,
                 ep_registry: Optional[_builtins.str] = None,
                 gbp_pod_subnet: Optional[_builtins.str] = None,
                 host_agent_log_level: Optional[_builtins.str] = None,
                 image_pull_policy: Optional[_builtins.str] = None,
                 image_pull_secret: Optional[_builtins.str] = None,
                 infra_vlan: Optional[_builtins.str] = None,
                 install_istio: Optional[_builtins.str] = None,
                 istio_profile: Optional[_builtins.str] = None,
                 kafka_brokers: Optional[Sequence[_builtins.str]] = None,
                 kafka_client_crt: Optional[_builtins.str] = None,
                 kafka_client_key: Optional[_builtins.str] = None,
                 max_nodes_svc_graph: Optional[_builtins.str] = None,
                 mtu_head_room: Optional[_builtins.str] = None,
                 multus_disable: Optional[_builtins.str] = None,
                 no_priority_class: Optional[_builtins.str] = None,
                 node_pod_if_enable: Optional[_builtins.str] = None,
                 opflex_client_ssl: Optional[_builtins.str] = None,
                 opflex_device_delete_timeout: Optional[_builtins.str] = None,
                 opflex_log_level: Optional[_builtins.str] = None,
                 opflex_mode: Optional[_builtins.str] = None,
                 opflex_server_port: Optional[_builtins.str] = None,
                 overlay_vrf_name: Optional[_builtins.str] = None,
                 ovs_memory_limit: Optional[_builtins.str] = None,
                 pbr_tracking_non_snat: Optional[_builtins.str] = None,
                 pod_subnet_chunk_size: Optional[_builtins.str] = None,
                 run_gbp_container: Optional[_builtins.str] = None,
                 run_opflex_server_container: Optional[_builtins.str] = None,
                 service_monitor_interval: Optional[_builtins.str] = None,
                 snat_contract_scope: Optional[_builtins.str] = None,
                 snat_namespace: Optional[_builtins.str] = None,
                 snat_port_range_end: Optional[_builtins.str] = None,
                 snat_port_range_start: Optional[_builtins.str] = None,
                 snat_ports_per_node: Optional[_builtins.str] = None,
                 sriov_enable: Optional[_builtins.str] = None,
                 subnet_domain_name: Optional[_builtins.str] = None,
                 tenant: Optional[_builtins.str] = None,
                 use_aci_anywhere_crd: Optional[_builtins.str] = None,
                 use_aci_cni_priority_class: Optional[_builtins.str] = None,
                 use_cluster_role: Optional[_builtins.str] = None,
                 use_host_netns_volume: Optional[_builtins.str] = None,
                 use_opflex_server_volume: Optional[_builtins.str] = None,
                 use_privileged_container: Optional[_builtins.str] = None,
                 vmm_controller: Optional[_builtins.str] = None,
                 vmm_domain: Optional[_builtins.str] = None):
        pulumi.set(__self__, "aep", aep)
        pulumi.set(__self__, "apic_hosts", apic_hosts)
        pulumi.set(__self__, "apic_user_crt", apic_user_crt)
        pulumi.set(__self__, "apic_user_key", apic_user_key)
        pulumi.set(__self__, "apic_user_name", apic_user_name)
        pulumi.set(__self__, "encap_type", encap_type)
        pulumi.set(__self__, "extern_dynamic", extern_dynamic)
        pulumi.set(__self__, "extern_static", extern_static)
        pulumi.set(__self__, "kube_api_vlan", kube_api_vlan)
        pulumi.set(__self__, "l3out", l3out)
        pulumi.set(__self__, "l3out_external_networks", l3out_external_networks)
        pulumi.set(__self__, "mcast_range_end", mcast_range_end)
        pulumi.set(__self__, "mcast_range_start", mcast_range_start)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "node_svc_subnet", node_svc_subnet)
        pulumi.set(__self__, "service_vlan", service_vlan)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "vrf_name", vrf_name)
        pulumi.set(__self__, "vrf_tenant", vrf_tenant)
        if apic_refresh_ticker_adjust is not None:
            pulumi.set(__self__, "apic_refresh_ticker_adjust", apic_refresh_ticker_adjust)
        if apic_refresh_time is not None:
            pulumi.set(__self__, "apic_refresh_time", apic_refresh_time)
        if apic_subscription_delay is not None:
            pulumi.set(__self__, "apic_subscription_delay", apic_subscription_delay)
        if capic is not None:
            pulumi.set(__self__, "capic", capic)
        if controller_log_level is not None:
            pulumi.set(__self__, "controller_log_level", controller_log_level)
        if disable_periodic_snat_global_info_sync is not None:
            pulumi.set(__self__, "disable_periodic_snat_global_info_sync", disable_periodic_snat_global_info_sync)
        if disable_wait_for_network is not None:
            pulumi.set(__self__, "disable_wait_for_network", disable_wait_for_network)
        if drop_log_enable is not None:
            pulumi.set(__self__, "drop_log_enable", drop_log_enable)
        if duration_wait_for_network is not None:
            pulumi.set(__self__, "duration_wait_for_network", duration_wait_for_network)
        if enable_endpoint_slice is not None:
            pulumi.set(__self__, "enable_endpoint_slice", enable_endpoint_slice)
        if ep_registry is not None:
            pulumi.set(__self__, "ep_registry", ep_registry)
        if gbp_pod_subnet is not None:
            pulumi.set(__self__, "gbp_pod_subnet", gbp_pod_subnet)
        if host_agent_log_level is not None:
            pulumi.set(__self__, "host_agent_log_level", host_agent_log_level)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if infra_vlan is not None:
            pulumi.set(__self__, "infra_vlan", infra_vlan)
        if install_istio is not None:
            pulumi.set(__self__, "install_istio", install_istio)
        if istio_profile is not None:
            pulumi.set(__self__, "istio_profile", istio_profile)
        if kafka_brokers is not None:
            pulumi.set(__self__, "kafka_brokers", kafka_brokers)
        if kafka_client_crt is not None:
            pulumi.set(__self__, "kafka_client_crt", kafka_client_crt)
        if kafka_client_key is not None:
            pulumi.set(__self__, "kafka_client_key", kafka_client_key)
        if max_nodes_svc_graph is not None:
            pulumi.set(__self__, "max_nodes_svc_graph", max_nodes_svc_graph)
        if mtu_head_room is not None:
            pulumi.set(__self__, "mtu_head_room", mtu_head_room)
        if multus_disable is not None:
            pulumi.set(__self__, "multus_disable", multus_disable)
        if no_priority_class is not None:
            pulumi.set(__self__, "no_priority_class", no_priority_class)
        if node_pod_if_enable is not None:
            pulumi.set(__self__, "node_pod_if_enable", node_pod_if_enable)
        if opflex_client_ssl is not None:
            pulumi.set(__self__, "opflex_client_ssl", opflex_client_ssl)
        if opflex_device_delete_timeout is not None:
            pulumi.set(__self__, "opflex_device_delete_timeout", opflex_device_delete_timeout)
        if opflex_log_level is not None:
            pulumi.set(__self__, "opflex_log_level", opflex_log_level)
        if opflex_mode is not None:
            pulumi.set(__self__, "opflex_mode", opflex_mode)
        if opflex_server_port is not None:
            pulumi.set(__self__, "opflex_server_port", opflex_server_port)
        if overlay_vrf_name is not None:
            pulumi.set(__self__, "overlay_vrf_name", overlay_vrf_name)
        if ovs_memory_limit is not None:
            pulumi.set(__self__, "ovs_memory_limit", ovs_memory_limit)
        if pbr_tracking_non_snat is not None:
            pulumi.set(__self__, "pbr_tracking_non_snat", pbr_tracking_non_snat)
        if pod_subnet_chunk_size is not None:
            pulumi.set(__self__, "pod_subnet_chunk_size", pod_subnet_chunk_size)
        if run_gbp_container is not None:
            pulumi.set(__self__, "run_gbp_container", run_gbp_container)
        if run_opflex_server_container is not None:
            pulumi.set(__self__, "run_opflex_server_container", run_opflex_server_container)
        if service_monitor_interval is not None:
            pulumi.set(__self__, "service_monitor_interval", service_monitor_interval)
        if snat_contract_scope is not None:
            pulumi.set(__self__, "snat_contract_scope", snat_contract_scope)
        if snat_namespace is not None:
            pulumi.set(__self__, "snat_namespace", snat_namespace)
        if snat_port_range_end is not None:
            pulumi.set(__self__, "snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            pulumi.set(__self__, "snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            pulumi.set(__self__, "snat_ports_per_node", snat_ports_per_node)
        if sriov_enable is not None:
            pulumi.set(__self__, "sriov_enable", sriov_enable)
        if subnet_domain_name is not None:
            pulumi.set(__self__, "subnet_domain_name", subnet_domain_name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if use_aci_anywhere_crd is not None:
            pulumi.set(__self__, "use_aci_anywhere_crd", use_aci_anywhere_crd)
        if use_aci_cni_priority_class is not None:
            pulumi.set(__self__, "use_aci_cni_priority_class", use_aci_cni_priority_class)
        if use_cluster_role is not None:
            pulumi.set(__self__, "use_cluster_role", use_cluster_role)
        if use_host_netns_volume is not None:
            pulumi.set(__self__, "use_host_netns_volume", use_host_netns_volume)
        if use_opflex_server_volume is not None:
            pulumi.set(__self__, "use_opflex_server_volume", use_opflex_server_volume)
        if use_privileged_container is not None:
            pulumi.set(__self__, "use_privileged_container", use_privileged_container)
        if vmm_controller is not None:
            pulumi.set(__self__, "vmm_controller", vmm_controller)
        if vmm_domain is not None:
            pulumi.set(__self__, "vmm_domain", vmm_domain)

    @_builtins.property
    @pulumi.getter
    def aep(self) -> _builtins.str:
        return pulumi.get(self, "aep")

    @_builtins.property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "apic_hosts")

    @_builtins.property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_crt")

    @_builtins.property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_key")

    @_builtins.property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_name")

    @_builtins.property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> _builtins.str:
        return pulumi.get(self, "encap_type")

    @_builtins.property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> _builtins.str:
        return pulumi.get(self, "extern_dynamic")

    @_builtins.property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> _builtins.str:
        return pulumi.get(self, "extern_static")

    @_builtins.property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> _builtins.str:
        return pulumi.get(self, "kube_api_vlan")

    @_builtins.property
    @pulumi.getter
    def l3out(self) -> _builtins.str:
        return pulumi.get(self, "l3out")

    @_builtins.property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "l3out_external_networks")

    @_builtins.property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> _builtins.str:
        return pulumi.get(self, "mcast_range_end")

    @_builtins.property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> _builtins.str:
        return pulumi.get(self, "mcast_range_start")

    @_builtins.property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> _builtins.str:
        return pulumi.get(self, "node_subnet")

    @_builtins.property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> _builtins.str:
        return pulumi.get(self, "node_svc_subnet")

    @_builtins.property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> _builtins.str:
        return pulumi.get(self, "service_vlan")

    @_builtins.property
    @pulumi.getter(name="systemId")
    def system_id(self) -> _builtins.str:
        return pulumi.get(self, "system_id")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> _builtins.str:
        return pulumi.get(self, "vrf_name")

    @_builtins.property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> _builtins.str:
        return pulumi.get(self, "vrf_tenant")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTickerAdjust")
    def apic_refresh_ticker_adjust(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_refresh_ticker_adjust")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTime")
    def apic_refresh_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_refresh_time")

    @_builtins.property
    @pulumi.getter(name="apicSubscriptionDelay")
    def apic_subscription_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_subscription_delay")

    @_builtins.property
    @pulumi.getter
    def capic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capic")

    @_builtins.property
    @pulumi.getter(name="controllerLogLevel")
    def controller_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "controller_log_level")

    @_builtins.property
    @pulumi.getter(name="disablePeriodicSnatGlobalInfoSync")
    def disable_periodic_snat_global_info_sync(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disable_periodic_snat_global_info_sync")

    @_builtins.property
    @pulumi.getter(name="disableWaitForNetwork")
    def disable_wait_for_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disable_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="dropLogEnable")
    def drop_log_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "drop_log_enable")

    @_builtins.property
    @pulumi.getter(name="durationWaitForNetwork")
    def duration_wait_for_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "duration_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="enableEndpointSlice")
    def enable_endpoint_slice(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "enable_endpoint_slice")

    @_builtins.property
    @pulumi.getter(name="epRegistry")
    def ep_registry(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ep_registry")

    @_builtins.property
    @pulumi.getter(name="gbpPodSubnet")
    def gbp_pod_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gbp_pod_subnet")

    @_builtins.property
    @pulumi.getter(name="hostAgentLogLevel")
    def host_agent_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_agent_log_level")

    @_builtins.property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_policy")

    @_builtins.property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_secret")

    @_builtins.property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "infra_vlan")

    @_builtins.property
    @pulumi.getter(name="installIstio")
    def install_istio(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "install_istio")

    @_builtins.property
    @pulumi.getter(name="istioProfile")
    def istio_profile(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "istio_profile")

    @_builtins.property
    @pulumi.getter(name="kafkaBrokers")
    def kafka_brokers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "kafka_brokers")

    @_builtins.property
    @pulumi.getter(name="kafkaClientCrt")
    def kafka_client_crt(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kafka_client_crt")

    @_builtins.property
    @pulumi.getter(name="kafkaClientKey")
    def kafka_client_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kafka_client_key")

    @_builtins.property
    @pulumi.getter(name="maxNodesSvcGraph")
    def max_nodes_svc_graph(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_nodes_svc_graph")

    @_builtins.property
    @pulumi.getter(name="mtuHeadRoom")
    def mtu_head_room(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mtu_head_room")

    @_builtins.property
    @pulumi.getter(name="multusDisable")
    def multus_disable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "multus_disable")

    @_builtins.property
    @pulumi.getter(name="noPriorityClass")
    def no_priority_class(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "no_priority_class")

    @_builtins.property
    @pulumi.getter(name="nodePodIfEnable")
    def node_pod_if_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_pod_if_enable")

    @_builtins.property
    @pulumi.getter(name="opflexClientSsl")
    def opflex_client_ssl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_client_ssl")

    @_builtins.property
    @pulumi.getter(name="opflexDeviceDeleteTimeout")
    def opflex_device_delete_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_device_delete_timeout")

    @_builtins.property
    @pulumi.getter(name="opflexLogLevel")
    def opflex_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_log_level")

    @_builtins.property
    @pulumi.getter(name="opflexMode")
    def opflex_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_mode")

    @_builtins.property
    @pulumi.getter(name="opflexServerPort")
    def opflex_server_port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_server_port")

    @_builtins.property
    @pulumi.getter(name="overlayVrfName")
    def overlay_vrf_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "overlay_vrf_name")

    @_builtins.property
    @pulumi.getter(name="ovsMemoryLimit")
    def ovs_memory_limit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ovs_memory_limit")

    @_builtins.property
    @pulumi.getter(name="pbrTrackingNonSnat")
    def pbr_tracking_non_snat(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pbr_tracking_non_snat")

    @_builtins.property
    @pulumi.getter(name="podSubnetChunkSize")
    def pod_subnet_chunk_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pod_subnet_chunk_size")

    @_builtins.property
    @pulumi.getter(name="runGbpContainer")
    def run_gbp_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_gbp_container")

    @_builtins.property
    @pulumi.getter(name="runOpflexServerContainer")
    def run_opflex_server_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_opflex_server_container")

    @_builtins.property
    @pulumi.getter(name="serviceMonitorInterval")
    def service_monitor_interval(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_monitor_interval")

    @_builtins.property
    @pulumi.getter(name="snatContractScope")
    def snat_contract_scope(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_contract_scope")

    @_builtins.property
    @pulumi.getter(name="snatNamespace")
    def snat_namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_namespace")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_port_range_end")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_port_range_start")

    @_builtins.property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_ports_per_node")

    @_builtins.property
    @pulumi.getter(name="sriovEnable")
    def sriov_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sriov_enable")

    @_builtins.property
    @pulumi.getter(name="subnetDomainName")
    def subnet_domain_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_domain_name")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter(name="useAciAnywhereCrd")
    def use_aci_anywhere_crd(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_aci_anywhere_crd")

    @_builtins.property
    @pulumi.getter(name="useAciCniPriorityClass")
    def use_aci_cni_priority_class(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_aci_cni_priority_class")

    @_builtins.property
    @pulumi.getter(name="useClusterRole")
    def use_cluster_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_cluster_role")

    @_builtins.property
    @pulumi.getter(name="useHostNetnsVolume")
    def use_host_netns_volume(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_host_netns_volume")

    @_builtins.property
    @pulumi.getter(name="useOpflexServerVolume")
    def use_opflex_server_volume(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_opflex_server_volume")

    @_builtins.property
    @pulumi.getter(name="usePrivilegedContainer")
    def use_privileged_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_privileged_container")

    @_builtins.property
    @pulumi.getter(name="vmmController")
    def vmm_controller(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vmm_controller")

    @_builtins.property
    @pulumi.getter(name="vmmDomain")
    def vmm_domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vmm_domain")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudProvider":
            suggest = "cloud_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_provider: Optional[_builtins.str] = None):
        if cloud_provider is not None:
            pulumi.set(__self__, "cloud_provider", cloud_provider)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cloud_provider")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider(dict):
    def __init__(__self__, *,
                 iface: Optional[_builtins.str] = None):
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iface")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider(dict):
    def __init__(__self__, *,
                 iface: Optional[_builtins.str] = None):
        if iface is not None:
            pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "iface")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider(dict):
    def __init__(__self__, *,
                 password: _builtins.str):
        pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dockerSocket":
            suggest = "docker_socket"
        elif key == "hostnameOverride":
            suggest = "hostname_override"
        elif key == "internalAddress":
            suggest = "internal_address"
        elif key == "nodeId":
            suggest = "node_id"
        elif key == "sshAgentAuth":
            suggest = "ssh_agent_auth"
        elif key == "sshKey":
            suggest = "ssh_key"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: _builtins.str,
                 roles: Sequence[_builtins.str],
                 user: _builtins.str,
                 docker_socket: Optional[_builtins.str] = None,
                 hostname_override: Optional[_builtins.str] = None,
                 internal_address: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 node_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None,
                 ssh_key: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] labels: Labels for the cluster template (map)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "user", user)
        if docker_socket is not None:
            pulumi.set(__self__, "docker_socket", docker_socket)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if internal_address is not None:
            pulumi.set(__self__, "internal_address", internal_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "docker_socket")

    @_builtins.property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname_override")

    @_builtins.property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "internal_address")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the cluster template (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ssh_agent_auth")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ssh_key_path")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ecrCredentialPlugin":
            suggest = "ecr_credential_plugin"
        elif key == "isDefault":
            suggest = "is_default"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: _builtins.str,
                 ecr_credential_plugin: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin'] = None,
                 is_default: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs' ecr_credential_plugin: ECR credential plugin config
        """
        pulumi.set(__self__, "url", url)
        if ecr_credential_plugin is not None:
            pulumi.set(__self__, "ecr_credential_plugin", ecr_credential_plugin)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="ecrCredentialPlugin")
    def ecr_credential_plugin(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin']:
        """
        ECR credential plugin config
        """
        return pulumi.get(self, "ecr_credential_plugin")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "awsSessionToken":
            suggest = "aws_session_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: Optional[_builtins.str] = None,
                 aws_secret_access_key: Optional[_builtins.str] = None,
                 aws_session_token: Optional[_builtins.str] = None):
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_session_token")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeApi":
            suggest = "kube_api"
        elif key == "kubeController":
            suggest = "kube_controller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 etcd: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd'] = None,
                 kube_api: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi'] = None,
                 kube_controller: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController'] = None,
                 kubelet: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet'] = None,
                 kubeproxy: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy'] = None,
                 scheduler: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler'] = None):
        if etcd is not None:
            pulumi.set(__self__, "etcd", etcd)
        if kube_api is not None:
            pulumi.set(__self__, "kube_api", kube_api)
        if kube_controller is not None:
            pulumi.set(__self__, "kube_controller", kube_controller)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if kubeproxy is not None:
            pulumi.set(__self__, "kubeproxy", kubeproxy)
        if scheduler is not None:
            pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd']:
        return pulumi.get(self, "etcd")

    @_builtins.property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi']:
        return pulumi.get(self, "kube_api")

    @_builtins.property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController']:
        return pulumi.get(self, "kube_controller")

    @_builtins.property
    @pulumi.getter
    def kubelet(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet']:
        return pulumi.get(self, "kubelet")

    @_builtins.property
    @pulumi.getter
    def kubeproxy(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy']:
        return pulumi.get(self, "kubeproxy")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler']:
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backupConfig":
            suggest = "backup_config"
        elif key == "caCert":
            suggest = "ca_cert"
        elif key == "externalUrls":
            suggest = "external_urls"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 backup_config: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig'] = None,
                 ca_cert: Optional[_builtins.str] = None,
                 cert: Optional[_builtins.str] = None,
                 creation: Optional[_builtins.str] = None,
                 external_urls: Optional[Sequence[_builtins.str]] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 gid: Optional[_builtins.int] = None,
                 image: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 retention: Optional[_builtins.str] = None,
                 snapshot: Optional[_builtins.bool] = None,
                 uid: Optional[_builtins.int] = None):
        if backup_config is not None:
            pulumi.set(__self__, "backup_config", backup_config)
        if ca_cert is not None:
            pulumi.set(__self__, "ca_cert", ca_cert)
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if creation is not None:
            pulumi.set(__self__, "creation", creation)
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if snapshot is not None:
            pulumi.set(__self__, "snapshot", snapshot)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig']:
        return pulumi.get(self, "backup_config")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def creation(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "creation")

    @_builtins.property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "external_urls")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "gid")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "uid")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalHours":
            suggest = "interval_hours"
        elif key == "s3BackupConfig":
            suggest = "s3_backup_config"
        elif key == "safeTimestamp":
            suggest = "safe_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None,
                 retention: Optional[_builtins.int] = None,
                 s3_backup_config: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig'] = None,
                 safe_timestamp: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enable cluster template revision. Default `true` (bool)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "interval_hours")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig']:
        return pulumi.get(self, "s3_backup_config")

    @_builtins.property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safe_timestamp")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "customCa":
            suggest = "custom_ca"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 endpoint: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 custom_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "admissionConfiguration":
            suggest = "admission_configuration"
        elif key == "alwaysPullImages":
            suggest = "always_pull_images"
        elif key == "auditLog":
            suggest = "audit_log"
        elif key == "eventRateLimit":
            suggest = "event_rate_limit"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "secretsEncryptionConfig":
            suggest = "secrets_encryption_config"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"
        elif key == "serviceNodePortRange":
            suggest = "service_node_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admission_configuration: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration'] = None,
                 always_pull_images: Optional[_builtins.bool] = None,
                 audit_log: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog'] = None,
                 event_rate_limit: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit'] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None,
                 secrets_encryption_config: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig'] = None,
                 service_cluster_ip_range: Optional[_builtins.str] = None,
                 service_node_port_range: Optional[_builtins.str] = None):
        """
        :param 'ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs' admission_configuration: Cluster admission configuration
        """
        if admission_configuration is not None:
            pulumi.set(__self__, "admission_configuration", admission_configuration)
        if always_pull_images is not None:
            pulumi.set(__self__, "always_pull_images", always_pull_images)
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if event_rate_limit is not None:
            pulumi.set(__self__, "event_rate_limit", event_rate_limit)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if secrets_encryption_config is not None:
            pulumi.set(__self__, "secrets_encryption_config", secrets_encryption_config)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if service_node_port_range is not None:
            pulumi.set(__self__, "service_node_port_range", service_node_port_range)

    @_builtins.property
    @pulumi.getter(name="admissionConfiguration")
    def admission_configuration(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration']:
        """
        Cluster admission configuration
        """
        return pulumi.get(self, "admission_configuration")

    @_builtins.property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "always_pull_images")

    @_builtins.property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog']:
        return pulumi.get(self, "audit_log")

    @_builtins.property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit']:
        return pulumi.get(self, "event_rate_limit")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig']:
        return pulumi.get(self, "secrets_encryption_config")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_cluster_ip_range")

    @_builtins.property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_node_port_range")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 plugins: Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPlugin']] = None):
        """
        :param _builtins.str api_version: Admission configuration ApiVersion
        :param _builtins.str kind: Admission configuration Kind
        :param Sequence['ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs'] plugins: Admission configuration plugins
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        Admission configuration ApiVersion
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Admission configuration Kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPlugin']]:
        """
        Admission configuration plugins
        """
        return pulumi.get(self, "plugins")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPlugin(dict):
    def __init__(__self__, *,
                 configuration: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str configuration: Plugin configuration
        :param _builtins.str name: The cluster template name (string)
        :param _builtins.str path: Plugin path
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[_builtins.str]:
        """
        Plugin configuration
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Plugin path
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog(dict):
    def __init__(__self__, *,
                 configuration: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration'] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable cluster template revision. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration']:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "maxBackup":
            suggest = "max_backup"
        elif key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: Optional[_builtins.str] = None,
                 max_age: Optional[_builtins.int] = None,
                 max_backup: Optional[_builtins.int] = None,
                 max_size: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 policy: Optional[_builtins.str] = None):
        if format is not None:
            pulumi.set(__self__, "format", format)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_backup is not None:
            pulumi.set(__self__, "max_backup", max_backup)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_age")

    @_builtins.property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_backup")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "policy")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit(dict):
    def __init__(__self__, *,
                 configuration: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable cluster template revision. Default `true` (bool)
        """
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customConfig":
            suggest = "custom_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_config: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable cluster template revision. Default `true` (bool)
        """
        if custom_config is not None:
            pulumi.set(__self__, "custom_config", custom_config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision. Default `true` (bool)
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCidr":
            suggest = "cluster_cidr"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "serviceClusterIpRange":
            suggest = "service_cluster_ip_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_cidr: Optional[_builtins.str] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None,
                 service_cluster_ip_range: Optional[_builtins.str] = None):
        if cluster_cidr is not None:
            pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if service_cluster_ip_range is not None:
            pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)

    @_builtins.property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_cidr")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_cluster_ip_range")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterDnsServer":
            suggest = "cluster_dns_server"
        elif key == "clusterDomain":
            suggest = "cluster_domain"
        elif key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"
        elif key == "failSwapOn":
            suggest = "fail_swap_on"
        elif key == "generateServingCertificate":
            suggest = "generate_serving_certificate"
        elif key == "infraContainerImage":
            suggest = "infra_container_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_dns_server: Optional[_builtins.str] = None,
                 cluster_domain: Optional[_builtins.str] = None,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 fail_swap_on: Optional[_builtins.bool] = None,
                 generate_serving_certificate: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 infra_container_image: Optional[_builtins.str] = None):
        if cluster_dns_server is not None:
            pulumi.set(__self__, "cluster_dns_server", cluster_dns_server)
        if cluster_domain is not None:
            pulumi.set(__self__, "cluster_domain", cluster_domain)
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if fail_swap_on is not None:
            pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        if generate_serving_certificate is not None:
            pulumi.set(__self__, "generate_serving_certificate", generate_serving_certificate)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if infra_container_image is not None:
            pulumi.set(__self__, "infra_container_image", infra_container_image)

    @_builtins.property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_dns_server")

    @_builtins.property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "cluster_domain")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "fail_swap_on")

    @_builtins.property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "generate_serving_certificate")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "infra_container_image")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None):
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extraArgs":
            suggest = "extra_args"
        elif key == "extraBinds":
            suggest = "extra_binds"
        elif key == "extraEnvs":
            suggest = "extra_envs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extra_args: Optional[Mapping[str, _builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 image: Optional[_builtins.str] = None):
        if extra_args is not None:
            pulumi.set(__self__, "extra_args", extra_args)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainInput":
            suggest = "drain_input"
        elif key == "maxUnavailableControlplane":
            suggest = "max_unavailable_controlplane"
        elif key == "maxUnavailableWorker":
            suggest = "max_unavailable_worker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain: Optional[_builtins.bool] = None,
                 drain_input: Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput'] = None,
                 max_unavailable_controlplane: Optional[_builtins.str] = None,
                 max_unavailable_worker: Optional[_builtins.str] = None):
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if drain_input is not None:
            pulumi.set(__self__, "drain_input", drain_input)
        if max_unavailable_controlplane is not None:
            pulumi.set(__self__, "max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            pulumi.set(__self__, "max_unavailable_worker", max_unavailable_worker)

    @_builtins.property
    @pulumi.getter
    def drain(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "drain")

    @_builtins.property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> Optional['outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput']:
        return pulumi.get(self, "drain_input")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_unavailable_controlplane")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_unavailable_worker")


@pulumi.output_type
class ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteLocalData":
            suggest = "delete_local_data"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "ignoreDaemonSets":
            suggest = "ignore_daemon_sets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_local_data: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        if delete_local_data is not None:
            pulumi.set(__self__, "delete_local_data", delete_local_data)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_local_data")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterTemplateTemplateRevisionQuestion(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 variable: _builtins.str,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str default: Default variable value
        :param _builtins.str variable: Variable name
        :param _builtins.bool required: Required variable
        :param _builtins.str type: Variable type
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "variable", variable)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        """
        Default variable value
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Variable name
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Required variable
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Variable type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ClusterV2AgentEnvVar(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the cluster.
        :param _builtins.str value: The taint value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The taint value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterV2ClusterAgentDeploymentCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendTolerations":
            suggest = "append_tolerations"
        elif key == "overrideAffinity":
            suggest = "override_affinity"
        elif key == "overrideResourceRequirements":
            suggest = "override_resource_requirements"
        elif key == "schedulingCustomizations":
            suggest = "scheduling_customizations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2ClusterAgentDeploymentCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2ClusterAgentDeploymentCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2ClusterAgentDeploymentCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_tolerations: Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationAppendToleration']] = None,
                 override_affinity: Optional[_builtins.str] = None,
                 override_resource_requirements: Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement']] = None,
                 scheduling_customizations: Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization']] = None):
        """
        :param Sequence['ClusterV2ClusterAgentDeploymentCustomizationAppendTolerationArgs'] append_tolerations: User defined tolerations to append to agent
        :param _builtins.str override_affinity: User defined affinity to override default agent affinity
        :param Sequence['ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirementArgs'] override_resource_requirements: User defined resource requirements to set on the agent
        :param Sequence['ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationArgs'] scheduling_customizations: User defined scheduling customization for the cattle cluster agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)
        if scheduling_customizations is not None:
            pulumi.set(__self__, "scheduling_customizations", scheduling_customizations)

    @_builtins.property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationAppendToleration']]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @_builtins.property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[_builtins.str]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @_builtins.property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement']]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")

    @_builtins.property
    @pulumi.getter(name="schedulingCustomizations")
    def scheduling_customizations(self) -> Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization']]:
        """
        User defined scheduling customization for the cattle cluster agent
        """
        return pulumi.get(self, "scheduling_customizations")


@pulumi.output_type
class ClusterV2ClusterAgentDeploymentCustomizationAppendToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Key is the name of the key of the item to retrieve.
        :param _builtins.str effect: The taint effect. Default: `\\"NoExecute\\"`.
        :param _builtins.str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param _builtins.int seconds: The number of seconds a pod will stay bound to a node with a matching taint.
        :param _builtins.str value: The taint value.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key is the name of the key of the item to retrieve.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds a pod will stay bound to a node with a matching taint.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit: Optional[_builtins.str] = None,
                 cpu_request: Optional[_builtins.str] = None,
                 memory_limit: Optional[_builtins.str] = None,
                 memory_request: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_limit: The maximum CPU limit for agent
        :param _builtins.str cpu_request: The minimum CPU required for agent
        :param _builtins.str memory_limit: The maximum memory limit for agent
        :param _builtins.str memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @_builtins.property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[_builtins.str]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @_builtins.property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[_builtins.str]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.str]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @_builtins.property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[_builtins.str]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podDisruptionBudgets":
            suggest = "pod_disruption_budgets"
        elif key == "priorityClasses":
            suggest = "priority_classes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_disruption_budgets: Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget']] = None,
                 priority_classes: Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass']] = None):
        """
        :param Sequence['ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudgetArgs'] pod_disruption_budgets: The Pod Disruption Budget created for the cattle cluster agent
        :param Sequence['ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClassArgs'] priority_classes: The Priority Class created for the cattle cluster agent
        """
        if pod_disruption_budgets is not None:
            pulumi.set(__self__, "pod_disruption_budgets", pod_disruption_budgets)
        if priority_classes is not None:
            pulumi.set(__self__, "priority_classes", priority_classes)

    @_builtins.property
    @pulumi.getter(name="podDisruptionBudgets")
    def pod_disruption_budgets(self) -> Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget']]:
        """
        The Pod Disruption Budget created for the cattle cluster agent
        """
        return pulumi.get(self, "pod_disruption_budgets")

    @_builtins.property
    @pulumi.getter(name="priorityClasses")
    def priority_classes(self) -> Optional[Sequence['outputs.ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass']]:
        """
        The Priority Class created for the cattle cluster agent
        """
        return pulumi.get(self, "priority_classes")


@pulumi.output_type
class ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxUnavailable":
            suggest = "max_unavailable"
        elif key == "minAvailable":
            suggest = "min_available"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPodDisruptionBudget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_unavailable: Optional[_builtins.str] = None,
                 min_available: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_unavailable: The maximum number of cattle cluster agent replicas that can be down at a given time.
        :param _builtins.str min_available: The minimum number of cattle cluster agent replicas that must be running at a given time.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)
        if min_available is not None:
            pulumi.set(__self__, "min_available", min_available)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        The maximum number of cattle cluster agent replicas that can be down at a given time.
        """
        return pulumi.get(self, "max_unavailable")

    @_builtins.property
    @pulumi.getter(name="minAvailable")
    def min_available(self) -> Optional[_builtins.str]:
        """
        The minimum number of cattle cluster agent replicas that must be running at a given time.
        """
        return pulumi.get(self, "min_available")


@pulumi.output_type
class ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preemptionPolicy":
            suggest = "preemption_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2ClusterAgentDeploymentCustomizationSchedulingCustomizationPriorityClass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: _builtins.int,
                 preemption_policy: Optional[_builtins.str] = None):
        """
        :param _builtins.int value: The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
        :param _builtins.str preemption_policy: The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
        """
        pulumi.set(__self__, "value", value)
        if preemption_policy is not None:
            pulumi.set(__self__, "preemption_policy", preemption_policy)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.int:
        """
        The priority value for the cattle cluster agent. Must be between negative 1 billion and 1 billion.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="preemptionPolicy")
    def preemption_policy(self) -> Optional[_builtins.str]:
        """
        The preemption behavior for the cattle cluster agent. Must be either 'PreemptLowerPriority' or 'Never'
        """
        return pulumi.get(self, "preemption_policy")


@pulumi.output_type
class ClusterV2ClusterRegistrationToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "insecureCommand":
            suggest = "insecure_command"
        elif key == "insecureNodeCommand":
            suggest = "insecure_node_command"
        elif key == "insecureWindowsNodeCommand":
            suggest = "insecure_windows_node_command"
        elif key == "manifestUrl":
            suggest = "manifest_url"
        elif key == "nodeCommand":
            suggest = "node_command"
        elif key == "windowsNodeCommand":
            suggest = "windows_node_command"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2ClusterRegistrationToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2ClusterRegistrationToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2ClusterRegistrationToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 cluster_id: Optional[_builtins.str] = None,
                 command: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 insecure_command: Optional[_builtins.str] = None,
                 insecure_node_command: Optional[_builtins.str] = None,
                 insecure_windows_node_command: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 manifest_url: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 node_command: Optional[_builtins.str] = None,
                 token: Optional[_builtins.str] = None,
                 windows_node_command: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] annotations: Annotations for the Cluster.
        :param _builtins.str cluster_id: Cluster ID.
        :param _builtins.str command: Command to execute in an imported k8s cluster.
        :param _builtins.str id: (Computed, string) The ID of the resource.
        :param _builtins.str insecure_command: Insecure command to execute in an imported k8s cluster.
        :param _builtins.str insecure_node_command: Insecure node command to execute in an imported k8s cluster.
        :param _builtins.str insecure_windows_node_command: Insecure windows command to execute in an imported k8s cluster.
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster.
        :param _builtins.str manifest_url: K8s manifest url to execute with `kubectl` to import an existing k8s cluster.
        :param _builtins.str name: The name of the cluster.
        :param _builtins.str node_command: Node command to execute in Linux nodes for custom k8s cluster.
        :param _builtins.str token: Token for cluster registration token object.
        :param _builtins.str windows_node_command: Node command to execute in Windows nodes for custom k8s cluster.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if insecure_command is not None:
            pulumi.set(__self__, "insecure_command", insecure_command)
        if insecure_node_command is not None:
            pulumi.set(__self__, "insecure_node_command", insecure_node_command)
        if insecure_windows_node_command is not None:
            pulumi.set(__self__, "insecure_windows_node_command", insecure_windows_node_command)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if manifest_url is not None:
            pulumi.set(__self__, "manifest_url", manifest_url)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if node_command is not None:
            pulumi.set(__self__, "node_command", node_command)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if windows_node_command is not None:
            pulumi.set(__self__, "windows_node_command", windows_node_command)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations for the Cluster.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[_builtins.str]:
        """
        Cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[_builtins.str]:
        """
        Command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Computed, string) The ID of the resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="insecureCommand")
    def insecure_command(self) -> Optional[_builtins.str]:
        """
        Insecure command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "insecure_command")

    @_builtins.property
    @pulumi.getter(name="insecureNodeCommand")
    def insecure_node_command(self) -> Optional[_builtins.str]:
        """
        Insecure node command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "insecure_node_command")

    @_builtins.property
    @pulumi.getter(name="insecureWindowsNodeCommand")
    def insecure_windows_node_command(self) -> Optional[_builtins.str]:
        """
        Insecure windows command to execute in an imported k8s cluster.
        """
        return pulumi.get(self, "insecure_windows_node_command")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="manifestUrl")
    def manifest_url(self) -> Optional[_builtins.str]:
        """
        K8s manifest url to execute with `kubectl` to import an existing k8s cluster.
        """
        return pulumi.get(self, "manifest_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCommand")
    def node_command(self) -> Optional[_builtins.str]:
        """
        Node command to execute in Linux nodes for custom k8s cluster.
        """
        return pulumi.get(self, "node_command")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Token for cluster registration token object.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="windowsNodeCommand")
    def windows_node_command(self) -> Optional[_builtins.str]:
        """
        Node command to execute in Windows nodes for custom k8s cluster.
        """
        return pulumi.get(self, "windows_node_command")


@pulumi.output_type
class ClusterV2FleetAgentDeploymentCustomization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendTolerations":
            suggest = "append_tolerations"
        elif key == "overrideAffinity":
            suggest = "override_affinity"
        elif key == "overrideResourceRequirements":
            suggest = "override_resource_requirements"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2FleetAgentDeploymentCustomization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2FleetAgentDeploymentCustomization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2FleetAgentDeploymentCustomization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_tolerations: Optional[Sequence['outputs.ClusterV2FleetAgentDeploymentCustomizationAppendToleration']] = None,
                 override_affinity: Optional[_builtins.str] = None,
                 override_resource_requirements: Optional[Sequence['outputs.ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement']] = None):
        """
        :param Sequence['ClusterV2FleetAgentDeploymentCustomizationAppendTolerationArgs'] append_tolerations: User defined tolerations to append to agent
        :param _builtins.str override_affinity: User defined affinity to override default agent affinity
        :param Sequence['ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirementArgs'] override_resource_requirements: User defined resource requirements to set on the agent
        """
        if append_tolerations is not None:
            pulumi.set(__self__, "append_tolerations", append_tolerations)
        if override_affinity is not None:
            pulumi.set(__self__, "override_affinity", override_affinity)
        if override_resource_requirements is not None:
            pulumi.set(__self__, "override_resource_requirements", override_resource_requirements)

    @_builtins.property
    @pulumi.getter(name="appendTolerations")
    def append_tolerations(self) -> Optional[Sequence['outputs.ClusterV2FleetAgentDeploymentCustomizationAppendToleration']]:
        """
        User defined tolerations to append to agent
        """
        return pulumi.get(self, "append_tolerations")

    @_builtins.property
    @pulumi.getter(name="overrideAffinity")
    def override_affinity(self) -> Optional[_builtins.str]:
        """
        User defined affinity to override default agent affinity
        """
        return pulumi.get(self, "override_affinity")

    @_builtins.property
    @pulumi.getter(name="overrideResourceRequirements")
    def override_resource_requirements(self) -> Optional[Sequence['outputs.ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement']]:
        """
        User defined resource requirements to set on the agent
        """
        return pulumi.get(self, "override_resource_requirements")


@pulumi.output_type
class ClusterV2FleetAgentDeploymentCustomizationAppendToleration(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Key is the name of the key of the item to retrieve.
        :param _builtins.str effect: The taint effect. Default: `\\"NoExecute\\"`.
        :param _builtins.str operator: Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        :param _builtins.int seconds: The number of seconds a pod will stay bound to a node with a matching taint.
        :param _builtins.str value: The taint value.
        """
        pulumi.set(__self__, "key", key)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key is the name of the key of the item to retrieve.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds a pod will stay bound to a node with a matching taint.
        """
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The taint value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuLimit":
            suggest = "cpu_limit"
        elif key == "cpuRequest":
            suggest = "cpu_request"
        elif key == "memoryLimit":
            suggest = "memory_limit"
        elif key == "memoryRequest":
            suggest = "memory_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2FleetAgentDeploymentCustomizationOverrideResourceRequirement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_limit: Optional[_builtins.str] = None,
                 cpu_request: Optional[_builtins.str] = None,
                 memory_limit: Optional[_builtins.str] = None,
                 memory_request: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu_limit: The maximum CPU limit for agent
        :param _builtins.str cpu_request: The minimum CPU required for agent
        :param _builtins.str memory_limit: The maximum memory limit for agent
        :param _builtins.str memory_request: The minimum memory required for agent
        """
        if cpu_limit is not None:
            pulumi.set(__self__, "cpu_limit", cpu_limit)
        if cpu_request is not None:
            pulumi.set(__self__, "cpu_request", cpu_request)
        if memory_limit is not None:
            pulumi.set(__self__, "memory_limit", memory_limit)
        if memory_request is not None:
            pulumi.set(__self__, "memory_request", memory_request)

    @_builtins.property
    @pulumi.getter(name="cpuLimit")
    def cpu_limit(self) -> Optional[_builtins.str]:
        """
        The maximum CPU limit for agent
        """
        return pulumi.get(self, "cpu_limit")

    @_builtins.property
    @pulumi.getter(name="cpuRequest")
    def cpu_request(self) -> Optional[_builtins.str]:
        """
        The minimum CPU required for agent
        """
        return pulumi.get(self, "cpu_request")

    @_builtins.property
    @pulumi.getter(name="memoryLimit")
    def memory_limit(self) -> Optional[_builtins.str]:
        """
        The maximum memory limit for agent
        """
        return pulumi.get(self, "memory_limit")

    @_builtins.property
    @pulumi.getter(name="memoryRequest")
    def memory_request(self) -> Optional[_builtins.str]:
        """
        The minimum memory required for agent
        """
        return pulumi.get(self, "memory_request")


@pulumi.output_type
class ClusterV2LocalAuthEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2LocalAuthEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2LocalAuthEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2LocalAuthEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certs: CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        :param _builtins.bool enabled: If `enabled` is set to true, nodes will be drained before upgrade.
        :param _builtins.str fqdn: FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        """
        CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        """
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If `enabled` is set to true, nodes will be drained before upgrade.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class ClusterV2RkeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalManifest":
            suggest = "additional_manifest"
        elif key == "chartValues":
            suggest = "chart_values"
        elif key == "etcdSnapshotCreate":
            suggest = "etcd_snapshot_create"
        elif key == "etcdSnapshotRestore":
            suggest = "etcd_snapshot_restore"
        elif key == "localAuthEndpoint":
            suggest = "local_auth_endpoint"
        elif key == "machineGlobalConfig":
            suggest = "machine_global_config"
        elif key == "machinePoolDefaults":
            suggest = "machine_pool_defaults"
        elif key == "machinePools":
            suggest = "machine_pools"
        elif key == "machineSelectorConfigs":
            suggest = "machine_selector_configs"
        elif key == "machineSelectorFiles":
            suggest = "machine_selector_files"
        elif key == "rotateCertificates":
            suggest = "rotate_certificates"
        elif key == "upgradeStrategy":
            suggest = "upgrade_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_manifest: Optional[_builtins.str] = None,
                 chart_values: Optional[_builtins.str] = None,
                 etcd: Optional['outputs.ClusterV2RkeConfigEtcd'] = None,
                 etcd_snapshot_create: Optional['outputs.ClusterV2RkeConfigEtcdSnapshotCreate'] = None,
                 etcd_snapshot_restore: Optional['outputs.ClusterV2RkeConfigEtcdSnapshotRestore'] = None,
                 local_auth_endpoint: Optional['outputs.ClusterV2RkeConfigLocalAuthEndpoint'] = None,
                 machine_global_config: Optional[_builtins.str] = None,
                 machine_pool_defaults: Optional[Sequence['outputs.ClusterV2RkeConfigMachinePoolDefault']] = None,
                 machine_pools: Optional[Sequence['outputs.ClusterV2RkeConfigMachinePool']] = None,
                 machine_selector_configs: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorConfig']] = None,
                 machine_selector_files: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFile']] = None,
                 registries: Optional['outputs.ClusterV2RkeConfigRegistries'] = None,
                 rotate_certificates: Optional['outputs.ClusterV2RkeConfigRotateCertificates'] = None,
                 upgrade_strategy: Optional['outputs.ClusterV2RkeConfigUpgradeStrategy'] = None):
        """
        :param _builtins.str additional_manifest: Cluster V2 additional manifest
        :param _builtins.str chart_values: Cluster V2 chart values. It should be in YAML format
        :param 'ClusterV2RkeConfigEtcdArgs' etcd: Cluster V2 etcd
        :param 'ClusterV2RkeConfigEtcdSnapshotCreateArgs' etcd_snapshot_create: Cluster V2 etcd snapshot create
        :param 'ClusterV2RkeConfigEtcdSnapshotRestoreArgs' etcd_snapshot_restore: Cluster V2 etcd snapshot restore
        :param 'ClusterV2RkeConfigLocalAuthEndpointArgs' local_auth_endpoint: Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to [Rancher Documentation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/kubernetes-clusters-in-rancher-setup/register-existing-clusters#authorized-cluster-endpoint-support-for-rke2-and-k3s-clusters).
        :param _builtins.str machine_global_config: Cluster V2 machine global config
        :param Sequence['ClusterV2RkeConfigMachinePoolDefaultArgs'] machine_pool_defaults: Default values for machine pool configurations if unset
        :param Sequence['ClusterV2RkeConfigMachinePoolArgs'] machine_pools: Cluster V2 machine pools
        :param Sequence['ClusterV2RkeConfigMachineSelectorConfigArgs'] machine_selector_configs: Cluster V2 machine selector config
        :param Sequence['ClusterV2RkeConfigMachineSelectorFileArgs'] machine_selector_files: Cluster V2 machine selector files
        :param 'ClusterV2RkeConfigRegistriesArgs' registries: Cluster V2 registries
        :param 'ClusterV2RkeConfigRotateCertificatesArgs' rotate_certificates: Cluster V2 certificate rotation
        :param 'ClusterV2RkeConfigUpgradeStrategyArgs' upgrade_strategy: Cluster V2 upgrade strategy
        """
        if additional_manifest is not None:
            pulumi.set(__self__, "additional_manifest", additional_manifest)
        if chart_values is not None:
            pulumi.set(__self__, "chart_values", chart_values)
        if etcd is not None:
            pulumi.set(__self__, "etcd", etcd)
        if etcd_snapshot_create is not None:
            pulumi.set(__self__, "etcd_snapshot_create", etcd_snapshot_create)
        if etcd_snapshot_restore is not None:
            pulumi.set(__self__, "etcd_snapshot_restore", etcd_snapshot_restore)
        if local_auth_endpoint is not None:
            pulumi.set(__self__, "local_auth_endpoint", local_auth_endpoint)
        if machine_global_config is not None:
            pulumi.set(__self__, "machine_global_config", machine_global_config)
        if machine_pool_defaults is not None:
            pulumi.set(__self__, "machine_pool_defaults", machine_pool_defaults)
        if machine_pools is not None:
            pulumi.set(__self__, "machine_pools", machine_pools)
        if machine_selector_configs is not None:
            pulumi.set(__self__, "machine_selector_configs", machine_selector_configs)
        if machine_selector_files is not None:
            pulumi.set(__self__, "machine_selector_files", machine_selector_files)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if rotate_certificates is not None:
            pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)

    @_builtins.property
    @pulumi.getter(name="additionalManifest")
    def additional_manifest(self) -> Optional[_builtins.str]:
        """
        Cluster V2 additional manifest
        """
        return pulumi.get(self, "additional_manifest")

    @_builtins.property
    @pulumi.getter(name="chartValues")
    def chart_values(self) -> Optional[_builtins.str]:
        """
        Cluster V2 chart values. It should be in YAML format
        """
        return pulumi.get(self, "chart_values")

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> Optional['outputs.ClusterV2RkeConfigEtcd']:
        """
        Cluster V2 etcd
        """
        return pulumi.get(self, "etcd")

    @_builtins.property
    @pulumi.getter(name="etcdSnapshotCreate")
    def etcd_snapshot_create(self) -> Optional['outputs.ClusterV2RkeConfigEtcdSnapshotCreate']:
        """
        Cluster V2 etcd snapshot create
        """
        return pulumi.get(self, "etcd_snapshot_create")

    @_builtins.property
    @pulumi.getter(name="etcdSnapshotRestore")
    def etcd_snapshot_restore(self) -> Optional['outputs.ClusterV2RkeConfigEtcdSnapshotRestore']:
        """
        Cluster V2 etcd snapshot restore
        """
        return pulumi.get(self, "etcd_snapshot_restore")

    @_builtins.property
    @pulumi.getter(name="localAuthEndpoint")
    @_utilities.deprecated("""Use rancher2_cluster_v2.local_auth_endpoint instead""")
    def local_auth_endpoint(self) -> Optional['outputs.ClusterV2RkeConfigLocalAuthEndpoint']:
        """
        Local auth endpoint configures the Authorized Cluster Endpoint (ACE) which can be used to directly access the Kubernetes API server, without requiring communication through Rancher. For more information, please refer to [Rancher Documentation](https://ranchermanager.docs.rancher.com/how-to-guides/new-user-guides/kubernetes-clusters-in-rancher-setup/register-existing-clusters#authorized-cluster-endpoint-support-for-rke2-and-k3s-clusters).
        """
        return pulumi.get(self, "local_auth_endpoint")

    @_builtins.property
    @pulumi.getter(name="machineGlobalConfig")
    def machine_global_config(self) -> Optional[_builtins.str]:
        """
        Cluster V2 machine global config
        """
        return pulumi.get(self, "machine_global_config")

    @_builtins.property
    @pulumi.getter(name="machinePoolDefaults")
    def machine_pool_defaults(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachinePoolDefault']]:
        """
        Default values for machine pool configurations if unset
        """
        return pulumi.get(self, "machine_pool_defaults")

    @_builtins.property
    @pulumi.getter(name="machinePools")
    def machine_pools(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachinePool']]:
        """
        Cluster V2 machine pools
        """
        return pulumi.get(self, "machine_pools")

    @_builtins.property
    @pulumi.getter(name="machineSelectorConfigs")
    def machine_selector_configs(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorConfig']]:
        """
        Cluster V2 machine selector config
        """
        return pulumi.get(self, "machine_selector_configs")

    @_builtins.property
    @pulumi.getter(name="machineSelectorFiles")
    def machine_selector_files(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFile']]:
        """
        Cluster V2 machine selector files
        """
        return pulumi.get(self, "machine_selector_files")

    @_builtins.property
    @pulumi.getter
    def registries(self) -> Optional['outputs.ClusterV2RkeConfigRegistries']:
        """
        Cluster V2 registries
        """
        return pulumi.get(self, "registries")

    @_builtins.property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> Optional['outputs.ClusterV2RkeConfigRotateCertificates']:
        """
        Cluster V2 certificate rotation
        """
        return pulumi.get(self, "rotate_certificates")

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional['outputs.ClusterV2RkeConfigUpgradeStrategy']:
        """
        Cluster V2 upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")


@pulumi.output_type
class ClusterV2RkeConfigEtcd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableSnapshots":
            suggest = "disable_snapshots"
        elif key == "s3Config":
            suggest = "s3_config"
        elif key == "snapshotRetention":
            suggest = "snapshot_retention"
        elif key == "snapshotScheduleCron":
            suggest = "snapshot_schedule_cron"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigEtcd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigEtcd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigEtcd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_snapshots: Optional[_builtins.bool] = None,
                 s3_config: Optional['outputs.ClusterV2RkeConfigEtcdS3Config'] = None,
                 snapshot_retention: Optional[_builtins.int] = None,
                 snapshot_schedule_cron: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_snapshots: Disable ETCD snapshots
        :param 'ClusterV2RkeConfigEtcdS3ConfigArgs' s3_config: ETCD snapshot S3 config
        :param _builtins.int snapshot_retention: ETCD snapshot retention
        :param _builtins.str snapshot_schedule_cron: ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
        if disable_snapshots is not None:
            pulumi.set(__self__, "disable_snapshots", disable_snapshots)
        if s3_config is not None:
            pulumi.set(__self__, "s3_config", s3_config)
        if snapshot_retention is not None:
            pulumi.set(__self__, "snapshot_retention", snapshot_retention)
        if snapshot_schedule_cron is not None:
            pulumi.set(__self__, "snapshot_schedule_cron", snapshot_schedule_cron)

    @_builtins.property
    @pulumi.getter(name="disableSnapshots")
    def disable_snapshots(self) -> Optional[_builtins.bool]:
        """
        Disable ETCD snapshots
        """
        return pulumi.get(self, "disable_snapshots")

    @_builtins.property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> Optional['outputs.ClusterV2RkeConfigEtcdS3Config']:
        """
        ETCD snapshot S3 config
        """
        return pulumi.get(self, "s3_config")

    @_builtins.property
    @pulumi.getter(name="snapshotRetention")
    def snapshot_retention(self) -> Optional[_builtins.int]:
        """
        ETCD snapshot retention
        """
        return pulumi.get(self, "snapshot_retention")

    @_builtins.property
    @pulumi.getter(name="snapshotScheduleCron")
    def snapshot_schedule_cron(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
        return pulumi.get(self, "snapshot_schedule_cron")


@pulumi.output_type
class ClusterV2RkeConfigEtcdS3Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudCredentialName":
            suggest = "cloud_credential_name"
        elif key == "endpointCa":
            suggest = "endpoint_ca"
        elif key == "skipSslVerify":
            suggest = "skip_ssl_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigEtcdS3Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigEtcdS3Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigEtcdS3Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 endpoint: _builtins.str,
                 cloud_credential_name: Optional[_builtins.str] = None,
                 endpoint_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 skip_ssl_verify: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: ETCD snapshot S3 bucket
        :param _builtins.str endpoint: ETCD snapshot S3 endpoint
        :param _builtins.str cloud_credential_name: ETCD snapshot S3 cloud credential name
        :param _builtins.str endpoint_ca: ETCD snapshot S3 endpoint CA
        :param _builtins.str folder: ETCD snapshot S3 folder
        :param _builtins.str region: ETCD snapshot S3 region
        :param _builtins.bool skip_ssl_verify: Disable ETCD skip ssl verify
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "endpoint", endpoint)
        if cloud_credential_name is not None:
            pulumi.set(__self__, "cloud_credential_name", cloud_credential_name)
        if endpoint_ca is not None:
            pulumi.set(__self__, "endpoint_ca", endpoint_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if skip_ssl_verify is not None:
            pulumi.set(__self__, "skip_ssl_verify", skip_ssl_verify)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        ETCD snapshot S3 bucket
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        ETCD snapshot S3 endpoint
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="cloudCredentialName")
    def cloud_credential_name(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 cloud credential name
        """
        return pulumi.get(self, "cloud_credential_name")

    @_builtins.property
    @pulumi.getter(name="endpointCa")
    def endpoint_ca(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 endpoint CA
        """
        return pulumi.get(self, "endpoint_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 folder
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="skipSslVerify")
    def skip_ssl_verify(self) -> Optional[_builtins.bool]:
        """
        Disable ETCD skip ssl verify
        """
        return pulumi.get(self, "skip_ssl_verify")


@pulumi.output_type
class ClusterV2RkeConfigEtcdSnapshotCreate(dict):
    def __init__(__self__, *,
                 generation: _builtins.int):
        """
        :param _builtins.int generation: ETCD generation to initiate a snapshot
        """
        pulumi.set(__self__, "generation", generation)

    @_builtins.property
    @pulumi.getter
    def generation(self) -> _builtins.int:
        """
        ETCD generation to initiate a snapshot
        """
        return pulumi.get(self, "generation")


@pulumi.output_type
class ClusterV2RkeConfigEtcdSnapshotRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restoreRkeConfig":
            suggest = "restore_rke_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigEtcdSnapshotRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigEtcdSnapshotRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigEtcdSnapshotRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generation: _builtins.int,
                 name: _builtins.str,
                 restore_rke_config: Optional[_builtins.str] = None):
        """
        :param _builtins.int generation: ETCD snapshot desired generation
        :param _builtins.str name: The name of the cluster.
        :param _builtins.str restore_rke_config: ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "name", name)
        if restore_rke_config is not None:
            pulumi.set(__self__, "restore_rke_config", restore_rke_config)

    @_builtins.property
    @pulumi.getter
    def generation(self) -> _builtins.int:
        """
        ETCD snapshot desired generation
        """
        return pulumi.get(self, "generation")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="restoreRkeConfig")
    def restore_rke_config(self) -> Optional[_builtins.str]:
        """
        ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
        return pulumi.get(self, "restore_rke_config")


@pulumi.output_type
class ClusterV2RkeConfigLocalAuthEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigLocalAuthEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigLocalAuthEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigLocalAuthEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certs: CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        :param _builtins.bool enabled: If `enabled` is set to true, nodes will be drained before upgrade.
        :param _builtins.str fqdn: FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        """
        CA certs for the authorized cluster endpoint. It is only needed if there is a load balancer in front of the downstream cluster that is using an untrusted certificate. If you have a valid certificate, then nothing needs to be added to the CA Certificates field.
        """
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If `enabled` is set to true, nodes will be drained before upgrade.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        FQDN for the authorized cluster endpoint. If one is entered, it should point to the downstream cluster.
        """
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class ClusterV2RkeConfigMachinePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineConfig":
            suggest = "machine_config"
        elif key == "cloudCredentialSecretName":
            suggest = "cloud_credential_secret_name"
        elif key == "controlPlaneRole":
            suggest = "control_plane_role"
        elif key == "drainBeforeDelete":
            suggest = "drain_before_delete"
        elif key == "etcdRole":
            suggest = "etcd_role"
        elif key == "hostnameLengthLimit":
            suggest = "hostname_length_limit"
        elif key == "machineLabels":
            suggest = "machine_labels"
        elif key == "machineOs":
            suggest = "machine_os"
        elif key == "maxUnhealthy":
            suggest = "max_unhealthy"
        elif key == "nodeDrainTimeout":
            suggest = "node_drain_timeout"
        elif key == "nodeStartupTimeoutSeconds":
            suggest = "node_startup_timeout_seconds"
        elif key == "rollingUpdate":
            suggest = "rolling_update"
        elif key == "unhealthyNodeTimeoutSeconds":
            suggest = "unhealthy_node_timeout_seconds"
        elif key == "unhealthyRange":
            suggest = "unhealthy_range"
        elif key == "workerRole":
            suggest = "worker_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachinePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachinePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachinePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_config: 'outputs.ClusterV2RkeConfigMachinePoolMachineConfig',
                 name: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 cloud_credential_secret_name: Optional[_builtins.str] = None,
                 control_plane_role: Optional[_builtins.bool] = None,
                 drain_before_delete: Optional[_builtins.bool] = None,
                 etcd_role: Optional[_builtins.bool] = None,
                 hostname_length_limit: Optional[_builtins.int] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 machine_labels: Optional[Mapping[str, _builtins.str]] = None,
                 machine_os: Optional[_builtins.str] = None,
                 max_unhealthy: Optional[_builtins.str] = None,
                 node_drain_timeout: Optional[_builtins.int] = None,
                 node_startup_timeout_seconds: Optional[_builtins.int] = None,
                 paused: Optional[_builtins.bool] = None,
                 quantity: Optional[_builtins.int] = None,
                 rolling_update: Optional['outputs.ClusterV2RkeConfigMachinePoolRollingUpdate'] = None,
                 taints: Optional[Sequence['outputs.ClusterV2RkeConfigMachinePoolTaint']] = None,
                 unhealthy_node_timeout_seconds: Optional[_builtins.int] = None,
                 unhealthy_range: Optional[_builtins.str] = None,
                 worker_role: Optional[_builtins.bool] = None):
        """
        :param 'ClusterV2RkeConfigMachinePoolMachineConfigArgs' machine_config: Machine config data
        :param _builtins.str name: The name of the cluster.
        :param Mapping[str, _builtins.str] annotations: Annotations for the Cluster.
        :param _builtins.str cloud_credential_secret_name: Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
        :param _builtins.bool control_plane_role: Machine pool control plane role
        :param _builtins.bool drain_before_delete: Machine pool drain before delete
        :param _builtins.bool etcd_role: Machine pool etcd role
        :param _builtins.int hostname_length_limit: maximum length for autogenerated hostname
        :param Mapping[str, _builtins.str] labels: Labels for the Cluster.
        :param Mapping[str, _builtins.str] machine_labels: Labels for the machine pool nodes
        :param _builtins.str machine_os: OS Type in machine pool
        :param _builtins.str max_unhealthy: max unhealthy nodes for automated replacement to be allowed
        :param _builtins.int node_drain_timeout: seconds to wait for machine pool drain to complete before machine deletion
        :param _builtins.int node_startup_timeout_seconds: seconds a new node has to become active before it is replaced
        :param _builtins.bool paused: Machine pool paused
        :param _builtins.int quantity: Machine pool quantity
        :param 'ClusterV2RkeConfigMachinePoolRollingUpdateArgs' rolling_update: Machine pool rolling update
        :param Sequence['ClusterV2RkeConfigMachinePoolTaintArgs'] taints: Machine pool taints
        :param _builtins.int unhealthy_node_timeout_seconds: seconds an unhealthy node has to become active before it is replaced
        :param _builtins.str unhealthy_range: range of unhealthy nodes for automated replacement to be allowed
        :param _builtins.bool worker_role: Machine pool worker role
        """
        pulumi.set(__self__, "machine_config", machine_config)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cloud_credential_secret_name is not None:
            pulumi.set(__self__, "cloud_credential_secret_name", cloud_credential_secret_name)
        if control_plane_role is not None:
            pulumi.set(__self__, "control_plane_role", control_plane_role)
        if drain_before_delete is not None:
            pulumi.set(__self__, "drain_before_delete", drain_before_delete)
        if etcd_role is not None:
            pulumi.set(__self__, "etcd_role", etcd_role)
        if hostname_length_limit is not None:
            pulumi.set(__self__, "hostname_length_limit", hostname_length_limit)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if machine_labels is not None:
            pulumi.set(__self__, "machine_labels", machine_labels)
        if machine_os is not None:
            pulumi.set(__self__, "machine_os", machine_os)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_startup_timeout_seconds is not None:
            pulumi.set(__self__, "node_startup_timeout_seconds", node_startup_timeout_seconds)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if unhealthy_node_timeout_seconds is not None:
            pulumi.set(__self__, "unhealthy_node_timeout_seconds", unhealthy_node_timeout_seconds)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)
        if worker_role is not None:
            pulumi.set(__self__, "worker_role", worker_role)

    @_builtins.property
    @pulumi.getter(name="machineConfig")
    def machine_config(self) -> 'outputs.ClusterV2RkeConfigMachinePoolMachineConfig':
        """
        Machine config data
        """
        return pulumi.get(self, "machine_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations for the Cluster.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="cloudCredentialSecretName")
    def cloud_credential_secret_name(self) -> Optional[_builtins.str]:
        """
        Cloud credential secret name is the secret to be used when a cloud credential secret name is not specified at the machine pool level.
        """
        return pulumi.get(self, "cloud_credential_secret_name")

    @_builtins.property
    @pulumi.getter(name="controlPlaneRole")
    def control_plane_role(self) -> Optional[_builtins.bool]:
        """
        Machine pool control plane role
        """
        return pulumi.get(self, "control_plane_role")

    @_builtins.property
    @pulumi.getter(name="drainBeforeDelete")
    def drain_before_delete(self) -> Optional[_builtins.bool]:
        """
        Machine pool drain before delete
        """
        return pulumi.get(self, "drain_before_delete")

    @_builtins.property
    @pulumi.getter(name="etcdRole")
    def etcd_role(self) -> Optional[_builtins.bool]:
        """
        Machine pool etcd role
        """
        return pulumi.get(self, "etcd_role")

    @_builtins.property
    @pulumi.getter(name="hostnameLengthLimit")
    def hostname_length_limit(self) -> Optional[_builtins.int]:
        """
        maximum length for autogenerated hostname
        """
        return pulumi.get(self, "hostname_length_limit")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the Cluster.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="machineLabels")
    def machine_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the machine pool nodes
        """
        return pulumi.get(self, "machine_labels")

    @_builtins.property
    @pulumi.getter(name="machineOs")
    def machine_os(self) -> Optional[_builtins.str]:
        """
        OS Type in machine pool
        """
        return pulumi.get(self, "machine_os")

    @_builtins.property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[_builtins.str]:
        """
        max unhealthy nodes for automated replacement to be allowed
        """
        return pulumi.get(self, "max_unhealthy")

    @_builtins.property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[_builtins.int]:
        """
        seconds to wait for machine pool drain to complete before machine deletion
        """
        return pulumi.get(self, "node_drain_timeout")

    @_builtins.property
    @pulumi.getter(name="nodeStartupTimeoutSeconds")
    def node_startup_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        seconds a new node has to become active before it is replaced
        """
        return pulumi.get(self, "node_startup_timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        Machine pool paused
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> Optional[_builtins.int]:
        """
        Machine pool quantity
        """
        return pulumi.get(self, "quantity")

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.ClusterV2RkeConfigMachinePoolRollingUpdate']:
        """
        Machine pool rolling update
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachinePoolTaint']]:
        """
        Machine pool taints
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="unhealthyNodeTimeoutSeconds")
    def unhealthy_node_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        seconds an unhealthy node has to become active before it is replaced
        """
        return pulumi.get(self, "unhealthy_node_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[_builtins.str]:
        """
        range of unhealthy nodes for automated replacement to be allowed
        """
        return pulumi.get(self, "unhealthy_range")

    @_builtins.property
    @pulumi.getter(name="workerRole")
    def worker_role(self) -> Optional[_builtins.bool]:
        """
        Machine pool worker role
        """
        return pulumi.get(self, "worker_role")


@pulumi.output_type
class ClusterV2RkeConfigMachinePoolDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostnameLengthLimit":
            suggest = "hostname_length_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachinePoolDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachinePoolDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachinePoolDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname_length_limit: Optional[_builtins.int] = None):
        """
        :param _builtins.int hostname_length_limit: maximum length for autogenerated hostname
        """
        if hostname_length_limit is not None:
            pulumi.set(__self__, "hostname_length_limit", hostname_length_limit)

    @_builtins.property
    @pulumi.getter(name="hostnameLengthLimit")
    def hostname_length_limit(self) -> Optional[_builtins.int]:
        """
        maximum length for autogenerated hostname
        """
        return pulumi.get(self, "hostname_length_limit")


@pulumi.output_type
class ClusterV2RkeConfigMachinePoolMachineConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachinePoolMachineConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachinePoolMachineConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachinePoolMachineConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 api_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: Machine config kind
        :param _builtins.str name: The name of the cluster.
        :param _builtins.str api_version: Machine config API version
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Machine config kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        Machine config API version
        """
        return pulumi.get(self, "api_version")


@pulumi.output_type
class ClusterV2RkeConfigMachinePoolRollingUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachinePoolRollingUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachinePoolRollingUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachinePoolRollingUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[_builtins.str] = None,
                 max_unavailable: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_surge: Rolling update max surge
        :param _builtins.str max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class ClusterV2RkeConfigMachinePoolTaint(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 effect: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Key is the name of the key of the item to retrieve.
        :param _builtins.str value: The taint value.
        :param _builtins.str effect: The taint effect. Default: `\\"NoExecute\\"`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key is the name of the key of the item to retrieve.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The taint value.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        The taint effect. Default: `\\"NoExecute\\"`.
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineLabelSelector":
            suggest = "machine_label_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachineSelectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachineSelectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachineSelectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config: Optional[_builtins.str] = None,
                 machine_label_selector: Optional['outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector'] = None):
        """
        :param _builtins.str config: Machine selector config
        :param 'ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs' machine_label_selector: Machine label selector
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if machine_label_selector is not None:
            pulumi.set(__self__, "machine_label_selector", machine_label_selector)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[_builtins.str]:
        """
        Machine selector config
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="machineLabelSelector")
    def machine_label_selector(self) -> Optional['outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector']:
        """
        Machine label selector
        """
        return pulumi.get(self, "machine_label_selector")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs'] match_expressions: Label selector match expressions
        :param Mapping[str, _builtins.str] match_labels: Label selector match labels
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression']]:
        """
        Label selector match expressions
        """
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Label selector match labels
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: Label selector requirement key
        :param _builtins.str operator: Label selector operator
        :param Sequence[_builtins.str] values: Label selector requirement values
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Label selector requirement key
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Label selector operator
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Label selector requirement values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSources":
            suggest = "file_sources"
        elif key == "machineLabelSelector":
            suggest = "machine_label_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachineSelectorFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachineSelectorFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachineSelectorFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_sources: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileFileSource']] = None,
                 machine_label_selector: Optional['outputs.ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector'] = None):
        """
        :param Sequence['ClusterV2RkeConfigMachineSelectorFileFileSourceArgs'] file_sources: File sources
        :param 'ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs' machine_label_selector: Machine label selector
        """
        if file_sources is not None:
            pulumi.set(__self__, "file_sources", file_sources)
        if machine_label_selector is not None:
            pulumi.set(__self__, "machine_label_selector", machine_label_selector)

    @_builtins.property
    @pulumi.getter(name="fileSources")
    def file_sources(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileFileSource']]:
        """
        File sources
        """
        return pulumi.get(self, "file_sources")

    @_builtins.property
    @pulumi.getter(name="machineLabelSelector")
    def machine_label_selector(self) -> Optional['outputs.ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector']:
        """
        Machine label selector
        """
        return pulumi.get(self, "machine_label_selector")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileFileSource(dict):
    def __init__(__self__, *,
                 configmap: Optional['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap'] = None,
                 secret: Optional['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceSecret'] = None):
        """
        :param 'ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs' configmap: The configmap which is the source of files
        :param 'ClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs' secret: The secret which is the source of files
        """
        if configmap is not None:
            pulumi.set(__self__, "configmap", configmap)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def configmap(self) -> Optional['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap']:
        """
        The configmap which is the source of files
        """
        return pulumi.get(self, "configmap")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceSecret']:
        """
        The secret which is the source of files
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPermissions":
            suggest = "default_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 default_permissions: Optional[_builtins.str] = None,
                 items: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem']] = None):
        """
        :param _builtins.str name: The name of the cluster.
        :param _builtins.str default_permissions: The default permissions to be applied when they are not set at the item level
        :param Sequence['ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs'] items: Items(files) to retrieve from the K8s object
        """
        pulumi.set(__self__, "name", name)
        if default_permissions is not None:
            pulumi.set(__self__, "default_permissions", default_permissions)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultPermissions")
    def default_permissions(self) -> Optional[_builtins.str]:
        """
        The default permissions to be applied when they are not set at the item level
        """
        return pulumi.get(self, "default_permissions")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem']]:
        """
        Items(files) to retrieve from the K8s object
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItem(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 path: _builtins.str,
                 dynamic: Optional[_builtins.bool] = None,
                 hash: Optional[_builtins.str] = None,
                 permissions: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the item(file) to retrieve
        :param _builtins.str path: The path to put the file in the target node
        :param _builtins.bool dynamic: If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        :param _builtins.str hash: The base64 encoded value of the SHA256 checksum of the file's content
        :param _builtins.str permissions: The numeric representation of the file permissions
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the item(file) to retrieve
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to put the file in the target node
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[_builtins.bool]:
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        return pulumi.get(self, "dynamic")

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[_builtins.str]:
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[_builtins.str]:
        """
        The numeric representation of the file permissions
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPermissions":
            suggest = "default_permissions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachineSelectorFileFileSourceSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachineSelectorFileFileSourceSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachineSelectorFileFileSourceSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 default_permissions: Optional[_builtins.str] = None,
                 items: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem']] = None):
        """
        :param _builtins.str name: The name of the cluster.
        :param _builtins.str default_permissions: The default permissions to be applied when they are not set at the item level
        :param Sequence['ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs'] items: Items(files) to retrieve from the K8s object
        """
        pulumi.set(__self__, "name", name)
        if default_permissions is not None:
            pulumi.set(__self__, "default_permissions", default_permissions)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultPermissions")
    def default_permissions(self) -> Optional[_builtins.str]:
        """
        The default permissions to be applied when they are not set at the item level
        """
        return pulumi.get(self, "default_permissions")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem']]:
        """
        Items(files) to retrieve from the K8s object
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileFileSourceSecretItem(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 path: _builtins.str,
                 dynamic: Optional[_builtins.bool] = None,
                 hash: Optional[_builtins.str] = None,
                 permissions: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the item(file) to retrieve
        :param _builtins.str path: The path to put the file in the target node
        :param _builtins.bool dynamic: If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        :param _builtins.str hash: The base64 encoded value of the SHA256 checksum of the file's content
        :param _builtins.str permissions: The numeric representation of the file permissions
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the item(file) to retrieve
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to put the file in the target node
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[_builtins.bool]:
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        return pulumi.get(self, "dynamic")

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[_builtins.str]:
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[_builtins.str]:
        """
        The numeric representation of the file permissions
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchExpressions":
            suggest = "match_expressions"
        elif key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigMachineSelectorFileMachineLabelSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs'] match_expressions: Label selector match expressions
        :param Mapping[str, _builtins.str] match_labels: Label selector match labels
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression']]:
        """
        Label selector match expressions
        """
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Label selector match labels
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpression(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: Label selector requirement key
        :param _builtins.str operator: Label selector operator
        :param Sequence[_builtins.str] values: Label selector requirement values
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Label selector requirement key
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Label selector operator
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Label selector requirement values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class ClusterV2RkeConfigRegistries(dict):
    def __init__(__self__, *,
                 configs: Optional[Sequence['outputs.ClusterV2RkeConfigRegistriesConfig']] = None,
                 mirrors: Optional[Sequence['outputs.ClusterV2RkeConfigRegistriesMirror']] = None):
        """
        :param Sequence['ClusterV2RkeConfigRegistriesConfigArgs'] configs: Registry config
        :param Sequence['ClusterV2RkeConfigRegistriesMirrorArgs'] mirrors: Registry mirrors
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigRegistriesConfig']]:
        """
        Registry config
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['outputs.ClusterV2RkeConfigRegistriesMirror']]:
        """
        Registry mirrors
        """
        return pulumi.get(self, "mirrors")


@pulumi.output_type
class ClusterV2RkeConfigRegistriesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authConfigSecretName":
            suggest = "auth_config_secret_name"
        elif key == "caBundle":
            suggest = "ca_bundle"
        elif key == "tlsSecretName":
            suggest = "tls_secret_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigRegistriesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigRegistriesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigRegistriesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 auth_config_secret_name: Optional[_builtins.str] = None,
                 ca_bundle: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 tls_secret_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: Registry hostname
        :param _builtins.str auth_config_secret_name: Registry auth config secret name
        :param _builtins.str ca_bundle: Registry CA bundle
        :param _builtins.bool insecure: Registry insecure connectivity
        :param _builtins.str tls_secret_name: Registry TLS secret name. TLS is a pair of Cert/Key
        """
        pulumi.set(__self__, "hostname", hostname)
        if auth_config_secret_name is not None:
            pulumi.set(__self__, "auth_config_secret_name", auth_config_secret_name)
        if ca_bundle is not None:
            pulumi.set(__self__, "ca_bundle", ca_bundle)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if tls_secret_name is not None:
            pulumi.set(__self__, "tls_secret_name", tls_secret_name)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Registry hostname
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="authConfigSecretName")
    def auth_config_secret_name(self) -> Optional[_builtins.str]:
        """
        Registry auth config secret name
        """
        return pulumi.get(self, "auth_config_secret_name")

    @_builtins.property
    @pulumi.getter(name="caBundle")
    def ca_bundle(self) -> Optional[_builtins.str]:
        """
        Registry CA bundle
        """
        return pulumi.get(self, "ca_bundle")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Registry insecure connectivity
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter(name="tlsSecretName")
    def tls_secret_name(self) -> Optional[_builtins.str]:
        """
        Registry TLS secret name. TLS is a pair of Cert/Key
        """
        return pulumi.get(self, "tls_secret_name")


@pulumi.output_type
class ClusterV2RkeConfigRegistriesMirror(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 endpoints: Optional[Sequence[_builtins.str]] = None,
                 rewrites: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: Registry hostname
        :param Sequence[_builtins.str] endpoints: Registry mirror endpoints
        :param Mapping[str, _builtins.str] rewrites: Registry mirror rewrites
        """
        pulumi.set(__self__, "hostname", hostname)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if rewrites is not None:
            pulumi.set(__self__, "rewrites", rewrites)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Registry hostname
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[_builtins.str]]:
        """
        Registry mirror endpoints
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def rewrites(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Registry mirror rewrites
        """
        return pulumi.get(self, "rewrites")


@pulumi.output_type
class ClusterV2RkeConfigRotateCertificates(dict):
    def __init__(__self__, *,
                 generation: _builtins.int,
                 services: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int generation: Desired certificate rotation generation.
        :param Sequence[_builtins.str] services: Service certificates to rotate with this generation.
        """
        pulumi.set(__self__, "generation", generation)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def generation(self) -> _builtins.int:
        """
        Desired certificate rotation generation.
        """
        return pulumi.get(self, "generation")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        Service certificates to rotate with this generation.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class ClusterV2RkeConfigUpgradeStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneConcurrency":
            suggest = "control_plane_concurrency"
        elif key == "controlPlaneDrainOptions":
            suggest = "control_plane_drain_options"
        elif key == "workerConcurrency":
            suggest = "worker_concurrency"
        elif key == "workerDrainOptions":
            suggest = "worker_drain_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigUpgradeStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigUpgradeStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigUpgradeStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_concurrency: Optional[_builtins.str] = None,
                 control_plane_drain_options: Optional['outputs.ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions'] = None,
                 worker_concurrency: Optional[_builtins.str] = None,
                 worker_drain_options: Optional['outputs.ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions'] = None):
        """
        :param _builtins.str control_plane_concurrency: How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        :param 'ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs' control_plane_drain_options: Controlplane nodes drain options
        :param _builtins.str worker_concurrency: How many worker nodes should be upgrade at time
        :param 'ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs' worker_drain_options: Worker nodes drain options
        """
        if control_plane_concurrency is not None:
            pulumi.set(__self__, "control_plane_concurrency", control_plane_concurrency)
        if control_plane_drain_options is not None:
            pulumi.set(__self__, "control_plane_drain_options", control_plane_drain_options)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)
        if worker_drain_options is not None:
            pulumi.set(__self__, "worker_drain_options", worker_drain_options)

    @_builtins.property
    @pulumi.getter(name="controlPlaneConcurrency")
    def control_plane_concurrency(self) -> Optional[_builtins.str]:
        """
        How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        """
        return pulumi.get(self, "control_plane_concurrency")

    @_builtins.property
    @pulumi.getter(name="controlPlaneDrainOptions")
    def control_plane_drain_options(self) -> Optional['outputs.ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions']:
        """
        Controlplane nodes drain options
        """
        return pulumi.get(self, "control_plane_drain_options")

    @_builtins.property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[_builtins.str]:
        """
        How many worker nodes should be upgrade at time
        """
        return pulumi.get(self, "worker_concurrency")

    @_builtins.property
    @pulumi.getter(name="workerDrainOptions")
    def worker_drain_options(self) -> Optional['outputs.ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions']:
        """
        Worker nodes drain options
        """
        return pulumi.get(self, "worker_drain_options")


@pulumi.output_type
class ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteEmptyDirData":
            suggest = "delete_empty_dir_data"
        elif key == "disableEviction":
            suggest = "disable_eviction"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "ignoreDaemonSets":
            suggest = "ignore_daemon_sets"
        elif key == "ignoreErrors":
            suggest = "ignore_errors"
        elif key == "skipWaitForDeleteTimeoutSeconds":
            suggest = "skip_wait_for_delete_timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_empty_dir_data: Optional[_builtins.bool] = None,
                 disable_eviction: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 ignore_errors: Optional[_builtins.bool] = None,
                 skip_wait_for_delete_timeout_seconds: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool delete_empty_dir_data: Drain options delete empty dir data
        :param _builtins.bool disable_eviction: Drain options disable eviction
        :param _builtins.bool enabled: Drain options enabled?
        :param _builtins.bool force: Drain options force
        :param _builtins.int grace_period: Drain options grace period
        :param _builtins.bool ignore_daemon_sets: Drain options ignore daemon sets
        :param _builtins.bool ignore_errors: Drain options ignore errors
        :param _builtins.int skip_wait_for_delete_timeout_seconds: Drain options skip wait for delete timeout seconds
        :param _builtins.int timeout: Drain options timeout
        """
        if delete_empty_dir_data is not None:
            pulumi.set(__self__, "delete_empty_dir_data", delete_empty_dir_data)
        if disable_eviction is not None:
            pulumi.set(__self__, "disable_eviction", disable_eviction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if ignore_errors is not None:
            pulumi.set(__self__, "ignore_errors", ignore_errors)
        if skip_wait_for_delete_timeout_seconds is not None:
            pulumi.set(__self__, "skip_wait_for_delete_timeout_seconds", skip_wait_for_delete_timeout_seconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="deleteEmptyDirData")
    def delete_empty_dir_data(self) -> Optional[_builtins.bool]:
        """
        Drain options delete empty dir data
        """
        return pulumi.get(self, "delete_empty_dir_data")

    @_builtins.property
    @pulumi.getter(name="disableEviction")
    def disable_eviction(self) -> Optional[_builtins.bool]:
        """
        Drain options disable eviction
        """
        return pulumi.get(self, "disable_eviction")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Drain options enabled?
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        Drain options force
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        """
        Drain options grace period
        """
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore daemon sets
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter(name="ignoreErrors")
    def ignore_errors(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore errors
        """
        return pulumi.get(self, "ignore_errors")

    @_builtins.property
    @pulumi.getter(name="skipWaitForDeleteTimeoutSeconds")
    def skip_wait_for_delete_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Drain options skip wait for delete timeout seconds
        """
        return pulumi.get(self, "skip_wait_for_delete_timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Drain options timeout
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteEmptyDirData":
            suggest = "delete_empty_dir_data"
        elif key == "disableEviction":
            suggest = "disable_eviction"
        elif key == "gracePeriod":
            suggest = "grace_period"
        elif key == "ignoreDaemonSets":
            suggest = "ignore_daemon_sets"
        elif key == "ignoreErrors":
            suggest = "ignore_errors"
        elif key == "skipWaitForDeleteTimeoutSeconds":
            suggest = "skip_wait_for_delete_timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_empty_dir_data: Optional[_builtins.bool] = None,
                 disable_eviction: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 ignore_errors: Optional[_builtins.bool] = None,
                 skip_wait_for_delete_timeout_seconds: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool delete_empty_dir_data: Drain options delete empty dir data
        :param _builtins.bool disable_eviction: Drain options disable eviction
        :param _builtins.bool enabled: Drain options enabled?
        :param _builtins.bool force: Drain options force
        :param _builtins.int grace_period: Drain options grace period
        :param _builtins.bool ignore_daemon_sets: Drain options ignore daemon sets
        :param _builtins.bool ignore_errors: Drain options ignore errors
        :param _builtins.int skip_wait_for_delete_timeout_seconds: Drain options skip wait for delete timeout seconds
        :param _builtins.int timeout: Drain options timeout
        """
        if delete_empty_dir_data is not None:
            pulumi.set(__self__, "delete_empty_dir_data", delete_empty_dir_data)
        if disable_eviction is not None:
            pulumi.set(__self__, "disable_eviction", disable_eviction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if ignore_errors is not None:
            pulumi.set(__self__, "ignore_errors", ignore_errors)
        if skip_wait_for_delete_timeout_seconds is not None:
            pulumi.set(__self__, "skip_wait_for_delete_timeout_seconds", skip_wait_for_delete_timeout_seconds)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="deleteEmptyDirData")
    def delete_empty_dir_data(self) -> Optional[_builtins.bool]:
        """
        Drain options delete empty dir data
        """
        return pulumi.get(self, "delete_empty_dir_data")

    @_builtins.property
    @pulumi.getter(name="disableEviction")
    def disable_eviction(self) -> Optional[_builtins.bool]:
        """
        Drain options disable eviction
        """
        return pulumi.get(self, "disable_eviction")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Drain options enabled?
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        Drain options force
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        """
        Drain options grace period
        """
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore daemon sets
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter(name="ignoreErrors")
    def ignore_errors(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore errors
        """
        return pulumi.get(self, "ignore_errors")

    @_builtins.property
    @pulumi.getter(name="skipWaitForDeleteTimeoutSeconds")
    def skip_wait_for_delete_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        Drain options skip wait for delete timeout seconds
        """
        return pulumi.get(self, "skip_wait_for_delete_timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Drain options timeout
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class EtcdBackupBackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intervalHours":
            suggest = "interval_hours"
        elif key == "s3BackupConfig":
            suggest = "s3_backup_config"
        elif key == "safeTimestamp":
            suggest = "safe_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EtcdBackupBackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EtcdBackupBackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EtcdBackupBackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None,
                 retention: Optional[_builtins.int] = None,
                 s3_backup_config: Optional['outputs.EtcdBackupBackupConfigS3BackupConfig'] = None,
                 safe_timestamp: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Enable etcd backup (bool)
        :param _builtins.int interval_hours: Interval hours for etcd backup. Default `12` (int)
        :param _builtins.int retention: Retention for etcd backup. Default `6` (int)
        :param 'EtcdBackupBackupConfigS3BackupConfigArgs' s3_backup_config: S3 config options for etcd backup. Valid for `imported` and `rke` clusters. (list maxitems:1)
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable etcd backup (bool)
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        """
        Interval hours for etcd backup. Default `12` (int)
        """
        return pulumi.get(self, "interval_hours")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.int]:
        """
        Retention for etcd backup. Default `6` (int)
        """
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.EtcdBackupBackupConfigS3BackupConfig']:
        """
        S3 config options for etcd backup. Valid for `imported` and `rke` clusters. (list maxitems:1)
        """
        return pulumi.get(self, "s3_backup_config")

    @_builtins.property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safe_timestamp")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class EtcdBackupBackupConfigS3BackupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "customCa":
            suggest = "custom_ca"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EtcdBackupBackupConfigS3BackupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EtcdBackupBackupConfigS3BackupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EtcdBackupBackupConfigS3BackupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 endpoint: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 custom_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: Bucket name for S3 service (string)
        :param _builtins.str endpoint: Endpoint for S3 service (string)
        :param _builtins.str access_key: Access key for S3 service (string)
        :param _builtins.str custom_ca: Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        :param _builtins.str folder: Folder for S3 service. Available from Rancher v2.2.7 (string)
        :param _builtins.str region: Region for S3 service (string)
        :param _builtins.str secret_key: Secret key for S3 service (string)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Bucket name for S3 service (string)
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Endpoint for S3 service (string)
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        Access key for S3 service (string)
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[_builtins.str]:
        """
        Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
        """
        return pulumi.get(self, "custom_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        """
        Folder for S3 service. Available from Rancher v2.2.7 (string)
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region for S3 service (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Secret key for S3 service (string)
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GlobalRoleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroups":
            suggest = "api_groups"
        elif key == "nonResourceUrls":
            suggest = "non_resource_urls"
        elif key == "resourceNames":
            suggest = "resource_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalRoleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalRoleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalRoleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_groups: Optional[Sequence[_builtins.str]] = None,
                 non_resource_urls: Optional[Sequence[_builtins.str]] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None,
                 verbs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_groups: Policy rule api groups
        :param Sequence[_builtins.str] non_resource_urls: Policy rule non resource urls
        :param Sequence[_builtins.str] resource_names: Policy rule resource names
        :param Sequence[_builtins.str] resources: Policy rule resources
        :param Sequence[_builtins.str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @_builtins.property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @_builtins.property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")


@pulumi.output_type
class MachineConfigV2Amazonec2Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "encryptEbsVolume":
            suggest = "encrypt_ebs_volume"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "insecureTransport":
            suggest = "insecure_transport"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "openPorts":
            suggest = "open_ports"
        elif key == "privateAddressOnly":
            suggest = "private_address_only"
        elif key == "requestSpotInstance":
            suggest = "request_spot_instance"
        elif key == "rootSize":
            suggest = "root_size"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "securityGroupReadonly":
            suggest = "security_group_readonly"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "sshKeyContents":
            suggest = "ssh_key_contents"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "useEbsOptimizedInstance":
            suggest = "use_ebs_optimized_instance"
        elif key == "usePrivateAddress":
            suggest = "use_private_address"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2Amazonec2Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2Amazonec2Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2Amazonec2Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami: _builtins.str,
                 region: _builtins.str,
                 security_groups: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str,
                 zone: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 block_duration_minutes: Optional[_builtins.str] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypt_ebs_volume: Optional[_builtins.bool] = None,
                 endpoint: Optional[_builtins.str] = None,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 iam_instance_profile: Optional[_builtins.str] = None,
                 insecure_transport: Optional[_builtins.bool] = None,
                 instance_type: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 open_ports: Optional[Sequence[_builtins.str]] = None,
                 private_address_only: Optional[_builtins.bool] = None,
                 request_spot_instance: Optional[_builtins.bool] = None,
                 retries: Optional[_builtins.str] = None,
                 root_size: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 security_group_readonly: Optional[_builtins.bool] = None,
                 session_token: Optional[_builtins.str] = None,
                 spot_price: Optional[_builtins.str] = None,
                 ssh_key_contents: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 use_ebs_optimized_instance: Optional[_builtins.bool] = None,
                 use_private_address: Optional[_builtins.bool] = None,
                 userdata: Optional[_builtins.str] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str ami: AWS machine image
        :param _builtins.str region: AWS Region
        :param Sequence[_builtins.str] security_groups: AWS VPC security group
        :param _builtins.str subnet_id: AWS VPC subnet id
        :param _builtins.str vpc_id: AWS VPC id
        :param _builtins.str zone: AWS zone for instance (i.e. a,b,c,d,e)
        :param _builtins.str access_key: AWS Access Key
        :param _builtins.str block_duration_minutes: AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        :param _builtins.str device_name: AWS root device name
        :param _builtins.bool encrypt_ebs_volume: Encrypt EBS volume
        :param _builtins.str endpoint: Optional endpoint URL (hostname only or fully qualified URI)
        :param _builtins.str http_endpoint: Enables or disables the HTTP metadata endpoint on your instances
        :param _builtins.str http_tokens: The state of token usage for your instance metadata requests
        :param _builtins.str iam_instance_profile: AWS IAM Instance Profile
        :param _builtins.bool insecure_transport: Disable SSL when sending requests
        :param _builtins.str instance_type: AWS instance type
        :param _builtins.str kms_key: Custom KMS key ID using the AWS Managed CMK
        :param _builtins.bool monitoring: Set this flag to enable CloudWatch monitoring
        :param Sequence[_builtins.str] open_ports: Make the specified port number accessible from the Internet
        :param _builtins.bool private_address_only: Only use a private IP address
        :param _builtins.bool request_spot_instance: Set this flag to request spot instance
        :param _builtins.str retries: Set retry count for recoverable failures (use -1 to disable)
        :param _builtins.str root_size: AWS root disk size (in GB)
        :param _builtins.str secret_key: AWS Secret Key
        :param _builtins.bool security_group_readonly: Skip adding default rules to security groups
        :param _builtins.str session_token: AWS Session Token
        :param _builtins.str spot_price: AWS spot instance bid price (in dollar)
        :param _builtins.str ssh_key_contents: SSH Key file contents for sshKeyContents
        :param _builtins.str ssh_user: Set the name of the ssh user
        :param _builtins.str tags: AWS Tags (e.g. key1,value1,key2,value2)
        :param _builtins.bool use_ebs_optimized_instance: Create an EBS optimized instance
        :param _builtins.bool use_private_address: Force the usage of private IP address
        :param _builtins.str userdata: Path to file with cloud-init user data
        :param _builtins.str volume_type: Amazon EBS volume type
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone", zone)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypt_ebs_volume is not None:
            pulumi.set(__self__, "encrypt_ebs_volume", encrypt_ebs_volume)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if insecure_transport is not None:
            pulumi.set(__self__, "insecure_transport", insecure_transport)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if private_address_only is not None:
            pulumi.set(__self__, "private_address_only", private_address_only)
        if request_spot_instance is not None:
            pulumi.set(__self__, "request_spot_instance", request_spot_instance)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if security_group_readonly is not None:
            pulumi.set(__self__, "security_group_readonly", security_group_readonly)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if ssh_key_contents is not None:
            pulumi.set(__self__, "ssh_key_contents", ssh_key_contents)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_ebs_optimized_instance is not None:
            pulumi.set(__self__, "use_ebs_optimized_instance", use_ebs_optimized_instance)
        if use_private_address is not None:
            pulumi.set(__self__, "use_private_address", use_private_address)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def ami(self) -> _builtins.str:
        """
        AWS machine image
        """
        return pulumi.get(self, "ami")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS Region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        """
        AWS VPC security group
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        AWS VPC subnet id
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        AWS VPC id
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        AWS zone for instance (i.e. a,b,c,d,e)
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[_builtins.str]:
        """
        AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        """
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        AWS root device name
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="encryptEbsVolume")
    def encrypt_ebs_volume(self) -> Optional[_builtins.bool]:
        """
        Encrypt EBS volume
        """
        return pulumi.get(self, "encrypt_ebs_volume")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Optional endpoint URL (hostname only or fully qualified URI)
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        Enables or disables the HTTP metadata endpoint on your instances
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        The state of token usage for your instance metadata requests
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[_builtins.str]:
        """
        AWS IAM Instance Profile
        """
        return pulumi.get(self, "iam_instance_profile")

    @_builtins.property
    @pulumi.getter(name="insecureTransport")
    def insecure_transport(self) -> Optional[_builtins.bool]:
        """
        Disable SSL when sending requests
        """
        return pulumi.get(self, "insecure_transport")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        AWS instance type
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        Custom KMS key ID using the AWS Managed CMK
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        """
        Set this flag to enable CloudWatch monitoring
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @_builtins.property
    @pulumi.getter(name="privateAddressOnly")
    def private_address_only(self) -> Optional[_builtins.bool]:
        """
        Only use a private IP address
        """
        return pulumi.get(self, "private_address_only")

    @_builtins.property
    @pulumi.getter(name="requestSpotInstance")
    def request_spot_instance(self) -> Optional[_builtins.bool]:
        """
        Set this flag to request spot instance
        """
        return pulumi.get(self, "request_spot_instance")

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[_builtins.str]:
        """
        Set retry count for recoverable failures (use -1 to disable)
        """
        return pulumi.get(self, "retries")

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[_builtins.str]:
        """
        AWS root disk size (in GB)
        """
        return pulumi.get(self, "root_size")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="securityGroupReadonly")
    def security_group_readonly(self) -> Optional[_builtins.bool]:
        """
        Skip adding default rules to security groups
        """
        return pulumi.get(self, "security_group_readonly")

    @_builtins.property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[_builtins.str]:
        """
        AWS Session Token
        """
        return pulumi.get(self, "session_token")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        AWS spot instance bid price (in dollar)
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="sshKeyContents")
    def ssh_key_contents(self) -> Optional[_builtins.str]:
        """
        SSH Key file contents for sshKeyContents
        """
        return pulumi.get(self, "ssh_key_contents")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        Set the name of the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        AWS Tags (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useEbsOptimizedInstance")
    def use_ebs_optimized_instance(self) -> Optional[_builtins.bool]:
        """
        Create an EBS optimized instance
        """
        return pulumi.get(self, "use_ebs_optimized_instance")

    @_builtins.property
    @pulumi.getter(name="usePrivateAddress")
    def use_private_address(self) -> Optional[_builtins.bool]:
        """
        Force the usage of private IP address
        """
        return pulumi.get(self, "use_private_address")

    @_builtins.property
    @pulumi.getter
    def userdata(self) -> Optional[_builtins.str]:
        """
        Path to file with cloud-init user data
        """
        return pulumi.get(self, "userdata")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Amazon EBS volume type
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class MachineConfigV2AzureConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratedNetworking":
            suggest = "accelerated_networking"
        elif key == "availabilitySet":
            suggest = "availability_set"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customData":
            suggest = "custom_data"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "dockerPort":
            suggest = "docker_port"
        elif key == "faultDomainCount":
            suggest = "fault_domain_count"
        elif key == "managedDisks":
            suggest = "managed_disks"
        elif key == "noPublicIp":
            suggest = "no_public_ip"
        elif key == "openPorts":
            suggest = "open_ports"
        elif key == "privateAddressOnly":
            suggest = "private_address_only"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "staticPublicIp":
            suggest = "static_public_ip"
        elif key == "storageType":
            suggest = "storage_type"
        elif key == "subnetPrefix":
            suggest = "subnet_prefix"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "updateDomainCount":
            suggest = "update_domain_count"
        elif key == "usePrivateIp":
            suggest = "use_private_ip"
        elif key == "usePublicIpStandardSku":
            suggest = "use_public_ip_standard_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2AzureConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2AzureConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2AzureConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerated_networking: Optional[_builtins.bool] = None,
                 availability_set: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 custom_data: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.str] = None,
                 dns: Optional[_builtins.str] = None,
                 docker_port: Optional[_builtins.str] = None,
                 environment: Optional[_builtins.str] = None,
                 fault_domain_count: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 managed_disks: Optional[_builtins.bool] = None,
                 no_public_ip: Optional[_builtins.bool] = None,
                 nsg: Optional[_builtins.str] = None,
                 open_ports: Optional[Sequence[_builtins.str]] = None,
                 private_address_only: Optional[_builtins.bool] = None,
                 private_ip_address: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 static_public_ip: Optional[_builtins.bool] = None,
                 storage_type: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None,
                 subnet_prefix: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 update_domain_count: Optional[_builtins.str] = None,
                 use_private_ip: Optional[_builtins.bool] = None,
                 use_public_ip_standard_sku: Optional[_builtins.bool] = None,
                 vnet: Optional[_builtins.str] = None):
        """
        :param _builtins.bool accelerated_networking: Use Accelerated Networking when creating a network interface for the Azure VM
        :param _builtins.str availability_set: Azure Availability Set to place the virtual machine into
        :param _builtins.str availability_zone: The Availability Zone that the Azure VM should be created in
        :param _builtins.str client_id: Azure Service Principal Account ID (optional, browser auth is used if not specified)
        :param _builtins.str client_secret: Azure Service Principal Account password (optional, browser auth is used if not specified)
        :param _builtins.str custom_data: Path to file with custom-data
        :param _builtins.str disk_size: Disk size if using managed disk
        :param _builtins.str dns: A unique DNS label for the public IP adddress
        :param _builtins.str docker_port: Port number for Docker engine
        :param _builtins.str environment: Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        :param _builtins.str fault_domain_count: Fault domain count to use for availability set
        :param _builtins.str image: Azure virtual machine OS image
        :param _builtins.str location: Azure region to create the virtual machine
        :param _builtins.bool managed_disks: Configures VM and availability set for managed disks
        :param _builtins.bool no_public_ip: Do not create a public IP address for the machine
        :param _builtins.str nsg: Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        :param Sequence[_builtins.str] open_ports: Make the specified port number accessible from the Internet
        :param _builtins.bool private_address_only: Only use a private IP address
        :param _builtins.str private_ip_address: Specify a static private IP address for the machine
        :param _builtins.str resource_group: Azure Resource Group name (will be created if missing)
        :param _builtins.str size: Size for Azure Virtual Machine
        :param _builtins.str ssh_user: Username for SSH login
        :param _builtins.bool static_public_ip: Assign a static public IP address to the machine
        :param _builtins.str storage_type: Type of Storage Account to host the OS Disk for the machine
        :param _builtins.str subnet: Azure Subnet Name to be used within the Virtual Network
        :param _builtins.str subnet_prefix: Private CIDR block to be used for the new subnet, should comply RFC 1918
        :param _builtins.str subscription_id: Azure Subscription ID
        :param _builtins.str tags: Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        :param _builtins.str tenant_id: Azure Tenant ID
        :param _builtins.str update_domain_count: Update domain count to use for availability set
        :param _builtins.bool use_private_ip: Use private IP address of the machine to connect
        :param _builtins.bool use_public_ip_standard_sku: Use the standard SKU when creating a Public IP for the Azure VM instance
        :param _builtins.str vnet: Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if availability_set is not None:
            pulumi.set(__self__, "availability_set", availability_set)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if fault_domain_count is not None:
            pulumi.set(__self__, "fault_domain_count", fault_domain_count)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if managed_disks is not None:
            pulumi.set(__self__, "managed_disks", managed_disks)
        if no_public_ip is not None:
            pulumi.set(__self__, "no_public_ip", no_public_ip)
        if nsg is not None:
            pulumi.set(__self__, "nsg", nsg)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if private_address_only is not None:
            pulumi.set(__self__, "private_address_only", private_address_only)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if static_public_ip is not None:
            pulumi.set(__self__, "static_public_ip", static_public_ip)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_prefix is not None:
            pulumi.set(__self__, "subnet_prefix", subnet_prefix)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if update_domain_count is not None:
            pulumi.set(__self__, "update_domain_count", update_domain_count)
        if use_private_ip is not None:
            pulumi.set(__self__, "use_private_ip", use_private_ip)
        if use_public_ip_standard_sku is not None:
            pulumi.set(__self__, "use_public_ip_standard_sku", use_public_ip_standard_sku)
        if vnet is not None:
            pulumi.set(__self__, "vnet", vnet)

    @_builtins.property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[_builtins.bool]:
        """
        Use Accelerated Networking when creating a network interface for the Azure VM
        """
        return pulumi.get(self, "accelerated_networking")

    @_builtins.property
    @pulumi.getter(name="availabilitySet")
    def availability_set(self) -> Optional[_builtins.str]:
        """
        Azure Availability Set to place the virtual machine into
        """
        return pulumi.get(self, "availability_set")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone that the Azure VM should be created in
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Azure Service Principal Account ID (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        Azure Service Principal Account password (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[_builtins.str]:
        """
        Path to file with custom-data
        """
        return pulumi.get(self, "custom_data")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.str]:
        """
        Disk size if using managed disk
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[_builtins.str]:
        """
        A unique DNS label for the public IP adddress
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[_builtins.str]:
        """
        Port number for Docker engine
        """
        return pulumi.get(self, "docker_port")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="faultDomainCount")
    def fault_domain_count(self) -> Optional[_builtins.str]:
        """
        Fault domain count to use for availability set
        """
        return pulumi.get(self, "fault_domain_count")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Azure virtual machine OS image
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Azure region to create the virtual machine
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="managedDisks")
    def managed_disks(self) -> Optional[_builtins.bool]:
        """
        Configures VM and availability set for managed disks
        """
        return pulumi.get(self, "managed_disks")

    @_builtins.property
    @pulumi.getter(name="noPublicIp")
    def no_public_ip(self) -> Optional[_builtins.bool]:
        """
        Do not create a public IP address for the machine
        """
        return pulumi.get(self, "no_public_ip")

    @_builtins.property
    @pulumi.getter
    def nsg(self) -> Optional[_builtins.str]:
        """
        Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        """
        return pulumi.get(self, "nsg")

    @_builtins.property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @_builtins.property
    @pulumi.getter(name="privateAddressOnly")
    def private_address_only(self) -> Optional[_builtins.bool]:
        """
        Only use a private IP address
        """
        return pulumi.get(self, "private_address_only")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        """
        Specify a static private IP address for the machine
        """
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        Azure Resource Group name (will be created if missing)
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        Size for Azure Virtual Machine
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        Username for SSH login
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="staticPublicIp")
    def static_public_ip(self) -> Optional[_builtins.bool]:
        """
        Assign a static public IP address to the machine
        """
        return pulumi.get(self, "static_public_ip")

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[_builtins.str]:
        """
        Type of Storage Account to host the OS Disk for the machine
        """
        return pulumi.get(self, "storage_type")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        Azure Subnet Name to be used within the Virtual Network
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="subnetPrefix")
    def subnet_prefix(self) -> Optional[_builtins.str]:
        """
        Private CIDR block to be used for the new subnet, should comply RFC 1918
        """
        return pulumi.get(self, "subnet_prefix")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        Azure Subscription ID
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        Azure Tenant ID
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="updateDomainCount")
    def update_domain_count(self) -> Optional[_builtins.str]:
        """
        Update domain count to use for availability set
        """
        return pulumi.get(self, "update_domain_count")

    @_builtins.property
    @pulumi.getter(name="usePrivateIp")
    def use_private_ip(self) -> Optional[_builtins.bool]:
        """
        Use private IP address of the machine to connect
        """
        return pulumi.get(self, "use_private_ip")

    @_builtins.property
    @pulumi.getter(name="usePublicIpStandardSku")
    def use_public_ip_standard_sku(self) -> Optional[_builtins.bool]:
        """
        Use the standard SKU when creating a Public IP for the Azure VM instance
        """
        return pulumi.get(self, "use_public_ip_standard_sku")

    @_builtins.property
    @pulumi.getter
    def vnet(self) -> Optional[_builtins.str]:
        """
        Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        return pulumi.get(self, "vnet")


@pulumi.output_type
class MachineConfigV2DigitaloceanConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "privateNetworking":
            suggest = "private_networking"
        elif key == "sshKeyContents":
            suggest = "ssh_key_contents"
        elif key == "sshKeyFingerprint":
            suggest = "ssh_key_fingerprint"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2DigitaloceanConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2DigitaloceanConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2DigitaloceanConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[_builtins.str] = None,
                 backups: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 private_networking: Optional[_builtins.bool] = None,
                 region: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 ssh_key_contents: Optional[_builtins.str] = None,
                 ssh_key_fingerprint: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 userdata: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_token: Digital Ocean access token
        :param _builtins.bool backups: Enable backups for droplet
        :param _builtins.str image: Digital Ocean Image
        :param _builtins.bool ipv6: Enable ipv6 for droplet
        :param _builtins.bool monitoring: Enable monitoring for droplet
        :param _builtins.bool private_networking: Enable private networking for droplet
        :param _builtins.str region: Digital Ocean region
        :param _builtins.str size: Digital Ocean size
        :param _builtins.str ssh_key_contents: SSH private key contents
        :param _builtins.str ssh_key_fingerprint: SSH key fingerprint
        :param _builtins.str ssh_port: SSH port
        :param _builtins.str ssh_user: SSH username
        :param _builtins.str tags: Comma-separated list of tags to apply to the Droplet
        :param _builtins.str userdata: Path to file with cloud-init user-data
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if backups is not None:
            pulumi.set(__self__, "backups", backups)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if private_networking is not None:
            pulumi.set(__self__, "private_networking", private_networking)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_contents is not None:
            pulumi.set(__self__, "ssh_key_contents", ssh_key_contents)
        if ssh_key_fingerprint is not None:
            pulumi.set(__self__, "ssh_key_fingerprint", ssh_key_fingerprint)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Digital Ocean access token
        """
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter
    def backups(self) -> Optional[_builtins.bool]:
        """
        Enable backups for droplet
        """
        return pulumi.get(self, "backups")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Digital Ocean Image
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        Enable ipv6 for droplet
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        """
        Enable monitoring for droplet
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="privateNetworking")
    def private_networking(self) -> Optional[_builtins.bool]:
        """
        Enable private networking for droplet
        """
        return pulumi.get(self, "private_networking")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Digital Ocean region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        Digital Ocean size
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshKeyContents")
    def ssh_key_contents(self) -> Optional[_builtins.str]:
        """
        SSH private key contents
        """
        return pulumi.get(self, "ssh_key_contents")

    @_builtins.property
    @pulumi.getter(name="sshKeyFingerprint")
    def ssh_key_fingerprint(self) -> Optional[_builtins.str]:
        """
        SSH key fingerprint
        """
        return pulumi.get(self, "ssh_key_fingerprint")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        SSH port
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of tags to apply to the Droplet
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def userdata(self) -> Optional[_builtins.str]:
        """
        Path to file with cloud-init user-data
        """
        return pulumi.get(self, "userdata")


@pulumi.output_type
class MachineConfigV2GoogleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskSize":
            suggest = "disk_size"
        elif key == "diskType":
            suggest = "disk_type"
        elif key == "machineImage":
            suggest = "machine_image"
        elif key == "machineType":
            suggest = "machine_type"
        elif key == "authEncodedJson":
            suggest = "auth_encoded_json"
        elif key == "externalFirewallRulePrefix":
            suggest = "external_firewall_rule_prefix"
        elif key == "internalFirewallRulePrefix":
            suggest = "internal_firewall_rule_prefix"
        elif key == "openPorts":
            suggest = "open_ports"
        elif key == "subNetwork":
            suggest = "sub_network"
        elif key == "useExisting":
            suggest = "use_existing"
        elif key == "useInternalIp":
            suggest = "use_internal_ip"
        elif key == "useInternalIpOnly":
            suggest = "use_internal_ip_only"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vmLabels":
            suggest = "vm_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2GoogleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2GoogleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2GoogleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disk_size: _builtins.str,
                 disk_type: _builtins.str,
                 machine_image: _builtins.str,
                 machine_type: _builtins.str,
                 network: _builtins.str,
                 project: _builtins.str,
                 zone: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 auth_encoded_json: Optional[_builtins.str] = None,
                 external_firewall_rule_prefix: Optional[_builtins.str] = None,
                 internal_firewall_rule_prefix: Optional[_builtins.str] = None,
                 open_ports: Optional[Sequence[_builtins.str]] = None,
                 preemptable: Optional[_builtins.bool] = None,
                 scopes: Optional[_builtins.str] = None,
                 sub_network: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 use_existing: Optional[_builtins.bool] = None,
                 use_internal_ip: Optional[_builtins.bool] = None,
                 use_internal_ip_only: Optional[_builtins.bool] = None,
                 user_data: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None,
                 vm_labels: Optional[_builtins.str] = None):
        """
        :param _builtins.str disk_size: GCE Instance Disk Size (in GB)
        :param _builtins.str disk_type: GCE Instance Disk Type
        :param _builtins.str machine_image: GCE instance image absolute URL
        :param _builtins.str machine_type: GCE instance type
        :param _builtins.str network: The network to provision virtual machines within
        :param _builtins.str project: The GCP project to create virtual machines within
        :param _builtins.str zone: The region and zone to create virtual machines within (e.g. us-east1-b)
        :param _builtins.str address: GCE Instance External IP
        :param _builtins.str auth_encoded_json: GCE service account auth json file path
        :param _builtins.str external_firewall_rule_prefix: A prefix to be added to firewall rules created when exposing ports publicly. Required if exposing ports publicly.
        :param _builtins.str internal_firewall_rule_prefix: A prefix to be added to an internal firewall rule created to ensure virtual machines can communicate with one another.
        :param Sequence[_builtins.str] open_ports: A list of ports to be opened publicly. 'external_firewall_rule_prefix' must also be set
        :param _builtins.bool preemptable: Indicates if the virtual machine can be preempted
        :param _builtins.str scopes: Access scopes to be set on the virtual machine
        :param _builtins.str sub_network: The subnetwork to provision virtual machines within
        :param _builtins.str tags: A set of network tags to be added to each VM, in the format of 'tag1,tag2'
        :param _builtins.bool use_existing: Indicates if an existing VM should be used. This is not currently support in Rancher.
        :param _builtins.bool use_internal_ip: Indicates if the virtual machines should use an internal IP
        :param _builtins.bool use_internal_ip_only: Indicates if the virtual machines should use an internal IP only and not be assigned a public IP
        :param _builtins.str user_data: GCE user-data file path
        :param _builtins.str username: The username to be set when logging into the virtual machines
        :param _builtins.str vm_labels: A set of labels to be added to each VM, in the format of 'key1,value1,key2,value2'
        """
        pulumi.set(__self__, "disk_size", disk_size)
        pulumi.set(__self__, "disk_type", disk_type)
        pulumi.set(__self__, "machine_image", machine_image)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "zone", zone)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if auth_encoded_json is not None:
            pulumi.set(__self__, "auth_encoded_json", auth_encoded_json)
        if external_firewall_rule_prefix is not None:
            pulumi.set(__self__, "external_firewall_rule_prefix", external_firewall_rule_prefix)
        if internal_firewall_rule_prefix is not None:
            pulumi.set(__self__, "internal_firewall_rule_prefix", internal_firewall_rule_prefix)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if preemptable is not None:
            pulumi.set(__self__, "preemptable", preemptable)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if sub_network is not None:
            pulumi.set(__self__, "sub_network", sub_network)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_existing is not None:
            pulumi.set(__self__, "use_existing", use_existing)
        if use_internal_ip is not None:
            pulumi.set(__self__, "use_internal_ip", use_internal_ip)
        if use_internal_ip_only is not None:
            pulumi.set(__self__, "use_internal_ip_only", use_internal_ip_only)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vm_labels is not None:
            pulumi.set(__self__, "vm_labels", vm_labels)

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> _builtins.str:
        """
        GCE Instance Disk Size (in GB)
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> _builtins.str:
        """
        GCE Instance Disk Type
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="machineImage")
    def machine_image(self) -> _builtins.str:
        """
        GCE instance image absolute URL
        """
        return pulumi.get(self, "machine_image")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> _builtins.str:
        """
        GCE instance type
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The network to provision virtual machines within
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        The GCP project to create virtual machines within
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The region and zone to create virtual machines within (e.g. us-east1-b)
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        GCE Instance External IP
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="authEncodedJson")
    def auth_encoded_json(self) -> Optional[_builtins.str]:
        """
        GCE service account auth json file path
        """
        return pulumi.get(self, "auth_encoded_json")

    @_builtins.property
    @pulumi.getter(name="externalFirewallRulePrefix")
    def external_firewall_rule_prefix(self) -> Optional[_builtins.str]:
        """
        A prefix to be added to firewall rules created when exposing ports publicly. Required if exposing ports publicly.
        """
        return pulumi.get(self, "external_firewall_rule_prefix")

    @_builtins.property
    @pulumi.getter(name="internalFirewallRulePrefix")
    def internal_firewall_rule_prefix(self) -> Optional[_builtins.str]:
        """
        A prefix to be added to an internal firewall rule created to ensure virtual machines can communicate with one another.
        """
        return pulumi.get(self, "internal_firewall_rule_prefix")

    @_builtins.property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of ports to be opened publicly. 'external_firewall_rule_prefix' must also be set
        """
        return pulumi.get(self, "open_ports")

    @_builtins.property
    @pulumi.getter
    def preemptable(self) -> Optional[_builtins.bool]:
        """
        Indicates if the virtual machine can be preempted
        """
        return pulumi.get(self, "preemptable")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[_builtins.str]:
        """
        Access scopes to be set on the virtual machine
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="subNetwork")
    def sub_network(self) -> Optional[_builtins.str]:
        """
        The subnetwork to provision virtual machines within
        """
        return pulumi.get(self, "sub_network")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        A set of network tags to be added to each VM, in the format of 'tag1,tag2'
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useExisting")
    def use_existing(self) -> Optional[_builtins.bool]:
        """
        Indicates if an existing VM should be used. This is not currently support in Rancher.
        """
        return pulumi.get(self, "use_existing")

    @_builtins.property
    @pulumi.getter(name="useInternalIp")
    def use_internal_ip(self) -> Optional[_builtins.bool]:
        """
        Indicates if the virtual machines should use an internal IP
        """
        return pulumi.get(self, "use_internal_ip")

    @_builtins.property
    @pulumi.getter(name="useInternalIpOnly")
    def use_internal_ip_only(self) -> Optional[_builtins.bool]:
        """
        Indicates if the virtual machines should use an internal IP only and not be assigned a public IP
        """
        return pulumi.get(self, "use_internal_ip_only")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        GCE user-data file path
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to be set when logging into the virtual machines
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="vmLabels")
    def vm_labels(self) -> Optional[_builtins.str]:
        """
        A set of labels to be added to each VM, in the format of 'key1,value1,key2,value2'
        """
        return pulumi.get(self, "vm_labels")


@pulumi.output_type
class MachineConfigV2HarvesterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshUser":
            suggest = "ssh_user"
        elif key == "vmNamespace":
            suggest = "vm_namespace"
        elif key == "cpuCount":
            suggest = "cpu_count"
        elif key == "diskBus":
            suggest = "disk_bus"
        elif key == "diskInfo":
            suggest = "disk_info"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "memorySize":
            suggest = "memory_size"
        elif key == "networkData":
            suggest = "network_data"
        elif key == "networkInfo":
            suggest = "network_info"
        elif key == "networkModel":
            suggest = "network_model"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "sshPassword":
            suggest = "ssh_password"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vmAffinity":
            suggest = "vm_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2HarvesterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2HarvesterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2HarvesterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_user: _builtins.str,
                 vm_namespace: _builtins.str,
                 cpu_count: Optional[_builtins.str] = None,
                 disk_bus: Optional[_builtins.str] = None,
                 disk_info: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.str] = None,
                 image_name: Optional[_builtins.str] = None,
                 memory_size: Optional[_builtins.str] = None,
                 network_data: Optional[_builtins.str] = None,
                 network_info: Optional[_builtins.str] = None,
                 network_model: Optional[_builtins.str] = None,
                 network_name: Optional[_builtins.str] = None,
                 ssh_password: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None,
                 vm_affinity: Optional[_builtins.str] = None):
        """
        :param _builtins.str ssh_user: SSH username
        :param _builtins.str vm_namespace: Virtual machine namespace
        :param _builtins.str cpu_count: CPU count
        :param _builtins.str disk_bus: Disk bus
        :param _builtins.str disk_info: A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        :param _builtins.str disk_size: Disk size (in GiB)
        :param _builtins.str image_name: Image name
        :param _builtins.str memory_size: Memory size (in GiB)
        :param _builtins.str network_data: NetworkData content of cloud-init, base64 is supported
        :param _builtins.str network_info: A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        :param _builtins.str network_model: Network model
        :param _builtins.str network_name: Network name
        :param _builtins.str ssh_password: SSH password
        :param _builtins.str user_data: UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        :param _builtins.str vm_affinity: VM affinity, base64 is supported
        """
        pulumi.set(__self__, "ssh_user", ssh_user)
        pulumi.set(__self__, "vm_namespace", vm_namespace)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if disk_bus is not None:
            pulumi.set(__self__, "disk_bus", disk_bus)
        if disk_info is not None:
            pulumi.set(__self__, "disk_info", disk_info)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if network_data is not None:
            pulumi.set(__self__, "network_data", network_data)
        if network_info is not None:
            pulumi.set(__self__, "network_info", network_info)
        if network_model is not None:
            pulumi.set(__self__, "network_model", network_model)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vm_affinity is not None:
            pulumi.set(__self__, "vm_affinity", vm_affinity)

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> _builtins.str:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="vmNamespace")
    def vm_namespace(self) -> _builtins.str:
        """
        Virtual machine namespace
        """
        return pulumi.get(self, "vm_namespace")

    @_builtins.property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[_builtins.str]:
        """
        CPU count
        """
        return pulumi.get(self, "cpu_count")

    @_builtins.property
    @pulumi.getter(name="diskBus")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_bus(self) -> Optional[_builtins.str]:
        """
        Disk bus
        """
        return pulumi.get(self, "disk_bus")

    @_builtins.property
    @pulumi.getter(name="diskInfo")
    def disk_info(self) -> Optional[_builtins.str]:
        """
        A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        """
        return pulumi.get(self, "disk_info")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_size(self) -> Optional[_builtins.str]:
        """
        Disk size (in GiB)
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="imageName")
    @_utilities.deprecated("""Use disk_info instead""")
    def image_name(self) -> Optional[_builtins.str]:
        """
        Image name
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[_builtins.str]:
        """
        Memory size (in GiB)
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter(name="networkData")
    def network_data(self) -> Optional[_builtins.str]:
        """
        NetworkData content of cloud-init, base64 is supported
        """
        return pulumi.get(self, "network_data")

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> Optional[_builtins.str]:
        """
        A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        """
        return pulumi.get(self, "network_info")

    @_builtins.property
    @pulumi.getter(name="networkModel")
    @_utilities.deprecated("""Use network_info instead""")
    def network_model(self) -> Optional[_builtins.str]:
        """
        Network model
        """
        return pulumi.get(self, "network_model")

    @_builtins.property
    @pulumi.getter(name="networkName")
    @_utilities.deprecated("""Use network_info instead""")
    def network_name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[_builtins.str]:
        """
        SSH password
        """
        return pulumi.get(self, "ssh_password")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="vmAffinity")
    def vm_affinity(self) -> Optional[_builtins.str]:
        """
        VM affinity, base64 is supported
        """
        return pulumi.get(self, "vm_affinity")


@pulumi.output_type
class MachineConfigV2LinodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedUsers":
            suggest = "authorized_users"
        elif key == "createPrivateIp":
            suggest = "create_private_ip"
        elif key == "dockerPort":
            suggest = "docker_port"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "rootPass":
            suggest = "root_pass"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "stackscriptData":
            suggest = "stackscript_data"
        elif key == "swapSize":
            suggest = "swap_size"
        elif key == "uaPrefix":
            suggest = "ua_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2LinodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2LinodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2LinodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_users: Optional[_builtins.str] = None,
                 create_private_ip: Optional[_builtins.bool] = None,
                 docker_port: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 instance_type: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 root_pass: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 stackscript: Optional[_builtins.str] = None,
                 stackscript_data: Optional[_builtins.str] = None,
                 swap_size: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 token: Optional[_builtins.str] = None,
                 ua_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str authorized_users: Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        :param _builtins.bool create_private_ip: Create private IP for the instance
        :param _builtins.str docker_port: Docker Port
        :param _builtins.str image: Specifies the Linode Instance image which determines the OS distribution and base files
        :param _builtins.str instance_type: Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        :param _builtins.str label: Linode Instance Label
        :param _builtins.str region: Specifies the region (location) of the Linode instance
        :param _builtins.str root_pass: Root Password
        :param _builtins.str ssh_port: Linode Instance SSH Port
        :param _builtins.str ssh_user: Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        :param _builtins.str stackscript: Specifies the Linode StackScript to use to create the instance
        :param _builtins.str stackscript_data: A JSON string specifying data for the selected StackScript
        :param _builtins.str swap_size: Linode Instance Swap Size (MB)
        :param _builtins.str tags: A comma separated list of tags to apply to the the Linode resource
        :param _builtins.str token: Linode API Token
        :param _builtins.str ua_prefix: Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        if authorized_users is not None:
            pulumi.set(__self__, "authorized_users", authorized_users)
        if create_private_ip is not None:
            pulumi.set(__self__, "create_private_ip", create_private_ip)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if root_pass is not None:
            pulumi.set(__self__, "root_pass", root_pass)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if stackscript is not None:
            pulumi.set(__self__, "stackscript", stackscript)
        if stackscript_data is not None:
            pulumi.set(__self__, "stackscript_data", stackscript_data)
        if swap_size is not None:
            pulumi.set(__self__, "swap_size", swap_size)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if ua_prefix is not None:
            pulumi.set(__self__, "ua_prefix", ua_prefix)

    @_builtins.property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[_builtins.str]:
        """
        Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        """
        return pulumi.get(self, "authorized_users")

    @_builtins.property
    @pulumi.getter(name="createPrivateIp")
    def create_private_ip(self) -> Optional[_builtins.bool]:
        """
        Create private IP for the instance
        """
        return pulumi.get(self, "create_private_ip")

    @_builtins.property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[_builtins.str]:
        """
        Docker Port
        """
        return pulumi.get(self, "docker_port")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Specifies the Linode Instance image which determines the OS distribution and base files
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Linode Instance Label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Specifies the region (location) of the Linode instance
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="rootPass")
    def root_pass(self) -> Optional[_builtins.str]:
        """
        Root Password
        """
        return pulumi.get(self, "root_pass")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        Linode Instance SSH Port
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter
    def stackscript(self) -> Optional[_builtins.str]:
        """
        Specifies the Linode StackScript to use to create the instance
        """
        return pulumi.get(self, "stackscript")

    @_builtins.property
    @pulumi.getter(name="stackscriptData")
    def stackscript_data(self) -> Optional[_builtins.str]:
        """
        A JSON string specifying data for the selected StackScript
        """
        return pulumi.get(self, "stackscript_data")

    @_builtins.property
    @pulumi.getter(name="swapSize")
    def swap_size(self) -> Optional[_builtins.str]:
        """
        Linode Instance Swap Size (MB)
        """
        return pulumi.get(self, "swap_size")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        A comma separated list of tags to apply to the the Linode resource
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Linode API Token
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="uaPrefix")
    def ua_prefix(self) -> Optional[_builtins.str]:
        """
        Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        return pulumi.get(self, "ua_prefix")


@pulumi.output_type
class MachineConfigV2OpenstackConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "activeTimeout":
            suggest = "active_timeout"
        elif key == "applicationCredentialId":
            suggest = "application_credential_id"
        elif key == "applicationCredentialName":
            suggest = "application_credential_name"
        elif key == "applicationCredentialSecret":
            suggest = "application_credential_secret"
        elif key == "bootFromVolume":
            suggest = "boot_from_volume"
        elif key == "configDrive":
            suggest = "config_drive"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "flavorId":
            suggest = "flavor_id"
        elif key == "flavorName":
            suggest = "flavor_name"
        elif key == "floatingIpPool":
            suggest = "floating_ip_pool"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "keypairName":
            suggest = "keypair_name"
        elif key == "netId":
            suggest = "net_id"
        elif key == "netName":
            suggest = "net_name"
        elif key == "novaNetwork":
            suggest = "nova_network"
        elif key == "privateKeyFile":
            suggest = "private_key_file"
        elif key == "secGroups":
            suggest = "sec_groups"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "tenantDomainId":
            suggest = "tenant_domain_id"
        elif key == "tenantDomainName":
            suggest = "tenant_domain_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "userDataFile":
            suggest = "user_data_file"
        elif key == "userDomainId":
            suggest = "user_domain_id"
        elif key == "userDomainName":
            suggest = "user_domain_name"
        elif key == "volumeDevicePath":
            suggest = "volume_device_path"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeName":
            suggest = "volume_name"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2OpenstackConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2OpenstackConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2OpenstackConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: _builtins.str,
                 availability_zone: _builtins.str,
                 region: _builtins.str,
                 active_timeout: Optional[_builtins.str] = None,
                 application_credential_id: Optional[_builtins.str] = None,
                 application_credential_name: Optional[_builtins.str] = None,
                 application_credential_secret: Optional[_builtins.str] = None,
                 boot_from_volume: Optional[_builtins.bool] = None,
                 cacert: Optional[_builtins.str] = None,
                 config_drive: Optional[_builtins.bool] = None,
                 domain_id: Optional[_builtins.str] = None,
                 domain_name: Optional[_builtins.str] = None,
                 endpoint_type: Optional[_builtins.str] = None,
                 flavor_id: Optional[_builtins.str] = None,
                 flavor_name: Optional[_builtins.str] = None,
                 floating_ip_pool: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 image_name: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 ip_version: Optional[_builtins.str] = None,
                 keypair_name: Optional[_builtins.str] = None,
                 net_id: Optional[_builtins.str] = None,
                 net_name: Optional[_builtins.str] = None,
                 nova_network: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 private_key_file: Optional[_builtins.str] = None,
                 sec_groups: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 tenant_domain_id: Optional[_builtins.str] = None,
                 tenant_domain_name: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 tenant_name: Optional[_builtins.str] = None,
                 user_data_file: Optional[_builtins.str] = None,
                 user_domain_id: Optional[_builtins.str] = None,
                 user_domain_name: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None,
                 volume_device_path: Optional[_builtins.str] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_name: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.str] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_url: OpenStack authentication URL (string)
        :param _builtins.str availability_zone: OpenStack availability zone (string)
        :param _builtins.str region: OpenStack region name (string)
        :param _builtins.str active_timeout: OpenStack active timeout Default `200` (string)
        :param _builtins.str application_credential_id: OpenStack application credential id. Conflicts with `application_credential_name` (string)
        :param _builtins.str application_credential_name: OpenStack application credential name. Conflicts with `application_credential_id` (string)
        :param _builtins.str application_credential_secret: OpenStack application credential secret (string)
        :param _builtins.bool boot_from_volume: Enable booting from volume. Default is `false` (bool)
        :param _builtins.str cacert: CA certificate bundle to verify against (string)
        :param _builtins.bool config_drive: Enables the OpenStack config drive for the instance. Default `false` (bool)
        :param _builtins.str domain_id: OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        :param _builtins.str domain_name: OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        :param _builtins.str endpoint_type: OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        :param _builtins.str flavor_id: OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        :param _builtins.str flavor_name: OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        :param _builtins.str floating_ip_pool: OpenStack floating IP pool to get an IP from to assign to the instance (string)
        :param _builtins.str image_id: OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        :param _builtins.str image_name: OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        :param _builtins.bool insecure: Disable TLS credential checking. Default `false` (bool)
        :param _builtins.str ip_version: OpenStack version of IP address assigned for the machine Default `4` (string)
        :param _builtins.str keypair_name: OpenStack keypair to use to SSH to the instance (string)
        :param _builtins.str net_id: OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        :param _builtins.str net_name: OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        :param _builtins.bool nova_network: Use the nova networking services instead of neutron (string)
        :param _builtins.str password: OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param _builtins.str private_key_file: Private key content to use for SSH (string)
        :param _builtins.str sec_groups: OpenStack comma separated security groups for the machine (string)
        :param _builtins.str ssh_port: If using a non-B2D image you can specify the ssh port. Default `22` (string)
        :param _builtins.str ssh_user: If using a non-B2D image you can specify the ssh user. Default `docker`. (string)
        :param _builtins.str tenant_domain_id: OpenStack tenant domain id. Conflicts with `tenant_domain_name` (string)
        :param _builtins.str tenant_domain_name: OpenStack tenant domain name. Conflicts with `tenant_domain_id` (string)
        :param _builtins.str tenant_id: OpenStack tenant id. Conflicts with `tenant_name` (string)
        :param _builtins.str tenant_name: OpenStack tenant name. Conflicts with `tenant_id` (string)
        :param _builtins.str user_data_file: File containing an openstack userdata script (string)
        :param _builtins.str user_domain_id: OpenStack user domain id. Conflicts with `user_domain_name` (string)
        :param _builtins.str user_domain_name: OpenStack user domain name. Conflicts with `user_domain_id` (string)
        :param _builtins.str username: The username to be set when logging into the virtual machines (string)
        :param _builtins.str volume_device_path: OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
               > **Note:**: `Required+` denotes that either the _name or _id is required but you cannot use both.
               > **Note:**: `Required++` denotes that either the _name or _id is required unless `application_credential_id` is defined.
               > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        :param _builtins.str volume_id: OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param _builtins.str volume_name: OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param _builtins.str volume_size: OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        :param _builtins.str volume_type: OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "region", region)
        if active_timeout is not None:
            pulumi.set(__self__, "active_timeout", active_timeout)
        if application_credential_id is not None:
            pulumi.set(__self__, "application_credential_id", application_credential_id)
        if application_credential_name is not None:
            pulumi.set(__self__, "application_credential_name", application_credential_name)
        if application_credential_secret is not None:
            pulumi.set(__self__, "application_credential_secret", application_credential_secret)
        if boot_from_volume is not None:
            pulumi.set(__self__, "boot_from_volume", boot_from_volume)
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if config_drive is not None:
            pulumi.set(__self__, "config_drive", config_drive)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if flavor_name is not None:
            pulumi.set(__self__, "flavor_name", flavor_name)
        if floating_ip_pool is not None:
            pulumi.set(__self__, "floating_ip_pool", floating_ip_pool)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if keypair_name is not None:
            pulumi.set(__self__, "keypair_name", keypair_name)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if net_name is not None:
            pulumi.set(__self__, "net_name", net_name)
        if nova_network is not None:
            pulumi.set(__self__, "nova_network", nova_network)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key_file is not None:
            pulumi.set(__self__, "private_key_file", private_key_file)
        if sec_groups is not None:
            pulumi.set(__self__, "sec_groups", sec_groups)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tenant_domain_id is not None:
            pulumi.set(__self__, "tenant_domain_id", tenant_domain_id)
        if tenant_domain_name is not None:
            pulumi.set(__self__, "tenant_domain_name", tenant_domain_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if user_data_file is not None:
            pulumi.set(__self__, "user_data_file", user_data_file)
        if user_domain_id is not None:
            pulumi.set(__self__, "user_domain_id", user_domain_id)
        if user_domain_name is not None:
            pulumi.set(__self__, "user_domain_name", user_domain_name)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if volume_device_path is not None:
            pulumi.set(__self__, "volume_device_path", volume_device_path)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        """
        OpenStack authentication URL (string)
        """
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        OpenStack availability zone (string)
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        OpenStack region name (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="activeTimeout")
    def active_timeout(self) -> Optional[_builtins.str]:
        """
        OpenStack active timeout Default `200` (string)
        """
        return pulumi.get(self, "active_timeout")

    @_builtins.property
    @pulumi.getter(name="applicationCredentialId")
    def application_credential_id(self) -> Optional[_builtins.str]:
        """
        OpenStack application credential id. Conflicts with `application_credential_name` (string)
        """
        return pulumi.get(self, "application_credential_id")

    @_builtins.property
    @pulumi.getter(name="applicationCredentialName")
    def application_credential_name(self) -> Optional[_builtins.str]:
        """
        OpenStack application credential name. Conflicts with `application_credential_id` (string)
        """
        return pulumi.get(self, "application_credential_name")

    @_builtins.property
    @pulumi.getter(name="applicationCredentialSecret")
    def application_credential_secret(self) -> Optional[_builtins.str]:
        """
        OpenStack application credential secret (string)
        """
        return pulumi.get(self, "application_credential_secret")

    @_builtins.property
    @pulumi.getter(name="bootFromVolume")
    def boot_from_volume(self) -> Optional[_builtins.bool]:
        """
        Enable booting from volume. Default is `false` (bool)
        """
        return pulumi.get(self, "boot_from_volume")

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[_builtins.str]:
        """
        CA certificate bundle to verify against (string)
        """
        return pulumi.get(self, "cacert")

    @_builtins.property
    @pulumi.getter(name="configDrive")
    def config_drive(self) -> Optional[_builtins.bool]:
        """
        Enables the OpenStack config drive for the instance. Default `false` (bool)
        """
        return pulumi.get(self, "config_drive")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[_builtins.str]:
        """
        OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[_builtins.str]:
        """
        OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        """
        return pulumi.get(self, "endpoint_type")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[_builtins.str]:
        """
        OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter(name="flavorName")
    def flavor_name(self) -> Optional[_builtins.str]:
        """
        OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        """
        return pulumi.get(self, "flavor_name")

    @_builtins.property
    @pulumi.getter(name="floatingIpPool")
    def floating_ip_pool(self) -> Optional[_builtins.str]:
        """
        OpenStack floating IP pool to get an IP from to assign to the instance (string)
        """
        return pulumi.get(self, "floating_ip_pool")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[_builtins.str]:
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Disable TLS credential checking. Default `false` (bool)
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[_builtins.str]:
        """
        OpenStack version of IP address assigned for the machine Default `4` (string)
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter(name="keypairName")
    def keypair_name(self) -> Optional[_builtins.str]:
        """
        OpenStack keypair to use to SSH to the instance (string)
        """
        return pulumi.get(self, "keypair_name")

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[_builtins.str]:
        """
        OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        """
        return pulumi.get(self, "net_id")

    @_builtins.property
    @pulumi.getter(name="netName")
    def net_name(self) -> Optional[_builtins.str]:
        """
        OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        """
        return pulumi.get(self, "net_name")

    @_builtins.property
    @pulumi.getter(name="novaNetwork")
    def nova_network(self) -> Optional[_builtins.bool]:
        """
        Use the nova networking services instead of neutron (string)
        """
        return pulumi.get(self, "nova_network")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="privateKeyFile")
    def private_key_file(self) -> Optional[_builtins.str]:
        """
        Private key content to use for SSH (string)
        """
        return pulumi.get(self, "private_key_file")

    @_builtins.property
    @pulumi.getter(name="secGroups")
    def sec_groups(self) -> Optional[_builtins.str]:
        """
        OpenStack comma separated security groups for the machine (string)
        """
        return pulumi.get(self, "sec_groups")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh port. Default `22` (string)
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. (string)
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="tenantDomainId")
    def tenant_domain_id(self) -> Optional[_builtins.str]:
        """
        OpenStack tenant domain id. Conflicts with `tenant_domain_name` (string)
        """
        return pulumi.get(self, "tenant_domain_id")

    @_builtins.property
    @pulumi.getter(name="tenantDomainName")
    def tenant_domain_name(self) -> Optional[_builtins.str]:
        """
        OpenStack tenant domain name. Conflicts with `tenant_domain_id` (string)
        """
        return pulumi.get(self, "tenant_domain_name")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        OpenStack tenant id. Conflicts with `tenant_name` (string)
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[_builtins.str]:
        """
        OpenStack tenant name. Conflicts with `tenant_id` (string)
        """
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter(name="userDataFile")
    def user_data_file(self) -> Optional[_builtins.str]:
        """
        File containing an openstack userdata script (string)
        """
        return pulumi.get(self, "user_data_file")

    @_builtins.property
    @pulumi.getter(name="userDomainId")
    def user_domain_id(self) -> Optional[_builtins.str]:
        """
        OpenStack user domain id. Conflicts with `user_domain_name` (string)
        """
        return pulumi.get(self, "user_domain_id")

    @_builtins.property
    @pulumi.getter(name="userDomainName")
    def user_domain_name(self) -> Optional[_builtins.str]:
        """
        OpenStack user domain name. Conflicts with `user_domain_id` (string)
        """
        return pulumi.get(self, "user_domain_name")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        The username to be set when logging into the virtual machines (string)
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="volumeDevicePath")
    def volume_device_path(self) -> Optional[_builtins.str]:
        """
        OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
        > **Note:**: `Required+` denotes that either the _name or _id is required but you cannot use both.
        > **Note:**: `Required++` denotes that either the _name or _id is required unless `application_credential_id` is defined.
        > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        """
        return pulumi.get(self, "volume_device_path")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        """
        OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[_builtins.str]:
        """
        OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_name")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.str]:
        """
        OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class MachineConfigV2VsphereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boot2dockerUrl":
            suggest = "boot2docker_url"
        elif key == "cloneFrom":
            suggest = "clone_from"
        elif key == "cloudConfig":
            suggest = "cloud_config"
        elif key == "contentLibrary":
            suggest = "content_library"
        elif key == "cpuCount":
            suggest = "cpu_count"
        elif key == "creationType":
            suggest = "creation_type"
        elif key == "customAttributes":
            suggest = "custom_attributes"
        elif key == "datastoreCluster":
            suggest = "datastore_cluster"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "gracefulShutdownTimeout":
            suggest = "graceful_shutdown_timeout"
        elif key == "memorySize":
            suggest = "memory_size"
        elif key == "sshPassword":
            suggest = "ssh_password"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "sshUserGroup":
            suggest = "ssh_user_group"
        elif key == "vappIpAllocationPolicy":
            suggest = "vapp_ip_allocation_policy"
        elif key == "vappIpProtocol":
            suggest = "vapp_ip_protocol"
        elif key == "vappProperties":
            suggest = "vapp_properties"
        elif key == "vappTransport":
            suggest = "vapp_transport"
        elif key == "vcenterPort":
            suggest = "vcenter_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MachineConfigV2VsphereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MachineConfigV2VsphereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MachineConfigV2VsphereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot2docker_url: Optional[_builtins.str] = None,
                 cfgparams: Optional[Sequence[_builtins.str]] = None,
                 clone_from: Optional[_builtins.str] = None,
                 cloud_config: Optional[_builtins.str] = None,
                 cloudinit: Optional[_builtins.str] = None,
                 content_library: Optional[_builtins.str] = None,
                 cpu_count: Optional[_builtins.str] = None,
                 creation_type: Optional[_builtins.str] = None,
                 custom_attributes: Optional[Sequence[_builtins.str]] = None,
                 datacenter: Optional[_builtins.str] = None,
                 datastore: Optional[_builtins.str] = None,
                 datastore_cluster: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 graceful_shutdown_timeout: Optional[_builtins.str] = None,
                 hostsystem: Optional[_builtins.str] = None,
                 memory_size: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 os: Optional[_builtins.str] = None,
                 password: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 ssh_password: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 ssh_user_group: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 username: Optional[_builtins.str] = None,
                 vapp_ip_allocation_policy: Optional[_builtins.str] = None,
                 vapp_ip_protocol: Optional[_builtins.str] = None,
                 vapp_properties: Optional[Sequence[_builtins.str]] = None,
                 vapp_transport: Optional[_builtins.str] = None,
                 vcenter: Optional[_builtins.str] = None,
                 vcenter_port: Optional[_builtins.str] = None):
        """
        :param _builtins.str boot2docker_url: vSphere URL for boot2docker image
        :param Sequence[_builtins.str] cfgparams: vSphere vm configuration parameters (used for guestinfo)
        :param _builtins.str clone_from: If you choose creation type clone a name of what you want to clone is required
        :param _builtins.str cloud_config: Filepath to a cloud-config yaml file to put into the ISO user-data
        :param _builtins.str cloudinit: vSphere cloud-init filepath or url to add to guestinfo
        :param _builtins.str content_library: If you choose to clone from a content library template specify the name of the library
        :param _builtins.str cpu_count: vSphere CPU number for docker VM
        :param _builtins.str creation_type: Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        :param Sequence[_builtins.str] custom_attributes: vSphere custom attributes, format key/value e.g. '200=my custom value'
        :param _builtins.str datacenter: vSphere datacenter for virtual machine
        :param _builtins.str datastore: vSphere datastore for virtual machine
        :param _builtins.str datastore_cluster: vSphere datastore cluster for virtual machine
        :param _builtins.str disk_size: vSphere size of disk for docker VM (in MB)
        :param _builtins.str folder: vSphere folder for the docker VM. This folder must already exist in the datacenter
        :param _builtins.str graceful_shutdown_timeout: Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        :param _builtins.str hostsystem: vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        :param _builtins.str memory_size: vSphere size of memory for docker VM (in MB)
        :param Sequence[_builtins.str] networks: vSphere network where the virtual machine will be attached
        :param _builtins.str os: Type of virtual machine OS in vSphere
        :param _builtins.str password: vSphere password
        :param _builtins.str pool: vSphere resource pool for docker VM
        :param _builtins.str ssh_password: If using a non-B2D image you can specify the ssh password
        :param _builtins.str ssh_port: If using a non-B2D image you can specify the ssh port
        :param _builtins.str ssh_user: If using a non-B2D image you can specify the ssh user
        :param _builtins.str ssh_user_group: If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        :param Sequence[_builtins.str] tags: vSphere tags id e.g. urn:xxx
        :param _builtins.str username: vSphere username
        :param _builtins.str vapp_ip_allocation_policy: vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        :param _builtins.str vapp_ip_protocol: vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        :param Sequence[_builtins.str] vapp_properties: vSphere vApp properties
        :param _builtins.str vapp_transport: vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        :param _builtins.str vcenter: vSphere IP/hostname for vCenter
        :param _builtins.str vcenter_port: vSphere Port for vCenter
        """
        if boot2docker_url is not None:
            pulumi.set(__self__, "boot2docker_url", boot2docker_url)
        if cfgparams is not None:
            pulumi.set(__self__, "cfgparams", cfgparams)
        if clone_from is not None:
            pulumi.set(__self__, "clone_from", clone_from)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloudinit is not None:
            pulumi.set(__self__, "cloudinit", cloudinit)
        if content_library is not None:
            pulumi.set(__self__, "content_library", content_library)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if datastore_cluster is not None:
            pulumi.set(__self__, "datastore_cluster", datastore_cluster)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if hostsystem is not None:
            pulumi.set(__self__, "hostsystem", hostsystem)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if os is not None:
            pulumi.set(__self__, "os", os)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if ssh_user_group is not None:
            pulumi.set(__self__, "ssh_user_group", ssh_user_group)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vapp_ip_allocation_policy is not None:
            pulumi.set(__self__, "vapp_ip_allocation_policy", vapp_ip_allocation_policy)
        if vapp_ip_protocol is not None:
            pulumi.set(__self__, "vapp_ip_protocol", vapp_ip_protocol)
        if vapp_properties is not None:
            pulumi.set(__self__, "vapp_properties", vapp_properties)
        if vapp_transport is not None:
            pulumi.set(__self__, "vapp_transport", vapp_transport)
        if vcenter is not None:
            pulumi.set(__self__, "vcenter", vcenter)
        if vcenter_port is not None:
            pulumi.set(__self__, "vcenter_port", vcenter_port)

    @_builtins.property
    @pulumi.getter(name="boot2dockerUrl")
    def boot2docker_url(self) -> Optional[_builtins.str]:
        """
        vSphere URL for boot2docker image
        """
        return pulumi.get(self, "boot2docker_url")

    @_builtins.property
    @pulumi.getter
    def cfgparams(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere vm configuration parameters (used for guestinfo)
        """
        return pulumi.get(self, "cfgparams")

    @_builtins.property
    @pulumi.getter(name="cloneFrom")
    def clone_from(self) -> Optional[_builtins.str]:
        """
        If you choose creation type clone a name of what you want to clone is required
        """
        return pulumi.get(self, "clone_from")

    @_builtins.property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[_builtins.str]:
        """
        Filepath to a cloud-config yaml file to put into the ISO user-data
        """
        return pulumi.get(self, "cloud_config")

    @_builtins.property
    @pulumi.getter
    def cloudinit(self) -> Optional[_builtins.str]:
        """
        vSphere cloud-init filepath or url to add to guestinfo
        """
        return pulumi.get(self, "cloudinit")

    @_builtins.property
    @pulumi.getter(name="contentLibrary")
    def content_library(self) -> Optional[_builtins.str]:
        """
        If you choose to clone from a content library template specify the name of the library
        """
        return pulumi.get(self, "content_library")

    @_builtins.property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[_builtins.str]:
        """
        vSphere CPU number for docker VM
        """
        return pulumi.get(self, "cpu_count")

    @_builtins.property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[_builtins.str]:
        """
        Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        """
        return pulumi.get(self, "creation_type")

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere custom attributes, format key/value e.g. '200=my custom value'
        """
        return pulumi.get(self, "custom_attributes")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        vSphere datacenter for virtual machine
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def datastore(self) -> Optional[_builtins.str]:
        """
        vSphere datastore for virtual machine
        """
        return pulumi.get(self, "datastore")

    @_builtins.property
    @pulumi.getter(name="datastoreCluster")
    def datastore_cluster(self) -> Optional[_builtins.str]:
        """
        vSphere datastore cluster for virtual machine
        """
        return pulumi.get(self, "datastore_cluster")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.str]:
        """
        vSphere size of disk for docker VM (in MB)
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        """
        vSphere folder for the docker VM. This folder must already exist in the datacenter
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[_builtins.str]:
        """
        Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        """
        return pulumi.get(self, "graceful_shutdown_timeout")

    @_builtins.property
    @pulumi.getter
    def hostsystem(self) -> Optional[_builtins.str]:
        """
        vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        """
        return pulumi.get(self, "hostsystem")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[_builtins.str]:
        """
        vSphere size of memory for docker VM (in MB)
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere network where the virtual machine will be attached
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def os(self) -> Optional[_builtins.str]:
        """
        Type of virtual machine OS in vSphere
        """
        return pulumi.get(self, "os")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        vSphere password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        vSphere resource pool for docker VM
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh password
        """
        return pulumi.get(self, "ssh_password")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh port
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="sshUserGroup")
    def ssh_user_group(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        """
        return pulumi.get(self, "ssh_user_group")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere tags id e.g. urn:xxx
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        vSphere username
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="vappIpAllocationPolicy")
    def vapp_ip_allocation_policy(self) -> Optional[_builtins.str]:
        """
        vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        """
        return pulumi.get(self, "vapp_ip_allocation_policy")

    @_builtins.property
    @pulumi.getter(name="vappIpProtocol")
    def vapp_ip_protocol(self) -> Optional[_builtins.str]:
        """
        vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        """
        return pulumi.get(self, "vapp_ip_protocol")

    @_builtins.property
    @pulumi.getter(name="vappProperties")
    def vapp_properties(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere vApp properties
        """
        return pulumi.get(self, "vapp_properties")

    @_builtins.property
    @pulumi.getter(name="vappTransport")
    def vapp_transport(self) -> Optional[_builtins.str]:
        """
        vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        """
        return pulumi.get(self, "vapp_transport")

    @_builtins.property
    @pulumi.getter
    def vcenter(self) -> Optional[_builtins.str]:
        """
        vSphere IP/hostname for vCenter
        """
        return pulumi.get(self, "vcenter")

    @_builtins.property
    @pulumi.getter(name="vcenterPort")
    def vcenter_port(self) -> Optional[_builtins.str]:
        """
        vSphere Port for vCenter
        """
        return pulumi.get(self, "vcenter_port")


@pulumi.output_type
class NamespaceContainerResourceLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitsCpu":
            suggest = "limits_cpu"
        elif key == "limitsMemory":
            suggest = "limits_memory"
        elif key == "requestsCpu":
            suggest = "requests_cpu"
        elif key == "requestsMemory":
            suggest = "requests_memory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceContainerResourceLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceContainerResourceLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceContainerResourceLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None):
        """
        :param _builtins.str limits_cpu: Limit for limits cpu in namespace (string)
        :param _builtins.str limits_memory: Limit for limits memory in namespace (string)
        :param _builtins.str requests_cpu: Limit for requests cpu in namespace (string)
        :param _builtins.str requests_memory: Limit for requests memory in namespace (string)
        """
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for limits cpu in namespace (string)
        """
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        """
        Limit for limits memory in namespace (string)
        """
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for requests cpu in namespace (string)
        """
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        """
        Limit for requests memory in namespace (string)
        """
        return pulumi.get(self, "requests_memory")


@pulumi.output_type
class NamespaceResourceQuota(dict):
    def __init__(__self__, *,
                 limit: 'outputs.NamespaceResourceQuotaLimit'):
        """
        :param 'NamespaceResourceQuotaLimitArgs' limit: Resource quota limit for namespace (list maxitems:1)
        """
        pulumi.set(__self__, "limit", limit)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> 'outputs.NamespaceResourceQuotaLimit':
        """
        Resource quota limit for namespace (list maxitems:1)
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class NamespaceResourceQuotaLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMaps":
            suggest = "config_maps"
        elif key == "limitsCpu":
            suggest = "limits_cpu"
        elif key == "limitsMemory":
            suggest = "limits_memory"
        elif key == "persistentVolumeClaims":
            suggest = "persistent_volume_claims"
        elif key == "replicationControllers":
            suggest = "replication_controllers"
        elif key == "requestsCpu":
            suggest = "requests_cpu"
        elif key == "requestsMemory":
            suggest = "requests_memory"
        elif key == "requestsStorage":
            suggest = "requests_storage"
        elif key == "servicesLoadBalancers":
            suggest = "services_load_balancers"
        elif key == "servicesNodePorts":
            suggest = "services_node_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NamespaceResourceQuotaLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NamespaceResourceQuotaLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NamespaceResourceQuotaLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_maps: Optional[_builtins.str] = None,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 persistent_volume_claims: Optional[_builtins.str] = None,
                 pods: Optional[_builtins.str] = None,
                 replication_controllers: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None,
                 requests_storage: Optional[_builtins.str] = None,
                 secrets: Optional[_builtins.str] = None,
                 services: Optional[_builtins.str] = None,
                 services_load_balancers: Optional[_builtins.str] = None,
                 services_node_ports: Optional[_builtins.str] = None):
        """
        :param _builtins.str config_maps: Limit for config maps in namespace (string)
        :param _builtins.str limits_cpu: Limit for limits cpu in namespace (string)
        :param _builtins.str limits_memory: Limit for limits memory in namespace (string)
        :param _builtins.str persistent_volume_claims: Limit for persistent volume claims in namespace (string)
        :param _builtins.str pods: Limit for pods in namespace (string)
        :param _builtins.str replication_controllers: Limit for replication controllers in namespace (string)
        :param _builtins.str requests_cpu: Limit for requests cpu in namespace (string)
        :param _builtins.str requests_memory: Limit for requests memory in namespace (string)
        :param _builtins.str requests_storage: Limit for requests storage in namespace (string)
        :param _builtins.str secrets: Limit for secrets in namespace (string)
        :param _builtins.str services_load_balancers: Limit for services load balancers in namespace (string)
        :param _builtins.str services_node_ports: Limit for services node ports in namespace (string)
               
               More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[_builtins.str]:
        """
        Limit for config maps in namespace (string)
        """
        return pulumi.get(self, "config_maps")

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for limits cpu in namespace (string)
        """
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        """
        Limit for limits memory in namespace (string)
        """
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[_builtins.str]:
        """
        Limit for persistent volume claims in namespace (string)
        """
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.str]:
        """
        Limit for pods in namespace (string)
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[_builtins.str]:
        """
        Limit for replication controllers in namespace (string)
        """
        return pulumi.get(self, "replication_controllers")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for requests cpu in namespace (string)
        """
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        """
        Limit for requests memory in namespace (string)
        """
        return pulumi.get(self, "requests_memory")

    @_builtins.property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[_builtins.str]:
        """
        Limit for requests storage in namespace (string)
        """
        return pulumi.get(self, "requests_storage")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[_builtins.str]:
        """
        Limit for secrets in namespace (string)
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[_builtins.str]:
        """
        Limit for services load balancers in namespace (string)
        """
        return pulumi.get(self, "services_load_balancers")

    @_builtins.property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[_builtins.str]:
        """
        Limit for services node ports in namespace (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        return pulumi.get(self, "services_node_ports")


@pulumi.output_type
class NodePoolNodeTaint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAdded":
            suggest = "time_added"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodePoolNodeTaint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodePoolNodeTaint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodePoolNodeTaint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 time_added: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Taint key (string)
        :param _builtins.str value: Taint value (string)
        :param _builtins.str effect: Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        :param _builtins.str time_added: Taint time added (string)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if time_added is not None:
            pulumi.set(__self__, "time_added", time_added)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Taint value (string)
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> Optional[_builtins.str]:
        """
        Taint time added (string)
        """
        return pulumi.get(self, "time_added")


@pulumi.output_type
class NodeTemplateAmazonec2Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "deviceName":
            suggest = "device_name"
        elif key == "encryptEbsVolume":
            suggest = "encrypt_ebs_volume"
        elif key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "insecureTransport":
            suggest = "insecure_transport"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kmsKey":
            suggest = "kms_key"
        elif key == "openPorts":
            suggest = "open_ports"
        elif key == "privateAddressOnly":
            suggest = "private_address_only"
        elif key == "requestSpotInstance":
            suggest = "request_spot_instance"
        elif key == "rootSize":
            suggest = "root_size"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "securityGroupReadonly":
            suggest = "security_group_readonly"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "sshKeypath":
            suggest = "ssh_keypath"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "useEbsOptimizedInstance":
            suggest = "use_ebs_optimized_instance"
        elif key == "usePrivateAddress":
            suggest = "use_private_address"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateAmazonec2Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateAmazonec2Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateAmazonec2Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ami: _builtins.str,
                 region: _builtins.str,
                 security_groups: Sequence[_builtins.str],
                 subnet_id: _builtins.str,
                 vpc_id: _builtins.str,
                 zone: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 block_duration_minutes: Optional[_builtins.str] = None,
                 device_name: Optional[_builtins.str] = None,
                 encrypt_ebs_volume: Optional[_builtins.bool] = None,
                 endpoint: Optional[_builtins.str] = None,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 iam_instance_profile: Optional[_builtins.str] = None,
                 insecure_transport: Optional[_builtins.bool] = None,
                 instance_type: Optional[_builtins.str] = None,
                 kms_key: Optional[_builtins.str] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 open_ports: Optional[Sequence[_builtins.str]] = None,
                 private_address_only: Optional[_builtins.bool] = None,
                 request_spot_instance: Optional[_builtins.bool] = None,
                 retries: Optional[_builtins.str] = None,
                 root_size: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 security_group_readonly: Optional[_builtins.bool] = None,
                 session_token: Optional[_builtins.str] = None,
                 spot_price: Optional[_builtins.str] = None,
                 ssh_keypath: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 use_ebs_optimized_instance: Optional[_builtins.bool] = None,
                 use_private_address: Optional[_builtins.bool] = None,
                 userdata: Optional[_builtins.str] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str ami: AWS machine image
        :param _builtins.str region: AWS Region
        :param Sequence[_builtins.str] security_groups: AWS VPC security group
        :param _builtins.str subnet_id: AWS VPC subnet id
        :param _builtins.str vpc_id: AWS VPC id
        :param _builtins.str zone: AWS zone for instance (i.e. a,b,c,d,e)
        :param _builtins.str access_key: AWS Access Key
        :param _builtins.str block_duration_minutes: AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        :param _builtins.str device_name: AWS root device name
        :param _builtins.bool encrypt_ebs_volume: Encrypt EBS volume
        :param _builtins.str endpoint: Optional endpoint URL (hostname only or fully qualified URI)
        :param _builtins.str http_endpoint: Enables or disables the HTTP metadata endpoint on your instances
        :param _builtins.str http_tokens: The state of token usage for your instance metadata requests
        :param _builtins.str iam_instance_profile: AWS IAM Instance Profile
        :param _builtins.bool insecure_transport: Disable SSL when sending requests
        :param _builtins.str instance_type: AWS instance type
        :param _builtins.str kms_key: Custom KMS key ID using the AWS Managed CMK
        :param _builtins.bool monitoring: Set this flag to enable CloudWatch monitoring
        :param Sequence[_builtins.str] open_ports: Make the specified port number accessible from the Internet
        :param _builtins.bool private_address_only: Only use a private IP address
        :param _builtins.bool request_spot_instance: Set this flag to request spot instance
        :param _builtins.str retries: Set retry count for recoverable failures (use -1 to disable)
        :param _builtins.str root_size: AWS root disk size (in GB)
        :param _builtins.str secret_key: AWS Secret Key
        :param _builtins.bool security_group_readonly: Skip adding default rules to security groups
        :param _builtins.str session_token: AWS Session Token
        :param _builtins.str spot_price: AWS spot instance bid price (in dollar)
        :param _builtins.str ssh_keypath: SSH Key for Instance
        :param _builtins.str ssh_user: Set the name of the ssh user
        :param _builtins.str tags: AWS Tags (e.g. key1,value1,key2,value2)
        :param _builtins.bool use_ebs_optimized_instance: Create an EBS optimized instance
        :param _builtins.bool use_private_address: Force the usage of private IP address
        :param _builtins.str userdata: Path to file with cloud-init user data
        :param _builtins.str volume_type: Amazon EBS volume type
        """
        pulumi.set(__self__, "ami", ami)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc_id", vpc_id)
        pulumi.set(__self__, "zone", zone)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if encrypt_ebs_volume is not None:
            pulumi.set(__self__, "encrypt_ebs_volume", encrypt_ebs_volume)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if insecure_transport is not None:
            pulumi.set(__self__, "insecure_transport", insecure_transport)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if private_address_only is not None:
            pulumi.set(__self__, "private_address_only", private_address_only)
        if request_spot_instance is not None:
            pulumi.set(__self__, "request_spot_instance", request_spot_instance)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if root_size is not None:
            pulumi.set(__self__, "root_size", root_size)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if security_group_readonly is not None:
            pulumi.set(__self__, "security_group_readonly", security_group_readonly)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if ssh_keypath is not None:
            pulumi.set(__self__, "ssh_keypath", ssh_keypath)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if use_ebs_optimized_instance is not None:
            pulumi.set(__self__, "use_ebs_optimized_instance", use_ebs_optimized_instance)
        if use_private_address is not None:
            pulumi.set(__self__, "use_private_address", use_private_address)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter
    def ami(self) -> _builtins.str:
        """
        AWS machine image
        """
        return pulumi.get(self, "ami")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS Region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        """
        AWS VPC security group
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        """
        AWS VPC subnet id
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> _builtins.str:
        """
        AWS VPC id
        """
        return pulumi.get(self, "vpc_id")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        AWS zone for instance (i.e. a,b,c,d,e)
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        """
        AWS Access Key
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[_builtins.str]:
        """
        AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360)
        """
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        AWS root device name
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter(name="encryptEbsVolume")
    def encrypt_ebs_volume(self) -> Optional[_builtins.bool]:
        """
        Encrypt EBS volume
        """
        return pulumi.get(self, "encrypt_ebs_volume")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Optional endpoint URL (hostname only or fully qualified URI)
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        Enables or disables the HTTP metadata endpoint on your instances
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        The state of token usage for your instance metadata requests
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[_builtins.str]:
        """
        AWS IAM Instance Profile
        """
        return pulumi.get(self, "iam_instance_profile")

    @_builtins.property
    @pulumi.getter(name="insecureTransport")
    def insecure_transport(self) -> Optional[_builtins.bool]:
        """
        Disable SSL when sending requests
        """
        return pulumi.get(self, "insecure_transport")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        AWS instance type
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        Custom KMS key ID using the AWS Managed CMK
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        """
        Set this flag to enable CloudWatch monitoring
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @_builtins.property
    @pulumi.getter(name="privateAddressOnly")
    def private_address_only(self) -> Optional[_builtins.bool]:
        """
        Only use a private IP address
        """
        return pulumi.get(self, "private_address_only")

    @_builtins.property
    @pulumi.getter(name="requestSpotInstance")
    def request_spot_instance(self) -> Optional[_builtins.bool]:
        """
        Set this flag to request spot instance
        """
        return pulumi.get(self, "request_spot_instance")

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[_builtins.str]:
        """
        Set retry count for recoverable failures (use -1 to disable)
        """
        return pulumi.get(self, "retries")

    @_builtins.property
    @pulumi.getter(name="rootSize")
    def root_size(self) -> Optional[_builtins.str]:
        """
        AWS root disk size (in GB)
        """
        return pulumi.get(self, "root_size")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        AWS Secret Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="securityGroupReadonly")
    def security_group_readonly(self) -> Optional[_builtins.bool]:
        """
        Skip adding default rules to security groups
        """
        return pulumi.get(self, "security_group_readonly")

    @_builtins.property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[_builtins.str]:
        """
        AWS Session Token
        """
        return pulumi.get(self, "session_token")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        AWS spot instance bid price (in dollar)
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="sshKeypath")
    def ssh_keypath(self) -> Optional[_builtins.str]:
        """
        SSH Key for Instance
        """
        return pulumi.get(self, "ssh_keypath")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        Set the name of the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        AWS Tags (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="useEbsOptimizedInstance")
    def use_ebs_optimized_instance(self) -> Optional[_builtins.bool]:
        """
        Create an EBS optimized instance
        """
        return pulumi.get(self, "use_ebs_optimized_instance")

    @_builtins.property
    @pulumi.getter(name="usePrivateAddress")
    def use_private_address(self) -> Optional[_builtins.bool]:
        """
        Force the usage of private IP address
        """
        return pulumi.get(self, "use_private_address")

    @_builtins.property
    @pulumi.getter
    def userdata(self) -> Optional[_builtins.str]:
        """
        Path to file with cloud-init user data
        """
        return pulumi.get(self, "userdata")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        Amazon EBS volume type
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class NodeTemplateAzureConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratedNetworking":
            suggest = "accelerated_networking"
        elif key == "availabilitySet":
            suggest = "availability_set"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "customData":
            suggest = "custom_data"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "dockerPort":
            suggest = "docker_port"
        elif key == "faultDomainCount":
            suggest = "fault_domain_count"
        elif key == "managedDisks":
            suggest = "managed_disks"
        elif key == "noPublicIp":
            suggest = "no_public_ip"
        elif key == "openPorts":
            suggest = "open_ports"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "resourceGroup":
            suggest = "resource_group"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "staticPublicIp":
            suggest = "static_public_ip"
        elif key == "storageType":
            suggest = "storage_type"
        elif key == "subnetPrefix":
            suggest = "subnet_prefix"
        elif key == "subscriptionId":
            suggest = "subscription_id"
        elif key == "updateDomainCount":
            suggest = "update_domain_count"
        elif key == "usePrivateIp":
            suggest = "use_private_ip"
        elif key == "usePublicIpStandardSku":
            suggest = "use_public_ip_standard_sku"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateAzureConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateAzureConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateAzureConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerated_networking: Optional[_builtins.bool] = None,
                 availability_set: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 custom_data: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.str] = None,
                 dns: Optional[_builtins.str] = None,
                 docker_port: Optional[_builtins.str] = None,
                 environment: Optional[_builtins.str] = None,
                 fault_domain_count: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None,
                 managed_disks: Optional[_builtins.bool] = None,
                 no_public_ip: Optional[_builtins.bool] = None,
                 nsg: Optional[_builtins.str] = None,
                 open_ports: Optional[Sequence[_builtins.str]] = None,
                 plan: Optional[_builtins.str] = None,
                 private_ip_address: Optional[_builtins.str] = None,
                 resource_group: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 static_public_ip: Optional[_builtins.bool] = None,
                 storage_type: Optional[_builtins.str] = None,
                 subnet: Optional[_builtins.str] = None,
                 subnet_prefix: Optional[_builtins.str] = None,
                 subscription_id: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 update_domain_count: Optional[_builtins.str] = None,
                 use_private_ip: Optional[_builtins.bool] = None,
                 use_public_ip_standard_sku: Optional[_builtins.bool] = None,
                 vnet: Optional[_builtins.str] = None):
        """
        :param _builtins.bool accelerated_networking: Enable Accelerated Networking when creating an Azure Network Interface
        :param _builtins.str availability_set: Azure Availability Set to place the virtual machine into
        :param _builtins.str availability_zone: The Azure Availability Zone the VM should be created in
        :param _builtins.str client_id: Azure Service Principal Account ID (optional, browser auth is used if not specified)
        :param _builtins.str client_secret: Azure Service Principal Account password (optional, browser auth is used if not specified)
        :param _builtins.str custom_data: Path to file with custom-data
        :param _builtins.str disk_size: Disk size if using managed disk
        :param _builtins.str dns: A unique DNS label for the public IP adddress
        :param _builtins.str docker_port: Port number for Docker engine
        :param _builtins.str environment: Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        :param _builtins.str fault_domain_count: Fault domain count to use for availability set
        :param _builtins.str image: Azure virtual machine OS image
        :param _builtins.str location: Azure region to create the virtual machine
        :param _builtins.bool managed_disks: Configures VM and availability set for managed disks
        :param _builtins.bool no_public_ip: Do not create a public IP address for the machine
        :param _builtins.str nsg: Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        :param Sequence[_builtins.str] open_ports: Make the specified port number accessible from the Internet
        :param _builtins.str plan: Purchase plan for Azure Virtual Machine (in <publisher>:<product>:<plan> format)
        :param _builtins.str private_ip_address: Specify a static private IP address for the machine
        :param _builtins.str resource_group: Azure Resource Group name (will be created if missing)
        :param _builtins.str size: Size for Azure Virtual Machine
        :param _builtins.str ssh_user: Username for SSH login
        :param _builtins.bool static_public_ip: Assign a static public IP address to the machine
        :param _builtins.str storage_type: Type of Storage Account to host the OS Disk for the machine
        :param _builtins.str subnet: Azure Subnet Name to be used within the Virtual Network
        :param _builtins.str subnet_prefix: Private CIDR block to be used for the new subnet, should comply RFC 1918
        :param _builtins.str subscription_id: Azure Subscription ID
        :param _builtins.str tags: Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        :param _builtins.str update_domain_count: Update domain count to use for availability set
        :param _builtins.bool use_private_ip: Use private IP address of the machine to connect
        :param _builtins.bool use_public_ip_standard_sku: Use the Standard SKU when creating a public IP for an Azure VM
        :param _builtins.str vnet: Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        if accelerated_networking is not None:
            pulumi.set(__self__, "accelerated_networking", accelerated_networking)
        if availability_set is not None:
            pulumi.set(__self__, "availability_set", availability_set)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if custom_data is not None:
            pulumi.set(__self__, "custom_data", custom_data)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if dns is not None:
            pulumi.set(__self__, "dns", dns)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if fault_domain_count is not None:
            pulumi.set(__self__, "fault_domain_count", fault_domain_count)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if managed_disks is not None:
            pulumi.set(__self__, "managed_disks", managed_disks)
        if no_public_ip is not None:
            pulumi.set(__self__, "no_public_ip", no_public_ip)
        if nsg is not None:
            pulumi.set(__self__, "nsg", nsg)
        if open_ports is not None:
            pulumi.set(__self__, "open_ports", open_ports)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if static_public_ip is not None:
            pulumi.set(__self__, "static_public_ip", static_public_ip)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_prefix is not None:
            pulumi.set(__self__, "subnet_prefix", subnet_prefix)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if update_domain_count is not None:
            pulumi.set(__self__, "update_domain_count", update_domain_count)
        if use_private_ip is not None:
            pulumi.set(__self__, "use_private_ip", use_private_ip)
        if use_public_ip_standard_sku is not None:
            pulumi.set(__self__, "use_public_ip_standard_sku", use_public_ip_standard_sku)
        if vnet is not None:
            pulumi.set(__self__, "vnet", vnet)

    @_builtins.property
    @pulumi.getter(name="acceleratedNetworking")
    def accelerated_networking(self) -> Optional[_builtins.bool]:
        """
        Enable Accelerated Networking when creating an Azure Network Interface
        """
        return pulumi.get(self, "accelerated_networking")

    @_builtins.property
    @pulumi.getter(name="availabilitySet")
    def availability_set(self) -> Optional[_builtins.str]:
        """
        Azure Availability Set to place the virtual machine into
        """
        return pulumi.get(self, "availability_set")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Azure Availability Zone the VM should be created in
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Azure Service Principal Account ID (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        Azure Service Principal Account password (optional, browser auth is used if not specified)
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="customData")
    def custom_data(self) -> Optional[_builtins.str]:
        """
        Path to file with custom-data
        """
        return pulumi.get(self, "custom_data")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.str]:
        """
        Disk size if using managed disk
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> Optional[_builtins.str]:
        """
        A unique DNS label for the public IP adddress
        """
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[_builtins.str]:
        """
        Port number for Docker engine
        """
        return pulumi.get(self, "docker_port")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[_builtins.str]:
        """
        Azure environment (e.g. AzurePublicCloud, AzureChinaCloud)
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter(name="faultDomainCount")
    def fault_domain_count(self) -> Optional[_builtins.str]:
        """
        Fault domain count to use for availability set
        """
        return pulumi.get(self, "fault_domain_count")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Azure virtual machine OS image
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Azure region to create the virtual machine
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="managedDisks")
    def managed_disks(self) -> Optional[_builtins.bool]:
        """
        Configures VM and availability set for managed disks
        """
        return pulumi.get(self, "managed_disks")

    @_builtins.property
    @pulumi.getter(name="noPublicIp")
    def no_public_ip(self) -> Optional[_builtins.bool]:
        """
        Do not create a public IP address for the machine
        """
        return pulumi.get(self, "no_public_ip")

    @_builtins.property
    @pulumi.getter
    def nsg(self) -> Optional[_builtins.str]:
        """
        Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine)
        """
        return pulumi.get(self, "nsg")

    @_builtins.property
    @pulumi.getter(name="openPorts")
    def open_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        Make the specified port number accessible from the Internet
        """
        return pulumi.get(self, "open_ports")

    @_builtins.property
    @pulumi.getter
    def plan(self) -> Optional[_builtins.str]:
        """
        Purchase plan for Azure Virtual Machine (in <publisher>:<product>:<plan> format)
        """
        return pulumi.get(self, "plan")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        """
        Specify a static private IP address for the machine
        """
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[_builtins.str]:
        """
        Azure Resource Group name (will be created if missing)
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        Size for Azure Virtual Machine
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        Username for SSH login
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="staticPublicIp")
    def static_public_ip(self) -> Optional[_builtins.bool]:
        """
        Assign a static public IP address to the machine
        """
        return pulumi.get(self, "static_public_ip")

    @_builtins.property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[_builtins.str]:
        """
        Type of Storage Account to host the OS Disk for the machine
        """
        return pulumi.get(self, "storage_type")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[_builtins.str]:
        """
        Azure Subnet Name to be used within the Virtual Network
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="subnetPrefix")
    def subnet_prefix(self) -> Optional[_builtins.str]:
        """
        Private CIDR block to be used for the new subnet, should comply RFC 1918
        """
        return pulumi.get(self, "subnet_prefix")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[_builtins.str]:
        """
        Azure Subscription ID
        """
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        Tags to be applied to the Azure VM instance (e.g. key1,value1,key2,value2)
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updateDomainCount")
    def update_domain_count(self) -> Optional[_builtins.str]:
        """
        Update domain count to use for availability set
        """
        return pulumi.get(self, "update_domain_count")

    @_builtins.property
    @pulumi.getter(name="usePrivateIp")
    def use_private_ip(self) -> Optional[_builtins.bool]:
        """
        Use private IP address of the machine to connect
        """
        return pulumi.get(self, "use_private_ip")

    @_builtins.property
    @pulumi.getter(name="usePublicIpStandardSku")
    def use_public_ip_standard_sku(self) -> Optional[_builtins.bool]:
        """
        Use the Standard SKU when creating a public IP for an Azure VM
        """
        return pulumi.get(self, "use_public_ip_standard_sku")

    @_builtins.property
    @pulumi.getter
    def vnet(self) -> Optional[_builtins.str]:
        """
        Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format)
        """
        return pulumi.get(self, "vnet")


@pulumi.output_type
class NodeTemplateDigitaloceanConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"
        elif key == "privateNetworking":
            suggest = "private_networking"
        elif key == "sshKeyFingerprint":
            suggest = "ssh_key_fingerprint"
        elif key == "sshKeyPath":
            suggest = "ssh_key_path"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateDigitaloceanConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateDigitaloceanConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateDigitaloceanConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: Optional[_builtins.str] = None,
                 backups: Optional[_builtins.bool] = None,
                 image: Optional[_builtins.str] = None,
                 ipv6: Optional[_builtins.bool] = None,
                 monitoring: Optional[_builtins.bool] = None,
                 private_networking: Optional[_builtins.bool] = None,
                 region: Optional[_builtins.str] = None,
                 size: Optional[_builtins.str] = None,
                 ssh_key_fingerprint: Optional[_builtins.str] = None,
                 ssh_key_path: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 userdata: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_token: Digital Ocean access token
        :param _builtins.bool backups: Enable backups for droplet
        :param _builtins.str image: Digital Ocean Image
        :param _builtins.bool ipv6: Enable ipv6 for droplet
        :param _builtins.bool monitoring: Enable monitoring for droplet
        :param _builtins.bool private_networking: Enable private networking for droplet
        :param _builtins.str region: Digital Ocean region
        :param _builtins.str size: Digital Ocean size
        :param _builtins.str ssh_key_fingerprint: SSH key fingerprint
        :param _builtins.str ssh_key_path: SSH private key path
        :param _builtins.str ssh_port: SSH port
        :param _builtins.str ssh_user: SSH username
        :param _builtins.str tags: Comma-separated list of tags to apply to the Droplet
        :param _builtins.str userdata: Path to file with cloud-init user-data
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if backups is not None:
            pulumi.set(__self__, "backups", backups)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if private_networking is not None:
            pulumi.set(__self__, "private_networking", private_networking)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if ssh_key_fingerprint is not None:
            pulumi.set(__self__, "ssh_key_fingerprint", ssh_key_fingerprint)
        if ssh_key_path is not None:
            pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[_builtins.str]:
        """
        Digital Ocean access token
        """
        return pulumi.get(self, "access_token")

    @_builtins.property
    @pulumi.getter
    def backups(self) -> Optional[_builtins.bool]:
        """
        Enable backups for droplet
        """
        return pulumi.get(self, "backups")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Digital Ocean Image
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        Enable ipv6 for droplet
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[_builtins.bool]:
        """
        Enable monitoring for droplet
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="privateNetworking")
    def private_networking(self) -> Optional[_builtins.bool]:
        """
        Enable private networking for droplet
        """
        return pulumi.get(self, "private_networking")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Digital Ocean region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> Optional[_builtins.str]:
        """
        Digital Ocean size
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshKeyFingerprint")
    def ssh_key_fingerprint(self) -> Optional[_builtins.str]:
        """
        SSH key fingerprint
        """
        return pulumi.get(self, "ssh_key_fingerprint")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> Optional[_builtins.str]:
        """
        SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        SSH port
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of tags to apply to the Droplet
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def userdata(self) -> Optional[_builtins.str]:
        """
        Path to file with cloud-init user-data
        """
        return pulumi.get(self, "userdata")


@pulumi.output_type
class NodeTemplateHarvesterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshUser":
            suggest = "ssh_user"
        elif key == "vmNamespace":
            suggest = "vm_namespace"
        elif key == "cpuCount":
            suggest = "cpu_count"
        elif key == "diskBus":
            suggest = "disk_bus"
        elif key == "diskInfo":
            suggest = "disk_info"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "memorySize":
            suggest = "memory_size"
        elif key == "networkData":
            suggest = "network_data"
        elif key == "networkInfo":
            suggest = "network_info"
        elif key == "networkModel":
            suggest = "network_model"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "sshPassword":
            suggest = "ssh_password"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vmAffinity":
            suggest = "vm_affinity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateHarvesterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateHarvesterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateHarvesterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_user: _builtins.str,
                 vm_namespace: _builtins.str,
                 cpu_count: Optional[_builtins.str] = None,
                 disk_bus: Optional[_builtins.str] = None,
                 disk_info: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.str] = None,
                 image_name: Optional[_builtins.str] = None,
                 memory_size: Optional[_builtins.str] = None,
                 network_data: Optional[_builtins.str] = None,
                 network_info: Optional[_builtins.str] = None,
                 network_model: Optional[_builtins.str] = None,
                 network_name: Optional[_builtins.str] = None,
                 ssh_password: Optional[_builtins.str] = None,
                 user_data: Optional[_builtins.str] = None,
                 vm_affinity: Optional[_builtins.str] = None):
        """
        :param _builtins.str ssh_user: SSH username
        :param _builtins.str vm_namespace: Virtual machine namespace
        :param _builtins.str cpu_count: CPU count
        :param _builtins.str disk_bus: Disk bus
        :param _builtins.str disk_info: A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        :param _builtins.str disk_size: Disk size (in GiB)
        :param _builtins.str image_name: Image name
        :param _builtins.str memory_size: Memory size (in GiB)
        :param _builtins.str network_data: NetworkData content of cloud-init, base64 is supported
        :param _builtins.str network_info: A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        :param _builtins.str network_model: Network model
        :param _builtins.str network_name: Network name
        :param _builtins.str ssh_password: SSH password
        :param _builtins.str user_data: UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        :param _builtins.str vm_affinity: VM affinity, base64 is supported
        """
        pulumi.set(__self__, "ssh_user", ssh_user)
        pulumi.set(__self__, "vm_namespace", vm_namespace)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if disk_bus is not None:
            pulumi.set(__self__, "disk_bus", disk_bus)
        if disk_info is not None:
            pulumi.set(__self__, "disk_info", disk_info)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if network_data is not None:
            pulumi.set(__self__, "network_data", network_data)
        if network_info is not None:
            pulumi.set(__self__, "network_info", network_info)
        if network_model is not None:
            pulumi.set(__self__, "network_model", network_model)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vm_affinity is not None:
            pulumi.set(__self__, "vm_affinity", vm_affinity)

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> _builtins.str:
        """
        SSH username
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="vmNamespace")
    def vm_namespace(self) -> _builtins.str:
        """
        Virtual machine namespace
        """
        return pulumi.get(self, "vm_namespace")

    @_builtins.property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[_builtins.str]:
        """
        CPU count
        """
        return pulumi.get(self, "cpu_count")

    @_builtins.property
    @pulumi.getter(name="diskBus")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_bus(self) -> Optional[_builtins.str]:
        """
        Disk bus
        """
        return pulumi.get(self, "disk_bus")

    @_builtins.property
    @pulumi.getter(name="diskInfo")
    def disk_info(self) -> Optional[_builtins.str]:
        """
        A JSON string specifying info for the disks e.g. `{"disks":[{"imageName":"harvester-public/image-57hzg","bootOrder":1,"size":40},{"storageClassName":"node-driver-test","bootOrder":2,"size":1}]}`
        """
        return pulumi.get(self, "disk_info")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    @_utilities.deprecated("""Use disk_info instead""")
    def disk_size(self) -> Optional[_builtins.str]:
        """
        Disk size (in GiB)
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="imageName")
    @_utilities.deprecated("""Use disk_info instead""")
    def image_name(self) -> Optional[_builtins.str]:
        """
        Image name
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[_builtins.str]:
        """
        Memory size (in GiB)
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter(name="networkData")
    def network_data(self) -> Optional[_builtins.str]:
        """
        NetworkData content of cloud-init, base64 is supported
        """
        return pulumi.get(self, "network_data")

    @_builtins.property
    @pulumi.getter(name="networkInfo")
    def network_info(self) -> Optional[_builtins.str]:
        """
        A JSON string specifying info for the networks e.g. `{"interfaces":[{"networkName":"harvester-public/vlan1"},{"networkName":"harvester-public/vlan2"}]}`
        """
        return pulumi.get(self, "network_info")

    @_builtins.property
    @pulumi.getter(name="networkModel")
    @_utilities.deprecated("""Use network_info instead""")
    def network_model(self) -> Optional[_builtins.str]:
        """
        Network model
        """
        return pulumi.get(self, "network_model")

    @_builtins.property
    @pulumi.getter(name="networkName")
    @_utilities.deprecated("""Use network_info instead""")
    def network_name(self) -> Optional[_builtins.str]:
        """
        Network name
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[_builtins.str]:
        """
        SSH password
        """
        return pulumi.get(self, "ssh_password")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="vmAffinity")
    def vm_affinity(self) -> Optional[_builtins.str]:
        """
        VM affinity, base64 is supported
        """
        return pulumi.get(self, "vm_affinity")


@pulumi.output_type
class NodeTemplateHetznerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"
        elif key == "serverLabels":
            suggest = "server_labels"
        elif key == "serverLocation":
            suggest = "server_location"
        elif key == "serverType":
            suggest = "server_type"
        elif key == "usePrivateNetwork":
            suggest = "use_private_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateHetznerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateHetznerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateHetznerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: _builtins.str,
                 image: Optional[_builtins.str] = None,
                 networks: Optional[_builtins.str] = None,
                 server_labels: Optional[Mapping[str, _builtins.str]] = None,
                 server_location: Optional[_builtins.str] = None,
                 server_type: Optional[_builtins.str] = None,
                 use_private_network: Optional[_builtins.bool] = None,
                 userdata: Optional[_builtins.str] = None,
                 volumes: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_token: Hetzner Cloud project API token
        :param _builtins.str image: Hetzner Cloud server image
        :param _builtins.str networks: Comma-separated list of network IDs or names which should be attached to the server private network interface
        :param Mapping[str, _builtins.str] server_labels: Map of the labels which will be assigned to the server
        :param _builtins.str server_location: Hetzner Cloud datacenter
        :param _builtins.str server_type: Hetzner Cloud server type
        :param _builtins.bool use_private_network: Use private network
        :param _builtins.str userdata: Path to file with cloud-init user-data
        :param _builtins.str volumes: Comma-separated list of volume IDs or names which should be attached to the server
        """
        pulumi.set(__self__, "api_token", api_token)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if server_labels is not None:
            pulumi.set(__self__, "server_labels", server_labels)
        if server_location is not None:
            pulumi.set(__self__, "server_location", server_location)
        if server_type is not None:
            pulumi.set(__self__, "server_type", server_type)
        if use_private_network is not None:
            pulumi.set(__self__, "use_private_network", use_private_network)
        if userdata is not None:
            pulumi.set(__self__, "userdata", userdata)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> _builtins.str:
        """
        Hetzner Cloud project API token
        """
        return pulumi.get(self, "api_token")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Hetzner Cloud server image
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of network IDs or names which should be attached to the server private network interface
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter(name="serverLabels")
    def server_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of the labels which will be assigned to the server
        """
        return pulumi.get(self, "server_labels")

    @_builtins.property
    @pulumi.getter(name="serverLocation")
    def server_location(self) -> Optional[_builtins.str]:
        """
        Hetzner Cloud datacenter
        """
        return pulumi.get(self, "server_location")

    @_builtins.property
    @pulumi.getter(name="serverType")
    def server_type(self) -> Optional[_builtins.str]:
        """
        Hetzner Cloud server type
        """
        return pulumi.get(self, "server_type")

    @_builtins.property
    @pulumi.getter(name="usePrivateNetwork")
    def use_private_network(self) -> Optional[_builtins.bool]:
        """
        Use private network
        """
        return pulumi.get(self, "use_private_network")

    @_builtins.property
    @pulumi.getter
    def userdata(self) -> Optional[_builtins.str]:
        """
        Path to file with cloud-init user-data
        """
        return pulumi.get(self, "userdata")

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[_builtins.str]:
        """
        Comma-separated list of volume IDs or names which should be attached to the server
        """
        return pulumi.get(self, "volumes")


@pulumi.output_type
class NodeTemplateLinodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizedUsers":
            suggest = "authorized_users"
        elif key == "createPrivateIp":
            suggest = "create_private_ip"
        elif key == "dockerPort":
            suggest = "docker_port"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "rootPass":
            suggest = "root_pass"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "stackscriptData":
            suggest = "stackscript_data"
        elif key == "swapSize":
            suggest = "swap_size"
        elif key == "uaPrefix":
            suggest = "ua_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateLinodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateLinodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateLinodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorized_users: Optional[_builtins.str] = None,
                 create_private_ip: Optional[_builtins.bool] = None,
                 docker_port: Optional[_builtins.str] = None,
                 image: Optional[_builtins.str] = None,
                 instance_type: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 root_pass: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 stackscript: Optional[_builtins.str] = None,
                 stackscript_data: Optional[_builtins.str] = None,
                 swap_size: Optional[_builtins.str] = None,
                 tags: Optional[_builtins.str] = None,
                 token: Optional[_builtins.str] = None,
                 ua_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str authorized_users: Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        :param _builtins.bool create_private_ip: Create private IP for the instance
        :param _builtins.str docker_port: Docker Port
        :param _builtins.str image: Specifies the Linode Instance image which determines the OS distribution and base files
        :param _builtins.str instance_type: Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        :param _builtins.str label: Linode Instance Label
        :param _builtins.str region: Specifies the region (location) of the Linode instance
        :param _builtins.str root_pass: Root Password
        :param _builtins.str ssh_port: Linode Instance SSH Port
        :param _builtins.str ssh_user: Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        :param _builtins.str stackscript: Specifies the Linode StackScript to use to create the instance
        :param _builtins.str stackscript_data: A JSON string specifying data for the selected StackScript
        :param _builtins.str swap_size: Linode Instance Swap Size (MB)
        :param _builtins.str tags: A comma separated list of tags to apply to the the Linode resource
        :param _builtins.str token: Linode API Token
        :param _builtins.str ua_prefix: Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        if authorized_users is not None:
            pulumi.set(__self__, "authorized_users", authorized_users)
        if create_private_ip is not None:
            pulumi.set(__self__, "create_private_ip", create_private_ip)
        if docker_port is not None:
            pulumi.set(__self__, "docker_port", docker_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if root_pass is not None:
            pulumi.set(__self__, "root_pass", root_pass)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if stackscript is not None:
            pulumi.set(__self__, "stackscript", stackscript)
        if stackscript_data is not None:
            pulumi.set(__self__, "stackscript_data", stackscript_data)
        if swap_size is not None:
            pulumi.set(__self__, "swap_size", swap_size)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if ua_prefix is not None:
            pulumi.set(__self__, "ua_prefix", ua_prefix)

    @_builtins.property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[_builtins.str]:
        """
        Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node
        """
        return pulumi.get(self, "authorized_users")

    @_builtins.property
    @pulumi.getter(name="createPrivateIp")
    def create_private_ip(self) -> Optional[_builtins.bool]:
        """
        Create private IP for the instance
        """
        return pulumi.get(self, "create_private_ip")

    @_builtins.property
    @pulumi.getter(name="dockerPort")
    def docker_port(self) -> Optional[_builtins.str]:
        """
        Docker Port
        """
        return pulumi.get(self, "docker_port")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[_builtins.str]:
        """
        Specifies the Linode Instance image which determines the OS distribution and base files
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        Specifies the Linode Instance type which determines CPU, memory, disk size, etc.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        Linode Instance Label
        """
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Specifies the region (location) of the Linode instance
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="rootPass")
    def root_pass(self) -> Optional[_builtins.str]:
        """
        Root Password
        """
        return pulumi.get(self, "root_pass")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        Linode Instance SSH Port
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        Specifies the user as which docker-machine should log in to the Linode instance to install Docker.
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter
    def stackscript(self) -> Optional[_builtins.str]:
        """
        Specifies the Linode StackScript to use to create the instance
        """
        return pulumi.get(self, "stackscript")

    @_builtins.property
    @pulumi.getter(name="stackscriptData")
    def stackscript_data(self) -> Optional[_builtins.str]:
        """
        A JSON string specifying data for the selected StackScript
        """
        return pulumi.get(self, "stackscript_data")

    @_builtins.property
    @pulumi.getter(name="swapSize")
    def swap_size(self) -> Optional[_builtins.str]:
        """
        Linode Instance Swap Size (MB)
        """
        return pulumi.get(self, "swap_size")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[_builtins.str]:
        """
        A comma separated list of tags to apply to the the Linode resource
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Linode API Token
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="uaPrefix")
    def ua_prefix(self) -> Optional[_builtins.str]:
        """
        Prefix the User-Agent in Linode API calls with some 'product/version'
        """
        return pulumi.get(self, "ua_prefix")


@pulumi.output_type
class NodeTemplateNodeTaint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeAdded":
            suggest = "time_added"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateNodeTaint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateNodeTaint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateNodeTaint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 effect: Optional[_builtins.str] = None,
                 time_added: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Taint key (string)
        :param _builtins.str value: Taint value (string)
        :param _builtins.str effect: Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        :param _builtins.str time_added: Taint time added (string)
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if time_added is not None:
            pulumi.set(__self__, "time_added", time_added)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Taint key (string)
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Taint value (string)
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        """
        Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> Optional[_builtins.str]:
        """
        Taint time added (string)
        """
        return pulumi.get(self, "time_added")


@pulumi.output_type
class NodeTemplateOpennebulaConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "xmlRpcUrl":
            suggest = "xml_rpc_url"
        elif key == "b2dSize":
            suggest = "b2d_size"
        elif key == "devPrefix":
            suggest = "dev_prefix"
        elif key == "disableVnc":
            suggest = "disable_vnc"
        elif key == "diskResize":
            suggest = "disk_resize"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "imageOwner":
            suggest = "image_owner"
        elif key == "networkId":
            suggest = "network_id"
        elif key == "networkName":
            suggest = "network_name"
        elif key == "networkOwner":
            suggest = "network_owner"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "templateId":
            suggest = "template_id"
        elif key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateOpennebulaConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateOpennebulaConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateOpennebulaConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 user: _builtins.str,
                 xml_rpc_url: _builtins.str,
                 b2d_size: Optional[_builtins.str] = None,
                 cpu: Optional[_builtins.str] = None,
                 dev_prefix: Optional[_builtins.str] = None,
                 disable_vnc: Optional[_builtins.bool] = None,
                 disk_resize: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 image_name: Optional[_builtins.str] = None,
                 image_owner: Optional[_builtins.str] = None,
                 memory: Optional[_builtins.str] = None,
                 network_id: Optional[_builtins.str] = None,
                 network_name: Optional[_builtins.str] = None,
                 network_owner: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 template_id: Optional[_builtins.str] = None,
                 template_name: Optional[_builtins.str] = None,
                 vcpu: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param _builtins.str user: Set the user for the XML-RPC API authentication (string)
        :param _builtins.str xml_rpc_url: Set the url for the Opennebula XML-RPC API (string)
        :param _builtins.str b2d_size: Size of the Volatile disk in MB - only for b2d (string)
        :param _builtins.str cpu: CPU value for the VM (string)
        :param _builtins.str dev_prefix: Dev prefix to use for the images. E.g.: 'vd', 'sd', 'hd' (string)
        :param _builtins.bool disable_vnc: VNC is enabled by default. Disable it with this flag (bool)
        :param _builtins.str disk_resize: Size of the disk for the VM in MB (string)
        :param _builtins.str image_id: OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        :param _builtins.str image_name: OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        :param _builtins.str image_owner: Owner of the image to use as the VM OS (string)
        :param _builtins.str memory: Size of the memory for the VM in MB (string)
        :param _builtins.str network_id: Opennebula network ID to connect the machine to. Conflicts with `network_name` (string)
        :param _builtins.str network_name: Opennebula network to connect the machine to. Conflicts with `network_id` (string)
        :param _builtins.str network_owner: Opennebula user ID of the Network to connect the machine to (string)
        :param _builtins.str ssh_user: If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        :param _builtins.str template_id: Opennebula template ID to use. Conflicts with `template_name` (string)
        :param _builtins.str template_name: Name of the Opennbula template to use. Conflicts with `template_id` (string)
        :param _builtins.str vcpu: VCPUs for the VM (string)
               
               > **Note:**: `Required*` denotes that one of image_name / image_id or template_name / template_id is required but you cannot combine them.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user", user)
        pulumi.set(__self__, "xml_rpc_url", xml_rpc_url)
        if b2d_size is not None:
            pulumi.set(__self__, "b2d_size", b2d_size)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if dev_prefix is not None:
            pulumi.set(__self__, "dev_prefix", dev_prefix)
        if disable_vnc is not None:
            pulumi.set(__self__, "disable_vnc", disable_vnc)
        if disk_resize is not None:
            pulumi.set(__self__, "disk_resize", disk_resize)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if image_owner is not None:
            pulumi.set(__self__, "image_owner", image_owner)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if network_id is not None:
            pulumi.set(__self__, "network_id", network_id)
        if network_name is not None:
            pulumi.set(__self__, "network_name", network_name)
        if network_owner is not None:
            pulumi.set(__self__, "network_owner", network_owner)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if template_id is not None:
            pulumi.set(__self__, "template_id", template_id)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)
        if vcpu is not None:
            pulumi.set(__self__, "vcpu", vcpu)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        """
        Set the user for the XML-RPC API authentication (string)
        """
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="xmlRpcUrl")
    def xml_rpc_url(self) -> _builtins.str:
        """
        Set the url for the Opennebula XML-RPC API (string)
        """
        return pulumi.get(self, "xml_rpc_url")

    @_builtins.property
    @pulumi.getter(name="b2dSize")
    def b2d_size(self) -> Optional[_builtins.str]:
        """
        Size of the Volatile disk in MB - only for b2d (string)
        """
        return pulumi.get(self, "b2d_size")

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.str]:
        """
        CPU value for the VM (string)
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter(name="devPrefix")
    def dev_prefix(self) -> Optional[_builtins.str]:
        """
        Dev prefix to use for the images. E.g.: 'vd', 'sd', 'hd' (string)
        """
        return pulumi.get(self, "dev_prefix")

    @_builtins.property
    @pulumi.getter(name="disableVnc")
    def disable_vnc(self) -> Optional[_builtins.bool]:
        """
        VNC is enabled by default. Disable it with this flag (bool)
        """
        return pulumi.get(self, "disable_vnc")

    @_builtins.property
    @pulumi.getter(name="diskResize")
    def disk_resize(self) -> Optional[_builtins.str]:
        """
        Size of the disk for the VM in MB (string)
        """
        return pulumi.get(self, "disk_resize")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[_builtins.str]:
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter(name="imageOwner")
    def image_owner(self) -> Optional[_builtins.str]:
        """
        Owner of the image to use as the VM OS (string)
        """
        return pulumi.get(self, "image_owner")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.str]:
        """
        Size of the memory for the VM in MB (string)
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> Optional[_builtins.str]:
        """
        Opennebula network ID to connect the machine to. Conflicts with `network_name` (string)
        """
        return pulumi.get(self, "network_id")

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> Optional[_builtins.str]:
        """
        Opennebula network to connect the machine to. Conflicts with `network_id` (string)
        """
        return pulumi.get(self, "network_name")

    @_builtins.property
    @pulumi.getter(name="networkOwner")
    def network_owner(self) -> Optional[_builtins.str]:
        """
        Opennebula user ID of the Network to connect the machine to (string)
        """
        return pulumi.get(self, "network_owner")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="templateId")
    def template_id(self) -> Optional[_builtins.str]:
        """
        Opennebula template ID to use. Conflicts with `template_name` (string)
        """
        return pulumi.get(self, "template_id")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[_builtins.str]:
        """
        Name of the Opennbula template to use. Conflicts with `template_id` (string)
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def vcpu(self) -> Optional[_builtins.str]:
        """
        VCPUs for the VM (string)

        > **Note:**: `Required*` denotes that one of image_name / image_id or template_name / template_id is required but you cannot combine them.
        """
        return pulumi.get(self, "vcpu")


@pulumi.output_type
class NodeTemplateOpenstackConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUrl":
            suggest = "auth_url"
        elif key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "activeTimeout":
            suggest = "active_timeout"
        elif key == "applicationCredentialId":
            suggest = "application_credential_id"
        elif key == "applicationCredentialName":
            suggest = "application_credential_name"
        elif key == "applicationCredentialSecret":
            suggest = "application_credential_secret"
        elif key == "bootFromVolume":
            suggest = "boot_from_volume"
        elif key == "configDrive":
            suggest = "config_drive"
        elif key == "domainId":
            suggest = "domain_id"
        elif key == "domainName":
            suggest = "domain_name"
        elif key == "endpointType":
            suggest = "endpoint_type"
        elif key == "flavorId":
            suggest = "flavor_id"
        elif key == "flavorName":
            suggest = "flavor_name"
        elif key == "floatingIpPool":
            suggest = "floating_ip_pool"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "imageName":
            suggest = "image_name"
        elif key == "ipVersion":
            suggest = "ip_version"
        elif key == "keypairName":
            suggest = "keypair_name"
        elif key == "netId":
            suggest = "net_id"
        elif key == "netName":
            suggest = "net_name"
        elif key == "novaNetwork":
            suggest = "nova_network"
        elif key == "privateKeyFile":
            suggest = "private_key_file"
        elif key == "secGroups":
            suggest = "sec_groups"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tenantName":
            suggest = "tenant_name"
        elif key == "userDataFile":
            suggest = "user_data_file"
        elif key == "volumeDevicePath":
            suggest = "volume_device_path"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeName":
            suggest = "volume_name"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateOpenstackConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateOpenstackConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateOpenstackConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_url: _builtins.str,
                 availability_zone: _builtins.str,
                 region: _builtins.str,
                 active_timeout: Optional[_builtins.str] = None,
                 application_credential_id: Optional[_builtins.str] = None,
                 application_credential_name: Optional[_builtins.str] = None,
                 application_credential_secret: Optional[_builtins.str] = None,
                 boot_from_volume: Optional[_builtins.bool] = None,
                 cacert: Optional[_builtins.str] = None,
                 config_drive: Optional[_builtins.bool] = None,
                 domain_id: Optional[_builtins.str] = None,
                 domain_name: Optional[_builtins.str] = None,
                 endpoint_type: Optional[_builtins.str] = None,
                 flavor_id: Optional[_builtins.str] = None,
                 flavor_name: Optional[_builtins.str] = None,
                 floating_ip_pool: Optional[_builtins.str] = None,
                 image_id: Optional[_builtins.str] = None,
                 image_name: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 ip_version: Optional[_builtins.str] = None,
                 keypair_name: Optional[_builtins.str] = None,
                 net_id: Optional[_builtins.str] = None,
                 net_name: Optional[_builtins.str] = None,
                 nova_network: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 private_key_file: Optional[_builtins.str] = None,
                 sec_groups: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None,
                 tenant_name: Optional[_builtins.str] = None,
                 user_data_file: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None,
                 volume_device_path: Optional[_builtins.str] = None,
                 volume_id: Optional[_builtins.str] = None,
                 volume_name: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.str] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str auth_url: OpenStack authentication URL (string)
        :param _builtins.str availability_zone: OpenStack availability zone (string)
        :param _builtins.str region: AWS region. Default `eu-west-2` (string)
        :param _builtins.str active_timeout: OpenStack active timeout Default `200` (string)
        :param _builtins.str application_credential_id: OpenStack application credential id. Conflicts with `application_credential_name` (string)
        :param _builtins.str application_credential_name: OpenStack application credential name. Conflicts with `application_credential_id` (string)
        :param _builtins.str application_credential_secret: OpenStack application credential secret (string)
        :param _builtins.bool boot_from_volume: Enable booting from volume. Default is `false` (bool)
        :param _builtins.str cacert: CA certificate bundle to verify against (string)
        :param _builtins.bool config_drive: Enables the OpenStack config drive for the instance. Default `false` (bool)
        :param _builtins.str domain_id: OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        :param _builtins.str domain_name: OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        :param _builtins.str endpoint_type: OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        :param _builtins.str flavor_id: OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        :param _builtins.str flavor_name: OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        :param _builtins.str floating_ip_pool: OpenStack floating IP pool to get an IP from to assign to the instance (string)
        :param _builtins.str image_id: OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        :param _builtins.str image_name: OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        :param _builtins.bool insecure: Disable TLS credential checking. Default `false` (bool)
        :param _builtins.str ip_version: OpenStack version of IP address assigned for the machine Default `4` (string)
        :param _builtins.str keypair_name: OpenStack keypair to use to SSH to the instance (string)
        :param _builtins.str net_id: OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        :param _builtins.str net_name: OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        :param _builtins.bool nova_network: Use the nova networking services instead of neutron (string)
        :param _builtins.str password: vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param _builtins.str private_key_file: Private key content to use for SSH (string)
        :param _builtins.str sec_groups: OpenStack comma separated security groups for the machine (string)
        :param _builtins.str ssh_port: If using a non-B2D image you can specify the ssh port. Default `22`. From Rancher v2.3.3 (string)
        :param _builtins.str ssh_user: If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        :param _builtins.str tenant_id: OpenStack tenant id. Conflicts with `tenant_name` (string)
        :param _builtins.str tenant_name: OpenStack tenant name. Conflicts with `tenant_id` (string)
        :param _builtins.str user_data_file: File containing an openstack userdata script (string)
        :param _builtins.str username: vSphere username. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        :param _builtins.str volume_device_path: OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)
               
               > **Note:**: `Required*` denotes that either the _name or _id is required but you cannot use both.
               
               > **Note:**: `Required**` denotes that either the _name or _id is required unless `application_credential_id` is defined.
               
               > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        :param _builtins.str volume_id: OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param _builtins.str volume_name: OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        :param _builtins.str volume_size: OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        :param _builtins.str volume_type: OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "availability_zone", availability_zone)
        pulumi.set(__self__, "region", region)
        if active_timeout is not None:
            pulumi.set(__self__, "active_timeout", active_timeout)
        if application_credential_id is not None:
            pulumi.set(__self__, "application_credential_id", application_credential_id)
        if application_credential_name is not None:
            pulumi.set(__self__, "application_credential_name", application_credential_name)
        if application_credential_secret is not None:
            pulumi.set(__self__, "application_credential_secret", application_credential_secret)
        if boot_from_volume is not None:
            pulumi.set(__self__, "boot_from_volume", boot_from_volume)
        if cacert is not None:
            pulumi.set(__self__, "cacert", cacert)
        if config_drive is not None:
            pulumi.set(__self__, "config_drive", config_drive)
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if domain_name is not None:
            pulumi.set(__self__, "domain_name", domain_name)
        if endpoint_type is not None:
            pulumi.set(__self__, "endpoint_type", endpoint_type)
        if flavor_id is not None:
            pulumi.set(__self__, "flavor_id", flavor_id)
        if flavor_name is not None:
            pulumi.set(__self__, "flavor_name", flavor_name)
        if floating_ip_pool is not None:
            pulumi.set(__self__, "floating_ip_pool", floating_ip_pool)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if image_name is not None:
            pulumi.set(__self__, "image_name", image_name)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if ip_version is not None:
            pulumi.set(__self__, "ip_version", ip_version)
        if keypair_name is not None:
            pulumi.set(__self__, "keypair_name", keypair_name)
        if net_id is not None:
            pulumi.set(__self__, "net_id", net_id)
        if net_name is not None:
            pulumi.set(__self__, "net_name", net_name)
        if nova_network is not None:
            pulumi.set(__self__, "nova_network", nova_network)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if private_key_file is not None:
            pulumi.set(__self__, "private_key_file", private_key_file)
        if sec_groups is not None:
            pulumi.set(__self__, "sec_groups", sec_groups)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if tenant_name is not None:
            pulumi.set(__self__, "tenant_name", tenant_name)
        if user_data_file is not None:
            pulumi.set(__self__, "user_data_file", user_data_file)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if volume_device_path is not None:
            pulumi.set(__self__, "volume_device_path", volume_device_path)
        if volume_id is not None:
            pulumi.set(__self__, "volume_id", volume_id)
        if volume_name is not None:
            pulumi.set(__self__, "volume_name", volume_name)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        """
        OpenStack authentication URL (string)
        """
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> _builtins.str:
        """
        OpenStack availability zone (string)
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        AWS region. Default `eu-west-2` (string)
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="activeTimeout")
    def active_timeout(self) -> Optional[_builtins.str]:
        """
        OpenStack active timeout Default `200` (string)
        """
        return pulumi.get(self, "active_timeout")

    @_builtins.property
    @pulumi.getter(name="applicationCredentialId")
    def application_credential_id(self) -> Optional[_builtins.str]:
        """
        OpenStack application credential id. Conflicts with `application_credential_name` (string)
        """
        return pulumi.get(self, "application_credential_id")

    @_builtins.property
    @pulumi.getter(name="applicationCredentialName")
    def application_credential_name(self) -> Optional[_builtins.str]:
        """
        OpenStack application credential name. Conflicts with `application_credential_id` (string)
        """
        return pulumi.get(self, "application_credential_name")

    @_builtins.property
    @pulumi.getter(name="applicationCredentialSecret")
    def application_credential_secret(self) -> Optional[_builtins.str]:
        """
        OpenStack application credential secret (string)
        """
        return pulumi.get(self, "application_credential_secret")

    @_builtins.property
    @pulumi.getter(name="bootFromVolume")
    def boot_from_volume(self) -> Optional[_builtins.bool]:
        """
        Enable booting from volume. Default is `false` (bool)
        """
        return pulumi.get(self, "boot_from_volume")

    @_builtins.property
    @pulumi.getter
    def cacert(self) -> Optional[_builtins.str]:
        """
        CA certificate bundle to verify against (string)
        """
        return pulumi.get(self, "cacert")

    @_builtins.property
    @pulumi.getter(name="configDrive")
    def config_drive(self) -> Optional[_builtins.bool]:
        """
        Enables the OpenStack config drive for the instance. Default `false` (bool)
        """
        return pulumi.get(self, "config_drive")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[_builtins.str]:
        """
        OpenStack domain ID. Identity v3 only. Conflicts with `domain_name` (string)
        """
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> Optional[_builtins.str]:
        """
        OpenStack domain name. Identity v3 only. Conflicts with `domain_id` (string)
        """
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter(name="endpointType")
    def endpoint_type(self) -> Optional[_builtins.str]:
        """
        OpenStack endpoint type. adminURL, internalURL or publicURL (string)
        """
        return pulumi.get(self, "endpoint_type")

    @_builtins.property
    @pulumi.getter(name="flavorId")
    def flavor_id(self) -> Optional[_builtins.str]:
        """
        OpenStack flavor id to use for the instance. Conflicts with `flavor_name` (string)
        """
        return pulumi.get(self, "flavor_id")

    @_builtins.property
    @pulumi.getter(name="flavorName")
    def flavor_name(self) -> Optional[_builtins.str]:
        """
        OpenStack flavor name to use for the instance. Conflicts with `flavor_id` (string)
        """
        return pulumi.get(self, "flavor_name")

    @_builtins.property
    @pulumi.getter(name="floatingIpPool")
    def floating_ip_pool(self) -> Optional[_builtins.str]:
        """
        OpenStack floating IP pool to get an IP from to assign to the instance (string)
        """
        return pulumi.get(self, "floating_ip_pool")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        OpenStack image id to use for the instance. Conflicts with `image_name` (string)
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="imageName")
    def image_name(self) -> Optional[_builtins.str]:
        """
        OpenStack image name to use for the instance. Conflicts with `image_id` (string)
        """
        return pulumi.get(self, "image_name")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Disable TLS credential checking. Default `false` (bool)
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter(name="ipVersion")
    def ip_version(self) -> Optional[_builtins.str]:
        """
        OpenStack version of IP address assigned for the machine Default `4` (string)
        """
        return pulumi.get(self, "ip_version")

    @_builtins.property
    @pulumi.getter(name="keypairName")
    def keypair_name(self) -> Optional[_builtins.str]:
        """
        OpenStack keypair to use to SSH to the instance (string)
        """
        return pulumi.get(self, "keypair_name")

    @_builtins.property
    @pulumi.getter(name="netId")
    def net_id(self) -> Optional[_builtins.str]:
        """
        OpenStack network id the machine will be connected on. Conflicts with `net_name` (string)
        """
        return pulumi.get(self, "net_id")

    @_builtins.property
    @pulumi.getter(name="netName")
    def net_name(self) -> Optional[_builtins.str]:
        """
        OpenStack network name the machine will be connected on. Conflicts with `net_id` (string)
        """
        return pulumi.get(self, "net_name")

    @_builtins.property
    @pulumi.getter(name="novaNetwork")
    def nova_network(self) -> Optional[_builtins.bool]:
        """
        Use the nova networking services instead of neutron (string)
        """
        return pulumi.get(self, "nova_network")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        vSphere password. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="privateKeyFile")
    def private_key_file(self) -> Optional[_builtins.str]:
        """
        Private key content to use for SSH (string)
        """
        return pulumi.get(self, "private_key_file")

    @_builtins.property
    @pulumi.getter(name="secGroups")
    def sec_groups(self) -> Optional[_builtins.str]:
        """
        OpenStack comma separated security groups for the machine (string)
        """
        return pulumi.get(self, "sec_groups")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh port. Default `22`. From Rancher v2.3.3 (string)
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh user. Default `docker`. From Rancher v2.3.3 (string)
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        OpenStack tenant id. Conflicts with `tenant_name` (string)
        """
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> Optional[_builtins.str]:
        """
        OpenStack tenant name. Conflicts with `tenant_id` (string)
        """
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter(name="userDataFile")
    def user_data_file(self) -> Optional[_builtins.str]:
        """
        File containing an openstack userdata script (string)
        """
        return pulumi.get(self, "user_data_file")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        vSphere username. Mandatory on Rancher v2.0.x and v2.1.x. Use `CloudCredential` from Rancher v2.2.x (string)
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="volumeDevicePath")
    def volume_device_path(self) -> Optional[_builtins.str]:
        """
        OpenStack volume device path (attaching). Applicable only when `boot_from_volume` is `true`. Omit for auto `/dev/vdb`. (string)

        > **Note:**: `Required*` denotes that either the _name or _id is required but you cannot use both.

        > **Note:**: `Required**` denotes that either the _name or _id is required unless `application_credential_id` is defined.

        > **Note for OpenStack users:**: `keypair_name` is required to be in the schema even if there are no references in rancher itself
        """
        return pulumi.get(self, "volume_device_path")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[_builtins.str]:
        """
        OpenStack volume id of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_id")

    @_builtins.property
    @pulumi.getter(name="volumeName")
    def volume_name(self) -> Optional[_builtins.str]:
        """
        OpenStack volume name of existing volume. Applicable only when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_name")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.str]:
        """
        OpenStack volume size (GiB). Required when `boot_from_volume` is `true` (string)
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        OpenStack volume type. Required when `boot_from_volume` is `true` and openstack cloud does not have a default volume type (string)
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class NodeTemplateOutscaleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "extraTagsAlls":
            suggest = "extra_tags_alls"
        elif key == "extraTagsInstances":
            suggest = "extra_tags_instances"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "rootDiskIops":
            suggest = "root_disk_iops"
        elif key == "rootDiskSize":
            suggest = "root_disk_size"
        elif key == "rootDiskType":
            suggest = "root_disk_type"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "sourceOmi":
            suggest = "source_omi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateOutscaleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateOutscaleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateOutscaleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: _builtins.str,
                 secret_key: _builtins.str,
                 extra_tags_alls: Optional[Sequence[_builtins.str]] = None,
                 extra_tags_instances: Optional[Sequence[_builtins.str]] = None,
                 instance_type: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 root_disk_iops: Optional[_builtins.int] = None,
                 root_disk_size: Optional[_builtins.int] = None,
                 root_disk_type: Optional[_builtins.str] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 source_omi: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key: Outscale Access Key
        :param _builtins.str secret_key: Outscale Secret Key
        :param Sequence[_builtins.str] extra_tags_alls: Extra tags for all created resources (e.g. key1=value1,key2=value2)
        :param Sequence[_builtins.str] extra_tags_instances: Extra tags only for instances (e.g. key1=value1,key2=value2)
        :param _builtins.str instance_type: Outscale VM type
        :param _builtins.str region: Outscale Region
        :param _builtins.int root_disk_iops: Iops for io1 Root Disk. From 1 to 13000.
        :param _builtins.int root_disk_size: Size of the Root Disk (in GB). From 1 to 14901.
        :param _builtins.str root_disk_type: Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
        :param Sequence[_builtins.str] security_group_ids: Ids of user defined Security Groups to add to the machine
        :param _builtins.str source_omi: Outscale Machine Image to use as bootstrap for the VM
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if extra_tags_alls is not None:
            pulumi.set(__self__, "extra_tags_alls", extra_tags_alls)
        if extra_tags_instances is not None:
            pulumi.set(__self__, "extra_tags_instances", extra_tags_instances)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if root_disk_iops is not None:
            pulumi.set(__self__, "root_disk_iops", root_disk_iops)
        if root_disk_size is not None:
            pulumi.set(__self__, "root_disk_size", root_disk_size)
        if root_disk_type is not None:
            pulumi.set(__self__, "root_disk_type", root_disk_type)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if source_omi is not None:
            pulumi.set(__self__, "source_omi", source_omi)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Outscale Access Key
        """
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        Outscale Secret Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter(name="extraTagsAlls")
    def extra_tags_alls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra tags for all created resources (e.g. key1=value1,key2=value2)
        """
        return pulumi.get(self, "extra_tags_alls")

    @_builtins.property
    @pulumi.getter(name="extraTagsInstances")
    def extra_tags_instances(self) -> Optional[Sequence[_builtins.str]]:
        """
        Extra tags only for instances (e.g. key1=value1,key2=value2)
        """
        return pulumi.get(self, "extra_tags_instances")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        Outscale VM type
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Outscale Region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="rootDiskIops")
    def root_disk_iops(self) -> Optional[_builtins.int]:
        """
        Iops for io1 Root Disk. From 1 to 13000.
        """
        return pulumi.get(self, "root_disk_iops")

    @_builtins.property
    @pulumi.getter(name="rootDiskSize")
    def root_disk_size(self) -> Optional[_builtins.int]:
        """
        Size of the Root Disk (in GB). From 1 to 14901.
        """
        return pulumi.get(self, "root_disk_size")

    @_builtins.property
    @pulumi.getter(name="rootDiskType")
    def root_disk_type(self) -> Optional[_builtins.str]:
        """
        Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
        """
        return pulumi.get(self, "root_disk_type")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Ids of user defined Security Groups to add to the machine
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="sourceOmi")
    def source_omi(self) -> Optional[_builtins.str]:
        """
        Outscale Machine Image to use as bootstrap for the VM
        """
        return pulumi.get(self, "source_omi")


@pulumi.output_type
class NodeTemplateVsphereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boot2dockerUrl":
            suggest = "boot2docker_url"
        elif key == "cloneFrom":
            suggest = "clone_from"
        elif key == "cloudConfig":
            suggest = "cloud_config"
        elif key == "contentLibrary":
            suggest = "content_library"
        elif key == "cpuCount":
            suggest = "cpu_count"
        elif key == "creationType":
            suggest = "creation_type"
        elif key == "customAttributes":
            suggest = "custom_attributes"
        elif key == "datastoreCluster":
            suggest = "datastore_cluster"
        elif key == "diskSize":
            suggest = "disk_size"
        elif key == "gracefulShutdownTimeout":
            suggest = "graceful_shutdown_timeout"
        elif key == "memorySize":
            suggest = "memory_size"
        elif key == "sshPassword":
            suggest = "ssh_password"
        elif key == "sshPort":
            suggest = "ssh_port"
        elif key == "sshUser":
            suggest = "ssh_user"
        elif key == "sshUserGroup":
            suggest = "ssh_user_group"
        elif key == "vappIpAllocationPolicy":
            suggest = "vapp_ip_allocation_policy"
        elif key == "vappIpProtocol":
            suggest = "vapp_ip_protocol"
        elif key == "vappProperties":
            suggest = "vapp_properties"
        elif key == "vappTransport":
            suggest = "vapp_transport"
        elif key == "vcenterPort":
            suggest = "vcenter_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NodeTemplateVsphereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NodeTemplateVsphereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NodeTemplateVsphereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot2docker_url: Optional[_builtins.str] = None,
                 cfgparams: Optional[Sequence[_builtins.str]] = None,
                 clone_from: Optional[_builtins.str] = None,
                 cloud_config: Optional[_builtins.str] = None,
                 cloudinit: Optional[_builtins.str] = None,
                 content_library: Optional[_builtins.str] = None,
                 cpu_count: Optional[_builtins.str] = None,
                 creation_type: Optional[_builtins.str] = None,
                 custom_attributes: Optional[Sequence[_builtins.str]] = None,
                 datacenter: Optional[_builtins.str] = None,
                 datastore: Optional[_builtins.str] = None,
                 datastore_cluster: Optional[_builtins.str] = None,
                 disk_size: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 graceful_shutdown_timeout: Optional[_builtins.str] = None,
                 hostsystem: Optional[_builtins.str] = None,
                 memory_size: Optional[_builtins.str] = None,
                 networks: Optional[Sequence[_builtins.str]] = None,
                 password: Optional[_builtins.str] = None,
                 pool: Optional[_builtins.str] = None,
                 ssh_password: Optional[_builtins.str] = None,
                 ssh_port: Optional[_builtins.str] = None,
                 ssh_user: Optional[_builtins.str] = None,
                 ssh_user_group: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 username: Optional[_builtins.str] = None,
                 vapp_ip_allocation_policy: Optional[_builtins.str] = None,
                 vapp_ip_protocol: Optional[_builtins.str] = None,
                 vapp_properties: Optional[Sequence[_builtins.str]] = None,
                 vapp_transport: Optional[_builtins.str] = None,
                 vcenter: Optional[_builtins.str] = None,
                 vcenter_port: Optional[_builtins.str] = None):
        """
        :param _builtins.str boot2docker_url: vSphere URL for boot2docker image
        :param Sequence[_builtins.str] cfgparams: vSphere vm configuration parameters (used for guestinfo)
        :param _builtins.str clone_from: If you choose creation type clone a name of what you want to clone is required
        :param _builtins.str cloud_config: Filepath to a cloud-config yaml file to put into the ISO user-data
        :param _builtins.str cloudinit: vSphere cloud-init filepath or url to add to guestinfo
        :param _builtins.str content_library: If you choose to clone from a content library template specify the name of the library
        :param _builtins.str cpu_count: vSphere CPU number for docker VM
        :param _builtins.str creation_type: Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        :param Sequence[_builtins.str] custom_attributes: vSphere custom attributes, format key/value e.g. '200=my custom value'
        :param _builtins.str datacenter: vSphere datacenter for virtual machine
        :param _builtins.str datastore: vSphere datastore for virtual machine
        :param _builtins.str datastore_cluster: vSphere datastore cluster for virtual machine
        :param _builtins.str disk_size: vSphere size of disk for docker VM (in MB)
        :param _builtins.str folder: vSphere folder for the docker VM. This folder must already exist in the datacenter
        :param _builtins.str graceful_shutdown_timeout: Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        :param _builtins.str hostsystem: vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        :param _builtins.str memory_size: vSphere size of memory for docker VM (in MB)
        :param Sequence[_builtins.str] networks: vSphere network where the virtual machine will be attached
        :param _builtins.str password: vSphere password
        :param _builtins.str pool: vSphere resource pool for docker VM
        :param _builtins.str ssh_password: If using a non-B2D image you can specify the ssh password
        :param _builtins.str ssh_port: If using a non-B2D image you can specify the ssh port
        :param _builtins.str ssh_user: If using a non-B2D image you can specify the ssh user
        :param _builtins.str ssh_user_group: If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        :param Sequence[_builtins.str] tags: vSphere tags id e.g. urn:xxx
        :param _builtins.str username: vSphere username
        :param _builtins.str vapp_ip_allocation_policy: vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        :param _builtins.str vapp_ip_protocol: vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        :param Sequence[_builtins.str] vapp_properties: vSphere vApp properties
        :param _builtins.str vapp_transport: vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        :param _builtins.str vcenter: vSphere IP/hostname for vCenter
        :param _builtins.str vcenter_port: vSphere Port for vCenter
        """
        if boot2docker_url is not None:
            pulumi.set(__self__, "boot2docker_url", boot2docker_url)
        if cfgparams is not None:
            pulumi.set(__self__, "cfgparams", cfgparams)
        if clone_from is not None:
            pulumi.set(__self__, "clone_from", clone_from)
        if cloud_config is not None:
            pulumi.set(__self__, "cloud_config", cloud_config)
        if cloudinit is not None:
            pulumi.set(__self__, "cloudinit", cloudinit)
        if content_library is not None:
            pulumi.set(__self__, "content_library", content_library)
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)
        if creation_type is not None:
            pulumi.set(__self__, "creation_type", creation_type)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if datastore_cluster is not None:
            pulumi.set(__self__, "datastore_cluster", datastore_cluster)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)
        if hostsystem is not None:
            pulumi.set(__self__, "hostsystem", hostsystem)
        if memory_size is not None:
            pulumi.set(__self__, "memory_size", memory_size)
        if networks is not None:
            pulumi.set(__self__, "networks", networks)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pool is not None:
            pulumi.set(__self__, "pool", pool)
        if ssh_password is not None:
            pulumi.set(__self__, "ssh_password", ssh_password)
        if ssh_port is not None:
            pulumi.set(__self__, "ssh_port", ssh_port)
        if ssh_user is not None:
            pulumi.set(__self__, "ssh_user", ssh_user)
        if ssh_user_group is not None:
            pulumi.set(__self__, "ssh_user_group", ssh_user_group)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vapp_ip_allocation_policy is not None:
            pulumi.set(__self__, "vapp_ip_allocation_policy", vapp_ip_allocation_policy)
        if vapp_ip_protocol is not None:
            pulumi.set(__self__, "vapp_ip_protocol", vapp_ip_protocol)
        if vapp_properties is not None:
            pulumi.set(__self__, "vapp_properties", vapp_properties)
        if vapp_transport is not None:
            pulumi.set(__self__, "vapp_transport", vapp_transport)
        if vcenter is not None:
            pulumi.set(__self__, "vcenter", vcenter)
        if vcenter_port is not None:
            pulumi.set(__self__, "vcenter_port", vcenter_port)

    @_builtins.property
    @pulumi.getter(name="boot2dockerUrl")
    def boot2docker_url(self) -> Optional[_builtins.str]:
        """
        vSphere URL for boot2docker image
        """
        return pulumi.get(self, "boot2docker_url")

    @_builtins.property
    @pulumi.getter
    def cfgparams(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere vm configuration parameters (used for guestinfo)
        """
        return pulumi.get(self, "cfgparams")

    @_builtins.property
    @pulumi.getter(name="cloneFrom")
    def clone_from(self) -> Optional[_builtins.str]:
        """
        If you choose creation type clone a name of what you want to clone is required
        """
        return pulumi.get(self, "clone_from")

    @_builtins.property
    @pulumi.getter(name="cloudConfig")
    def cloud_config(self) -> Optional[_builtins.str]:
        """
        Filepath to a cloud-config yaml file to put into the ISO user-data
        """
        return pulumi.get(self, "cloud_config")

    @_builtins.property
    @pulumi.getter
    def cloudinit(self) -> Optional[_builtins.str]:
        """
        vSphere cloud-init filepath or url to add to guestinfo
        """
        return pulumi.get(self, "cloudinit")

    @_builtins.property
    @pulumi.getter(name="contentLibrary")
    def content_library(self) -> Optional[_builtins.str]:
        """
        If you choose to clone from a content library template specify the name of the library
        """
        return pulumi.get(self, "content_library")

    @_builtins.property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[_builtins.str]:
        """
        vSphere CPU number for docker VM
        """
        return pulumi.get(self, "cpu_count")

    @_builtins.property
    @pulumi.getter(name="creationType")
    def creation_type(self) -> Optional[_builtins.str]:
        """
        Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy
        """
        return pulumi.get(self, "creation_type")

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere custom attributes, format key/value e.g. '200=my custom value'
        """
        return pulumi.get(self, "custom_attributes")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        vSphere datacenter for virtual machine
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def datastore(self) -> Optional[_builtins.str]:
        """
        vSphere datastore for virtual machine
        """
        return pulumi.get(self, "datastore")

    @_builtins.property
    @pulumi.getter(name="datastoreCluster")
    def datastore_cluster(self) -> Optional[_builtins.str]:
        """
        vSphere datastore cluster for virtual machine
        """
        return pulumi.get(self, "datastore_cluster")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.str]:
        """
        vSphere size of disk for docker VM (in MB)
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        """
        vSphere folder for the docker VM. This folder must already exist in the datacenter
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[_builtins.str]:
        """
        Duration in seconds before the graceful shutdown of the VM times out and the VM is destroyed. A force destroy will be performed when the value is zero
        """
        return pulumi.get(self, "graceful_shutdown_timeout")

    @_builtins.property
    @pulumi.getter
    def hostsystem(self) -> Optional[_builtins.str]:
        """
        vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS
        """
        return pulumi.get(self, "hostsystem")

    @_builtins.property
    @pulumi.getter(name="memorySize")
    def memory_size(self) -> Optional[_builtins.str]:
        """
        vSphere size of memory for docker VM (in MB)
        """
        return pulumi.get(self, "memory_size")

    @_builtins.property
    @pulumi.getter
    def networks(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere network where the virtual machine will be attached
        """
        return pulumi.get(self, "networks")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        vSphere password
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def pool(self) -> Optional[_builtins.str]:
        """
        vSphere resource pool for docker VM
        """
        return pulumi.get(self, "pool")

    @_builtins.property
    @pulumi.getter(name="sshPassword")
    def ssh_password(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh password
        """
        return pulumi.get(self, "ssh_password")

    @_builtins.property
    @pulumi.getter(name="sshPort")
    def ssh_port(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh port
        """
        return pulumi.get(self, "ssh_port")

    @_builtins.property
    @pulumi.getter(name="sshUser")
    def ssh_user(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image you can specify the ssh user
        """
        return pulumi.get(self, "ssh_user")

    @_builtins.property
    @pulumi.getter(name="sshUserGroup")
    def ssh_user_group(self) -> Optional[_builtins.str]:
        """
        If using a non-B2D image the uploaded keys will need chown'ed, defaults to staff e.g. docker:staff
        """
        return pulumi.get(self, "ssh_user_group")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere tags id e.g. urn:xxx
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        vSphere username
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="vappIpAllocationPolicy")
    def vapp_ip_allocation_policy(self) -> Optional[_builtins.str]:
        """
        vSphere vApp IP allocation policy. Supported values are: dhcp, fixed, transient and fixedAllocated
        """
        return pulumi.get(self, "vapp_ip_allocation_policy")

    @_builtins.property
    @pulumi.getter(name="vappIpProtocol")
    def vapp_ip_protocol(self) -> Optional[_builtins.str]:
        """
        vSphere vApp IP protocol for this deployment. Supported values are: IPv4 and IPv6
        """
        return pulumi.get(self, "vapp_ip_protocol")

    @_builtins.property
    @pulumi.getter(name="vappProperties")
    def vapp_properties(self) -> Optional[Sequence[_builtins.str]]:
        """
        vSphere vApp properties
        """
        return pulumi.get(self, "vapp_properties")

    @_builtins.property
    @pulumi.getter(name="vappTransport")
    def vapp_transport(self) -> Optional[_builtins.str]:
        """
        vSphere OVF environment transports to use for properties. Supported values are: iso and com.vmware.guestInfo
        """
        return pulumi.get(self, "vapp_transport")

    @_builtins.property
    @pulumi.getter
    def vcenter(self) -> Optional[_builtins.str]:
        """
        vSphere IP/hostname for vCenter
        """
        return pulumi.get(self, "vcenter")

    @_builtins.property
    @pulumi.getter(name="vcenterPort")
    def vcenter_port(self) -> Optional[_builtins.str]:
        """
        vSphere Port for vCenter
        """
        return pulumi.get(self, "vcenter_port")


@pulumi.output_type
class PodSecurityAdmissionConfigurationTemplateDefaults(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditVersion":
            suggest = "audit_version"
        elif key == "enforceVersion":
            suggest = "enforce_version"
        elif key == "warnVersion":
            suggest = "warn_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PodSecurityAdmissionConfigurationTemplateDefaults. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PodSecurityAdmissionConfigurationTemplateDefaults.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PodSecurityAdmissionConfigurationTemplateDefaults.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audit: Optional[_builtins.str] = None,
                 audit_version: Optional[_builtins.str] = None,
                 enforce: Optional[_builtins.str] = None,
                 enforce_version: Optional[_builtins.str] = None,
                 warn: Optional[_builtins.str] = None,
                 warn_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str audit: Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param _builtins.str audit_version: Pod Security Admission Configuration audit version (default: latest)
        :param _builtins.str enforce: Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param _builtins.str enforce_version: Pod Security Admission Configuration enforce version (default: latest)
        :param _builtins.str warn: Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param _builtins.str warn_version: Pod Security Admission Configuration warn version (default: latest)
        """
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if audit_version is not None:
            pulumi.set(__self__, "audit_version", audit_version)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if enforce_version is not None:
            pulumi.set(__self__, "enforce_version", enforce_version)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)
        if warn_version is not None:
            pulumi.set(__self__, "warn_version", warn_version)

    @_builtins.property
    @pulumi.getter
    def audit(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "audit")

    @_builtins.property
    @pulumi.getter(name="auditVersion")
    def audit_version(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration audit version (default: latest)
        """
        return pulumi.get(self, "audit_version")

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="enforceVersion")
    def enforce_version(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration enforce version (default: latest)
        """
        return pulumi.get(self, "enforce_version")

    @_builtins.property
    @pulumi.getter
    def warn(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "warn")

    @_builtins.property
    @pulumi.getter(name="warnVersion")
    def warn_version(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration warn version (default: latest)
        """
        return pulumi.get(self, "warn_version")


@pulumi.output_type
class PodSecurityAdmissionConfigurationTemplateExemptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runtimeClasses":
            suggest = "runtime_classes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PodSecurityAdmissionConfigurationTemplateExemptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PodSecurityAdmissionConfigurationTemplateExemptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PodSecurityAdmissionConfigurationTemplateExemptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespaces: Optional[Sequence[_builtins.str]] = None,
                 runtime_classes: Optional[Sequence[_builtins.str]] = None,
                 usernames: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] namespaces: Pod Security Admission Configuration namespace exemptions
        :param Sequence[_builtins.str] runtime_classes: Pod Security Admission Configuration runtime class exemptions
        :param Sequence[_builtins.str] usernames: Pod Security Admission Configuration username exemptions
        """
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if runtime_classes is not None:
            pulumi.set(__self__, "runtime_classes", runtime_classes)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod Security Admission Configuration namespace exemptions
        """
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter(name="runtimeClasses")
    def runtime_classes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod Security Admission Configuration runtime class exemptions
        """
        return pulumi.get(self, "runtime_classes")

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod Security Admission Configuration username exemptions
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class ProjectContainerResourceLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitsCpu":
            suggest = "limits_cpu"
        elif key == "limitsMemory":
            suggest = "limits_memory"
        elif key == "requestsCpu":
            suggest = "requests_cpu"
        elif key == "requestsMemory":
            suggest = "requests_memory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectContainerResourceLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectContainerResourceLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectContainerResourceLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None):
        """
        :param _builtins.str limits_cpu: Limit for limits cpu in project (string)
        :param _builtins.str limits_memory: Limit for limits memory in project (string)
        :param _builtins.str requests_cpu: Limit for requests cpu in project (string)
        :param _builtins.str requests_memory: Limit for requests memory in project (string)
        """
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for limits cpu in project (string)
        """
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        """
        Limit for limits memory in project (string)
        """
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for requests cpu in project (string)
        """
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        """
        Limit for requests memory in project (string)
        """
        return pulumi.get(self, "requests_memory")


@pulumi.output_type
class ProjectResourceQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceDefaultLimit":
            suggest = "namespace_default_limit"
        elif key == "projectLimit":
            suggest = "project_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectResourceQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectResourceQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectResourceQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 namespace_default_limit: 'outputs.ProjectResourceQuotaNamespaceDefaultLimit',
                 project_limit: 'outputs.ProjectResourceQuotaProjectLimit'):
        """
        :param 'ProjectResourceQuotaNamespaceDefaultLimitArgs' namespace_default_limit: Default resource quota limit for  namespaces in project (list maxitems:1)
        :param 'ProjectResourceQuotaProjectLimitArgs' project_limit: Resource quota limit for project (list maxitems:1)
        """
        pulumi.set(__self__, "namespace_default_limit", namespace_default_limit)
        pulumi.set(__self__, "project_limit", project_limit)

    @_builtins.property
    @pulumi.getter(name="namespaceDefaultLimit")
    def namespace_default_limit(self) -> 'outputs.ProjectResourceQuotaNamespaceDefaultLimit':
        """
        Default resource quota limit for  namespaces in project (list maxitems:1)
        """
        return pulumi.get(self, "namespace_default_limit")

    @_builtins.property
    @pulumi.getter(name="projectLimit")
    def project_limit(self) -> 'outputs.ProjectResourceQuotaProjectLimit':
        """
        Resource quota limit for project (list maxitems:1)
        """
        return pulumi.get(self, "project_limit")


@pulumi.output_type
class ProjectResourceQuotaNamespaceDefaultLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMaps":
            suggest = "config_maps"
        elif key == "limitsCpu":
            suggest = "limits_cpu"
        elif key == "limitsMemory":
            suggest = "limits_memory"
        elif key == "persistentVolumeClaims":
            suggest = "persistent_volume_claims"
        elif key == "replicationControllers":
            suggest = "replication_controllers"
        elif key == "requestsCpu":
            suggest = "requests_cpu"
        elif key == "requestsMemory":
            suggest = "requests_memory"
        elif key == "requestsStorage":
            suggest = "requests_storage"
        elif key == "servicesLoadBalancers":
            suggest = "services_load_balancers"
        elif key == "servicesNodePorts":
            suggest = "services_node_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectResourceQuotaNamespaceDefaultLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectResourceQuotaNamespaceDefaultLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectResourceQuotaNamespaceDefaultLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_maps: Optional[_builtins.str] = None,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 persistent_volume_claims: Optional[_builtins.str] = None,
                 pods: Optional[_builtins.str] = None,
                 replication_controllers: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None,
                 requests_storage: Optional[_builtins.str] = None,
                 secrets: Optional[_builtins.str] = None,
                 services: Optional[_builtins.str] = None,
                 services_load_balancers: Optional[_builtins.str] = None,
                 services_node_ports: Optional[_builtins.str] = None):
        """
        :param _builtins.str config_maps: Limit for config maps in project (string)
        :param _builtins.str limits_cpu: Limit for limits cpu in project (string)
        :param _builtins.str limits_memory: Limit for limits memory in project (string)
        :param _builtins.str persistent_volume_claims: Limit for persistent volume claims in project (string)
        :param _builtins.str pods: Limit for pods in project (string)
        :param _builtins.str replication_controllers: Limit for replication controllers in project (string)
        :param _builtins.str requests_cpu: Limit for requests cpu in project (string)
        :param _builtins.str requests_memory: Limit for requests memory in project (string)
        :param _builtins.str requests_storage: Limit for requests storage in project (string)
        :param _builtins.str secrets: Limit for secrets in project (string)
        :param _builtins.str services_load_balancers: Limit for services load balancers in project (string)
        :param _builtins.str services_node_ports: Limit for services node ports in project (string)
               
               More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[_builtins.str]:
        """
        Limit for config maps in project (string)
        """
        return pulumi.get(self, "config_maps")

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for limits cpu in project (string)
        """
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        """
        Limit for limits memory in project (string)
        """
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[_builtins.str]:
        """
        Limit for persistent volume claims in project (string)
        """
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.str]:
        """
        Limit for pods in project (string)
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[_builtins.str]:
        """
        Limit for replication controllers in project (string)
        """
        return pulumi.get(self, "replication_controllers")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for requests cpu in project (string)
        """
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        """
        Limit for requests memory in project (string)
        """
        return pulumi.get(self, "requests_memory")

    @_builtins.property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[_builtins.str]:
        """
        Limit for requests storage in project (string)
        """
        return pulumi.get(self, "requests_storage")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[_builtins.str]:
        """
        Limit for secrets in project (string)
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[_builtins.str]:
        """
        Limit for services load balancers in project (string)
        """
        return pulumi.get(self, "services_load_balancers")

    @_builtins.property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[_builtins.str]:
        """
        Limit for services node ports in project (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        return pulumi.get(self, "services_node_ports")


@pulumi.output_type
class ProjectResourceQuotaProjectLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configMaps":
            suggest = "config_maps"
        elif key == "limitsCpu":
            suggest = "limits_cpu"
        elif key == "limitsMemory":
            suggest = "limits_memory"
        elif key == "persistentVolumeClaims":
            suggest = "persistent_volume_claims"
        elif key == "replicationControllers":
            suggest = "replication_controllers"
        elif key == "requestsCpu":
            suggest = "requests_cpu"
        elif key == "requestsMemory":
            suggest = "requests_memory"
        elif key == "requestsStorage":
            suggest = "requests_storage"
        elif key == "servicesLoadBalancers":
            suggest = "services_load_balancers"
        elif key == "servicesNodePorts":
            suggest = "services_node_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProjectResourceQuotaProjectLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProjectResourceQuotaProjectLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProjectResourceQuotaProjectLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 config_maps: Optional[_builtins.str] = None,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 persistent_volume_claims: Optional[_builtins.str] = None,
                 pods: Optional[_builtins.str] = None,
                 replication_controllers: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None,
                 requests_storage: Optional[_builtins.str] = None,
                 secrets: Optional[_builtins.str] = None,
                 services: Optional[_builtins.str] = None,
                 services_load_balancers: Optional[_builtins.str] = None,
                 services_node_ports: Optional[_builtins.str] = None):
        """
        :param _builtins.str config_maps: Limit for config maps in project (string)
        :param _builtins.str limits_cpu: Limit for limits cpu in project (string)
        :param _builtins.str limits_memory: Limit for limits memory in project (string)
        :param _builtins.str persistent_volume_claims: Limit for persistent volume claims in project (string)
        :param _builtins.str pods: Limit for pods in project (string)
        :param _builtins.str replication_controllers: Limit for replication controllers in project (string)
        :param _builtins.str requests_cpu: Limit for requests cpu in project (string)
        :param _builtins.str requests_memory: Limit for requests memory in project (string)
        :param _builtins.str requests_storage: Limit for requests storage in project (string)
        :param _builtins.str secrets: Limit for secrets in project (string)
        :param _builtins.str services_load_balancers: Limit for services load balancers in project (string)
        :param _builtins.str services_node_ports: Limit for services node ports in project (string)
               
               More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[_builtins.str]:
        """
        Limit for config maps in project (string)
        """
        return pulumi.get(self, "config_maps")

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for limits cpu in project (string)
        """
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        """
        Limit for limits memory in project (string)
        """
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[_builtins.str]:
        """
        Limit for persistent volume claims in project (string)
        """
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.str]:
        """
        Limit for pods in project (string)
        """
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[_builtins.str]:
        """
        Limit for replication controllers in project (string)
        """
        return pulumi.get(self, "replication_controllers")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        """
        Limit for requests cpu in project (string)
        """
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        """
        Limit for requests memory in project (string)
        """
        return pulumi.get(self, "requests_memory")

    @_builtins.property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[_builtins.str]:
        """
        Limit for requests storage in project (string)
        """
        return pulumi.get(self, "requests_storage")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[_builtins.str]:
        """
        Limit for secrets in project (string)
        """
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[_builtins.str]:
        """
        Limit for services load balancers in project (string)
        """
        return pulumi.get(self, "services_load_balancers")

    @_builtins.property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[_builtins.str]:
        """
        Limit for services node ports in project (string)

        More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
        """
        return pulumi.get(self, "services_node_ports")


@pulumi.output_type
class RegistryRegistry(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str address: Address for registry.
        :param _builtins.str password: Password for the registry (string)
        :param _builtins.str username: Username for the registry (string)
        """
        pulumi.set(__self__, "address", address)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        Address for registry.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the registry (string)
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username for the registry (string)
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class RoleTemplateExternalRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroups":
            suggest = "api_groups"
        elif key == "nonResourceUrls":
            suggest = "non_resource_urls"
        elif key == "resourceNames":
            suggest = "resource_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleTemplateExternalRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleTemplateExternalRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleTemplateExternalRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_groups: Optional[Sequence[_builtins.str]] = None,
                 non_resource_urls: Optional[Sequence[_builtins.str]] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None,
                 verbs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_groups: Policy rule api groups
        :param Sequence[_builtins.str] non_resource_urls: Policy rule non resource urls
        :param Sequence[_builtins.str] resource_names: Policy rule resource names
        :param Sequence[_builtins.str] resources: Policy rule resources
        :param Sequence[_builtins.str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @_builtins.property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @_builtins.property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")


@pulumi.output_type
class RoleTemplateRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiGroups":
            suggest = "api_groups"
        elif key == "nonResourceUrls":
            suggest = "non_resource_urls"
        elif key == "resourceNames":
            suggest = "resource_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleTemplateRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleTemplateRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleTemplateRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_groups: Optional[Sequence[_builtins.str]] = None,
                 non_resource_urls: Optional[Sequence[_builtins.str]] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None,
                 verbs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_groups: Policy rule api groups
        :param Sequence[_builtins.str] non_resource_urls: Policy rule non resource urls
        :param Sequence[_builtins.str] resource_names: Policy rule resource names
        :param Sequence[_builtins.str] resources: Policy rule resources
        :param Sequence[_builtins.str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @_builtins.property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @_builtins.property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")


@pulumi.output_type
class GetClusterAksConfigV2Result(dict):
    def __init__(__self__, *,
                 cloud_credential_id: _builtins.str,
                 http_application_routing: _builtins.bool,
                 linux_admin_username: _builtins.str,
                 linux_ssh_public_key: _builtins.str,
                 load_balancer_sku: _builtins.str,
                 log_analytics_workspace_group: _builtins.str,
                 log_analytics_workspace_name: _builtins.str,
                 monitoring: _builtins.bool,
                 name: _builtins.str,
                 network_dns_service_ip: _builtins.str,
                 network_docker_bridge_cidr: _builtins.str,
                 network_pod_cidr: _builtins.str,
                 network_policy: _builtins.str,
                 network_service_cidr: _builtins.str,
                 node_resource_group: _builtins.str,
                 private_cluster: _builtins.bool,
                 resource_group: _builtins.str,
                 resource_location: _builtins.str,
                 subnet: _builtins.str,
                 tags: Mapping[str, _builtins.str],
                 virtual_network: _builtins.str,
                 virtual_network_resource_group: _builtins.str,
                 auth_base_url: Optional[_builtins.str] = None,
                 authorized_ip_ranges: Optional[Sequence[_builtins.str]] = None,
                 base_url: Optional[_builtins.str] = None,
                 dns_prefix: Optional[_builtins.str] = None,
                 imported: Optional[_builtins.bool] = None,
                 kubernetes_version: Optional[_builtins.str] = None,
                 network_plugin: Optional[_builtins.str] = None,
                 node_pools: Optional[Sequence['outputs.GetClusterAksConfigV2NodePoolResult']] = None,
                 outbound_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cloud_credential_id: The AKS Cloud Credential ID to use
        :param _builtins.bool http_application_routing: Enable AKS http application routing?
        :param _builtins.str linux_admin_username: The AKS linux admin username
        :param _builtins.str linux_ssh_public_key: The AKS linux ssh public key
        :param _builtins.str load_balancer_sku: The AKS load balancer sku
        :param _builtins.str log_analytics_workspace_group: The AKS log analytics workspace group
        :param _builtins.str log_analytics_workspace_name: The AKS log analytics workspace name
        :param _builtins.bool monitoring: Is AKS cluster monitoring enabled?
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str network_dns_service_ip: The AKS network dns service ip
        :param _builtins.str network_docker_bridge_cidr: The AKS network docker bridge cidr
        :param _builtins.str network_pod_cidr: The AKS network pod cidr
        :param _builtins.str network_policy: The AKS network policy
        :param _builtins.str network_service_cidr: The AKS network service cidr
        :param _builtins.str node_resource_group: The AKS node resource group name
        :param _builtins.bool private_cluster: Is AKS cluster private?
        :param _builtins.str resource_group: The AKS resource group
        :param _builtins.str resource_location: The AKS resource location
        :param _builtins.str subnet: The AKS subnet
        :param Mapping[str, _builtins.str] tags: The AKS cluster tags
        :param _builtins.str virtual_network: The AKS virtual network
        :param _builtins.str virtual_network_resource_group: The AKS virtual network resource group
        :param _builtins.str auth_base_url: The AKS auth base url
        :param Sequence[_builtins.str] authorized_ip_ranges: The AKS authorized ip ranges
        :param _builtins.str base_url: The AKS base url
        :param _builtins.str dns_prefix: The AKS dns prefix. Required if `import=false`
        :param _builtins.bool imported: Is AKS cluster imported?
        :param _builtins.str kubernetes_version: The kubernetes master version. Required if `import=false`
        :param _builtins.str network_plugin: The AKS network plugin. Required if `import=false`
        :param Sequence['GetClusterAksConfigV2NodePoolArgs'] node_pools: The AKS node pools to use. Required if `import=false`
        :param _builtins.str outbound_type: The AKS outbound type for the egress traffic
        """
        pulumi.set(__self__, "cloud_credential_id", cloud_credential_id)
        pulumi.set(__self__, "http_application_routing", http_application_routing)
        pulumi.set(__self__, "linux_admin_username", linux_admin_username)
        pulumi.set(__self__, "linux_ssh_public_key", linux_ssh_public_key)
        pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)
        pulumi.set(__self__, "log_analytics_workspace_group", log_analytics_workspace_group)
        pulumi.set(__self__, "log_analytics_workspace_name", log_analytics_workspace_name)
        pulumi.set(__self__, "monitoring", monitoring)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_dns_service_ip", network_dns_service_ip)
        pulumi.set(__self__, "network_docker_bridge_cidr", network_docker_bridge_cidr)
        pulumi.set(__self__, "network_pod_cidr", network_pod_cidr)
        pulumi.set(__self__, "network_policy", network_policy)
        pulumi.set(__self__, "network_service_cidr", network_service_cidr)
        pulumi.set(__self__, "node_resource_group", node_resource_group)
        pulumi.set(__self__, "private_cluster", private_cluster)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "resource_location", resource_location)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "virtual_network", virtual_network)
        pulumi.set(__self__, "virtual_network_resource_group", virtual_network_resource_group)
        if auth_base_url is not None:
            pulumi.set(__self__, "auth_base_url", auth_base_url)
        if authorized_ip_ranges is not None:
            pulumi.set(__self__, "authorized_ip_ranges", authorized_ip_ranges)
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if dns_prefix is not None:
            pulumi.set(__self__, "dns_prefix", dns_prefix)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if kubernetes_version is not None:
            pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        if network_plugin is not None:
            pulumi.set(__self__, "network_plugin", network_plugin)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if outbound_type is not None:
            pulumi.set(__self__, "outbound_type", outbound_type)

    @_builtins.property
    @pulumi.getter(name="cloudCredentialId")
    def cloud_credential_id(self) -> _builtins.str:
        """
        The AKS Cloud Credential ID to use
        """
        return pulumi.get(self, "cloud_credential_id")

    @_builtins.property
    @pulumi.getter(name="httpApplicationRouting")
    def http_application_routing(self) -> _builtins.bool:
        """
        Enable AKS http application routing?
        """
        return pulumi.get(self, "http_application_routing")

    @_builtins.property
    @pulumi.getter(name="linuxAdminUsername")
    def linux_admin_username(self) -> _builtins.str:
        """
        The AKS linux admin username
        """
        return pulumi.get(self, "linux_admin_username")

    @_builtins.property
    @pulumi.getter(name="linuxSshPublicKey")
    def linux_ssh_public_key(self) -> _builtins.str:
        """
        The AKS linux ssh public key
        """
        return pulumi.get(self, "linux_ssh_public_key")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> _builtins.str:
        """
        The AKS load balancer sku
        """
        return pulumi.get(self, "load_balancer_sku")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceGroup")
    def log_analytics_workspace_group(self) -> _builtins.str:
        """
        The AKS log analytics workspace group
        """
        return pulumi.get(self, "log_analytics_workspace_group")

    @_builtins.property
    @pulumi.getter(name="logAnalyticsWorkspaceName")
    def log_analytics_workspace_name(self) -> _builtins.str:
        """
        The AKS log analytics workspace name
        """
        return pulumi.get(self, "log_analytics_workspace_name")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> _builtins.bool:
        """
        Is AKS cluster monitoring enabled?
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="networkDnsServiceIp")
    def network_dns_service_ip(self) -> _builtins.str:
        """
        The AKS network dns service ip
        """
        return pulumi.get(self, "network_dns_service_ip")

    @_builtins.property
    @pulumi.getter(name="networkDockerBridgeCidr")
    def network_docker_bridge_cidr(self) -> _builtins.str:
        """
        The AKS network docker bridge cidr
        """
        return pulumi.get(self, "network_docker_bridge_cidr")

    @_builtins.property
    @pulumi.getter(name="networkPodCidr")
    def network_pod_cidr(self) -> _builtins.str:
        """
        The AKS network pod cidr
        """
        return pulumi.get(self, "network_pod_cidr")

    @_builtins.property
    @pulumi.getter(name="networkPolicy")
    def network_policy(self) -> _builtins.str:
        """
        The AKS network policy
        """
        return pulumi.get(self, "network_policy")

    @_builtins.property
    @pulumi.getter(name="networkServiceCidr")
    def network_service_cidr(self) -> _builtins.str:
        """
        The AKS network service cidr
        """
        return pulumi.get(self, "network_service_cidr")

    @_builtins.property
    @pulumi.getter(name="nodeResourceGroup")
    def node_resource_group(self) -> _builtins.str:
        """
        The AKS node resource group name
        """
        return pulumi.get(self, "node_resource_group")

    @_builtins.property
    @pulumi.getter(name="privateCluster")
    def private_cluster(self) -> _builtins.bool:
        """
        Is AKS cluster private?
        """
        return pulumi.get(self, "private_cluster")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        """
        The AKS resource group
        """
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="resourceLocation")
    def resource_location(self) -> _builtins.str:
        """
        The AKS resource location
        """
        return pulumi.get(self, "resource_location")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The AKS subnet
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Mapping[str, _builtins.str]:
        """
        The AKS cluster tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="virtualNetwork")
    def virtual_network(self) -> _builtins.str:
        """
        The AKS virtual network
        """
        return pulumi.get(self, "virtual_network")

    @_builtins.property
    @pulumi.getter(name="virtualNetworkResourceGroup")
    def virtual_network_resource_group(self) -> _builtins.str:
        """
        The AKS virtual network resource group
        """
        return pulumi.get(self, "virtual_network_resource_group")

    @_builtins.property
    @pulumi.getter(name="authBaseUrl")
    def auth_base_url(self) -> Optional[_builtins.str]:
        """
        The AKS auth base url
        """
        return pulumi.get(self, "auth_base_url")

    @_builtins.property
    @pulumi.getter(name="authorizedIpRanges")
    def authorized_ip_ranges(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AKS authorized ip ranges
        """
        return pulumi.get(self, "authorized_ip_ranges")

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        The AKS base url
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="dnsPrefix")
    def dns_prefix(self) -> Optional[_builtins.str]:
        """
        The AKS dns prefix. Required if `import=false`
        """
        return pulumi.get(self, "dns_prefix")

    @_builtins.property
    @pulumi.getter
    def imported(self) -> Optional[_builtins.bool]:
        """
        Is AKS cluster imported?
        """
        return pulumi.get(self, "imported")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[_builtins.str]:
        """
        The kubernetes master version. Required if `import=false`
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter(name="networkPlugin")
    def network_plugin(self) -> Optional[_builtins.str]:
        """
        The AKS network plugin. Required if `import=false`
        """
        return pulumi.get(self, "network_plugin")

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.GetClusterAksConfigV2NodePoolResult']]:
        """
        The AKS node pools to use. Required if `import=false`
        """
        return pulumi.get(self, "node_pools")

    @_builtins.property
    @pulumi.getter(name="outboundType")
    def outbound_type(self) -> Optional[_builtins.str]:
        """
        The AKS outbound type for the egress traffic
        """
        return pulumi.get(self, "outbound_type")


@pulumi.output_type
class GetClusterAksConfigV2NodePoolResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 taints: Sequence[_builtins.str],
                 vm_size: _builtins.str,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 count: Optional[_builtins.int] = None,
                 enable_auto_scaling: Optional[_builtins.bool] = None,
                 max_count: Optional[_builtins.int] = None,
                 max_pods: Optional[_builtins.int] = None,
                 max_surge: Optional[_builtins.str] = None,
                 min_count: Optional[_builtins.int] = None,
                 mode: Optional[_builtins.str] = None,
                 orchestrator_version: Optional[_builtins.str] = None,
                 os_disk_size_gb: Optional[_builtins.int] = None,
                 os_disk_type: Optional[_builtins.str] = None,
                 os_type: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for Node Pool object (map)
        :param _builtins.str name: The name of the Cluster (string)
        :param Sequence[_builtins.str] taints: The AKS node pool taints
        :param _builtins.str vm_size: The AKS node pool vm size
        :param Sequence[_builtins.str] availability_zones: The AKS node pool availability zones
        :param _builtins.int count: The AKS node pool count
        :param _builtins.bool enable_auto_scaling: Is AKS node pool auto scaling enabled?
        :param _builtins.int max_count: The AKS node pool max count
        :param _builtins.int max_pods: The AKS node pool max pods
        :param _builtins.str max_surge: The AKS node pool max surge
        :param _builtins.int min_count: The AKS node pool min count
        :param _builtins.str mode: The AKS node pool mode
        :param _builtins.str orchestrator_version: The AKS node pool orchestrator version
        :param _builtins.int os_disk_size_gb: The AKS node pool os disk size gb
        :param _builtins.str os_disk_type: The AKS node pool os disk type
        :param _builtins.str os_type: Enable AKS node pool os type
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "taints", taints)
        pulumi.set(__self__, "vm_size", vm_size)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if enable_auto_scaling is not None:
            pulumi.set(__self__, "enable_auto_scaling", enable_auto_scaling)
        if max_count is not None:
            pulumi.set(__self__, "max_count", max_count)
        if max_pods is not None:
            pulumi.set(__self__, "max_pods", max_pods)
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if min_count is not None:
            pulumi.set(__self__, "min_count", min_count)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if orchestrator_version is not None:
            pulumi.set(__self__, "orchestrator_version", orchestrator_version)
        if os_disk_size_gb is not None:
            pulumi.set(__self__, "os_disk_size_gb", os_disk_size_gb)
        if os_disk_type is not None:
            pulumi.set(__self__, "os_disk_type", os_disk_type)
        if os_type is not None:
            pulumi.set(__self__, "os_type", os_type)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Labels for Node Pool object (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence[_builtins.str]:
        """
        The AKS node pool taints
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="vmSize")
    def vm_size(self) -> _builtins.str:
        """
        The AKS node pool vm size
        """
        return pulumi.get(self, "vm_size")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AKS node pool availability zones
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The AKS node pool count
        """
        return pulumi.get(self, "count")

    @_builtins.property
    @pulumi.getter(name="enableAutoScaling")
    def enable_auto_scaling(self) -> Optional[_builtins.bool]:
        """
        Is AKS node pool auto scaling enabled?
        """
        return pulumi.get(self, "enable_auto_scaling")

    @_builtins.property
    @pulumi.getter(name="maxCount")
    def max_count(self) -> Optional[_builtins.int]:
        """
        The AKS node pool max count
        """
        return pulumi.get(self, "max_count")

    @_builtins.property
    @pulumi.getter(name="maxPods")
    def max_pods(self) -> Optional[_builtins.int]:
        """
        The AKS node pool max pods
        """
        return pulumi.get(self, "max_pods")

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        The AKS node pool max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="minCount")
    def min_count(self) -> Optional[_builtins.int]:
        """
        The AKS node pool min count
        """
        return pulumi.get(self, "min_count")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        """
        The AKS node pool mode
        """
        return pulumi.get(self, "mode")

    @_builtins.property
    @pulumi.getter(name="orchestratorVersion")
    def orchestrator_version(self) -> Optional[_builtins.str]:
        """
        The AKS node pool orchestrator version
        """
        return pulumi.get(self, "orchestrator_version")

    @_builtins.property
    @pulumi.getter(name="osDiskSizeGb")
    def os_disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The AKS node pool os disk size gb
        """
        return pulumi.get(self, "os_disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="osDiskType")
    def os_disk_type(self) -> Optional[_builtins.str]:
        """
        The AKS node pool os disk type
        """
        return pulumi.get(self, "os_disk_type")

    @_builtins.property
    @pulumi.getter(name="osType")
    def os_type(self) -> Optional[_builtins.str]:
        """
        Enable AKS node pool os type
        """
        return pulumi.get(self, "os_type")


@pulumi.output_type
class GetClusterClusterAuthEndpointResult(dict):
    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetClusterClusterRegistrationTokenResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, _builtins.str],
                 cluster_id: _builtins.str,
                 command: _builtins.str,
                 id: _builtins.str,
                 insecure_command: _builtins.str,
                 insecure_node_command: _builtins.str,
                 insecure_windows_node_command: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 manifest_url: _builtins.str,
                 name: _builtins.str,
                 node_command: _builtins.str,
                 token: _builtins.str,
                 windows_node_command: _builtins.str):
        """
        :param Mapping[str, _builtins.str] annotations: (Computed) Annotations for Node Pool object (map)
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for Node Pool object (map)
        :param _builtins.str name: The name of the Cluster (string)
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "insecure_command", insecure_command)
        pulumi.set(__self__, "insecure_node_command", insecure_node_command)
        pulumi.set(__self__, "insecure_windows_node_command", insecure_windows_node_command)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "manifest_url", manifest_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_command", node_command)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "windows_node_command", windows_node_command)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Annotations for Node Pool object (map)
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def command(self) -> _builtins.str:
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="insecureCommand")
    def insecure_command(self) -> _builtins.str:
        return pulumi.get(self, "insecure_command")

    @_builtins.property
    @pulumi.getter(name="insecureNodeCommand")
    def insecure_node_command(self) -> _builtins.str:
        return pulumi.get(self, "insecure_node_command")

    @_builtins.property
    @pulumi.getter(name="insecureWindowsNodeCommand")
    def insecure_windows_node_command(self) -> _builtins.str:
        return pulumi.get(self, "insecure_windows_node_command")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Labels for Node Pool object (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="manifestUrl")
    def manifest_url(self) -> _builtins.str:
        return pulumi.get(self, "manifest_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCommand")
    def node_command(self) -> _builtins.str:
        return pulumi.get(self, "node_command")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="windowsNodeCommand")
    def windows_node_command(self) -> _builtins.str:
        return pulumi.get(self, "windows_node_command")


@pulumi.output_type
class GetClusterClusterTemplateAnswersResult(dict):
    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 project_id: _builtins.str,
                 values: Mapping[str, _builtins.str]):
        """
        :param _builtins.str cluster_id: Cluster ID for answer
        :param _builtins.str project_id: Project ID for answer
        :param Mapping[str, _builtins.str] values: Key/values for answer
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        Cluster ID for answer
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID for answer
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Mapping[str, _builtins.str]:
        """
        Key/values for answer
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterClusterTemplateQuestionResult(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 variable: _builtins.str,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str default: Default variable value
        :param _builtins.str variable: Variable name
        :param _builtins.bool required: Required variable
        :param _builtins.str type: Variable type
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "variable", variable)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        """
        Default variable value
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Variable name
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Required variable
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Variable type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterEksConfigV2Result(dict):
    def __init__(__self__, *,
                 cloud_credential_id: _builtins.str,
                 kubernetes_version: _builtins.str,
                 name: _builtins.str,
                 node_groups: Sequence['outputs.GetClusterEksConfigV2NodeGroupResult'],
                 private_access: _builtins.bool,
                 public_access: _builtins.bool,
                 public_access_sources: Sequence[_builtins.str],
                 secrets_encryption: _builtins.bool,
                 imported: Optional[_builtins.bool] = None,
                 kms_key: Optional[_builtins.str] = None,
                 logging_types: Optional[Sequence[_builtins.str]] = None,
                 region: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 service_role: Optional[_builtins.str] = None,
                 subnets: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str cloud_credential_id: The AWS Cloud Credential ID to use
        :param _builtins.str kubernetes_version: The kubernetes master version
        :param _builtins.str name: The name of the Cluster (string)
        :param Sequence['GetClusterEksConfigV2NodeGroupArgs'] node_groups: The AWS node groups to use
        :param _builtins.bool private_access: The EKS cluster has private access
        :param _builtins.bool public_access: The EKS cluster has public access
        :param Sequence[_builtins.str] public_access_sources: The EKS cluster public access sources
        :param _builtins.bool secrets_encryption: Enable EKS cluster secret encryption
        :param _builtins.bool imported: Is EKS cluster imported?
        :param _builtins.str kms_key: The AWS kms key to use
        :param Sequence[_builtins.str] logging_types: The AWS logging types
        :param _builtins.str region: The AWS Region to create the EKS cluster in
        :param Sequence[_builtins.str] security_groups: List of security groups to use for the cluster
        :param _builtins.str service_role: The AWS service role to use
        :param Sequence[_builtins.str] subnets: List of subnets in the virtual network to use
        :param Mapping[str, _builtins.str] tags: The EKS cluster tags
        """
        pulumi.set(__self__, "cloud_credential_id", cloud_credential_id)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_groups", node_groups)
        pulumi.set(__self__, "private_access", private_access)
        pulumi.set(__self__, "public_access", public_access)
        pulumi.set(__self__, "public_access_sources", public_access_sources)
        pulumi.set(__self__, "secrets_encryption", secrets_encryption)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if logging_types is not None:
            pulumi.set(__self__, "logging_types", logging_types)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if service_role is not None:
            pulumi.set(__self__, "service_role", service_role)
        if subnets is not None:
            pulumi.set(__self__, "subnets", subnets)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="cloudCredentialId")
    def cloud_credential_id(self) -> _builtins.str:
        """
        The AWS Cloud Credential ID to use
        """
        return pulumi.get(self, "cloud_credential_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeGroups")
    def node_groups(self) -> Sequence['outputs.GetClusterEksConfigV2NodeGroupResult']:
        """
        The AWS node groups to use
        """
        return pulumi.get(self, "node_groups")

    @_builtins.property
    @pulumi.getter(name="privateAccess")
    def private_access(self) -> _builtins.bool:
        """
        The EKS cluster has private access
        """
        return pulumi.get(self, "private_access")

    @_builtins.property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> _builtins.bool:
        """
        The EKS cluster has public access
        """
        return pulumi.get(self, "public_access")

    @_builtins.property
    @pulumi.getter(name="publicAccessSources")
    def public_access_sources(self) -> Sequence[_builtins.str]:
        """
        The EKS cluster public access sources
        """
        return pulumi.get(self, "public_access_sources")

    @_builtins.property
    @pulumi.getter(name="secretsEncryption")
    def secrets_encryption(self) -> _builtins.bool:
        """
        Enable EKS cluster secret encryption
        """
        return pulumi.get(self, "secrets_encryption")

    @_builtins.property
    @pulumi.getter
    def imported(self) -> Optional[_builtins.bool]:
        """
        Is EKS cluster imported?
        """
        return pulumi.get(self, "imported")

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[_builtins.str]:
        """
        The AWS kms key to use
        """
        return pulumi.get(self, "kms_key")

    @_builtins.property
    @pulumi.getter(name="loggingTypes")
    def logging_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The AWS logging types
        """
        return pulumi.get(self, "logging_types")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The AWS Region to create the EKS cluster in
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security groups to use for the cluster
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="serviceRole")
    def service_role(self) -> Optional[_builtins.str]:
        """
        The AWS service role to use
        """
        return pulumi.get(self, "service_role")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of subnets in the virtual network to use
        """
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The EKS cluster tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetClusterEksConfigV2NodeGroupResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 subnets: Sequence[_builtins.str],
                 user_data: _builtins.str,
                 version: _builtins.str,
                 desired_size: Optional[_builtins.int] = None,
                 disk_size: Optional[_builtins.int] = None,
                 ec2_ssh_key: Optional[_builtins.str] = None,
                 gpu: Optional[_builtins.bool] = None,
                 image_id: Optional[_builtins.str] = None,
                 instance_type: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 launch_templates: Optional[Sequence['outputs.GetClusterEksConfigV2NodeGroupLaunchTemplateResult']] = None,
                 max_size: Optional[_builtins.int] = None,
                 min_size: Optional[_builtins.int] = None,
                 node_role: Optional[_builtins.str] = None,
                 request_spot_instances: Optional[_builtins.bool] = None,
                 resource_tags: Optional[Mapping[str, _builtins.str]] = None,
                 spot_instance_types: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str name: The name of the Cluster (string)
        :param Sequence[_builtins.str] subnets: The EKS node group subnets
        :param _builtins.str user_data: The EKS node group user data
        :param _builtins.str version: The EKS node group k8s version
        :param _builtins.int desired_size: The EKS node group desired size
        :param _builtins.int disk_size: The EKS node group disk size
        :param _builtins.str ec2_ssh_key: The EKS node group ssh key
        :param _builtins.bool gpu: Is EKS cluster using gpu?
        :param _builtins.str image_id: The EKS node group image ID
        :param _builtins.str instance_type: The EKS node group instance type
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for Node Pool object (map)
        :param Sequence['GetClusterEksConfigV2NodeGroupLaunchTemplateArgs'] launch_templates: The EKS node groups launch template
        :param _builtins.int max_size: The EKS node group maximum size
        :param _builtins.int min_size: The EKS node group minimum size
        :param _builtins.str node_role: The EKS node group node role ARN
        :param _builtins.bool request_spot_instances: Enable EKS node group request spot instances
        :param Mapping[str, _builtins.str] resource_tags: The EKS node group resource tags
        :param Sequence[_builtins.str] spot_instance_types: The EKS node group spot instance types
        :param Mapping[str, _builtins.str] tags: The EKS node group tags
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnets", subnets)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "version", version)
        if desired_size is not None:
            pulumi.set(__self__, "desired_size", desired_size)
        if disk_size is not None:
            pulumi.set(__self__, "disk_size", disk_size)
        if ec2_ssh_key is not None:
            pulumi.set(__self__, "ec2_ssh_key", ec2_ssh_key)
        if gpu is not None:
            pulumi.set(__self__, "gpu", gpu)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if launch_templates is not None:
            pulumi.set(__self__, "launch_templates", launch_templates)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if node_role is not None:
            pulumi.set(__self__, "node_role", node_role)
        if request_spot_instances is not None:
            pulumi.set(__self__, "request_spot_instances", request_spot_instances)
        if resource_tags is not None:
            pulumi.set(__self__, "resource_tags", resource_tags)
        if spot_instance_types is not None:
            pulumi.set(__self__, "spot_instance_types", spot_instance_types)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        """
        The EKS node group subnets
        """
        return pulumi.get(self, "subnets")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> _builtins.str:
        """
        The EKS node group user data
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The EKS node group k8s version
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="desiredSize")
    def desired_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group desired size
        """
        return pulumi.get(self, "desired_size")

    @_builtins.property
    @pulumi.getter(name="diskSize")
    def disk_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group disk size
        """
        return pulumi.get(self, "disk_size")

    @_builtins.property
    @pulumi.getter(name="ec2SshKey")
    def ec2_ssh_key(self) -> Optional[_builtins.str]:
        """
        The EKS node group ssh key
        """
        return pulumi.get(self, "ec2_ssh_key")

    @_builtins.property
    @pulumi.getter
    def gpu(self) -> Optional[_builtins.bool]:
        """
        Is EKS cluster using gpu?
        """
        return pulumi.get(self, "gpu")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        The EKS node group image ID
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The EKS node group instance type
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Computed) Labels for Node Pool object (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="launchTemplates")
    def launch_templates(self) -> Optional[Sequence['outputs.GetClusterEksConfigV2NodeGroupLaunchTemplateResult']]:
        """
        The EKS node groups launch template
        """
        return pulumi.get(self, "launch_templates")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group maximum size
        """
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[_builtins.int]:
        """
        The EKS node group minimum size
        """
        return pulumi.get(self, "min_size")

    @_builtins.property
    @pulumi.getter(name="nodeRole")
    def node_role(self) -> Optional[_builtins.str]:
        """
        The EKS node group node role ARN
        """
        return pulumi.get(self, "node_role")

    @_builtins.property
    @pulumi.getter(name="requestSpotInstances")
    def request_spot_instances(self) -> Optional[_builtins.bool]:
        """
        Enable EKS node group request spot instances
        """
        return pulumi.get(self, "request_spot_instances")

    @_builtins.property
    @pulumi.getter(name="resourceTags")
    def resource_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The EKS node group resource tags
        """
        return pulumi.get(self, "resource_tags")

    @_builtins.property
    @pulumi.getter(name="spotInstanceTypes")
    def spot_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The EKS node group spot instance types
        """
        return pulumi.get(self, "spot_instance_types")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The EKS node group tags
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetClusterEksConfigV2NodeGroupLaunchTemplateResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 version: _builtins.int):
        """
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.int version: The EKS node group launch template version
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.int:
        """
        The EKS node group launch template version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterGkeConfigV2Result(dict):
    def __init__(__self__, *,
                 cluster_addons: 'outputs.GetClusterGkeConfigV2ClusterAddonsResult',
                 cluster_ipv4_cidr_block: _builtins.str,
                 description: _builtins.str,
                 enable_kubernetes_alpha: _builtins.bool,
                 google_credential_secret: _builtins.str,
                 ip_allocation_policy: 'outputs.GetClusterGkeConfigV2IpAllocationPolicyResult',
                 kubernetes_version: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 locations: Sequence[_builtins.str],
                 logging_service: _builtins.str,
                 maintenance_window: _builtins.str,
                 master_authorized_networks_config: 'outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfigResult',
                 monitoring_service: _builtins.str,
                 name: _builtins.str,
                 network: _builtins.str,
                 network_policy_enabled: _builtins.bool,
                 node_pools: Sequence['outputs.GetClusterGkeConfigV2NodePoolResult'],
                 private_cluster_config: 'outputs.GetClusterGkeConfigV2PrivateClusterConfigResult',
                 project_id: _builtins.str,
                 region: _builtins.str,
                 subnetwork: _builtins.str,
                 zone: _builtins.str,
                 imported: Optional[_builtins.bool] = None):
        """
        :param 'GetClusterGkeConfigV2ClusterAddonsArgs' cluster_addons: The GKE cluster addons
        :param _builtins.str cluster_ipv4_cidr_block: The GKE ip v4 cidr block
        :param _builtins.str description: (Computed) The description for Cluster (string)
        :param _builtins.bool enable_kubernetes_alpha: Enable Kubernetes alpha
        :param _builtins.str google_credential_secret: Google credential secret
        :param 'GetClusterGkeConfigV2IpAllocationPolicyArgs' ip_allocation_policy: The GKE ip allocation policy
        :param _builtins.str kubernetes_version: The kubernetes master version
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for Node Pool object (map)
        :param Sequence[_builtins.str] locations: The GKE cluster locations
        :param _builtins.str logging_service: The GKE cluster logging service
        :param _builtins.str maintenance_window: The GKE cluster maintenance window
        :param 'GetClusterGkeConfigV2MasterAuthorizedNetworksConfigArgs' master_authorized_networks_config: The GKE cluster master authorized networks config
        :param _builtins.str monitoring_service: The GKE cluster monitoring service
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str network: The GKE cluster network
        :param _builtins.bool network_policy_enabled: Is GKE cluster network policy enabled?
        :param Sequence['GetClusterGkeConfigV2NodePoolArgs'] node_pools: The GKE cluster node pools
        :param 'GetClusterGkeConfigV2PrivateClusterConfigArgs' private_cluster_config: The GKE private cluster config
        :param _builtins.str project_id: The GKE project id
        :param _builtins.str region: The GKE cluster region. Required if `zone` is empty
        :param _builtins.str subnetwork: The GKE cluster subnetwork
        :param _builtins.str zone: The GKE cluster zone. Required if `region` is empty
        :param _builtins.bool imported: Is GKE cluster imported?
        """
        pulumi.set(__self__, "cluster_addons", cluster_addons)
        pulumi.set(__self__, "cluster_ipv4_cidr_block", cluster_ipv4_cidr_block)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enable_kubernetes_alpha", enable_kubernetes_alpha)
        pulumi.set(__self__, "google_credential_secret", google_credential_secret)
        pulumi.set(__self__, "ip_allocation_policy", ip_allocation_policy)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "locations", locations)
        pulumi.set(__self__, "logging_service", logging_service)
        pulumi.set(__self__, "maintenance_window", maintenance_window)
        pulumi.set(__self__, "master_authorized_networks_config", master_authorized_networks_config)
        pulumi.set(__self__, "monitoring_service", monitoring_service)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "network_policy_enabled", network_policy_enabled)
        pulumi.set(__self__, "node_pools", node_pools)
        pulumi.set(__self__, "private_cluster_config", private_cluster_config)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "subnetwork", subnetwork)
        pulumi.set(__self__, "zone", zone)
        if imported is not None:
            pulumi.set(__self__, "imported", imported)

    @_builtins.property
    @pulumi.getter(name="clusterAddons")
    def cluster_addons(self) -> 'outputs.GetClusterGkeConfigV2ClusterAddonsResult':
        """
        The GKE cluster addons
        """
        return pulumi.get(self, "cluster_addons")

    @_builtins.property
    @pulumi.getter(name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> _builtins.str:
        """
        The GKE ip v4 cidr block
        """
        return pulumi.get(self, "cluster_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        (Computed) The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enableKubernetesAlpha")
    def enable_kubernetes_alpha(self) -> _builtins.bool:
        """
        Enable Kubernetes alpha
        """
        return pulumi.get(self, "enable_kubernetes_alpha")

    @_builtins.property
    @pulumi.getter(name="googleCredentialSecret")
    def google_credential_secret(self) -> _builtins.str:
        """
        Google credential secret
        """
        return pulumi.get(self, "google_credential_secret")

    @_builtins.property
    @pulumi.getter(name="ipAllocationPolicy")
    def ip_allocation_policy(self) -> 'outputs.GetClusterGkeConfigV2IpAllocationPolicyResult':
        """
        The GKE ip allocation policy
        """
        return pulumi.get(self, "ip_allocation_policy")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        The kubernetes master version
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Labels for Node Pool object (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Sequence[_builtins.str]:
        """
        The GKE cluster locations
        """
        return pulumi.get(self, "locations")

    @_builtins.property
    @pulumi.getter(name="loggingService")
    def logging_service(self) -> _builtins.str:
        """
        The GKE cluster logging service
        """
        return pulumi.get(self, "logging_service")

    @_builtins.property
    @pulumi.getter(name="maintenanceWindow")
    def maintenance_window(self) -> _builtins.str:
        """
        The GKE cluster maintenance window
        """
        return pulumi.get(self, "maintenance_window")

    @_builtins.property
    @pulumi.getter(name="masterAuthorizedNetworksConfig")
    def master_authorized_networks_config(self) -> 'outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfigResult':
        """
        The GKE cluster master authorized networks config
        """
        return pulumi.get(self, "master_authorized_networks_config")

    @_builtins.property
    @pulumi.getter(name="monitoringService")
    def monitoring_service(self) -> _builtins.str:
        """
        The GKE cluster monitoring service
        """
        return pulumi.get(self, "monitoring_service")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The GKE cluster network
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="networkPolicyEnabled")
    def network_policy_enabled(self) -> _builtins.bool:
        """
        Is GKE cluster network policy enabled?
        """
        return pulumi.get(self, "network_policy_enabled")

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Sequence['outputs.GetClusterGkeConfigV2NodePoolResult']:
        """
        The GKE cluster node pools
        """
        return pulumi.get(self, "node_pools")

    @_builtins.property
    @pulumi.getter(name="privateClusterConfig")
    def private_cluster_config(self) -> 'outputs.GetClusterGkeConfigV2PrivateClusterConfigResult':
        """
        The GKE private cluster config
        """
        return pulumi.get(self, "private_cluster_config")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        The GKE project id
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The GKE cluster region. Required if `zone` is empty
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def subnetwork(self) -> _builtins.str:
        """
        The GKE cluster subnetwork
        """
        return pulumi.get(self, "subnetwork")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        """
        The GKE cluster zone. Required if `region` is empty
        """
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter
    def imported(self) -> Optional[_builtins.bool]:
        """
        Is GKE cluster imported?
        """
        return pulumi.get(self, "imported")


@pulumi.output_type
class GetClusterGkeConfigV2ClusterAddonsResult(dict):
    def __init__(__self__, *,
                 horizontal_pod_autoscaling: _builtins.bool,
                 http_load_balancing: _builtins.bool,
                 network_policy_config: _builtins.bool):
        """
        :param _builtins.bool horizontal_pod_autoscaling: Enable GKE horizontal pod autoscaling
        :param _builtins.bool http_load_balancing: Enable GKE HTTP load balancing
        :param _builtins.bool network_policy_config: Enable GKE network policy config
        """
        pulumi.set(__self__, "horizontal_pod_autoscaling", horizontal_pod_autoscaling)
        pulumi.set(__self__, "http_load_balancing", http_load_balancing)
        pulumi.set(__self__, "network_policy_config", network_policy_config)

    @_builtins.property
    @pulumi.getter(name="horizontalPodAutoscaling")
    def horizontal_pod_autoscaling(self) -> _builtins.bool:
        """
        Enable GKE horizontal pod autoscaling
        """
        return pulumi.get(self, "horizontal_pod_autoscaling")

    @_builtins.property
    @pulumi.getter(name="httpLoadBalancing")
    def http_load_balancing(self) -> _builtins.bool:
        """
        Enable GKE HTTP load balancing
        """
        return pulumi.get(self, "http_load_balancing")

    @_builtins.property
    @pulumi.getter(name="networkPolicyConfig")
    def network_policy_config(self) -> _builtins.bool:
        """
        Enable GKE network policy config
        """
        return pulumi.get(self, "network_policy_config")


@pulumi.output_type
class GetClusterGkeConfigV2IpAllocationPolicyResult(dict):
    def __init__(__self__, *,
                 cluster_ipv4_cidr_block: _builtins.str,
                 cluster_secondary_range_name: _builtins.str,
                 create_subnetwork: _builtins.bool,
                 node_ipv4_cidr_block: _builtins.str,
                 services_ipv4_cidr_block: _builtins.str,
                 services_secondary_range_name: _builtins.str,
                 subnetwork_name: _builtins.str,
                 use_ip_aliases: _builtins.bool):
        """
        :param _builtins.str cluster_ipv4_cidr_block: The GKE cluster ip v4 allocation cidr block
        :param _builtins.str cluster_secondary_range_name: The GKE cluster ip v4 allocation secondary range name
        :param _builtins.bool create_subnetwork: Create GKE subnetwork?
        :param _builtins.str node_ipv4_cidr_block: The GKE node ip v4 allocation cidr block
        :param _builtins.str services_ipv4_cidr_block: The GKE services ip v4 allocation cidr block
        :param _builtins.str services_secondary_range_name: The GKE services ip v4 allocation secondary range name
        :param _builtins.str subnetwork_name: The GKE cluster subnetwork name
        :param _builtins.bool use_ip_aliases: Use GKE ip aliases?
        """
        pulumi.set(__self__, "cluster_ipv4_cidr_block", cluster_ipv4_cidr_block)
        pulumi.set(__self__, "cluster_secondary_range_name", cluster_secondary_range_name)
        pulumi.set(__self__, "create_subnetwork", create_subnetwork)
        pulumi.set(__self__, "node_ipv4_cidr_block", node_ipv4_cidr_block)
        pulumi.set(__self__, "services_ipv4_cidr_block", services_ipv4_cidr_block)
        pulumi.set(__self__, "services_secondary_range_name", services_secondary_range_name)
        pulumi.set(__self__, "subnetwork_name", subnetwork_name)
        pulumi.set(__self__, "use_ip_aliases", use_ip_aliases)

    @_builtins.property
    @pulumi.getter(name="clusterIpv4CidrBlock")
    def cluster_ipv4_cidr_block(self) -> _builtins.str:
        """
        The GKE cluster ip v4 allocation cidr block
        """
        return pulumi.get(self, "cluster_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="clusterSecondaryRangeName")
    def cluster_secondary_range_name(self) -> _builtins.str:
        """
        The GKE cluster ip v4 allocation secondary range name
        """
        return pulumi.get(self, "cluster_secondary_range_name")

    @_builtins.property
    @pulumi.getter(name="createSubnetwork")
    def create_subnetwork(self) -> _builtins.bool:
        """
        Create GKE subnetwork?
        """
        return pulumi.get(self, "create_subnetwork")

    @_builtins.property
    @pulumi.getter(name="nodeIpv4CidrBlock")
    def node_ipv4_cidr_block(self) -> _builtins.str:
        """
        The GKE node ip v4 allocation cidr block
        """
        return pulumi.get(self, "node_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="servicesIpv4CidrBlock")
    def services_ipv4_cidr_block(self) -> _builtins.str:
        """
        The GKE services ip v4 allocation cidr block
        """
        return pulumi.get(self, "services_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="servicesSecondaryRangeName")
    def services_secondary_range_name(self) -> _builtins.str:
        """
        The GKE services ip v4 allocation secondary range name
        """
        return pulumi.get(self, "services_secondary_range_name")

    @_builtins.property
    @pulumi.getter(name="subnetworkName")
    def subnetwork_name(self) -> _builtins.str:
        """
        The GKE cluster subnetwork name
        """
        return pulumi.get(self, "subnetwork_name")

    @_builtins.property
    @pulumi.getter(name="useIpAliases")
    def use_ip_aliases(self) -> _builtins.bool:
        """
        Use GKE ip aliases?
        """
        return pulumi.get(self, "use_ip_aliases")


@pulumi.output_type
class GetClusterGkeConfigV2MasterAuthorizedNetworksConfigResult(dict):
    def __init__(__self__, *,
                 cidr_blocks: Sequence['outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockResult'],
                 enabled: Optional[_builtins.bool] = None):
        """
        :param Sequence['GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockArgs'] cidr_blocks: The GKE master authorized network config cidr blocks
        :param _builtins.bool enabled: Enable GKE master authorized network config
        """
        pulumi.set(__self__, "cidr_blocks", cidr_blocks)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="cidrBlocks")
    def cidr_blocks(self) -> Sequence['outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockResult']:
        """
        The GKE master authorized network config cidr blocks
        """
        return pulumi.get(self, "cidr_blocks")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable GKE master authorized network config
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlockResult(dict):
    def __init__(__self__, *,
                 cidr_block: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr_block: The GKE master authorized network config cidr block
        :param _builtins.str display_name: The GKE master authorized network config cidr block dispaly name
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> _builtins.str:
        """
        The GKE master authorized network config cidr block
        """
        return pulumi.get(self, "cidr_block")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The GKE master authorized network config cidr block dispaly name
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class GetClusterGkeConfigV2NodePoolResult(dict):
    def __init__(__self__, *,
                 autoscaling: 'outputs.GetClusterGkeConfigV2NodePoolAutoscalingResult',
                 config: 'outputs.GetClusterGkeConfigV2NodePoolConfigResult',
                 initial_node_count: _builtins.int,
                 management: 'outputs.GetClusterGkeConfigV2NodePoolManagementResult',
                 max_pods_constraint: _builtins.int,
                 name: _builtins.str,
                 version: _builtins.str):
        """
        :param 'GetClusterGkeConfigV2NodePoolAutoscalingArgs' autoscaling: The GKE node pool config autoscaling
        :param 'GetClusterGkeConfigV2NodePoolConfigArgs' config: The GKE node pool node config
        :param _builtins.int initial_node_count: The GKE node pool config initial node count
        :param 'GetClusterGkeConfigV2NodePoolManagementArgs' management: The GKE node pool config management
        :param _builtins.int max_pods_constraint: The GKE node pool config max pods constraint
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str version: The GKE node pool config version
        """
        pulumi.set(__self__, "autoscaling", autoscaling)
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "initial_node_count", initial_node_count)
        pulumi.set(__self__, "management", management)
        pulumi.set(__self__, "max_pods_constraint", max_pods_constraint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> 'outputs.GetClusterGkeConfigV2NodePoolAutoscalingResult':
        """
        The GKE node pool config autoscaling
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def config(self) -> 'outputs.GetClusterGkeConfigV2NodePoolConfigResult':
        """
        The GKE node pool node config
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="initialNodeCount")
    def initial_node_count(self) -> _builtins.int:
        """
        The GKE node pool config initial node count
        """
        return pulumi.get(self, "initial_node_count")

    @_builtins.property
    @pulumi.getter
    def management(self) -> 'outputs.GetClusterGkeConfigV2NodePoolManagementResult':
        """
        The GKE node pool config management
        """
        return pulumi.get(self, "management")

    @_builtins.property
    @pulumi.getter(name="maxPodsConstraint")
    def max_pods_constraint(self) -> _builtins.int:
        """
        The GKE node pool config max pods constraint
        """
        return pulumi.get(self, "max_pods_constraint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The GKE node pool config version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterGkeConfigV2NodePoolAutoscalingResult(dict):
    def __init__(__self__, *,
                 max_node_count: _builtins.int,
                 min_node_count: _builtins.int,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.int max_node_count: The GKE node pool config max node count
        :param _builtins.int min_node_count: The GKE node pool config min node count
        :param _builtins.bool enabled: Enable GKE node pool config autoscaling
        """
        pulumi.set(__self__, "max_node_count", max_node_count)
        pulumi.set(__self__, "min_node_count", min_node_count)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> _builtins.int:
        """
        The GKE node pool config max node count
        """
        return pulumi.get(self, "max_node_count")

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> _builtins.int:
        """
        The GKE node pool config min node count
        """
        return pulumi.get(self, "min_node_count")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable GKE node pool config autoscaling
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterGkeConfigV2NodePoolConfigResult(dict):
    def __init__(__self__, *,
                 labels: Mapping[str, _builtins.str],
                 oauth_scopes: Sequence[_builtins.str],
                 tags: Sequence[_builtins.str],
                 disk_size_gb: Optional[_builtins.int] = None,
                 disk_type: Optional[_builtins.str] = None,
                 image_type: Optional[_builtins.str] = None,
                 local_ssd_count: Optional[_builtins.int] = None,
                 machine_type: Optional[_builtins.str] = None,
                 preemptible: Optional[_builtins.bool] = None,
                 service_account: Optional[_builtins.str] = None,
                 taints: Optional[Sequence['outputs.GetClusterGkeConfigV2NodePoolConfigTaintResult']] = None):
        """
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for Node Pool object (map)
        :param Sequence[_builtins.str] oauth_scopes: The GKE node config oauth scopes
        :param Sequence[_builtins.str] tags: The GKE node config tags
        :param _builtins.int disk_size_gb: The GKE node config disk size (Gb)
        :param _builtins.str disk_type: The GKE node config disk type
        :param _builtins.str image_type: The GKE node config image type
        :param _builtins.int local_ssd_count: The GKE node config local ssd count
        :param _builtins.str machine_type: The GKE node config machine type
        :param _builtins.bool preemptible: Enable GKE node config preemptible
        :param _builtins.str service_account: The GKE node config service account
        :param Sequence['GetClusterGkeConfigV2NodePoolConfigTaintArgs'] taints: The GKE node config taints
        """
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "oauth_scopes", oauth_scopes)
        pulumi.set(__self__, "tags", tags)
        if disk_size_gb is not None:
            pulumi.set(__self__, "disk_size_gb", disk_size_gb)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)
        if local_ssd_count is not None:
            pulumi.set(__self__, "local_ssd_count", local_ssd_count)
        if machine_type is not None:
            pulumi.set(__self__, "machine_type", machine_type)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Labels for Node Pool object (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="oauthScopes")
    def oauth_scopes(self) -> Sequence[_builtins.str]:
        """
        The GKE node config oauth scopes
        """
        return pulumi.get(self, "oauth_scopes")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        The GKE node config tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="diskSizeGb")
    def disk_size_gb(self) -> Optional[_builtins.int]:
        """
        The GKE node config disk size (Gb)
        """
        return pulumi.get(self, "disk_size_gb")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        The GKE node config disk type
        """
        return pulumi.get(self, "disk_type")

    @_builtins.property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[_builtins.str]:
        """
        The GKE node config image type
        """
        return pulumi.get(self, "image_type")

    @_builtins.property
    @pulumi.getter(name="localSsdCount")
    def local_ssd_count(self) -> Optional[_builtins.int]:
        """
        The GKE node config local ssd count
        """
        return pulumi.get(self, "local_ssd_count")

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> Optional[_builtins.str]:
        """
        The GKE node config machine type
        """
        return pulumi.get(self, "machine_type")

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[_builtins.bool]:
        """
        Enable GKE node config preemptible
        """
        return pulumi.get(self, "preemptible")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        The GKE node config service account
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.GetClusterGkeConfigV2NodePoolConfigTaintResult']]:
        """
        The GKE node config taints
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetClusterGkeConfigV2NodePoolConfigTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterGkeConfigV2NodePoolManagementResult(dict):
    def __init__(__self__, *,
                 auto_repair: _builtins.bool,
                 auto_upgrade: _builtins.bool):
        """
        :param _builtins.bool auto_repair: Enable GKE node pool config management auto repair
        :param _builtins.bool auto_upgrade: Enable GKE node pool config management auto upgrade
        """
        pulumi.set(__self__, "auto_repair", auto_repair)
        pulumi.set(__self__, "auto_upgrade", auto_upgrade)

    @_builtins.property
    @pulumi.getter(name="autoRepair")
    def auto_repair(self) -> _builtins.bool:
        """
        Enable GKE node pool config management auto repair
        """
        return pulumi.get(self, "auto_repair")

    @_builtins.property
    @pulumi.getter(name="autoUpgrade")
    def auto_upgrade(self) -> _builtins.bool:
        """
        Enable GKE node pool config management auto upgrade
        """
        return pulumi.get(self, "auto_upgrade")


@pulumi.output_type
class GetClusterGkeConfigV2PrivateClusterConfigResult(dict):
    def __init__(__self__, *,
                 master_ipv4_cidr_block: _builtins.str,
                 enable_private_endpoint: Optional[_builtins.bool] = None,
                 enable_private_nodes: Optional[_builtins.bool] = None):
        """
        :param _builtins.str master_ipv4_cidr_block: The GKE cluster private master ip v4 cidr block
        :param _builtins.bool enable_private_endpoint: Enable GKE cluster private endpoint
        :param _builtins.bool enable_private_nodes: Enable GKE cluster private nodes
        """
        pulumi.set(__self__, "master_ipv4_cidr_block", master_ipv4_cidr_block)
        if enable_private_endpoint is not None:
            pulumi.set(__self__, "enable_private_endpoint", enable_private_endpoint)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)

    @_builtins.property
    @pulumi.getter(name="masterIpv4CidrBlock")
    def master_ipv4_cidr_block(self) -> _builtins.str:
        """
        The GKE cluster private master ip v4 cidr block
        """
        return pulumi.get(self, "master_ipv4_cidr_block")

    @_builtins.property
    @pulumi.getter(name="enablePrivateEndpoint")
    def enable_private_endpoint(self) -> Optional[_builtins.bool]:
        """
        Enable GKE cluster private endpoint
        """
        return pulumi.get(self, "enable_private_endpoint")

    @_builtins.property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[_builtins.bool]:
        """
        Enable GKE cluster private nodes
        """
        return pulumi.get(self, "enable_private_nodes")


@pulumi.output_type
class GetClusterImportedConfigResult(dict):
    def __init__(__self__, *,
                 private_registry_url: _builtins.str):
        """
        :param _builtins.str private_registry_url: Private registry URL
        """
        pulumi.set(__self__, "private_registry_url", private_registry_url)

    @_builtins.property
    @pulumi.getter(name="privateRegistryUrl")
    def private_registry_url(self) -> _builtins.str:
        """
        Private registry URL
        """
        return pulumi.get(self, "private_registry_url")


@pulumi.output_type
class GetClusterK3sConfigResult(dict):
    def __init__(__self__, *,
                 upgrade_strategy: 'outputs.GetClusterK3sConfigUpgradeStrategyResult',
                 version: _builtins.str):
        """
        :param 'GetClusterK3sConfigUpgradeStrategyArgs' upgrade_strategy: The K3S upgrade strategy
        :param _builtins.str version: The K3S kubernetes version
        """
        pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> 'outputs.GetClusterK3sConfigUpgradeStrategyResult':
        """
        The K3S upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The K3S kubernetes version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterK3sConfigUpgradeStrategyResult(dict):
    def __init__(__self__, *,
                 drain_server_nodes: Optional[_builtins.bool] = None,
                 drain_worker_nodes: Optional[_builtins.bool] = None,
                 server_concurrency: Optional[_builtins.int] = None,
                 worker_concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.bool drain_server_nodes: Drain server nodes
        :param _builtins.bool drain_worker_nodes: Drain worker nodes
        :param _builtins.int server_concurrency: Server concurrency
        :param _builtins.int worker_concurrency: Worker concurrency
        """
        if drain_server_nodes is not None:
            pulumi.set(__self__, "drain_server_nodes", drain_server_nodes)
        if drain_worker_nodes is not None:
            pulumi.set(__self__, "drain_worker_nodes", drain_worker_nodes)
        if server_concurrency is not None:
            pulumi.set(__self__, "server_concurrency", server_concurrency)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)

    @_builtins.property
    @pulumi.getter(name="drainServerNodes")
    def drain_server_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain server nodes
        """
        return pulumi.get(self, "drain_server_nodes")

    @_builtins.property
    @pulumi.getter(name="drainWorkerNodes")
    def drain_worker_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain worker nodes
        """
        return pulumi.get(self, "drain_worker_nodes")

    @_builtins.property
    @pulumi.getter(name="serverConcurrency")
    def server_concurrency(self) -> Optional[_builtins.int]:
        """
        Server concurrency
        """
        return pulumi.get(self, "server_concurrency")

    @_builtins.property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[_builtins.int]:
        """
        Worker concurrency
        """
        return pulumi.get(self, "worker_concurrency")


@pulumi.output_type
class GetClusterOkeConfigResult(dict):
    def __init__(__self__, *,
                 compartment_id: _builtins.str,
                 kubernetes_version: _builtins.str,
                 node_image: _builtins.str,
                 node_shape: _builtins.str,
                 region: _builtins.str,
                 tenancy_id: _builtins.str,
                 cluster_type: Optional[_builtins.str] = None,
                 control_plane_subnet_name: Optional[_builtins.str] = None,
                 custom_boot_volume_size: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 enable_kubernetes_dashboard: Optional[_builtins.bool] = None,
                 enable_private_control_plane: Optional[_builtins.bool] = None,
                 enable_private_nodes: Optional[_builtins.bool] = None,
                 eviction_grace_duration: Optional[_builtins.str] = None,
                 fingerprint: Optional[_builtins.str] = None,
                 flex_memory_in_gbs: Optional[_builtins.int] = None,
                 flex_ocpus: Optional[_builtins.int] = None,
                 force_delete_after_grace_duration: Optional[_builtins.bool] = None,
                 image_verification_kms_key_id: Optional[_builtins.str] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 limit_node_count: Optional[_builtins.int] = None,
                 load_balancer_subnet_name1: Optional[_builtins.str] = None,
                 load_balancer_subnet_name2: Optional[_builtins.str] = None,
                 node_pool_dns_domain_name: Optional[_builtins.str] = None,
                 node_pool_subnet_name: Optional[_builtins.str] = None,
                 node_public_key_contents: Optional[_builtins.str] = None,
                 node_user_data_contents: Optional[_builtins.str] = None,
                 pod_cidr: Optional[_builtins.str] = None,
                 pod_network: Optional[_builtins.str] = None,
                 pod_subnet_name: Optional[_builtins.str] = None,
                 private_key_contents: Optional[_builtins.str] = None,
                 private_key_passphrase: Optional[_builtins.str] = None,
                 quantity_of_node_subnets: Optional[_builtins.int] = None,
                 quantity_per_subnet: Optional[_builtins.int] = None,
                 service_cidr: Optional[_builtins.str] = None,
                 service_dns_domain_name: Optional[_builtins.str] = None,
                 skip_vcn_delete: Optional[_builtins.bool] = None,
                 user_ocid: Optional[_builtins.str] = None,
                 vcn_compartment_id: Optional[_builtins.str] = None,
                 vcn_name: Optional[_builtins.str] = None,
                 worker_node_ingress_cidr: Optional[_builtins.str] = None):
        """
        :param _builtins.str compartment_id: The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        :param _builtins.str kubernetes_version: The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
        :param _builtins.str node_image: The OS for the node image
        :param _builtins.str node_shape: The shape of the node (determines number of CPUs and  amount of memory on each node)
        :param _builtins.str region: The availability domain within the region to host the OKE cluster
        :param _builtins.str tenancy_id: The OCID of the tenancy in which to create resources
        :param _builtins.str cluster_type: Optionally specify a cluster type of basic or enhanced
        :param _builtins.str control_plane_subnet_name: The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
        :param _builtins.int custom_boot_volume_size: An optional custom boot volume size (in GB) for the nodes
        :param _builtins.str description: (Computed) The description for Cluster (string)
        :param _builtins.bool enable_kubernetes_dashboard: Enable the kubernetes dashboard
        :param _builtins.bool enable_private_control_plane: Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        :param _builtins.bool enable_private_nodes: Whether worker nodes are deployed into a new private subnet
        :param _builtins.str eviction_grace_duration: The optional grace period in minutes to allow cordon and drain to complete successfuly
        :param _builtins.str fingerprint: The fingerprint corresponding to the specified user's private API Key
        :param _builtins.int flex_memory_in_gbs: Optional amount of memory in GB for nodes (requires flexible node_shape)
        :param _builtins.int flex_ocpus: Optional number of OCPUs for nodes (requires flexible node_shape)
        :param _builtins.bool force_delete_after_grace_duration: Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
        :param _builtins.str image_verification_kms_key_id: Optional specify a comma separated list of master encryption key OCID(s) to verify images
        :param _builtins.str kms_key_id: Optional specify the OCID of the KMS Vault master key
        :param _builtins.int limit_node_count: Optional limit on the total number of nodes in the pool
        :param _builtins.str load_balancer_subnet_name1: The name of the first existing subnet to use for Kubernetes services / LB
        :param _builtins.str load_balancer_subnet_name2: The (optional) name of a second existing subnet to use for Kubernetes services / LB
        :param _builtins.str node_pool_dns_domain_name: Optional name for DNS domain of node pool subnet
        :param _builtins.str node_pool_subnet_name: Optional pre-existing subnet (public or private) for nodes
        :param _builtins.str node_public_key_contents: The contents of the SSH public key file to use for the nodes
        :param _builtins.str node_user_data_contents: The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
        :param _builtins.str pod_cidr: Optional specify the pod CIDR, defaults to 10.244.0.0/16
        :param _builtins.str pod_network: Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
        :param _builtins.str pod_subnet_name: The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
        :param _builtins.str private_key_contents: The private API key file contents for the specified user, in PEM format
        :param _builtins.str private_key_passphrase: The passphrase of the private key for the OKE cluster
        :param _builtins.int quantity_of_node_subnets: Number of node subnets (defaults to creating 1 regional subnet)
        :param _builtins.int quantity_per_subnet: Number of worker nodes in each subnet / availability domain
        :param _builtins.str service_cidr: Optional specify the service CIDR, defaults to 10.96.0.0/16
        :param _builtins.str service_dns_domain_name: Optional name for DNS domain of service subnet
        :param _builtins.bool skip_vcn_delete: Whether to skip deleting VCN
        :param _builtins.str user_ocid: The OCID of a user who has access to the tenancy/compartment
        :param _builtins.str vcn_compartment_id: The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        :param _builtins.str vcn_name: The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        :param _builtins.str worker_node_ingress_cidr: Additional CIDR from which to allow ingress to worker nodes
        """
        pulumi.set(__self__, "compartment_id", compartment_id)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "node_image", node_image)
        pulumi.set(__self__, "node_shape", node_shape)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tenancy_id", tenancy_id)
        if cluster_type is not None:
            pulumi.set(__self__, "cluster_type", cluster_type)
        if control_plane_subnet_name is not None:
            pulumi.set(__self__, "control_plane_subnet_name", control_plane_subnet_name)
        if custom_boot_volume_size is not None:
            pulumi.set(__self__, "custom_boot_volume_size", custom_boot_volume_size)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enable_kubernetes_dashboard is not None:
            pulumi.set(__self__, "enable_kubernetes_dashboard", enable_kubernetes_dashboard)
        if enable_private_control_plane is not None:
            pulumi.set(__self__, "enable_private_control_plane", enable_private_control_plane)
        if enable_private_nodes is not None:
            pulumi.set(__self__, "enable_private_nodes", enable_private_nodes)
        if eviction_grace_duration is not None:
            pulumi.set(__self__, "eviction_grace_duration", eviction_grace_duration)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if flex_memory_in_gbs is not None:
            pulumi.set(__self__, "flex_memory_in_gbs", flex_memory_in_gbs)
        if flex_ocpus is not None:
            pulumi.set(__self__, "flex_ocpus", flex_ocpus)
        if force_delete_after_grace_duration is not None:
            pulumi.set(__self__, "force_delete_after_grace_duration", force_delete_after_grace_duration)
        if image_verification_kms_key_id is not None:
            pulumi.set(__self__, "image_verification_kms_key_id", image_verification_kms_key_id)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if limit_node_count is not None:
            pulumi.set(__self__, "limit_node_count", limit_node_count)
        if load_balancer_subnet_name1 is not None:
            pulumi.set(__self__, "load_balancer_subnet_name1", load_balancer_subnet_name1)
        if load_balancer_subnet_name2 is not None:
            pulumi.set(__self__, "load_balancer_subnet_name2", load_balancer_subnet_name2)
        if node_pool_dns_domain_name is not None:
            pulumi.set(__self__, "node_pool_dns_domain_name", node_pool_dns_domain_name)
        if node_pool_subnet_name is not None:
            pulumi.set(__self__, "node_pool_subnet_name", node_pool_subnet_name)
        if node_public_key_contents is not None:
            pulumi.set(__self__, "node_public_key_contents", node_public_key_contents)
        if node_user_data_contents is not None:
            pulumi.set(__self__, "node_user_data_contents", node_user_data_contents)
        if pod_cidr is not None:
            pulumi.set(__self__, "pod_cidr", pod_cidr)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if pod_subnet_name is not None:
            pulumi.set(__self__, "pod_subnet_name", pod_subnet_name)
        if private_key_contents is not None:
            pulumi.set(__self__, "private_key_contents", private_key_contents)
        if private_key_passphrase is not None:
            pulumi.set(__self__, "private_key_passphrase", private_key_passphrase)
        if quantity_of_node_subnets is not None:
            pulumi.set(__self__, "quantity_of_node_subnets", quantity_of_node_subnets)
        if quantity_per_subnet is not None:
            pulumi.set(__self__, "quantity_per_subnet", quantity_per_subnet)
        if service_cidr is not None:
            pulumi.set(__self__, "service_cidr", service_cidr)
        if service_dns_domain_name is not None:
            pulumi.set(__self__, "service_dns_domain_name", service_dns_domain_name)
        if skip_vcn_delete is not None:
            pulumi.set(__self__, "skip_vcn_delete", skip_vcn_delete)
        if user_ocid is not None:
            pulumi.set(__self__, "user_ocid", user_ocid)
        if vcn_compartment_id is not None:
            pulumi.set(__self__, "vcn_compartment_id", vcn_compartment_id)
        if vcn_name is not None:
            pulumi.set(__self__, "vcn_name", vcn_name)
        if worker_node_ingress_cidr is not None:
            pulumi.set(__self__, "worker_node_ingress_cidr", worker_node_ingress_cidr)

    @_builtins.property
    @pulumi.getter(name="compartmentId")
    def compartment_id(self) -> _builtins.str:
        """
        The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        """
        return pulumi.get(self, "compartment_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter(name="nodeImage")
    def node_image(self) -> _builtins.str:
        """
        The OS for the node image
        """
        return pulumi.get(self, "node_image")

    @_builtins.property
    @pulumi.getter(name="nodeShape")
    def node_shape(self) -> _builtins.str:
        """
        The shape of the node (determines number of CPUs and  amount of memory on each node)
        """
        return pulumi.get(self, "node_shape")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The availability domain within the region to host the OKE cluster
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tenancyId")
    def tenancy_id(self) -> _builtins.str:
        """
        The OCID of the tenancy in which to create resources
        """
        return pulumi.get(self, "tenancy_id")

    @_builtins.property
    @pulumi.getter(name="clusterType")
    def cluster_type(self) -> Optional[_builtins.str]:
        """
        Optionally specify a cluster type of basic or enhanced
        """
        return pulumi.get(self, "cluster_type")

    @_builtins.property
    @pulumi.getter(name="controlPlaneSubnetName")
    def control_plane_subnet_name(self) -> Optional[_builtins.str]:
        """
        The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
        """
        return pulumi.get(self, "control_plane_subnet_name")

    @_builtins.property
    @pulumi.getter(name="customBootVolumeSize")
    def custom_boot_volume_size(self) -> Optional[_builtins.int]:
        """
        An optional custom boot volume size (in GB) for the nodes
        """
        return pulumi.get(self, "custom_boot_volume_size")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (Computed) The description for Cluster (string)
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enableKubernetesDashboard")
    def enable_kubernetes_dashboard(self) -> Optional[_builtins.bool]:
        """
        Enable the kubernetes dashboard
        """
        return pulumi.get(self, "enable_kubernetes_dashboard")

    @_builtins.property
    @pulumi.getter(name="enablePrivateControlPlane")
    def enable_private_control_plane(self) -> Optional[_builtins.bool]:
        """
        Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        """
        return pulumi.get(self, "enable_private_control_plane")

    @_builtins.property
    @pulumi.getter(name="enablePrivateNodes")
    def enable_private_nodes(self) -> Optional[_builtins.bool]:
        """
        Whether worker nodes are deployed into a new private subnet
        """
        return pulumi.get(self, "enable_private_nodes")

    @_builtins.property
    @pulumi.getter(name="evictionGraceDuration")
    def eviction_grace_duration(self) -> Optional[_builtins.str]:
        """
        The optional grace period in minutes to allow cordon and drain to complete successfuly
        """
        return pulumi.get(self, "eviction_grace_duration")

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[_builtins.str]:
        """
        The fingerprint corresponding to the specified user's private API Key
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter(name="flexMemoryInGbs")
    def flex_memory_in_gbs(self) -> Optional[_builtins.int]:
        """
        Optional amount of memory in GB for nodes (requires flexible node_shape)
        """
        return pulumi.get(self, "flex_memory_in_gbs")

    @_builtins.property
    @pulumi.getter(name="flexOcpus")
    def flex_ocpus(self) -> Optional[_builtins.int]:
        """
        Optional number of OCPUs for nodes (requires flexible node_shape)
        """
        return pulumi.get(self, "flex_ocpus")

    @_builtins.property
    @pulumi.getter(name="forceDeleteAfterGraceDuration")
    def force_delete_after_grace_duration(self) -> Optional[_builtins.bool]:
        """
        Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
        """
        return pulumi.get(self, "force_delete_after_grace_duration")

    @_builtins.property
    @pulumi.getter(name="imageVerificationKmsKeyId")
    def image_verification_kms_key_id(self) -> Optional[_builtins.str]:
        """
        Optional specify a comma separated list of master encryption key OCID(s) to verify images
        """
        return pulumi.get(self, "image_verification_kms_key_id")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Optional specify the OCID of the KMS Vault master key
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="limitNodeCount")
    def limit_node_count(self) -> Optional[_builtins.int]:
        """
        Optional limit on the total number of nodes in the pool
        """
        return pulumi.get(self, "limit_node_count")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSubnetName1")
    def load_balancer_subnet_name1(self) -> Optional[_builtins.str]:
        """
        The name of the first existing subnet to use for Kubernetes services / LB
        """
        return pulumi.get(self, "load_balancer_subnet_name1")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSubnetName2")
    def load_balancer_subnet_name2(self) -> Optional[_builtins.str]:
        """
        The (optional) name of a second existing subnet to use for Kubernetes services / LB
        """
        return pulumi.get(self, "load_balancer_subnet_name2")

    @_builtins.property
    @pulumi.getter(name="nodePoolDnsDomainName")
    def node_pool_dns_domain_name(self) -> Optional[_builtins.str]:
        """
        Optional name for DNS domain of node pool subnet
        """
        return pulumi.get(self, "node_pool_dns_domain_name")

    @_builtins.property
    @pulumi.getter(name="nodePoolSubnetName")
    def node_pool_subnet_name(self) -> Optional[_builtins.str]:
        """
        Optional pre-existing subnet (public or private) for nodes
        """
        return pulumi.get(self, "node_pool_subnet_name")

    @_builtins.property
    @pulumi.getter(name="nodePublicKeyContents")
    def node_public_key_contents(self) -> Optional[_builtins.str]:
        """
        The contents of the SSH public key file to use for the nodes
        """
        return pulumi.get(self, "node_public_key_contents")

    @_builtins.property
    @pulumi.getter(name="nodeUserDataContents")
    def node_user_data_contents(self) -> Optional[_builtins.str]:
        """
        The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
        """
        return pulumi.get(self, "node_user_data_contents")

    @_builtins.property
    @pulumi.getter(name="podCidr")
    def pod_cidr(self) -> Optional[_builtins.str]:
        """
        Optional specify the pod CIDR, defaults to 10.244.0.0/16
        """
        return pulumi.get(self, "pod_cidr")

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[_builtins.str]:
        """
        Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
        """
        return pulumi.get(self, "pod_network")

    @_builtins.property
    @pulumi.getter(name="podSubnetName")
    def pod_subnet_name(self) -> Optional[_builtins.str]:
        """
        The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
        """
        return pulumi.get(self, "pod_subnet_name")

    @_builtins.property
    @pulumi.getter(name="privateKeyContents")
    def private_key_contents(self) -> Optional[_builtins.str]:
        """
        The private API key file contents for the specified user, in PEM format
        """
        return pulumi.get(self, "private_key_contents")

    @_builtins.property
    @pulumi.getter(name="privateKeyPassphrase")
    def private_key_passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase of the private key for the OKE cluster
        """
        return pulumi.get(self, "private_key_passphrase")

    @_builtins.property
    @pulumi.getter(name="quantityOfNodeSubnets")
    def quantity_of_node_subnets(self) -> Optional[_builtins.int]:
        """
        Number of node subnets (defaults to creating 1 regional subnet)
        """
        return pulumi.get(self, "quantity_of_node_subnets")

    @_builtins.property
    @pulumi.getter(name="quantityPerSubnet")
    def quantity_per_subnet(self) -> Optional[_builtins.int]:
        """
        Number of worker nodes in each subnet / availability domain
        """
        return pulumi.get(self, "quantity_per_subnet")

    @_builtins.property
    @pulumi.getter(name="serviceCidr")
    def service_cidr(self) -> Optional[_builtins.str]:
        """
        Optional specify the service CIDR, defaults to 10.96.0.0/16
        """
        return pulumi.get(self, "service_cidr")

    @_builtins.property
    @pulumi.getter(name="serviceDnsDomainName")
    def service_dns_domain_name(self) -> Optional[_builtins.str]:
        """
        Optional name for DNS domain of service subnet
        """
        return pulumi.get(self, "service_dns_domain_name")

    @_builtins.property
    @pulumi.getter(name="skipVcnDelete")
    def skip_vcn_delete(self) -> Optional[_builtins.bool]:
        """
        Whether to skip deleting VCN
        """
        return pulumi.get(self, "skip_vcn_delete")

    @_builtins.property
    @pulumi.getter(name="userOcid")
    def user_ocid(self) -> Optional[_builtins.str]:
        """
        The OCID of a user who has access to the tenancy/compartment
        """
        return pulumi.get(self, "user_ocid")

    @_builtins.property
    @pulumi.getter(name="vcnCompartmentId")
    def vcn_compartment_id(self) -> Optional[_builtins.str]:
        """
        The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        """
        return pulumi.get(self, "vcn_compartment_id")

    @_builtins.property
    @pulumi.getter(name="vcnName")
    def vcn_name(self) -> Optional[_builtins.str]:
        """
        The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        """
        return pulumi.get(self, "vcn_name")

    @_builtins.property
    @pulumi.getter(name="workerNodeIngressCidr")
    def worker_node_ingress_cidr(self) -> Optional[_builtins.str]:
        """
        Additional CIDR from which to allow ingress to worker nodes
        """
        return pulumi.get(self, "worker_node_ingress_cidr")


@pulumi.output_type
class GetClusterRke2ConfigResult(dict):
    def __init__(__self__, *,
                 upgrade_strategy: 'outputs.GetClusterRke2ConfigUpgradeStrategyResult',
                 version: _builtins.str):
        """
        :param 'GetClusterRke2ConfigUpgradeStrategyArgs' upgrade_strategy: The RKE2 upgrade strategy
        :param _builtins.str version: The RKE2 kubernetes version
        """
        pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> 'outputs.GetClusterRke2ConfigUpgradeStrategyResult':
        """
        The RKE2 upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The RKE2 kubernetes version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetClusterRke2ConfigUpgradeStrategyResult(dict):
    def __init__(__self__, *,
                 drain_server_nodes: Optional[_builtins.bool] = None,
                 drain_worker_nodes: Optional[_builtins.bool] = None,
                 server_concurrency: Optional[_builtins.int] = None,
                 worker_concurrency: Optional[_builtins.int] = None):
        """
        :param _builtins.bool drain_server_nodes: Drain server nodes
        :param _builtins.bool drain_worker_nodes: Drain worker nodes
        :param _builtins.int server_concurrency: Server concurrency
        :param _builtins.int worker_concurrency: Worker concurrency
        """
        if drain_server_nodes is not None:
            pulumi.set(__self__, "drain_server_nodes", drain_server_nodes)
        if drain_worker_nodes is not None:
            pulumi.set(__self__, "drain_worker_nodes", drain_worker_nodes)
        if server_concurrency is not None:
            pulumi.set(__self__, "server_concurrency", server_concurrency)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)

    @_builtins.property
    @pulumi.getter(name="drainServerNodes")
    def drain_server_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain server nodes
        """
        return pulumi.get(self, "drain_server_nodes")

    @_builtins.property
    @pulumi.getter(name="drainWorkerNodes")
    def drain_worker_nodes(self) -> Optional[_builtins.bool]:
        """
        Drain worker nodes
        """
        return pulumi.get(self, "drain_worker_nodes")

    @_builtins.property
    @pulumi.getter(name="serverConcurrency")
    def server_concurrency(self) -> Optional[_builtins.int]:
        """
        Server concurrency
        """
        return pulumi.get(self, "server_concurrency")

    @_builtins.property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[_builtins.int]:
        """
        Worker concurrency
        """
        return pulumi.get(self, "worker_concurrency")


@pulumi.output_type
class GetClusterRkeConfigResult(dict):
    def __init__(__self__, *,
                 addon_job_timeout: _builtins.int,
                 authentication: 'outputs.GetClusterRkeConfigAuthenticationResult',
                 authorization: 'outputs.GetClusterRkeConfigAuthorizationResult',
                 bastion_host: 'outputs.GetClusterRkeConfigBastionHostResult',
                 cloud_provider: 'outputs.GetClusterRkeConfigCloudProviderResult',
                 dns: 'outputs.GetClusterRkeConfigDnsResult',
                 ingress: 'outputs.GetClusterRkeConfigIngressResult',
                 kubernetes_version: _builtins.str,
                 monitoring: 'outputs.GetClusterRkeConfigMonitoringResult',
                 network: 'outputs.GetClusterRkeConfigNetworkResult',
                 prefix_path: _builtins.str,
                 services: 'outputs.GetClusterRkeConfigServicesResult',
                 ssh_cert_path: _builtins.str,
                 ssh_key_path: _builtins.str,
                 upgrade_strategy: 'outputs.GetClusterRkeConfigUpgradeStrategyResult',
                 win_prefix_path: _builtins.str,
                 addons: Optional[_builtins.str] = None,
                 addons_includes: Optional[Sequence[_builtins.str]] = None,
                 enable_cri_dockerd: Optional[_builtins.bool] = None,
                 ignore_docker_version: Optional[_builtins.bool] = None,
                 nodes: Optional[Sequence['outputs.GetClusterRkeConfigNodeResult']] = None,
                 private_registries: Optional[Sequence['outputs.GetClusterRkeConfigPrivateRegistryResult']] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None):
        """
        :param _builtins.int addon_job_timeout: Optional duration in seconds of addon job.
        :param 'GetClusterRkeConfigAuthenticationArgs' authentication: Kubernetes cluster authentication
        :param 'GetClusterRkeConfigAuthorizationArgs' authorization: Kubernetes cluster authorization
        :param 'GetClusterRkeConfigBastionHostArgs' bastion_host: RKE bastion host
        :param 'GetClusterRkeConfigIngressArgs' ingress: Kubernetes ingress configuration
        :param _builtins.str kubernetes_version: Optional kubernetes version to deploy
        :param 'GetClusterRkeConfigMonitoringArgs' monitoring: Kubernetes cluster monitoring
        :param 'GetClusterRkeConfigNetworkArgs' network: Kubernetes cluster networking
        :param _builtins.str prefix_path: Optional prefix to customize kubernetes path
        :param 'GetClusterRkeConfigServicesArgs' services: Kubernetes cluster services
        :param _builtins.str ssh_cert_path: Optional cluster level SSH certificate path
        :param _builtins.str ssh_key_path: Optional cluster level SSH private key path
        :param 'GetClusterRkeConfigUpgradeStrategyArgs' upgrade_strategy: RKE upgrade strategy
        :param _builtins.str win_prefix_path: Optional prefix to customize kubernetes path for windows nodes
        :param _builtins.str addons: Optional addons descripton to deploy on rke cluster.
        :param Sequence[_builtins.str] addons_includes: Optional addons yaml manisfest to deploy on rke cluster.
        :param _builtins.bool enable_cri_dockerd: Enable/disable using cri-dockerd
        :param _builtins.bool ignore_docker_version: Optional ignore docker version on nodes
        :param Sequence['GetClusterRkeConfigNodeArgs'] nodes: Optional RKE cluster nodes
        :param Sequence['GetClusterRkeConfigPrivateRegistryArgs'] private_registries: Optional private registries for docker images
        :param _builtins.bool ssh_agent_auth: Optional use ssh agent auth
        """
        pulumi.set(__self__, "addon_job_timeout", addon_job_timeout)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "authorization", authorization)
        pulumi.set(__self__, "bastion_host", bastion_host)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ingress", ingress)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "monitoring", monitoring)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "prefix_path", prefix_path)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "ssh_cert_path", ssh_cert_path)
        pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        pulumi.set(__self__, "win_prefix_path", win_prefix_path)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if addons_includes is not None:
            pulumi.set(__self__, "addons_includes", addons_includes)
        if enable_cri_dockerd is not None:
            pulumi.set(__self__, "enable_cri_dockerd", enable_cri_dockerd)
        if ignore_docker_version is not None:
            pulumi.set(__self__, "ignore_docker_version", ignore_docker_version)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if private_registries is not None:
            pulumi.set(__self__, "private_registries", private_registries)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)

    @_builtins.property
    @pulumi.getter(name="addonJobTimeout")
    def addon_job_timeout(self) -> _builtins.int:
        """
        Optional duration in seconds of addon job.
        """
        return pulumi.get(self, "addon_job_timeout")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetClusterRkeConfigAuthenticationResult':
        """
        Kubernetes cluster authentication
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> 'outputs.GetClusterRkeConfigAuthorizationResult':
        """
        Kubernetes cluster authorization
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="bastionHost")
    def bastion_host(self) -> 'outputs.GetClusterRkeConfigBastionHostResult':
        """
        RKE bastion host
        """
        return pulumi.get(self, "bastion_host")

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> 'outputs.GetClusterRkeConfigCloudProviderResult':
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> 'outputs.GetClusterRkeConfigDnsResult':
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> 'outputs.GetClusterRkeConfigIngressResult':
        """
        Kubernetes ingress configuration
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        Optional kubernetes version to deploy
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> 'outputs.GetClusterRkeConfigMonitoringResult':
        """
        Kubernetes cluster monitoring
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def network(self) -> 'outputs.GetClusterRkeConfigNetworkResult':
        """
        Kubernetes cluster networking
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> _builtins.str:
        """
        Optional prefix to customize kubernetes path
        """
        return pulumi.get(self, "prefix_path")

    @_builtins.property
    @pulumi.getter
    def services(self) -> 'outputs.GetClusterRkeConfigServicesResult':
        """
        Kubernetes cluster services
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> _builtins.str:
        """
        Optional cluster level SSH certificate path
        """
        return pulumi.get(self, "ssh_cert_path")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> _builtins.str:
        """
        Optional cluster level SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> 'outputs.GetClusterRkeConfigUpgradeStrategyResult':
        """
        RKE upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter(name="winPrefixPath")
    def win_prefix_path(self) -> _builtins.str:
        """
        Optional prefix to customize kubernetes path for windows nodes
        """
        return pulumi.get(self, "win_prefix_path")

    @_builtins.property
    @pulumi.getter
    def addons(self) -> Optional[_builtins.str]:
        """
        Optional addons descripton to deploy on rke cluster.
        """
        return pulumi.get(self, "addons")

    @_builtins.property
    @pulumi.getter(name="addonsIncludes")
    def addons_includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        return pulumi.get(self, "addons_includes")

    @_builtins.property
    @pulumi.getter(name="enableCriDockerd")
    def enable_cri_dockerd(self) -> Optional[_builtins.bool]:
        """
        Enable/disable using cri-dockerd
        """
        return pulumi.get(self, "enable_cri_dockerd")

    @_builtins.property
    @pulumi.getter(name="ignoreDockerVersion")
    def ignore_docker_version(self) -> Optional[_builtins.bool]:
        """
        Optional ignore docker version on nodes
        """
        return pulumi.get(self, "ignore_docker_version")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.GetClusterRkeConfigNodeResult']]:
        """
        Optional RKE cluster nodes
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="privateRegistries")
    def private_registries(self) -> Optional[Sequence['outputs.GetClusterRkeConfigPrivateRegistryResult']]:
        """
        Optional private registries for docker images
        """
        return pulumi.get(self, "private_registries")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        """
        Optional use ssh agent auth
        """
        return pulumi.get(self, "ssh_agent_auth")


@pulumi.output_type
class GetClusterRkeConfigAuthenticationResult(dict):
    def __init__(__self__, *,
                 sans: Sequence[_builtins.str],
                 strategy: _builtins.str):
        pulumi.set(__self__, "sans", sans)
        pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def sans(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "sans")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> _builtins.str:
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterRkeConfigAuthorizationResult(dict):
    def __init__(__self__, *,
                 options: Mapping[str, _builtins.str],
                 mode: Optional[_builtins.str] = None):
        pulumi.set(__self__, "options", options)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetClusterRkeConfigBastionHostResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 ssh_key: _builtins.str,
                 ssh_key_path: _builtins.str,
                 user: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ssh_agent_auth")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderResult(dict):
    def __init__(__self__, *,
                 custom_cloud_provider: _builtins.str,
                 aws_cloud_provider: Optional['outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderResult'] = None,
                 azure_cloud_provider: Optional['outputs.GetClusterRkeConfigCloudProviderAzureCloudProviderResult'] = None,
                 name: Optional[_builtins.str] = None,
                 openstack_cloud_provider: Optional['outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult'] = None,
                 vsphere_cloud_provider: Optional['outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderResult'] = None):
        """
        :param _builtins.str name: The name of the Cluster (string)
        """
        pulumi.set(__self__, "custom_cloud_provider", custom_cloud_provider)
        if aws_cloud_provider is not None:
            pulumi.set(__self__, "aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_provider is not None:
            pulumi.set(__self__, "azure_cloud_provider", azure_cloud_provider)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if openstack_cloud_provider is not None:
            pulumi.set(__self__, "openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_provider is not None:
            pulumi.set(__self__, "vsphere_cloud_provider", vsphere_cloud_provider)

    @_builtins.property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "custom_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional['outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderResult']:
        return pulumi.get(self, "aws_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional['outputs.GetClusterRkeConfigCloudProviderAzureCloudProviderResult']:
        return pulumi.get(self, "azure_cloud_provider")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional['outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult']:
        return pulumi.get(self, "openstack_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional['outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderResult']:
        return pulumi.get(self, "vsphere_cloud_provider")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderAwsCloudProviderResult(dict):
    def __init__(__self__, *,
                 global_: 'outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult',
                 service_overrides: Optional[Sequence['outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult']] = None):
        pulumi.set(__self__, "global_", global_)
        if service_overrides is not None:
            pulumi.set(__self__, "service_overrides", service_overrides)

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[Sequence['outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult']]:
        return pulumi.get(self, "service_overrides")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult(dict):
    def __init__(__self__, *,
                 elb_security_group: _builtins.str,
                 kubernetes_cluster_id: _builtins.str,
                 kubernetes_cluster_tag: _builtins.str,
                 role_arn: _builtins.str,
                 route_table_id: _builtins.str,
                 subnet_id: _builtins.str,
                 vpc: _builtins.str,
                 zone: _builtins.str,
                 disable_security_group_ingress: Optional[_builtins.bool] = None,
                 disable_strict_zone_check: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "elb_security_group", elb_security_group)
        pulumi.set(__self__, "kubernetes_cluster_id", kubernetes_cluster_id)
        pulumi.set(__self__, "kubernetes_cluster_tag", kubernetes_cluster_tag)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "route_table_id", route_table_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc", vpc)
        pulumi.set(__self__, "zone", zone)
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            pulumi.set(__self__, "disable_strict_zone_check", disable_strict_zone_check)

    @_builtins.property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> _builtins.str:
        return pulumi.get(self, "elb_security_group")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "kubernetes_cluster_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> _builtins.str:
        return pulumi.get(self, "kubernetes_cluster_tag")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> _builtins.str:
        return pulumi.get(self, "route_table_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        return pulumi.get(self, "vpc")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_security_group_ingress")

    @_builtins.property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_strict_zone_check")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult(dict):
    def __init__(__self__, *,
                 region: _builtins.str,
                 service: _builtins.str,
                 signing_method: _builtins.str,
                 signing_name: _builtins.str,
                 signing_region: _builtins.str,
                 url: _builtins.str):
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "signing_method", signing_method)
        pulumi.set(__self__, "signing_name", signing_name)
        pulumi.set(__self__, "signing_region", signing_region)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> _builtins.str:
        return pulumi.get(self, "signing_method")

    @_builtins.property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> _builtins.str:
        return pulumi.get(self, "signing_name")

    @_builtins.property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> _builtins.str:
        return pulumi.get(self, "signing_region")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderAzureCloudProviderResult(dict):
    def __init__(__self__, *,
                 aad_client_cert_password: _builtins.str,
                 aad_client_cert_path: _builtins.str,
                 aad_client_id: _builtins.str,
                 aad_client_secret: _builtins.str,
                 cloud: _builtins.str,
                 cloud_provider_backoff: _builtins.bool,
                 cloud_provider_backoff_duration: _builtins.int,
                 cloud_provider_backoff_exponent: _builtins.int,
                 cloud_provider_backoff_jitter: _builtins.int,
                 cloud_provider_backoff_retries: _builtins.int,
                 cloud_provider_rate_limit: _builtins.bool,
                 cloud_provider_rate_limit_bucket: _builtins.int,
                 cloud_provider_rate_limit_qps: _builtins.int,
                 location: _builtins.str,
                 maximum_load_balancer_rule_count: _builtins.int,
                 primary_availability_set_name: _builtins.str,
                 primary_scale_set_name: _builtins.str,
                 resource_group: _builtins.str,
                 route_table_name: _builtins.str,
                 security_group_name: _builtins.str,
                 subnet_name: _builtins.str,
                 subscription_id: _builtins.str,
                 tenant_id: _builtins.str,
                 use_instance_metadata: _builtins.bool,
                 use_managed_identity_extension: _builtins.bool,
                 vm_type: _builtins.str,
                 vnet_name: _builtins.str,
                 vnet_resource_group: _builtins.str,
                 load_balancer_sku: Optional[_builtins.str] = None):
        """
        :param _builtins.str load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        pulumi.set(__self__, "aad_client_cert_password", aad_client_cert_password)
        pulumi.set(__self__, "aad_client_cert_path", aad_client_cert_path)
        pulumi.set(__self__, "aad_client_id", aad_client_id)
        pulumi.set(__self__, "aad_client_secret", aad_client_secret)
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "cloud_provider_backoff", cloud_provider_backoff)
        pulumi.set(__self__, "cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        pulumi.set(__self__, "cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        pulumi.set(__self__, "cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        pulumi.set(__self__, "cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        pulumi.set(__self__, "cloud_provider_rate_limit", cloud_provider_rate_limit)
        pulumi.set(__self__, "cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        pulumi.set(__self__, "cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        pulumi.set(__self__, "primary_availability_set_name", primary_availability_set_name)
        pulumi.set(__self__, "primary_scale_set_name", primary_scale_set_name)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "route_table_name", route_table_name)
        pulumi.set(__self__, "security_group_name", security_group_name)
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "use_instance_metadata", use_instance_metadata)
        pulumi.set(__self__, "use_managed_identity_extension", use_managed_identity_extension)
        pulumi.set(__self__, "vm_type", vm_type)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vnet_resource_group", vnet_resource_group)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)

    @_builtins.property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_cert_password")

    @_builtins.property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_cert_path")

    @_builtins.property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_id")

    @_builtins.property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_secret")

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> _builtins.str:
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> _builtins.bool:
        return pulumi.get(self, "cloud_provider_backoff")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> _builtins.bool:
        return pulumi.get(self, "cloud_provider_rate_limit")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> _builtins.int:
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> _builtins.str:
        return pulumi.get(self, "primary_availability_set_name")

    @_builtins.property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> _builtins.str:
        return pulumi.get(self, "primary_scale_set_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> _builtins.str:
        return pulumi.get(self, "route_table_name")

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> _builtins.str:
        return pulumi.get(self, "security_group_name")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> _builtins.bool:
        return pulumi.get(self, "use_instance_metadata")

    @_builtins.property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> _builtins.bool:
        return pulumi.get(self, "use_managed_identity_extension")

    @_builtins.property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> _builtins.str:
        return pulumi.get(self, "vm_type")

    @_builtins.property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> _builtins.str:
        return pulumi.get(self, "vnet_name")

    @_builtins.property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> _builtins.str:
        return pulumi.get(self, "vnet_resource_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult(dict):
    def __init__(__self__, *,
                 block_storage: 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult',
                 global_: 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult',
                 load_balancer: 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult',
                 metadata: 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult',
                 route: 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult'):
        pulumi.set(__self__, "block_storage", block_storage)
        pulumi.set(__self__, "global_", global_)
        pulumi.set(__self__, "load_balancer", load_balancer)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult':
        return pulumi.get(self, "block_storage")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult':
        return pulumi.get(self, "load_balancer")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult':
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def route(self) -> 'outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult':
        return pulumi.get(self, "route")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult(dict):
    def __init__(__self__, *,
                 bs_version: _builtins.str,
                 ignore_volume_az: _builtins.bool,
                 trust_device_path: _builtins.bool):
        pulumi.set(__self__, "bs_version", bs_version)
        pulumi.set(__self__, "ignore_volume_az", ignore_volume_az)
        pulumi.set(__self__, "trust_device_path", trust_device_path)

    @_builtins.property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> _builtins.str:
        return pulumi.get(self, "bs_version")

    @_builtins.property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> _builtins.bool:
        return pulumi.get(self, "ignore_volume_az")

    @_builtins.property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> _builtins.bool:
        return pulumi.get(self, "trust_device_path")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult(dict):
    def __init__(__self__, *,
                 auth_url: _builtins.str,
                 ca_file: _builtins.str,
                 domain_id: _builtins.str,
                 domain_name: _builtins.str,
                 password: _builtins.str,
                 region: _builtins.str,
                 tenant_id: _builtins.str,
                 tenant_name: _builtins.str,
                 trust_id: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "ca_file", ca_file)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "tenant_name", tenant_name)
        pulumi.set(__self__, "trust_id", trust_id)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> _builtins.str:
        return pulumi.get(self, "ca_file")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> _builtins.str:
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> _builtins.str:
        return pulumi.get(self, "trust_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult(dict):
    def __init__(__self__, *,
                 create_monitor: _builtins.bool,
                 floating_network_id: _builtins.str,
                 lb_method: _builtins.str,
                 lb_provider: _builtins.str,
                 lb_version: _builtins.str,
                 manage_security_groups: _builtins.bool,
                 subnet_id: _builtins.str,
                 use_octavia: _builtins.bool,
                 monitor_delay: Optional[_builtins.str] = None,
                 monitor_max_retries: Optional[_builtins.int] = None,
                 monitor_timeout: Optional[_builtins.str] = None):
        pulumi.set(__self__, "create_monitor", create_monitor)
        pulumi.set(__self__, "floating_network_id", floating_network_id)
        pulumi.set(__self__, "lb_method", lb_method)
        pulumi.set(__self__, "lb_provider", lb_provider)
        pulumi.set(__self__, "lb_version", lb_version)
        pulumi.set(__self__, "manage_security_groups", manage_security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "use_octavia", use_octavia)
        if monitor_delay is not None:
            pulumi.set(__self__, "monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            pulumi.set(__self__, "monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)

    @_builtins.property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> _builtins.bool:
        return pulumi.get(self, "create_monitor")

    @_builtins.property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> _builtins.str:
        return pulumi.get(self, "floating_network_id")

    @_builtins.property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> _builtins.str:
        return pulumi.get(self, "lb_method")

    @_builtins.property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> _builtins.str:
        return pulumi.get(self, "lb_provider")

    @_builtins.property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> _builtins.str:
        return pulumi.get(self, "lb_version")

    @_builtins.property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> _builtins.bool:
        return pulumi.get(self, "manage_security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> _builtins.bool:
        return pulumi.get(self, "use_octavia")

    @_builtins.property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitor_delay")

    @_builtins.property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "monitor_max_retries")

    @_builtins.property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitor_timeout")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult(dict):
    def __init__(__self__, *,
                 request_timeout: _builtins.int,
                 search_order: _builtins.str):
        pulumi.set(__self__, "request_timeout", request_timeout)
        pulumi.set(__self__, "search_order", search_order)

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> _builtins.int:
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> _builtins.str:
        return pulumi.get(self, "search_order")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult(dict):
    def __init__(__self__, *,
                 router_id: _builtins.str):
        pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> _builtins.str:
        return pulumi.get(self, "router_id")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderVsphereCloudProviderResult(dict):
    def __init__(__self__, *,
                 disk: 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult',
                 global_: 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult',
                 network: 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult',
                 virtual_centers: Sequence['outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult'],
                 workspace: 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult'):
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "global_", global_)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "virtual_centers", virtual_centers)
        pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult':
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter
    def network(self) -> 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult':
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> Sequence['outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult']:
        return pulumi.get(self, "virtual_centers")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> 'outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult':
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult(dict):
    def __init__(__self__, *,
                 scsi_controller_type: _builtins.str):
        pulumi.set(__self__, "scsi_controller_type", scsi_controller_type)

    @_builtins.property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> _builtins.str:
        return pulumi.get(self, "scsi_controller_type")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult(dict):
    def __init__(__self__, *,
                 datacenters: _builtins.str,
                 insecure_flag: _builtins.bool,
                 password: _builtins.str,
                 port: _builtins.str,
                 soap_roundtrip_count: _builtins.int,
                 user: _builtins.str,
                 graceful_shutdown_timeout: Optional[_builtins.str] = None):
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "insecure_flag", insecure_flag)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        pulumi.set(__self__, "user", user)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> _builtins.str:
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> _builtins.bool:
        return pulumi.get(self, "insecure_flag")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> _builtins.int:
        return pulumi.get(self, "soap_roundtrip_count")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "graceful_shutdown_timeout")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult(dict):
    def __init__(__self__, *,
                 public_network: _builtins.str):
        pulumi.set(__self__, "public_network", public_network)

    @_builtins.property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> _builtins.str:
        return pulumi.get(self, "public_network")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult(dict):
    def __init__(__self__, *,
                 datacenters: _builtins.str,
                 name: _builtins.str,
                 password: _builtins.str,
                 port: _builtins.str,
                 soap_roundtrip_count: _builtins.int,
                 user: _builtins.str):
        """
        :param _builtins.str name: The name of the Cluster (string)
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> _builtins.str:
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> _builtins.int:
        return pulumi.get(self, "soap_roundtrip_count")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult(dict):
    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 default_datastore: _builtins.str,
                 folder: _builtins.str,
                 resourcepool_path: _builtins.str,
                 server: _builtins.str):
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "default_datastore", default_datastore)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "resourcepool_path", resourcepool_path)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> _builtins.str:
        return pulumi.get(self, "default_datastore")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> _builtins.str:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> _builtins.str:
        return pulumi.get(self, "resourcepool_path")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        return pulumi.get(self, "server")


@pulumi.output_type
class GetClusterRkeConfigDnsResult(dict):
    def __init__(__self__, *,
                 node_selector: Mapping[str, _builtins.str],
                 options: Mapping[str, _builtins.str],
                 reverse_cidrs: Sequence[_builtins.str],
                 upstream_nameservers: Sequence[_builtins.str],
                 linear_autoscaler_params: Optional['outputs.GetClusterRkeConfigDnsLinearAutoscalerParamsResult'] = None,
                 nodelocal: Optional['outputs.GetClusterRkeConfigDnsNodelocalResult'] = None,
                 provider: Optional[_builtins.str] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterRkeConfigDnsTolerationResult']] = None,
                 update_strategy: Optional['outputs.GetClusterRkeConfigDnsUpdateStrategyResult'] = None):
        """
        :param 'GetClusterRkeConfigDnsLinearAutoscalerParamsArgs' linear_autoscaler_params: Linear Autoscaler Params
        :param 'GetClusterRkeConfigDnsNodelocalArgs' nodelocal: Nodelocal dns
        :param Sequence['GetClusterRkeConfigDnsTolerationArgs'] tolerations: DNS service tolerations
        :param 'GetClusterRkeConfigDnsUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "reverse_cidrs", reverse_cidrs)
        pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)
        if linear_autoscaler_params is not None:
            pulumi.set(__self__, "linear_autoscaler_params", linear_autoscaler_params)
        if nodelocal is not None:
            pulumi.set(__self__, "nodelocal", nodelocal)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "reverse_cidrs")

    @_builtins.property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "upstream_nameservers")

    @_builtins.property
    @pulumi.getter(name="linearAutoscalerParams")
    def linear_autoscaler_params(self) -> Optional['outputs.GetClusterRkeConfigDnsLinearAutoscalerParamsResult']:
        """
        Linear Autoscaler Params
        """
        return pulumi.get(self, "linear_autoscaler_params")

    @_builtins.property
    @pulumi.getter
    def nodelocal(self) -> Optional['outputs.GetClusterRkeConfigDnsNodelocalResult']:
        """
        Nodelocal dns
        """
        return pulumi.get(self, "nodelocal")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterRkeConfigDnsTolerationResult']]:
        """
        DNS service tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.GetClusterRkeConfigDnsUpdateStrategyResult']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class GetClusterRkeConfigDnsLinearAutoscalerParamsResult(dict):
    def __init__(__self__, *,
                 cores_per_replica: Optional[_builtins.float] = None,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 nodes_per_replica: Optional[_builtins.float] = None,
                 prevent_single_point_failure: Optional[_builtins.bool] = None):
        if cores_per_replica is not None:
            pulumi.set(__self__, "cores_per_replica", cores_per_replica)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if nodes_per_replica is not None:
            pulumi.set(__self__, "nodes_per_replica", nodes_per_replica)
        if prevent_single_point_failure is not None:
            pulumi.set(__self__, "prevent_single_point_failure", prevent_single_point_failure)

    @_builtins.property
    @pulumi.getter(name="coresPerReplica")
    def cores_per_replica(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cores_per_replica")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="nodesPerReplica")
    def nodes_per_replica(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "nodes_per_replica")

    @_builtins.property
    @pulumi.getter(name="preventSinglePointFailure")
    def prevent_single_point_failure(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "prevent_single_point_failure")


@pulumi.output_type
class GetClusterRkeConfigDnsNodelocalResult(dict):
    def __init__(__self__, *,
                 ip_address: Optional[_builtins.str] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] node_selector: Node selector key pair
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Node selector key pair
        """
        return pulumi.get(self, "node_selector")


@pulumi.output_type
class GetClusterRkeConfigDnsTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterRkeConfigDnsUpdateStrategyResult(dict):
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.GetClusterRkeConfigDnsUpdateStrategyRollingUpdateResult'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'GetClusterRkeConfigDnsUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterRkeConfigDnsUpdateStrategyRollingUpdateResult']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterRkeConfigDnsUpdateStrategyRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterRkeConfigIngressResult(dict):
    def __init__(__self__, *,
                 dns_policy: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 http_port: _builtins.int,
                 https_port: _builtins.int,
                 network_mode: _builtins.str,
                 node_selector: Mapping[str, _builtins.str],
                 options: Mapping[str, _builtins.str],
                 provider: _builtins.str,
                 default_backend: Optional[_builtins.bool] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterRkeConfigIngressTolerationResult']] = None,
                 update_strategy: Optional['outputs.GetClusterRkeConfigIngressUpdateStrategyResult'] = None):
        """
        :param Sequence['GetClusterRkeConfigIngressTolerationArgs'] tolerations: Ingress add-on tolerations
        :param 'GetClusterRkeConfigIngressUpdateStrategyArgs' update_strategy: Update daemon set strategy
        """
        pulumi.set(__self__, "dns_policy", dns_policy)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "network_mode", network_mode)
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "provider", provider)
        if default_backend is not None:
            pulumi.set(__self__, "default_backend", default_backend)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> _builtins.str:
        return pulumi.get(self, "dns_policy")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> _builtins.int:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> _builtins.int:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> _builtins.str:
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "default_backend")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterRkeConfigIngressTolerationResult']]:
        """
        Ingress add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.GetClusterRkeConfigIngressUpdateStrategyResult']:
        """
        Update daemon set strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class GetClusterRkeConfigIngressTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterRkeConfigIngressUpdateStrategyResult(dict):
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.GetClusterRkeConfigIngressUpdateStrategyRollingUpdateResult'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'GetClusterRkeConfigIngressUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterRkeConfigIngressUpdateStrategyRollingUpdateResult']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterRkeConfigIngressUpdateStrategyRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterRkeConfigMonitoringResult(dict):
    def __init__(__self__, *,
                 options: Mapping[str, _builtins.str],
                 provider: _builtins.str,
                 replicas: _builtins.int,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterRkeConfigMonitoringTolerationResult']] = None,
                 update_strategy: Optional['outputs.GetClusterRkeConfigMonitoringUpdateStrategyResult'] = None):
        """
        :param Sequence['GetClusterRkeConfigMonitoringTolerationArgs'] tolerations: Monitoring add-on tolerations
        :param 'GetClusterRkeConfigMonitoringUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "replicas", replicas)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterRkeConfigMonitoringTolerationResult']]:
        """
        Monitoring add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.GetClusterRkeConfigMonitoringUpdateStrategyResult']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class GetClusterRkeConfigMonitoringTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterRkeConfigMonitoringUpdateStrategyResult(dict):
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdateResult'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdateResult']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterRkeConfigNetworkResult(dict):
    def __init__(__self__, *,
                 options: Mapping[str, _builtins.str],
                 plugin: _builtins.str,
                 aci_network_provider: Optional['outputs.GetClusterRkeConfigNetworkAciNetworkProviderResult'] = None,
                 calico_network_provider: Optional['outputs.GetClusterRkeConfigNetworkCalicoNetworkProviderResult'] = None,
                 canal_network_provider: Optional['outputs.GetClusterRkeConfigNetworkCanalNetworkProviderResult'] = None,
                 flannel_network_provider: Optional['outputs.GetClusterRkeConfigNetworkFlannelNetworkProviderResult'] = None,
                 mtu: Optional[_builtins.int] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterRkeConfigNetworkTolerationResult']] = None,
                 weave_network_provider: Optional['outputs.GetClusterRkeConfigNetworkWeaveNetworkProviderResult'] = None):
        """
        :param Sequence['GetClusterRkeConfigNetworkTolerationArgs'] tolerations: Network add-on tolerations
        """
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "plugin", plugin)
        if aci_network_provider is not None:
            pulumi.set(__self__, "aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            pulumi.set(__self__, "calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            pulumi.set(__self__, "canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            pulumi.set(__self__, "flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if weave_network_provider is not None:
            pulumi.set(__self__, "weave_network_provider", weave_network_provider)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def plugin(self) -> _builtins.str:
        return pulumi.get(self, "plugin")

    @_builtins.property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional['outputs.GetClusterRkeConfigNetworkAciNetworkProviderResult']:
        return pulumi.get(self, "aci_network_provider")

    @_builtins.property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional['outputs.GetClusterRkeConfigNetworkCalicoNetworkProviderResult']:
        return pulumi.get(self, "calico_network_provider")

    @_builtins.property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional['outputs.GetClusterRkeConfigNetworkCanalNetworkProviderResult']:
        return pulumi.get(self, "canal_network_provider")

    @_builtins.property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional['outputs.GetClusterRkeConfigNetworkFlannelNetworkProviderResult']:
        return pulumi.get(self, "flannel_network_provider")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterRkeConfigNetworkTolerationResult']]:
        """
        Network add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional['outputs.GetClusterRkeConfigNetworkWeaveNetworkProviderResult']:
        return pulumi.get(self, "weave_network_provider")


@pulumi.output_type
class GetClusterRkeConfigNetworkAciNetworkProviderResult(dict):
    def __init__(__self__, *,
                 aep: _builtins.str,
                 apic_hosts: Sequence[_builtins.str],
                 apic_user_crt: _builtins.str,
                 apic_user_key: _builtins.str,
                 apic_user_name: _builtins.str,
                 encap_type: _builtins.str,
                 extern_dynamic: _builtins.str,
                 extern_static: _builtins.str,
                 kube_api_vlan: _builtins.str,
                 l3out: _builtins.str,
                 l3out_external_networks: Sequence[_builtins.str],
                 mcast_range_end: _builtins.str,
                 mcast_range_start: _builtins.str,
                 node_subnet: _builtins.str,
                 node_svc_subnet: _builtins.str,
                 service_vlan: _builtins.str,
                 system_id: _builtins.str,
                 token: _builtins.str,
                 vrf_name: _builtins.str,
                 vrf_tenant: _builtins.str,
                 apic_refresh_ticker_adjust: Optional[_builtins.str] = None,
                 apic_refresh_time: Optional[_builtins.str] = None,
                 apic_subscription_delay: Optional[_builtins.str] = None,
                 capic: Optional[_builtins.str] = None,
                 controller_log_level: Optional[_builtins.str] = None,
                 disable_periodic_snat_global_info_sync: Optional[_builtins.str] = None,
                 disable_wait_for_network: Optional[_builtins.str] = None,
                 drop_log_enable: Optional[_builtins.str] = None,
                 duration_wait_for_network: Optional[_builtins.str] = None,
                 enable_endpoint_slice: Optional[_builtins.str] = None,
                 ep_registry: Optional[_builtins.str] = None,
                 gbp_pod_subnet: Optional[_builtins.str] = None,
                 host_agent_log_level: Optional[_builtins.str] = None,
                 image_pull_policy: Optional[_builtins.str] = None,
                 image_pull_secret: Optional[_builtins.str] = None,
                 infra_vlan: Optional[_builtins.str] = None,
                 install_istio: Optional[_builtins.str] = None,
                 istio_profile: Optional[_builtins.str] = None,
                 kafka_brokers: Optional[Sequence[_builtins.str]] = None,
                 kafka_client_crt: Optional[_builtins.str] = None,
                 kafka_client_key: Optional[_builtins.str] = None,
                 max_nodes_svc_graph: Optional[_builtins.str] = None,
                 mtu_head_room: Optional[_builtins.str] = None,
                 multus_disable: Optional[_builtins.str] = None,
                 no_priority_class: Optional[_builtins.str] = None,
                 node_pod_if_enable: Optional[_builtins.str] = None,
                 opflex_client_ssl: Optional[_builtins.str] = None,
                 opflex_device_delete_timeout: Optional[_builtins.str] = None,
                 opflex_log_level: Optional[_builtins.str] = None,
                 opflex_mode: Optional[_builtins.str] = None,
                 opflex_server_port: Optional[_builtins.str] = None,
                 overlay_vrf_name: Optional[_builtins.str] = None,
                 ovs_memory_limit: Optional[_builtins.str] = None,
                 pbr_tracking_non_snat: Optional[_builtins.str] = None,
                 pod_subnet_chunk_size: Optional[_builtins.str] = None,
                 run_gbp_container: Optional[_builtins.str] = None,
                 run_opflex_server_container: Optional[_builtins.str] = None,
                 service_monitor_interval: Optional[_builtins.str] = None,
                 snat_contract_scope: Optional[_builtins.str] = None,
                 snat_namespace: Optional[_builtins.str] = None,
                 snat_port_range_end: Optional[_builtins.str] = None,
                 snat_port_range_start: Optional[_builtins.str] = None,
                 snat_ports_per_node: Optional[_builtins.str] = None,
                 sriov_enable: Optional[_builtins.str] = None,
                 subnet_domain_name: Optional[_builtins.str] = None,
                 tenant: Optional[_builtins.str] = None,
                 use_aci_anywhere_crd: Optional[_builtins.str] = None,
                 use_aci_cni_priority_class: Optional[_builtins.str] = None,
                 use_cluster_role: Optional[_builtins.str] = None,
                 use_host_netns_volume: Optional[_builtins.str] = None,
                 use_opflex_server_volume: Optional[_builtins.str] = None,
                 use_privileged_container: Optional[_builtins.str] = None,
                 vmm_controller: Optional[_builtins.str] = None,
                 vmm_domain: Optional[_builtins.str] = None):
        pulumi.set(__self__, "aep", aep)
        pulumi.set(__self__, "apic_hosts", apic_hosts)
        pulumi.set(__self__, "apic_user_crt", apic_user_crt)
        pulumi.set(__self__, "apic_user_key", apic_user_key)
        pulumi.set(__self__, "apic_user_name", apic_user_name)
        pulumi.set(__self__, "encap_type", encap_type)
        pulumi.set(__self__, "extern_dynamic", extern_dynamic)
        pulumi.set(__self__, "extern_static", extern_static)
        pulumi.set(__self__, "kube_api_vlan", kube_api_vlan)
        pulumi.set(__self__, "l3out", l3out)
        pulumi.set(__self__, "l3out_external_networks", l3out_external_networks)
        pulumi.set(__self__, "mcast_range_end", mcast_range_end)
        pulumi.set(__self__, "mcast_range_start", mcast_range_start)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "node_svc_subnet", node_svc_subnet)
        pulumi.set(__self__, "service_vlan", service_vlan)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "vrf_name", vrf_name)
        pulumi.set(__self__, "vrf_tenant", vrf_tenant)
        if apic_refresh_ticker_adjust is not None:
            pulumi.set(__self__, "apic_refresh_ticker_adjust", apic_refresh_ticker_adjust)
        if apic_refresh_time is not None:
            pulumi.set(__self__, "apic_refresh_time", apic_refresh_time)
        if apic_subscription_delay is not None:
            pulumi.set(__self__, "apic_subscription_delay", apic_subscription_delay)
        if capic is not None:
            pulumi.set(__self__, "capic", capic)
        if controller_log_level is not None:
            pulumi.set(__self__, "controller_log_level", controller_log_level)
        if disable_periodic_snat_global_info_sync is not None:
            pulumi.set(__self__, "disable_periodic_snat_global_info_sync", disable_periodic_snat_global_info_sync)
        if disable_wait_for_network is not None:
            pulumi.set(__self__, "disable_wait_for_network", disable_wait_for_network)
        if drop_log_enable is not None:
            pulumi.set(__self__, "drop_log_enable", drop_log_enable)
        if duration_wait_for_network is not None:
            pulumi.set(__self__, "duration_wait_for_network", duration_wait_for_network)
        if enable_endpoint_slice is not None:
            pulumi.set(__self__, "enable_endpoint_slice", enable_endpoint_slice)
        if ep_registry is not None:
            pulumi.set(__self__, "ep_registry", ep_registry)
        if gbp_pod_subnet is not None:
            pulumi.set(__self__, "gbp_pod_subnet", gbp_pod_subnet)
        if host_agent_log_level is not None:
            pulumi.set(__self__, "host_agent_log_level", host_agent_log_level)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if infra_vlan is not None:
            pulumi.set(__self__, "infra_vlan", infra_vlan)
        if install_istio is not None:
            pulumi.set(__self__, "install_istio", install_istio)
        if istio_profile is not None:
            pulumi.set(__self__, "istio_profile", istio_profile)
        if kafka_brokers is not None:
            pulumi.set(__self__, "kafka_brokers", kafka_brokers)
        if kafka_client_crt is not None:
            pulumi.set(__self__, "kafka_client_crt", kafka_client_crt)
        if kafka_client_key is not None:
            pulumi.set(__self__, "kafka_client_key", kafka_client_key)
        if max_nodes_svc_graph is not None:
            pulumi.set(__self__, "max_nodes_svc_graph", max_nodes_svc_graph)
        if mtu_head_room is not None:
            pulumi.set(__self__, "mtu_head_room", mtu_head_room)
        if multus_disable is not None:
            pulumi.set(__self__, "multus_disable", multus_disable)
        if no_priority_class is not None:
            pulumi.set(__self__, "no_priority_class", no_priority_class)
        if node_pod_if_enable is not None:
            pulumi.set(__self__, "node_pod_if_enable", node_pod_if_enable)
        if opflex_client_ssl is not None:
            pulumi.set(__self__, "opflex_client_ssl", opflex_client_ssl)
        if opflex_device_delete_timeout is not None:
            pulumi.set(__self__, "opflex_device_delete_timeout", opflex_device_delete_timeout)
        if opflex_log_level is not None:
            pulumi.set(__self__, "opflex_log_level", opflex_log_level)
        if opflex_mode is not None:
            pulumi.set(__self__, "opflex_mode", opflex_mode)
        if opflex_server_port is not None:
            pulumi.set(__self__, "opflex_server_port", opflex_server_port)
        if overlay_vrf_name is not None:
            pulumi.set(__self__, "overlay_vrf_name", overlay_vrf_name)
        if ovs_memory_limit is not None:
            pulumi.set(__self__, "ovs_memory_limit", ovs_memory_limit)
        if pbr_tracking_non_snat is not None:
            pulumi.set(__self__, "pbr_tracking_non_snat", pbr_tracking_non_snat)
        if pod_subnet_chunk_size is not None:
            pulumi.set(__self__, "pod_subnet_chunk_size", pod_subnet_chunk_size)
        if run_gbp_container is not None:
            pulumi.set(__self__, "run_gbp_container", run_gbp_container)
        if run_opflex_server_container is not None:
            pulumi.set(__self__, "run_opflex_server_container", run_opflex_server_container)
        if service_monitor_interval is not None:
            pulumi.set(__self__, "service_monitor_interval", service_monitor_interval)
        if snat_contract_scope is not None:
            pulumi.set(__self__, "snat_contract_scope", snat_contract_scope)
        if snat_namespace is not None:
            pulumi.set(__self__, "snat_namespace", snat_namespace)
        if snat_port_range_end is not None:
            pulumi.set(__self__, "snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            pulumi.set(__self__, "snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            pulumi.set(__self__, "snat_ports_per_node", snat_ports_per_node)
        if sriov_enable is not None:
            pulumi.set(__self__, "sriov_enable", sriov_enable)
        if subnet_domain_name is not None:
            pulumi.set(__self__, "subnet_domain_name", subnet_domain_name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if use_aci_anywhere_crd is not None:
            pulumi.set(__self__, "use_aci_anywhere_crd", use_aci_anywhere_crd)
        if use_aci_cni_priority_class is not None:
            pulumi.set(__self__, "use_aci_cni_priority_class", use_aci_cni_priority_class)
        if use_cluster_role is not None:
            pulumi.set(__self__, "use_cluster_role", use_cluster_role)
        if use_host_netns_volume is not None:
            pulumi.set(__self__, "use_host_netns_volume", use_host_netns_volume)
        if use_opflex_server_volume is not None:
            pulumi.set(__self__, "use_opflex_server_volume", use_opflex_server_volume)
        if use_privileged_container is not None:
            pulumi.set(__self__, "use_privileged_container", use_privileged_container)
        if vmm_controller is not None:
            pulumi.set(__self__, "vmm_controller", vmm_controller)
        if vmm_domain is not None:
            pulumi.set(__self__, "vmm_domain", vmm_domain)

    @_builtins.property
    @pulumi.getter
    def aep(self) -> _builtins.str:
        return pulumi.get(self, "aep")

    @_builtins.property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "apic_hosts")

    @_builtins.property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_crt")

    @_builtins.property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_key")

    @_builtins.property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_name")

    @_builtins.property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> _builtins.str:
        return pulumi.get(self, "encap_type")

    @_builtins.property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> _builtins.str:
        return pulumi.get(self, "extern_dynamic")

    @_builtins.property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> _builtins.str:
        return pulumi.get(self, "extern_static")

    @_builtins.property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> _builtins.str:
        return pulumi.get(self, "kube_api_vlan")

    @_builtins.property
    @pulumi.getter
    def l3out(self) -> _builtins.str:
        return pulumi.get(self, "l3out")

    @_builtins.property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "l3out_external_networks")

    @_builtins.property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> _builtins.str:
        return pulumi.get(self, "mcast_range_end")

    @_builtins.property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> _builtins.str:
        return pulumi.get(self, "mcast_range_start")

    @_builtins.property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> _builtins.str:
        return pulumi.get(self, "node_subnet")

    @_builtins.property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> _builtins.str:
        return pulumi.get(self, "node_svc_subnet")

    @_builtins.property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> _builtins.str:
        return pulumi.get(self, "service_vlan")

    @_builtins.property
    @pulumi.getter(name="systemId")
    def system_id(self) -> _builtins.str:
        return pulumi.get(self, "system_id")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> _builtins.str:
        return pulumi.get(self, "vrf_name")

    @_builtins.property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> _builtins.str:
        return pulumi.get(self, "vrf_tenant")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTickerAdjust")
    def apic_refresh_ticker_adjust(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_refresh_ticker_adjust")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTime")
    def apic_refresh_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_refresh_time")

    @_builtins.property
    @pulumi.getter(name="apicSubscriptionDelay")
    def apic_subscription_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_subscription_delay")

    @_builtins.property
    @pulumi.getter
    def capic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capic")

    @_builtins.property
    @pulumi.getter(name="controllerLogLevel")
    def controller_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "controller_log_level")

    @_builtins.property
    @pulumi.getter(name="disablePeriodicSnatGlobalInfoSync")
    def disable_periodic_snat_global_info_sync(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disable_periodic_snat_global_info_sync")

    @_builtins.property
    @pulumi.getter(name="disableWaitForNetwork")
    def disable_wait_for_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disable_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="dropLogEnable")
    def drop_log_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "drop_log_enable")

    @_builtins.property
    @pulumi.getter(name="durationWaitForNetwork")
    def duration_wait_for_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "duration_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="enableEndpointSlice")
    def enable_endpoint_slice(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "enable_endpoint_slice")

    @_builtins.property
    @pulumi.getter(name="epRegistry")
    def ep_registry(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ep_registry")

    @_builtins.property
    @pulumi.getter(name="gbpPodSubnet")
    def gbp_pod_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gbp_pod_subnet")

    @_builtins.property
    @pulumi.getter(name="hostAgentLogLevel")
    def host_agent_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_agent_log_level")

    @_builtins.property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_policy")

    @_builtins.property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_secret")

    @_builtins.property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "infra_vlan")

    @_builtins.property
    @pulumi.getter(name="installIstio")
    def install_istio(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "install_istio")

    @_builtins.property
    @pulumi.getter(name="istioProfile")
    def istio_profile(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "istio_profile")

    @_builtins.property
    @pulumi.getter(name="kafkaBrokers")
    def kafka_brokers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "kafka_brokers")

    @_builtins.property
    @pulumi.getter(name="kafkaClientCrt")
    def kafka_client_crt(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kafka_client_crt")

    @_builtins.property
    @pulumi.getter(name="kafkaClientKey")
    def kafka_client_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kafka_client_key")

    @_builtins.property
    @pulumi.getter(name="maxNodesSvcGraph")
    def max_nodes_svc_graph(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_nodes_svc_graph")

    @_builtins.property
    @pulumi.getter(name="mtuHeadRoom")
    def mtu_head_room(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mtu_head_room")

    @_builtins.property
    @pulumi.getter(name="multusDisable")
    def multus_disable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "multus_disable")

    @_builtins.property
    @pulumi.getter(name="noPriorityClass")
    def no_priority_class(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "no_priority_class")

    @_builtins.property
    @pulumi.getter(name="nodePodIfEnable")
    def node_pod_if_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_pod_if_enable")

    @_builtins.property
    @pulumi.getter(name="opflexClientSsl")
    def opflex_client_ssl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_client_ssl")

    @_builtins.property
    @pulumi.getter(name="opflexDeviceDeleteTimeout")
    def opflex_device_delete_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_device_delete_timeout")

    @_builtins.property
    @pulumi.getter(name="opflexLogLevel")
    def opflex_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_log_level")

    @_builtins.property
    @pulumi.getter(name="opflexMode")
    def opflex_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_mode")

    @_builtins.property
    @pulumi.getter(name="opflexServerPort")
    def opflex_server_port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_server_port")

    @_builtins.property
    @pulumi.getter(name="overlayVrfName")
    def overlay_vrf_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "overlay_vrf_name")

    @_builtins.property
    @pulumi.getter(name="ovsMemoryLimit")
    def ovs_memory_limit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ovs_memory_limit")

    @_builtins.property
    @pulumi.getter(name="pbrTrackingNonSnat")
    def pbr_tracking_non_snat(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pbr_tracking_non_snat")

    @_builtins.property
    @pulumi.getter(name="podSubnetChunkSize")
    def pod_subnet_chunk_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pod_subnet_chunk_size")

    @_builtins.property
    @pulumi.getter(name="runGbpContainer")
    def run_gbp_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_gbp_container")

    @_builtins.property
    @pulumi.getter(name="runOpflexServerContainer")
    def run_opflex_server_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_opflex_server_container")

    @_builtins.property
    @pulumi.getter(name="serviceMonitorInterval")
    def service_monitor_interval(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_monitor_interval")

    @_builtins.property
    @pulumi.getter(name="snatContractScope")
    def snat_contract_scope(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_contract_scope")

    @_builtins.property
    @pulumi.getter(name="snatNamespace")
    def snat_namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_namespace")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_port_range_end")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_port_range_start")

    @_builtins.property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_ports_per_node")

    @_builtins.property
    @pulumi.getter(name="sriovEnable")
    def sriov_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sriov_enable")

    @_builtins.property
    @pulumi.getter(name="subnetDomainName")
    def subnet_domain_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_domain_name")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter(name="useAciAnywhereCrd")
    def use_aci_anywhere_crd(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_aci_anywhere_crd")

    @_builtins.property
    @pulumi.getter(name="useAciCniPriorityClass")
    def use_aci_cni_priority_class(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_aci_cni_priority_class")

    @_builtins.property
    @pulumi.getter(name="useClusterRole")
    def use_cluster_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_cluster_role")

    @_builtins.property
    @pulumi.getter(name="useHostNetnsVolume")
    def use_host_netns_volume(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_host_netns_volume")

    @_builtins.property
    @pulumi.getter(name="useOpflexServerVolume")
    def use_opflex_server_volume(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_opflex_server_volume")

    @_builtins.property
    @pulumi.getter(name="usePrivilegedContainer")
    def use_privileged_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_privileged_container")

    @_builtins.property
    @pulumi.getter(name="vmmController")
    def vmm_controller(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vmm_controller")

    @_builtins.property
    @pulumi.getter(name="vmmDomain")
    def vmm_domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vmm_domain")


@pulumi.output_type
class GetClusterRkeConfigNetworkCalicoNetworkProviderResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "cloud_provider")


@pulumi.output_type
class GetClusterRkeConfigNetworkCanalNetworkProviderResult(dict):
    def __init__(__self__, *,
                 iface: _builtins.str):
        pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> _builtins.str:
        return pulumi.get(self, "iface")


@pulumi.output_type
class GetClusterRkeConfigNetworkFlannelNetworkProviderResult(dict):
    def __init__(__self__, *,
                 iface: _builtins.str):
        pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> _builtins.str:
        return pulumi.get(self, "iface")


@pulumi.output_type
class GetClusterRkeConfigNetworkTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterRkeConfigNetworkWeaveNetworkProviderResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str):
        pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")


@pulumi.output_type
class GetClusterRkeConfigNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 docker_socket: _builtins.str,
                 roles: Sequence[_builtins.str],
                 ssh_key: _builtins.str,
                 ssh_key_path: _builtins.str,
                 user: _builtins.str,
                 hostname_override: Optional[_builtins.str] = None,
                 internal_address: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 node_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for Node Pool object (map)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "docker_socket", docker_socket)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        pulumi.set(__self__, "user", user)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if internal_address is not None:
            pulumi.set(__self__, "internal_address", internal_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> _builtins.str:
        return pulumi.get(self, "docker_socket")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname_override")

    @_builtins.property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "internal_address")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Computed) Labels for Node Pool object (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ssh_agent_auth")


@pulumi.output_type
class GetClusterRkeConfigPrivateRegistryResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 ecr_credential_plugin: Optional['outputs.GetClusterRkeConfigPrivateRegistryEcrCredentialPluginResult'] = None,
                 is_default: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param 'GetClusterRkeConfigPrivateRegistryEcrCredentialPluginArgs' ecr_credential_plugin: ECR credential plugin config
        """
        pulumi.set(__self__, "url", url)
        if ecr_credential_plugin is not None:
            pulumi.set(__self__, "ecr_credential_plugin", ecr_credential_plugin)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="ecrCredentialPlugin")
    def ecr_credential_plugin(self) -> Optional['outputs.GetClusterRkeConfigPrivateRegistryEcrCredentialPluginResult']:
        """
        ECR credential plugin config
        """
        return pulumi.get(self, "ecr_credential_plugin")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetClusterRkeConfigPrivateRegistryEcrCredentialPluginResult(dict):
    def __init__(__self__, *,
                 aws_access_key_id: Optional[_builtins.str] = None,
                 aws_secret_access_key: Optional[_builtins.str] = None,
                 aws_session_token: Optional[_builtins.str] = None):
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_session_token")


@pulumi.output_type
class GetClusterRkeConfigServicesResult(dict):
    def __init__(__self__, *,
                 etcd: 'outputs.GetClusterRkeConfigServicesEtcdResult',
                 kube_api: 'outputs.GetClusterRkeConfigServicesKubeApiResult',
                 kube_controller: 'outputs.GetClusterRkeConfigServicesKubeControllerResult',
                 kubelet: 'outputs.GetClusterRkeConfigServicesKubeletResult',
                 kubeproxy: 'outputs.GetClusterRkeConfigServicesKubeproxyResult',
                 scheduler: 'outputs.GetClusterRkeConfigServicesSchedulerResult'):
        pulumi.set(__self__, "etcd", etcd)
        pulumi.set(__self__, "kube_api", kube_api)
        pulumi.set(__self__, "kube_controller", kube_controller)
        pulumi.set(__self__, "kubelet", kubelet)
        pulumi.set(__self__, "kubeproxy", kubeproxy)
        pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> 'outputs.GetClusterRkeConfigServicesEtcdResult':
        return pulumi.get(self, "etcd")

    @_builtins.property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> 'outputs.GetClusterRkeConfigServicesKubeApiResult':
        return pulumi.get(self, "kube_api")

    @_builtins.property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> 'outputs.GetClusterRkeConfigServicesKubeControllerResult':
        return pulumi.get(self, "kube_controller")

    @_builtins.property
    @pulumi.getter
    def kubelet(self) -> 'outputs.GetClusterRkeConfigServicesKubeletResult':
        return pulumi.get(self, "kubelet")

    @_builtins.property
    @pulumi.getter
    def kubeproxy(self) -> 'outputs.GetClusterRkeConfigServicesKubeproxyResult':
        return pulumi.get(self, "kubeproxy")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> 'outputs.GetClusterRkeConfigServicesSchedulerResult':
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class GetClusterRkeConfigServicesEtcdResult(dict):
    def __init__(__self__, *,
                 backup_config: 'outputs.GetClusterRkeConfigServicesEtcdBackupConfigResult',
                 ca_cert: _builtins.str,
                 cert: _builtins.str,
                 creation: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 key: _builtins.str,
                 path: _builtins.str,
                 retention: _builtins.str,
                 snapshot: _builtins.bool,
                 external_urls: Optional[Sequence[_builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 gid: Optional[_builtins.int] = None,
                 uid: Optional[_builtins.int] = None):
        """
        :param _builtins.str ca_cert: (Computed) K8s cluster ca cert (string)
        """
        pulumi.set(__self__, "backup_config", backup_config)
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "creation", creation)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "snapshot", snapshot)
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> 'outputs.GetClusterRkeConfigServicesEtcdBackupConfigResult':
        return pulumi.get(self, "backup_config")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> _builtins.str:
        """
        (Computed) K8s cluster ca cert (string)
        """
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def creation(self) -> _builtins.str:
        return pulumi.get(self, "creation")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> _builtins.str:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> _builtins.bool:
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "external_urls")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "gid")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetClusterRkeConfigServicesEtcdBackupConfigResult(dict):
    def __init__(__self__, *,
                 timeout: _builtins.int,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None,
                 retention: Optional[_builtins.int] = None,
                 s3_backup_config: Optional['outputs.GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult'] = None,
                 safe_timestamp: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "timeout", timeout)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "interval_hours")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult']:
        return pulumi.get(self, "s3_backup_config")

    @_builtins.property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safe_timestamp")


@pulumi.output_type
class GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 endpoint: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 custom_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiResult(dict):
    def __init__(__self__, *,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 service_cluster_ip_range: _builtins.str,
                 service_node_port_range: _builtins.str,
                 admission_configuration: Optional['outputs.GetClusterRkeConfigServicesKubeApiAdmissionConfigurationResult'] = None,
                 always_pull_images: Optional[_builtins.bool] = None,
                 audit_log: Optional['outputs.GetClusterRkeConfigServicesKubeApiAuditLogResult'] = None,
                 event_rate_limit: Optional['outputs.GetClusterRkeConfigServicesKubeApiEventRateLimitResult'] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 secrets_encryption_config: Optional['outputs.GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult'] = None):
        """
        :param 'GetClusterRkeConfigServicesKubeApiAdmissionConfigurationArgs' admission_configuration: Cluster admission configuration
        """
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        pulumi.set(__self__, "service_node_port_range", service_node_port_range)
        if admission_configuration is not None:
            pulumi.set(__self__, "admission_configuration", admission_configuration)
        if always_pull_images is not None:
            pulumi.set(__self__, "always_pull_images", always_pull_images)
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if event_rate_limit is not None:
            pulumi.set(__self__, "event_rate_limit", event_rate_limit)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if secrets_encryption_config is not None:
            pulumi.set(__self__, "secrets_encryption_config", secrets_encryption_config)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> _builtins.str:
        return pulumi.get(self, "service_cluster_ip_range")

    @_builtins.property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> _builtins.str:
        return pulumi.get(self, "service_node_port_range")

    @_builtins.property
    @pulumi.getter(name="admissionConfiguration")
    def admission_configuration(self) -> Optional['outputs.GetClusterRkeConfigServicesKubeApiAdmissionConfigurationResult']:
        """
        Cluster admission configuration
        """
        return pulumi.get(self, "admission_configuration")

    @_builtins.property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "always_pull_images")

    @_builtins.property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.GetClusterRkeConfigServicesKubeApiAuditLogResult']:
        return pulumi.get(self, "audit_log")

    @_builtins.property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional['outputs.GetClusterRkeConfigServicesKubeApiEventRateLimitResult']:
        return pulumi.get(self, "event_rate_limit")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional['outputs.GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult']:
        return pulumi.get(self, "secrets_encryption_config")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiAdmissionConfigurationResult(dict):
    def __init__(__self__, *,
                 plugins: Sequence['outputs.GetClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginResult'],
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None):
        """
        :param Sequence['GetClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs'] plugins: Admission configuration plugins
        :param _builtins.str api_version: Admission configuration ApiVersion
        :param _builtins.str kind: Admission configuration Kind
        """
        pulumi.set(__self__, "plugins", plugins)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def plugins(self) -> Sequence['outputs.GetClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginResult']:
        """
        Admission configuration plugins
        """
        return pulumi.get(self, "plugins")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        Admission configuration ApiVersion
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Admission configuration Kind
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiAdmissionConfigurationPluginResult(dict):
    def __init__(__self__, *,
                 configuration: _builtins.str,
                 name: _builtins.str,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str configuration: Plugin configuration
        :param _builtins.str name: The name of the Cluster (string)
        :param _builtins.str path: Plugin path
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> _builtins.str:
        """
        Plugin configuration
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Plugin path
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiAuditLogResult(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult',
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> 'outputs.GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult':
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 format: Optional[_builtins.str] = None,
                 max_age: Optional[_builtins.int] = None,
                 max_backup: Optional[_builtins.int] = None,
                 max_size: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "policy", policy)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_backup is not None:
            pulumi.set(__self__, "max_backup", max_backup)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_age")

    @_builtins.property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_backup")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiEventRateLimitResult(dict):
    def __init__(__self__, *,
                 configuration: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> _builtins.str:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult(dict):
    def __init__(__self__, *,
                 custom_config: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "custom_config", custom_config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> _builtins.str:
        return pulumi.get(self, "custom_config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeControllerResult(dict):
    def __init__(__self__, *,
                 cluster_cidr: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 service_cluster_ip_range: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)

    @_builtins.property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> _builtins.str:
        return pulumi.get(self, "cluster_cidr")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> _builtins.str:
        return pulumi.get(self, "service_cluster_ip_range")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeletResult(dict):
    def __init__(__self__, *,
                 cluster_dns_server: _builtins.str,
                 cluster_domain: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 fail_swap_on: _builtins.bool,
                 image: _builtins.str,
                 infra_container_image: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 generate_serving_certificate: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "cluster_dns_server", cluster_dns_server)
        pulumi.set(__self__, "cluster_domain", cluster_domain)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "infra_container_image", infra_container_image)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if generate_serving_certificate is not None:
            pulumi.set(__self__, "generate_serving_certificate", generate_serving_certificate)

    @_builtins.property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> _builtins.str:
        return pulumi.get(self, "cluster_dns_server")

    @_builtins.property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> _builtins.str:
        return pulumi.get(self, "cluster_domain")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> _builtins.bool:
        return pulumi.get(self, "fail_swap_on")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> _builtins.str:
        return pulumi.get(self, "infra_container_image")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "generate_serving_certificate")


@pulumi.output_type
class GetClusterRkeConfigServicesKubeproxyResult(dict):
    def __init__(__self__, *,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")


@pulumi.output_type
class GetClusterRkeConfigServicesSchedulerResult(dict):
    def __init__(__self__, *,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")


@pulumi.output_type
class GetClusterRkeConfigUpgradeStrategyResult(dict):
    def __init__(__self__, *,
                 drain_input: 'outputs.GetClusterRkeConfigUpgradeStrategyDrainInputResult',
                 drain: Optional[_builtins.bool] = None,
                 max_unavailable_controlplane: Optional[_builtins.str] = None,
                 max_unavailable_worker: Optional[_builtins.str] = None):
        pulumi.set(__self__, "drain_input", drain_input)
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if max_unavailable_controlplane is not None:
            pulumi.set(__self__, "max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            pulumi.set(__self__, "max_unavailable_worker", max_unavailable_worker)

    @_builtins.property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> 'outputs.GetClusterRkeConfigUpgradeStrategyDrainInputResult':
        return pulumi.get(self, "drain_input")

    @_builtins.property
    @pulumi.getter
    def drain(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "drain")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_unavailable_controlplane")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_unavailable_worker")


@pulumi.output_type
class GetClusterRkeConfigUpgradeStrategyDrainInputResult(dict):
    def __init__(__self__, *,
                 delete_local_data: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        if delete_local_data is not None:
            pulumi.set(__self__, "delete_local_data", delete_local_data)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_local_data")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetClusterTemplateMemberResult(dict):
    def __init__(__self__, *,
                 access_type: Optional[_builtins.str] = None,
                 group_principal_id: Optional[_builtins.str] = None,
                 user_principal_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_type: Member access type: member, owner, read-only
        :param _builtins.str group_principal_id: Member group principal id
        :param _builtins.str user_principal_id: Member user principal id
        """
        if access_type is not None:
            pulumi.set(__self__, "access_type", access_type)
        if group_principal_id is not None:
            pulumi.set(__self__, "group_principal_id", group_principal_id)
        if user_principal_id is not None:
            pulumi.set(__self__, "user_principal_id", user_principal_id)

    @_builtins.property
    @pulumi.getter(name="accessType")
    def access_type(self) -> Optional[_builtins.str]:
        """
        Member access type: member, owner, read-only
        """
        return pulumi.get(self, "access_type")

    @_builtins.property
    @pulumi.getter(name="groupPrincipalId")
    def group_principal_id(self) -> Optional[_builtins.str]:
        """
        Member group principal id
        """
        return pulumi.get(self, "group_principal_id")

    @_builtins.property
    @pulumi.getter(name="userPrincipalId")
    def user_principal_id(self) -> Optional[_builtins.str]:
        """
        Member user principal id
        """
        return pulumi.get(self, "user_principal_id")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, _builtins.str],
                 cluster_config: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigResult',
                 cluster_template_id: _builtins.str,
                 id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 default: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 questions: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionQuestionResult']] = None):
        """
        :param Mapping[str, _builtins.str] annotations: (Computed) Annotations for the cluster template (map)
        :param 'GetClusterTemplateTemplateRevisionClusterConfigArgs' cluster_config: Cluster configuration
        :param _builtins.str cluster_template_id: Cluster template ID
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for the cluster template (map)
        :param _builtins.str name: The cluster template name (string)
        :param _builtins.bool default: Default cluster template revision
        :param _builtins.bool enabled: Enable cluster template revision
        :param Sequence['GetClusterTemplateTemplateRevisionQuestionArgs'] questions: Cluster template questions
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_config", cluster_config)
        pulumi.set(__self__, "cluster_template_id", cluster_template_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if questions is not None:
            pulumi.set(__self__, "questions", questions)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Annotations for the cluster template (map)
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigResult':
        """
        Cluster configuration
        """
        return pulumi.get(self, "cluster_config")

    @_builtins.property
    @pulumi.getter(name="clusterTemplateId")
    def cluster_template_id(self) -> _builtins.str:
        """
        Cluster template ID
        """
        return pulumi.get(self, "cluster_template_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        (Computed) Labels for the cluster template (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.bool]:
        """
        Default cluster template revision
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable cluster template revision
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def questions(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionQuestionResult']]:
        """
        Cluster template questions
        """
        return pulumi.get(self, "questions")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigResult(dict):
    def __init__(__self__, *,
                 cluster_auth_endpoint: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointResult',
                 default_cluster_role_for_project_members: _builtins.str,
                 default_pod_security_admission_configuration_template_name: _builtins.str,
                 desired_agent_image: _builtins.str,
                 desired_auth_image: _builtins.str,
                 docker_root_dir: _builtins.str,
                 rke_config: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigResult',
                 enable_network_policy: Optional[_builtins.bool] = None,
                 windows_prefered_cluster: Optional[_builtins.bool] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointArgs' cluster_auth_endpoint: Local cluster auth endpoint
        :param _builtins.str default_cluster_role_for_project_members: Default cluster role for project members
        :param _builtins.str default_pod_security_admission_configuration_template_name: Default pod security admission configuration template name
        :param _builtins.str desired_agent_image: Desired agent image
        :param _builtins.str desired_auth_image: Desired auth image
        :param _builtins.str docker_root_dir: Docker Root Dir
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigArgs' rke_config: Rancher Kubernetes Engine Config
        :param _builtins.bool enable_network_policy: Enable project network isolation
        :param _builtins.bool windows_prefered_cluster: Windows prefered cluster
        """
        pulumi.set(__self__, "cluster_auth_endpoint", cluster_auth_endpoint)
        pulumi.set(__self__, "default_cluster_role_for_project_members", default_cluster_role_for_project_members)
        pulumi.set(__self__, "default_pod_security_admission_configuration_template_name", default_pod_security_admission_configuration_template_name)
        pulumi.set(__self__, "desired_agent_image", desired_agent_image)
        pulumi.set(__self__, "desired_auth_image", desired_auth_image)
        pulumi.set(__self__, "docker_root_dir", docker_root_dir)
        pulumi.set(__self__, "rke_config", rke_config)
        if enable_network_policy is not None:
            pulumi.set(__self__, "enable_network_policy", enable_network_policy)
        if windows_prefered_cluster is not None:
            pulumi.set(__self__, "windows_prefered_cluster", windows_prefered_cluster)

    @_builtins.property
    @pulumi.getter(name="clusterAuthEndpoint")
    def cluster_auth_endpoint(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointResult':
        """
        Local cluster auth endpoint
        """
        return pulumi.get(self, "cluster_auth_endpoint")

    @_builtins.property
    @pulumi.getter(name="defaultClusterRoleForProjectMembers")
    def default_cluster_role_for_project_members(self) -> _builtins.str:
        """
        Default cluster role for project members
        """
        return pulumi.get(self, "default_cluster_role_for_project_members")

    @_builtins.property
    @pulumi.getter(name="defaultPodSecurityAdmissionConfigurationTemplateName")
    def default_pod_security_admission_configuration_template_name(self) -> _builtins.str:
        """
        Default pod security admission configuration template name
        """
        return pulumi.get(self, "default_pod_security_admission_configuration_template_name")

    @_builtins.property
    @pulumi.getter(name="desiredAgentImage")
    def desired_agent_image(self) -> _builtins.str:
        """
        Desired agent image
        """
        return pulumi.get(self, "desired_agent_image")

    @_builtins.property
    @pulumi.getter(name="desiredAuthImage")
    def desired_auth_image(self) -> _builtins.str:
        """
        Desired auth image
        """
        return pulumi.get(self, "desired_auth_image")

    @_builtins.property
    @pulumi.getter(name="dockerRootDir")
    def docker_root_dir(self) -> _builtins.str:
        """
        Docker Root Dir
        """
        return pulumi.get(self, "docker_root_dir")

    @_builtins.property
    @pulumi.getter(name="rkeConfig")
    def rke_config(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigResult':
        """
        Rancher Kubernetes Engine Config
        """
        return pulumi.get(self, "rke_config")

    @_builtins.property
    @pulumi.getter(name="enableNetworkPolicy")
    def enable_network_policy(self) -> Optional[_builtins.bool]:
        """
        Enable project network isolation
        """
        return pulumi.get(self, "enable_network_policy")

    @_builtins.property
    @pulumi.getter(name="windowsPreferedCluster")
    def windows_prefered_cluster(self) -> Optional[_builtins.bool]:
        """
        Windows prefered cluster
        """
        return pulumi.get(self, "windows_prefered_cluster")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpointResult(dict):
    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigResult(dict):
    def __init__(__self__, *,
                 addon_job_timeout: _builtins.int,
                 authentication: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationResult',
                 authorization: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationResult',
                 bastion_host: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostResult',
                 cloud_provider: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderResult',
                 dns: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsResult',
                 ingress: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressResult',
                 kubernetes_version: _builtins.str,
                 monitoring: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringResult',
                 network: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkResult',
                 prefix_path: _builtins.str,
                 services: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesResult',
                 ssh_cert_path: _builtins.str,
                 ssh_key_path: _builtins.str,
                 upgrade_strategy: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyResult',
                 win_prefix_path: _builtins.str,
                 addons: Optional[_builtins.str] = None,
                 addons_includes: Optional[Sequence[_builtins.str]] = None,
                 enable_cri_dockerd: Optional[_builtins.bool] = None,
                 ignore_docker_version: Optional[_builtins.bool] = None,
                 nodes: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeResult']] = None,
                 private_registries: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryResult']] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None):
        """
        :param _builtins.int addon_job_timeout: Optional duration in seconds of addon job.
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationArgs' authentication: Kubernetes cluster authentication
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationArgs' authorization: Kubernetes cluster authorization
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostArgs' bastion_host: RKE bastion host
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressArgs' ingress: Kubernetes ingress configuration
        :param _builtins.str kubernetes_version: Optional kubernetes version to deploy
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringArgs' monitoring: Kubernetes cluster monitoring
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkArgs' network: Kubernetes cluster networking
        :param _builtins.str prefix_path: Optional prefix to customize kubernetes path
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesArgs' services: Kubernetes cluster services
        :param _builtins.str ssh_cert_path: Optional cluster level SSH certificate path
        :param _builtins.str ssh_key_path: Optional cluster level SSH private key path
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyArgs' upgrade_strategy: RKE upgrade strategy
        :param _builtins.str win_prefix_path: Optional prefix to customize kubernetes path for windows nodes
        :param _builtins.str addons: Optional addons descripton to deploy on rke cluster.
        :param Sequence[_builtins.str] addons_includes: Optional addons yaml manisfest to deploy on rke cluster.
        :param _builtins.bool enable_cri_dockerd: Enable/disable using cri-dockerd
        :param _builtins.bool ignore_docker_version: Optional ignore docker version on nodes
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeArgs'] nodes: Optional RKE cluster nodes
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryArgs'] private_registries: Optional private registries for docker images
        :param _builtins.bool ssh_agent_auth: Optional use ssh agent auth
        """
        pulumi.set(__self__, "addon_job_timeout", addon_job_timeout)
        pulumi.set(__self__, "authentication", authentication)
        pulumi.set(__self__, "authorization", authorization)
        pulumi.set(__self__, "bastion_host", bastion_host)
        pulumi.set(__self__, "cloud_provider", cloud_provider)
        pulumi.set(__self__, "dns", dns)
        pulumi.set(__self__, "ingress", ingress)
        pulumi.set(__self__, "kubernetes_version", kubernetes_version)
        pulumi.set(__self__, "monitoring", monitoring)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "prefix_path", prefix_path)
        pulumi.set(__self__, "services", services)
        pulumi.set(__self__, "ssh_cert_path", ssh_cert_path)
        pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)
        pulumi.set(__self__, "win_prefix_path", win_prefix_path)
        if addons is not None:
            pulumi.set(__self__, "addons", addons)
        if addons_includes is not None:
            pulumi.set(__self__, "addons_includes", addons_includes)
        if enable_cri_dockerd is not None:
            pulumi.set(__self__, "enable_cri_dockerd", enable_cri_dockerd)
        if ignore_docker_version is not None:
            pulumi.set(__self__, "ignore_docker_version", ignore_docker_version)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if private_registries is not None:
            pulumi.set(__self__, "private_registries", private_registries)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)

    @_builtins.property
    @pulumi.getter(name="addonJobTimeout")
    def addon_job_timeout(self) -> _builtins.int:
        """
        Optional duration in seconds of addon job.
        """
        return pulumi.get(self, "addon_job_timeout")

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationResult':
        """
        Kubernetes cluster authentication
        """
        return pulumi.get(self, "authentication")

    @_builtins.property
    @pulumi.getter
    def authorization(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationResult':
        """
        Kubernetes cluster authorization
        """
        return pulumi.get(self, "authorization")

    @_builtins.property
    @pulumi.getter(name="bastionHost")
    def bastion_host(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostResult':
        """
        RKE bastion host
        """
        return pulumi.get(self, "bastion_host")

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderResult':
        return pulumi.get(self, "cloud_provider")

    @_builtins.property
    @pulumi.getter
    def dns(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsResult':
        return pulumi.get(self, "dns")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressResult':
        """
        Kubernetes ingress configuration
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> _builtins.str:
        """
        Optional kubernetes version to deploy
        """
        return pulumi.get(self, "kubernetes_version")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringResult':
        """
        Kubernetes cluster monitoring
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def network(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkResult':
        """
        Kubernetes cluster networking
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="prefixPath")
    def prefix_path(self) -> _builtins.str:
        """
        Optional prefix to customize kubernetes path
        """
        return pulumi.get(self, "prefix_path")

    @_builtins.property
    @pulumi.getter
    def services(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesResult':
        """
        Kubernetes cluster services
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="sshCertPath")
    def ssh_cert_path(self) -> _builtins.str:
        """
        Optional cluster level SSH certificate path
        """
        return pulumi.get(self, "ssh_cert_path")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> _builtins.str:
        """
        Optional cluster level SSH private key path
        """
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyResult':
        """
        RKE upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")

    @_builtins.property
    @pulumi.getter(name="winPrefixPath")
    def win_prefix_path(self) -> _builtins.str:
        """
        Optional prefix to customize kubernetes path for windows nodes
        """
        return pulumi.get(self, "win_prefix_path")

    @_builtins.property
    @pulumi.getter
    def addons(self) -> Optional[_builtins.str]:
        """
        Optional addons descripton to deploy on rke cluster.
        """
        return pulumi.get(self, "addons")

    @_builtins.property
    @pulumi.getter(name="addonsIncludes")
    def addons_includes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional addons yaml manisfest to deploy on rke cluster.
        """
        return pulumi.get(self, "addons_includes")

    @_builtins.property
    @pulumi.getter(name="enableCriDockerd")
    def enable_cri_dockerd(self) -> Optional[_builtins.bool]:
        """
        Enable/disable using cri-dockerd
        """
        return pulumi.get(self, "enable_cri_dockerd")

    @_builtins.property
    @pulumi.getter(name="ignoreDockerVersion")
    def ignore_docker_version(self) -> Optional[_builtins.bool]:
        """
        Optional ignore docker version on nodes
        """
        return pulumi.get(self, "ignore_docker_version")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeResult']]:
        """
        Optional RKE cluster nodes
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter(name="privateRegistries")
    def private_registries(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryResult']]:
        """
        Optional private registries for docker images
        """
        return pulumi.get(self, "private_registries")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        """
        Optional use ssh agent auth
        """
        return pulumi.get(self, "ssh_agent_auth")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthenticationResult(dict):
    def __init__(__self__, *,
                 sans: Sequence[_builtins.str],
                 strategy: _builtins.str):
        pulumi.set(__self__, "sans", sans)
        pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter
    def sans(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "sans")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> _builtins.str:
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorizationResult(dict):
    def __init__(__self__, *,
                 options: Mapping[str, _builtins.str],
                 mode: Optional[_builtins.str] = None):
        pulumi.set(__self__, "options", options)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHostResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 ssh_key: _builtins.str,
                 ssh_key_path: _builtins.str,
                 user: _builtins.str,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        pulumi.set(__self__, "user", user)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ssh_agent_auth")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderResult(dict):
    def __init__(__self__, *,
                 custom_cloud_provider: _builtins.str,
                 aws_cloud_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderResult'] = None,
                 azure_cloud_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderResult'] = None,
                 name: Optional[_builtins.str] = None,
                 openstack_cloud_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderResult'] = None,
                 vsphere_cloud_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderResult'] = None):
        """
        :param _builtins.str name: The cluster template name (string)
        """
        pulumi.set(__self__, "custom_cloud_provider", custom_cloud_provider)
        if aws_cloud_provider is not None:
            pulumi.set(__self__, "aws_cloud_provider", aws_cloud_provider)
        if azure_cloud_provider is not None:
            pulumi.set(__self__, "azure_cloud_provider", azure_cloud_provider)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if openstack_cloud_provider is not None:
            pulumi.set(__self__, "openstack_cloud_provider", openstack_cloud_provider)
        if vsphere_cloud_provider is not None:
            pulumi.set(__self__, "vsphere_cloud_provider", vsphere_cloud_provider)

    @_builtins.property
    @pulumi.getter(name="customCloudProvider")
    def custom_cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "custom_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="awsCloudProvider")
    def aws_cloud_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderResult']:
        return pulumi.get(self, "aws_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="azureCloudProvider")
    def azure_cloud_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderResult']:
        return pulumi.get(self, "azure_cloud_provider")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openstackCloudProvider")
    def openstack_cloud_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderResult']:
        return pulumi.get(self, "openstack_cloud_provider")

    @_builtins.property
    @pulumi.getter(name="vsphereCloudProvider")
    def vsphere_cloud_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderResult']:
        return pulumi.get(self, "vsphere_cloud_provider")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderResult(dict):
    def __init__(__self__, *,
                 global_: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalResult',
                 service_overrides: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult']] = None):
        pulumi.set(__self__, "global_", global_)
        if service_overrides is not None:
            pulumi.set(__self__, "service_overrides", service_overrides)

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalResult':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="serviceOverrides")
    def service_overrides(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult']]:
        return pulumi.get(self, "service_overrides")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobalResult(dict):
    def __init__(__self__, *,
                 elb_security_group: _builtins.str,
                 kubernetes_cluster_id: _builtins.str,
                 kubernetes_cluster_tag: _builtins.str,
                 role_arn: _builtins.str,
                 route_table_id: _builtins.str,
                 subnet_id: _builtins.str,
                 vpc: _builtins.str,
                 zone: _builtins.str,
                 disable_security_group_ingress: Optional[_builtins.bool] = None,
                 disable_strict_zone_check: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "elb_security_group", elb_security_group)
        pulumi.set(__self__, "kubernetes_cluster_id", kubernetes_cluster_id)
        pulumi.set(__self__, "kubernetes_cluster_tag", kubernetes_cluster_tag)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "route_table_id", route_table_id)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "vpc", vpc)
        pulumi.set(__self__, "zone", zone)
        if disable_security_group_ingress is not None:
            pulumi.set(__self__, "disable_security_group_ingress", disable_security_group_ingress)
        if disable_strict_zone_check is not None:
            pulumi.set(__self__, "disable_strict_zone_check", disable_strict_zone_check)

    @_builtins.property
    @pulumi.getter(name="elbSecurityGroup")
    def elb_security_group(self) -> _builtins.str:
        return pulumi.get(self, "elb_security_group")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterId")
    def kubernetes_cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "kubernetes_cluster_id")

    @_builtins.property
    @pulumi.getter(name="kubernetesClusterTag")
    def kubernetes_cluster_tag(self) -> _builtins.str:
        return pulumi.get(self, "kubernetes_cluster_tag")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter(name="routeTableId")
    def route_table_id(self) -> _builtins.str:
        return pulumi.get(self, "route_table_id")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        return pulumi.get(self, "vpc")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> _builtins.str:
        return pulumi.get(self, "zone")

    @_builtins.property
    @pulumi.getter(name="disableSecurityGroupIngress")
    def disable_security_group_ingress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_security_group_ingress")

    @_builtins.property
    @pulumi.getter(name="disableStrictZoneCheck")
    def disable_strict_zone_check(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "disable_strict_zone_check")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverrideResult(dict):
    def __init__(__self__, *,
                 region: _builtins.str,
                 service: _builtins.str,
                 signing_method: _builtins.str,
                 signing_name: _builtins.str,
                 signing_region: _builtins.str,
                 url: _builtins.str):
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "signing_method", signing_method)
        pulumi.set(__self__, "signing_name", signing_name)
        pulumi.set(__self__, "signing_region", signing_region)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="signingMethod")
    def signing_method(self) -> _builtins.str:
        return pulumi.get(self, "signing_method")

    @_builtins.property
    @pulumi.getter(name="signingName")
    def signing_name(self) -> _builtins.str:
        return pulumi.get(self, "signing_name")

    @_builtins.property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> _builtins.str:
        return pulumi.get(self, "signing_region")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProviderResult(dict):
    def __init__(__self__, *,
                 aad_client_cert_password: _builtins.str,
                 aad_client_cert_path: _builtins.str,
                 aad_client_id: _builtins.str,
                 aad_client_secret: _builtins.str,
                 cloud: _builtins.str,
                 cloud_provider_backoff: _builtins.bool,
                 cloud_provider_backoff_duration: _builtins.int,
                 cloud_provider_backoff_exponent: _builtins.int,
                 cloud_provider_backoff_jitter: _builtins.int,
                 cloud_provider_backoff_retries: _builtins.int,
                 cloud_provider_rate_limit: _builtins.bool,
                 cloud_provider_rate_limit_bucket: _builtins.int,
                 cloud_provider_rate_limit_qps: _builtins.int,
                 location: _builtins.str,
                 maximum_load_balancer_rule_count: _builtins.int,
                 primary_availability_set_name: _builtins.str,
                 primary_scale_set_name: _builtins.str,
                 resource_group: _builtins.str,
                 route_table_name: _builtins.str,
                 security_group_name: _builtins.str,
                 subnet_name: _builtins.str,
                 subscription_id: _builtins.str,
                 tenant_id: _builtins.str,
                 use_instance_metadata: _builtins.bool,
                 use_managed_identity_extension: _builtins.bool,
                 vm_type: _builtins.str,
                 vnet_name: _builtins.str,
                 vnet_resource_group: _builtins.str,
                 load_balancer_sku: Optional[_builtins.str] = None):
        """
        :param _builtins.str load_balancer_sku: Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        pulumi.set(__self__, "aad_client_cert_password", aad_client_cert_password)
        pulumi.set(__self__, "aad_client_cert_path", aad_client_cert_path)
        pulumi.set(__self__, "aad_client_id", aad_client_id)
        pulumi.set(__self__, "aad_client_secret", aad_client_secret)
        pulumi.set(__self__, "cloud", cloud)
        pulumi.set(__self__, "cloud_provider_backoff", cloud_provider_backoff)
        pulumi.set(__self__, "cloud_provider_backoff_duration", cloud_provider_backoff_duration)
        pulumi.set(__self__, "cloud_provider_backoff_exponent", cloud_provider_backoff_exponent)
        pulumi.set(__self__, "cloud_provider_backoff_jitter", cloud_provider_backoff_jitter)
        pulumi.set(__self__, "cloud_provider_backoff_retries", cloud_provider_backoff_retries)
        pulumi.set(__self__, "cloud_provider_rate_limit", cloud_provider_rate_limit)
        pulumi.set(__self__, "cloud_provider_rate_limit_bucket", cloud_provider_rate_limit_bucket)
        pulumi.set(__self__, "cloud_provider_rate_limit_qps", cloud_provider_rate_limit_qps)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "maximum_load_balancer_rule_count", maximum_load_balancer_rule_count)
        pulumi.set(__self__, "primary_availability_set_name", primary_availability_set_name)
        pulumi.set(__self__, "primary_scale_set_name", primary_scale_set_name)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "route_table_name", route_table_name)
        pulumi.set(__self__, "security_group_name", security_group_name)
        pulumi.set(__self__, "subnet_name", subnet_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "use_instance_metadata", use_instance_metadata)
        pulumi.set(__self__, "use_managed_identity_extension", use_managed_identity_extension)
        pulumi.set(__self__, "vm_type", vm_type)
        pulumi.set(__self__, "vnet_name", vnet_name)
        pulumi.set(__self__, "vnet_resource_group", vnet_resource_group)
        if load_balancer_sku is not None:
            pulumi.set(__self__, "load_balancer_sku", load_balancer_sku)

    @_builtins.property
    @pulumi.getter(name="aadClientCertPassword")
    def aad_client_cert_password(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_cert_password")

    @_builtins.property
    @pulumi.getter(name="aadClientCertPath")
    def aad_client_cert_path(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_cert_path")

    @_builtins.property
    @pulumi.getter(name="aadClientId")
    def aad_client_id(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_id")

    @_builtins.property
    @pulumi.getter(name="aadClientSecret")
    def aad_client_secret(self) -> _builtins.str:
        return pulumi.get(self, "aad_client_secret")

    @_builtins.property
    @pulumi.getter
    def cloud(self) -> _builtins.str:
        return pulumi.get(self, "cloud")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoff")
    def cloud_provider_backoff(self) -> _builtins.bool:
        return pulumi.get(self, "cloud_provider_backoff")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffDuration")
    def cloud_provider_backoff_duration(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_duration")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffExponent")
    def cloud_provider_backoff_exponent(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_exponent")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffJitter")
    def cloud_provider_backoff_jitter(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_jitter")

    @_builtins.property
    @pulumi.getter(name="cloudProviderBackoffRetries")
    def cloud_provider_backoff_retries(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_backoff_retries")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimit")
    def cloud_provider_rate_limit(self) -> _builtins.bool:
        return pulumi.get(self, "cloud_provider_rate_limit")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitBucket")
    def cloud_provider_rate_limit_bucket(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_rate_limit_bucket")

    @_builtins.property
    @pulumi.getter(name="cloudProviderRateLimitQps")
    def cloud_provider_rate_limit_qps(self) -> _builtins.int:
        return pulumi.get(self, "cloud_provider_rate_limit_qps")

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="maximumLoadBalancerRuleCount")
    def maximum_load_balancer_rule_count(self) -> _builtins.int:
        return pulumi.get(self, "maximum_load_balancer_rule_count")

    @_builtins.property
    @pulumi.getter(name="primaryAvailabilitySetName")
    def primary_availability_set_name(self) -> _builtins.str:
        return pulumi.get(self, "primary_availability_set_name")

    @_builtins.property
    @pulumi.getter(name="primaryScaleSetName")
    def primary_scale_set_name(self) -> _builtins.str:
        return pulumi.get(self, "primary_scale_set_name")

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> _builtins.str:
        return pulumi.get(self, "resource_group")

    @_builtins.property
    @pulumi.getter(name="routeTableName")
    def route_table_name(self) -> _builtins.str:
        return pulumi.get(self, "route_table_name")

    @_builtins.property
    @pulumi.getter(name="securityGroupName")
    def security_group_name(self) -> _builtins.str:
        return pulumi.get(self, "security_group_name")

    @_builtins.property
    @pulumi.getter(name="subnetName")
    def subnet_name(self) -> _builtins.str:
        return pulumi.get(self, "subnet_name")

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> _builtins.str:
        return pulumi.get(self, "subscription_id")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="useInstanceMetadata")
    def use_instance_metadata(self) -> _builtins.bool:
        return pulumi.get(self, "use_instance_metadata")

    @_builtins.property
    @pulumi.getter(name="useManagedIdentityExtension")
    def use_managed_identity_extension(self) -> _builtins.bool:
        return pulumi.get(self, "use_managed_identity_extension")

    @_builtins.property
    @pulumi.getter(name="vmType")
    def vm_type(self) -> _builtins.str:
        return pulumi.get(self, "vm_type")

    @_builtins.property
    @pulumi.getter(name="vnetName")
    def vnet_name(self) -> _builtins.str:
        return pulumi.get(self, "vnet_name")

    @_builtins.property
    @pulumi.getter(name="vnetResourceGroup")
    def vnet_resource_group(self) -> _builtins.str:
        return pulumi.get(self, "vnet_resource_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerSku")
    def load_balancer_sku(self) -> Optional[_builtins.str]:
        """
        Load balancer type (basic | standard). Must be standard for auto-scaling
        """
        return pulumi.get(self, "load_balancer_sku")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderResult(dict):
    def __init__(__self__, *,
                 block_storage: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult',
                 global_: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalResult',
                 load_balancer: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult',
                 metadata: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataResult',
                 route: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteResult'):
        pulumi.set(__self__, "block_storage", block_storage)
        pulumi.set(__self__, "global_", global_)
        pulumi.set(__self__, "load_balancer", load_balancer)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "route", route)

    @_builtins.property
    @pulumi.getter(name="blockStorage")
    def block_storage(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult':
        return pulumi.get(self, "block_storage")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalResult':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult':
        return pulumi.get(self, "load_balancer")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataResult':
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def route(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteResult':
        return pulumi.get(self, "route")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult(dict):
    def __init__(__self__, *,
                 bs_version: _builtins.str,
                 ignore_volume_az: _builtins.bool,
                 trust_device_path: _builtins.bool):
        pulumi.set(__self__, "bs_version", bs_version)
        pulumi.set(__self__, "ignore_volume_az", ignore_volume_az)
        pulumi.set(__self__, "trust_device_path", trust_device_path)

    @_builtins.property
    @pulumi.getter(name="bsVersion")
    def bs_version(self) -> _builtins.str:
        return pulumi.get(self, "bs_version")

    @_builtins.property
    @pulumi.getter(name="ignoreVolumeAz")
    def ignore_volume_az(self) -> _builtins.bool:
        return pulumi.get(self, "ignore_volume_az")

    @_builtins.property
    @pulumi.getter(name="trustDevicePath")
    def trust_device_path(self) -> _builtins.bool:
        return pulumi.get(self, "trust_device_path")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobalResult(dict):
    def __init__(__self__, *,
                 auth_url: _builtins.str,
                 ca_file: _builtins.str,
                 domain_id: _builtins.str,
                 domain_name: _builtins.str,
                 password: _builtins.str,
                 region: _builtins.str,
                 tenant_id: _builtins.str,
                 tenant_name: _builtins.str,
                 trust_id: _builtins.str,
                 username: _builtins.str):
        pulumi.set(__self__, "auth_url", auth_url)
        pulumi.set(__self__, "ca_file", ca_file)
        pulumi.set(__self__, "domain_id", domain_id)
        pulumi.set(__self__, "domain_name", domain_name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tenant_id", tenant_id)
        pulumi.set(__self__, "tenant_name", tenant_name)
        pulumi.set(__self__, "trust_id", trust_id)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="authUrl")
    def auth_url(self) -> _builtins.str:
        return pulumi.get(self, "auth_url")

    @_builtins.property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> _builtins.str:
        return pulumi.get(self, "ca_file")

    @_builtins.property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> _builtins.str:
        return pulumi.get(self, "domain_id")

    @_builtins.property
    @pulumi.getter(name="domainName")
    def domain_name(self) -> _builtins.str:
        return pulumi.get(self, "domain_name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> _builtins.str:
        return pulumi.get(self, "tenant_id")

    @_builtins.property
    @pulumi.getter(name="tenantName")
    def tenant_name(self) -> _builtins.str:
        return pulumi.get(self, "tenant_name")

    @_builtins.property
    @pulumi.getter(name="trustId")
    def trust_id(self) -> _builtins.str:
        return pulumi.get(self, "trust_id")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult(dict):
    def __init__(__self__, *,
                 create_monitor: _builtins.bool,
                 floating_network_id: _builtins.str,
                 lb_method: _builtins.str,
                 lb_provider: _builtins.str,
                 lb_version: _builtins.str,
                 manage_security_groups: _builtins.bool,
                 subnet_id: _builtins.str,
                 use_octavia: _builtins.bool,
                 monitor_delay: Optional[_builtins.str] = None,
                 monitor_max_retries: Optional[_builtins.int] = None,
                 monitor_timeout: Optional[_builtins.str] = None):
        pulumi.set(__self__, "create_monitor", create_monitor)
        pulumi.set(__self__, "floating_network_id", floating_network_id)
        pulumi.set(__self__, "lb_method", lb_method)
        pulumi.set(__self__, "lb_provider", lb_provider)
        pulumi.set(__self__, "lb_version", lb_version)
        pulumi.set(__self__, "manage_security_groups", manage_security_groups)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "use_octavia", use_octavia)
        if monitor_delay is not None:
            pulumi.set(__self__, "monitor_delay", monitor_delay)
        if monitor_max_retries is not None:
            pulumi.set(__self__, "monitor_max_retries", monitor_max_retries)
        if monitor_timeout is not None:
            pulumi.set(__self__, "monitor_timeout", monitor_timeout)

    @_builtins.property
    @pulumi.getter(name="createMonitor")
    def create_monitor(self) -> _builtins.bool:
        return pulumi.get(self, "create_monitor")

    @_builtins.property
    @pulumi.getter(name="floatingNetworkId")
    def floating_network_id(self) -> _builtins.str:
        return pulumi.get(self, "floating_network_id")

    @_builtins.property
    @pulumi.getter(name="lbMethod")
    def lb_method(self) -> _builtins.str:
        return pulumi.get(self, "lb_method")

    @_builtins.property
    @pulumi.getter(name="lbProvider")
    def lb_provider(self) -> _builtins.str:
        return pulumi.get(self, "lb_provider")

    @_builtins.property
    @pulumi.getter(name="lbVersion")
    def lb_version(self) -> _builtins.str:
        return pulumi.get(self, "lb_version")

    @_builtins.property
    @pulumi.getter(name="manageSecurityGroups")
    def manage_security_groups(self) -> _builtins.bool:
        return pulumi.get(self, "manage_security_groups")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> _builtins.str:
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="useOctavia")
    def use_octavia(self) -> _builtins.bool:
        return pulumi.get(self, "use_octavia")

    @_builtins.property
    @pulumi.getter(name="monitorDelay")
    def monitor_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitor_delay")

    @_builtins.property
    @pulumi.getter(name="monitorMaxRetries")
    def monitor_max_retries(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "monitor_max_retries")

    @_builtins.property
    @pulumi.getter(name="monitorTimeout")
    def monitor_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "monitor_timeout")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadataResult(dict):
    def __init__(__self__, *,
                 request_timeout: _builtins.int,
                 search_order: _builtins.str):
        pulumi.set(__self__, "request_timeout", request_timeout)
        pulumi.set(__self__, "search_order", search_order)

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> _builtins.int:
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="searchOrder")
    def search_order(self) -> _builtins.str:
        return pulumi.get(self, "search_order")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRouteResult(dict):
    def __init__(__self__, *,
                 router_id: _builtins.str):
        pulumi.set(__self__, "router_id", router_id)

    @_builtins.property
    @pulumi.getter(name="routerId")
    def router_id(self) -> _builtins.str:
        return pulumi.get(self, "router_id")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderResult(dict):
    def __init__(__self__, *,
                 disk: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskResult',
                 global_: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalResult',
                 network: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkResult',
                 virtual_centers: Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult'],
                 workspace: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult'):
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "global_", global_)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "virtual_centers", virtual_centers)
        pulumi.set(__self__, "workspace", workspace)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskResult':
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="global")
    def global_(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalResult':
        return pulumi.get(self, "global_")

    @_builtins.property
    @pulumi.getter
    def network(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkResult':
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter(name="virtualCenters")
    def virtual_centers(self) -> Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult']:
        return pulumi.get(self, "virtual_centers")

    @_builtins.property
    @pulumi.getter
    def workspace(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult':
        return pulumi.get(self, "workspace")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDiskResult(dict):
    def __init__(__self__, *,
                 scsi_controller_type: _builtins.str):
        pulumi.set(__self__, "scsi_controller_type", scsi_controller_type)

    @_builtins.property
    @pulumi.getter(name="scsiControllerType")
    def scsi_controller_type(self) -> _builtins.str:
        return pulumi.get(self, "scsi_controller_type")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobalResult(dict):
    def __init__(__self__, *,
                 datacenters: _builtins.str,
                 insecure_flag: _builtins.bool,
                 password: _builtins.str,
                 port: _builtins.str,
                 soap_roundtrip_count: _builtins.int,
                 user: _builtins.str,
                 graceful_shutdown_timeout: Optional[_builtins.str] = None):
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "insecure_flag", insecure_flag)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        pulumi.set(__self__, "user", user)
        if graceful_shutdown_timeout is not None:
            pulumi.set(__self__, "graceful_shutdown_timeout", graceful_shutdown_timeout)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> _builtins.str:
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="insecureFlag")
    def insecure_flag(self) -> _builtins.bool:
        return pulumi.get(self, "insecure_flag")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> _builtins.int:
        return pulumi.get(self, "soap_roundtrip_count")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="gracefulShutdownTimeout")
    def graceful_shutdown_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "graceful_shutdown_timeout")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetworkResult(dict):
    def __init__(__self__, *,
                 public_network: _builtins.str):
        pulumi.set(__self__, "public_network", public_network)

    @_builtins.property
    @pulumi.getter(name="publicNetwork")
    def public_network(self) -> _builtins.str:
        return pulumi.get(self, "public_network")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenterResult(dict):
    def __init__(__self__, *,
                 datacenters: _builtins.str,
                 name: _builtins.str,
                 password: _builtins.str,
                 port: _builtins.str,
                 soap_roundtrip_count: _builtins.int,
                 user: _builtins.str):
        """
        :param _builtins.str name: The cluster template name (string)
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "soap_roundtrip_count", soap_roundtrip_count)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> _builtins.str:
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="soapRoundtripCount")
    def soap_roundtrip_count(self) -> _builtins.int:
        return pulumi.get(self, "soap_roundtrip_count")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult(dict):
    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 default_datastore: _builtins.str,
                 folder: _builtins.str,
                 resourcepool_path: _builtins.str,
                 server: _builtins.str):
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "default_datastore", default_datastore)
        pulumi.set(__self__, "folder", folder)
        pulumi.set(__self__, "resourcepool_path", resourcepool_path)
        pulumi.set(__self__, "server", server)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter(name="defaultDatastore")
    def default_datastore(self) -> _builtins.str:
        return pulumi.get(self, "default_datastore")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> _builtins.str:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter(name="resourcepoolPath")
    def resourcepool_path(self) -> _builtins.str:
        return pulumi.get(self, "resourcepool_path")

    @_builtins.property
    @pulumi.getter
    def server(self) -> _builtins.str:
        return pulumi.get(self, "server")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsResult(dict):
    def __init__(__self__, *,
                 node_selector: Mapping[str, _builtins.str],
                 options: Mapping[str, _builtins.str],
                 reverse_cidrs: Sequence[_builtins.str],
                 upstream_nameservers: Sequence[_builtins.str],
                 linear_autoscaler_params: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsResult'] = None,
                 nodelocal: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalResult'] = None,
                 provider: Optional[_builtins.str] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationResult']] = None,
                 update_strategy: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyResult'] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsArgs' linear_autoscaler_params: Linear Autoscaler Params
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalArgs' nodelocal: Nodelocal dns
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationArgs'] tolerations: DNS service tolerations
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "reverse_cidrs", reverse_cidrs)
        pulumi.set(__self__, "upstream_nameservers", upstream_nameservers)
        if linear_autoscaler_params is not None:
            pulumi.set(__self__, "linear_autoscaler_params", linear_autoscaler_params)
        if nodelocal is not None:
            pulumi.set(__self__, "nodelocal", nodelocal)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter(name="reverseCidrs")
    def reverse_cidrs(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "reverse_cidrs")

    @_builtins.property
    @pulumi.getter(name="upstreamNameservers")
    def upstream_nameservers(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "upstream_nameservers")

    @_builtins.property
    @pulumi.getter(name="linearAutoscalerParams")
    def linear_autoscaler_params(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsResult']:
        """
        Linear Autoscaler Params
        """
        return pulumi.get(self, "linear_autoscaler_params")

    @_builtins.property
    @pulumi.getter
    def nodelocal(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalResult']:
        """
        Nodelocal dns
        """
        return pulumi.get(self, "nodelocal")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationResult']]:
        """
        DNS service tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyResult']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParamsResult(dict):
    def __init__(__self__, *,
                 cores_per_replica: Optional[_builtins.float] = None,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None,
                 nodes_per_replica: Optional[_builtins.float] = None,
                 prevent_single_point_failure: Optional[_builtins.bool] = None):
        if cores_per_replica is not None:
            pulumi.set(__self__, "cores_per_replica", cores_per_replica)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if nodes_per_replica is not None:
            pulumi.set(__self__, "nodes_per_replica", nodes_per_replica)
        if prevent_single_point_failure is not None:
            pulumi.set(__self__, "prevent_single_point_failure", prevent_single_point_failure)

    @_builtins.property
    @pulumi.getter(name="coresPerReplica")
    def cores_per_replica(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "cores_per_replica")

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min")

    @_builtins.property
    @pulumi.getter(name="nodesPerReplica")
    def nodes_per_replica(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "nodes_per_replica")

    @_builtins.property
    @pulumi.getter(name="preventSinglePointFailure")
    def prevent_single_point_failure(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "prevent_single_point_failure")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocalResult(dict):
    def __init__(__self__, *,
                 ip_address: Optional[_builtins.str] = None,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] node_selector: Node selector key pair
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Node selector key pair
        """
        return pulumi.get(self, "node_selector")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyResult(dict):
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateResult'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateResult']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressResult(dict):
    def __init__(__self__, *,
                 dns_policy: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 http_port: _builtins.int,
                 https_port: _builtins.int,
                 network_mode: _builtins.str,
                 node_selector: Mapping[str, _builtins.str],
                 options: Mapping[str, _builtins.str],
                 provider: _builtins.str,
                 default_backend: Optional[_builtins.bool] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationResult']] = None,
                 update_strategy: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyResult'] = None):
        """
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationArgs'] tolerations: Ingress add-on tolerations
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyArgs' update_strategy: Update daemon set strategy
        """
        pulumi.set(__self__, "dns_policy", dns_policy)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "https_port", https_port)
        pulumi.set(__self__, "network_mode", network_mode)
        pulumi.set(__self__, "node_selector", node_selector)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "provider", provider)
        if default_backend is not None:
            pulumi.set(__self__, "default_backend", default_backend)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter(name="dnsPolicy")
    def dns_policy(self) -> _builtins.str:
        return pulumi.get(self, "dns_policy")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> _builtins.int:
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="httpsPort")
    def https_port(self) -> _builtins.int:
        return pulumi.get(self, "https_port")

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> _builtins.str:
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="defaultBackend")
    def default_backend(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "default_backend")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationResult']]:
        """
        Ingress add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyResult']:
        """
        Update daemon set strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyResult(dict):
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateResult'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateResult']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringResult(dict):
    def __init__(__self__, *,
                 options: Mapping[str, _builtins.str],
                 provider: _builtins.str,
                 replicas: _builtins.int,
                 node_selector: Optional[Mapping[str, _builtins.str]] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationResult']] = None,
                 update_strategy: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyResult'] = None):
        """
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationArgs'] tolerations: Monitoring add-on tolerations
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyArgs' update_strategy: Update deployment strategy
        """
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "provider", provider)
        pulumi.set(__self__, "replicas", replicas)
        if node_selector is not None:
            pulumi.set(__self__, "node_selector", node_selector)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if update_strategy is not None:
            pulumi.set(__self__, "update_strategy", update_strategy)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> _builtins.str:
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> _builtins.int:
        return pulumi.get(self, "replicas")

    @_builtins.property
    @pulumi.getter(name="nodeSelector")
    def node_selector(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_selector")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationResult']]:
        """
        Monitoring add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="updateStrategy")
    def update_strategy(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyResult']:
        """
        Update deployment strategy
        """
        return pulumi.get(self, "update_strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyResult(dict):
    def __init__(__self__, *,
                 rolling_update: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateResult'] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateArgs' rolling_update: Rolling update for update strategy
        :param _builtins.str strategy: Strategy
        """
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateResult']:
        """
        Rolling update for update strategy
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_surge: Optional[_builtins.int] = None,
                 max_unavailable: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_surge: Rolling update max surge
        :param _builtins.int max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.int]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.int]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkResult(dict):
    def __init__(__self__, *,
                 options: Mapping[str, _builtins.str],
                 plugin: _builtins.str,
                 aci_network_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderResult'] = None,
                 calico_network_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderResult'] = None,
                 canal_network_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderResult'] = None,
                 flannel_network_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderResult'] = None,
                 mtu: Optional[_builtins.int] = None,
                 tolerations: Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationResult']] = None,
                 weave_network_provider: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderResult'] = None):
        """
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationArgs'] tolerations: Network add-on tolerations
        """
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "plugin", plugin)
        if aci_network_provider is not None:
            pulumi.set(__self__, "aci_network_provider", aci_network_provider)
        if calico_network_provider is not None:
            pulumi.set(__self__, "calico_network_provider", calico_network_provider)
        if canal_network_provider is not None:
            pulumi.set(__self__, "canal_network_provider", canal_network_provider)
        if flannel_network_provider is not None:
            pulumi.set(__self__, "flannel_network_provider", flannel_network_provider)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if tolerations is not None:
            pulumi.set(__self__, "tolerations", tolerations)
        if weave_network_provider is not None:
            pulumi.set(__self__, "weave_network_provider", weave_network_provider)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "options")

    @_builtins.property
    @pulumi.getter
    def plugin(self) -> _builtins.str:
        return pulumi.get(self, "plugin")

    @_builtins.property
    @pulumi.getter(name="aciNetworkProvider")
    def aci_network_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderResult']:
        return pulumi.get(self, "aci_network_provider")

    @_builtins.property
    @pulumi.getter(name="calicoNetworkProvider")
    def calico_network_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderResult']:
        return pulumi.get(self, "calico_network_provider")

    @_builtins.property
    @pulumi.getter(name="canalNetworkProvider")
    def canal_network_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderResult']:
        return pulumi.get(self, "canal_network_provider")

    @_builtins.property
    @pulumi.getter(name="flannelNetworkProvider")
    def flannel_network_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderResult']:
        return pulumi.get(self, "flannel_network_provider")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter
    def tolerations(self) -> Optional[Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationResult']]:
        """
        Network add-on tolerations
        """
        return pulumi.get(self, "tolerations")

    @_builtins.property
    @pulumi.getter(name="weaveNetworkProvider")
    def weave_network_provider(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderResult']:
        return pulumi.get(self, "weave_network_provider")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProviderResult(dict):
    def __init__(__self__, *,
                 aep: _builtins.str,
                 apic_hosts: Sequence[_builtins.str],
                 apic_user_crt: _builtins.str,
                 apic_user_key: _builtins.str,
                 apic_user_name: _builtins.str,
                 encap_type: _builtins.str,
                 extern_dynamic: _builtins.str,
                 extern_static: _builtins.str,
                 kube_api_vlan: _builtins.str,
                 l3out: _builtins.str,
                 l3out_external_networks: Sequence[_builtins.str],
                 mcast_range_end: _builtins.str,
                 mcast_range_start: _builtins.str,
                 node_subnet: _builtins.str,
                 node_svc_subnet: _builtins.str,
                 service_vlan: _builtins.str,
                 system_id: _builtins.str,
                 token: _builtins.str,
                 vrf_name: _builtins.str,
                 vrf_tenant: _builtins.str,
                 apic_refresh_ticker_adjust: Optional[_builtins.str] = None,
                 apic_refresh_time: Optional[_builtins.str] = None,
                 apic_subscription_delay: Optional[_builtins.str] = None,
                 capic: Optional[_builtins.str] = None,
                 controller_log_level: Optional[_builtins.str] = None,
                 disable_periodic_snat_global_info_sync: Optional[_builtins.str] = None,
                 disable_wait_for_network: Optional[_builtins.str] = None,
                 drop_log_enable: Optional[_builtins.str] = None,
                 duration_wait_for_network: Optional[_builtins.str] = None,
                 enable_endpoint_slice: Optional[_builtins.str] = None,
                 ep_registry: Optional[_builtins.str] = None,
                 gbp_pod_subnet: Optional[_builtins.str] = None,
                 host_agent_log_level: Optional[_builtins.str] = None,
                 image_pull_policy: Optional[_builtins.str] = None,
                 image_pull_secret: Optional[_builtins.str] = None,
                 infra_vlan: Optional[_builtins.str] = None,
                 install_istio: Optional[_builtins.str] = None,
                 istio_profile: Optional[_builtins.str] = None,
                 kafka_brokers: Optional[Sequence[_builtins.str]] = None,
                 kafka_client_crt: Optional[_builtins.str] = None,
                 kafka_client_key: Optional[_builtins.str] = None,
                 max_nodes_svc_graph: Optional[_builtins.str] = None,
                 mtu_head_room: Optional[_builtins.str] = None,
                 multus_disable: Optional[_builtins.str] = None,
                 no_priority_class: Optional[_builtins.str] = None,
                 node_pod_if_enable: Optional[_builtins.str] = None,
                 opflex_client_ssl: Optional[_builtins.str] = None,
                 opflex_device_delete_timeout: Optional[_builtins.str] = None,
                 opflex_log_level: Optional[_builtins.str] = None,
                 opflex_mode: Optional[_builtins.str] = None,
                 opflex_server_port: Optional[_builtins.str] = None,
                 overlay_vrf_name: Optional[_builtins.str] = None,
                 ovs_memory_limit: Optional[_builtins.str] = None,
                 pbr_tracking_non_snat: Optional[_builtins.str] = None,
                 pod_subnet_chunk_size: Optional[_builtins.str] = None,
                 run_gbp_container: Optional[_builtins.str] = None,
                 run_opflex_server_container: Optional[_builtins.str] = None,
                 service_monitor_interval: Optional[_builtins.str] = None,
                 snat_contract_scope: Optional[_builtins.str] = None,
                 snat_namespace: Optional[_builtins.str] = None,
                 snat_port_range_end: Optional[_builtins.str] = None,
                 snat_port_range_start: Optional[_builtins.str] = None,
                 snat_ports_per_node: Optional[_builtins.str] = None,
                 sriov_enable: Optional[_builtins.str] = None,
                 subnet_domain_name: Optional[_builtins.str] = None,
                 tenant: Optional[_builtins.str] = None,
                 use_aci_anywhere_crd: Optional[_builtins.str] = None,
                 use_aci_cni_priority_class: Optional[_builtins.str] = None,
                 use_cluster_role: Optional[_builtins.str] = None,
                 use_host_netns_volume: Optional[_builtins.str] = None,
                 use_opflex_server_volume: Optional[_builtins.str] = None,
                 use_privileged_container: Optional[_builtins.str] = None,
                 vmm_controller: Optional[_builtins.str] = None,
                 vmm_domain: Optional[_builtins.str] = None):
        pulumi.set(__self__, "aep", aep)
        pulumi.set(__self__, "apic_hosts", apic_hosts)
        pulumi.set(__self__, "apic_user_crt", apic_user_crt)
        pulumi.set(__self__, "apic_user_key", apic_user_key)
        pulumi.set(__self__, "apic_user_name", apic_user_name)
        pulumi.set(__self__, "encap_type", encap_type)
        pulumi.set(__self__, "extern_dynamic", extern_dynamic)
        pulumi.set(__self__, "extern_static", extern_static)
        pulumi.set(__self__, "kube_api_vlan", kube_api_vlan)
        pulumi.set(__self__, "l3out", l3out)
        pulumi.set(__self__, "l3out_external_networks", l3out_external_networks)
        pulumi.set(__self__, "mcast_range_end", mcast_range_end)
        pulumi.set(__self__, "mcast_range_start", mcast_range_start)
        pulumi.set(__self__, "node_subnet", node_subnet)
        pulumi.set(__self__, "node_svc_subnet", node_svc_subnet)
        pulumi.set(__self__, "service_vlan", service_vlan)
        pulumi.set(__self__, "system_id", system_id)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "vrf_name", vrf_name)
        pulumi.set(__self__, "vrf_tenant", vrf_tenant)
        if apic_refresh_ticker_adjust is not None:
            pulumi.set(__self__, "apic_refresh_ticker_adjust", apic_refresh_ticker_adjust)
        if apic_refresh_time is not None:
            pulumi.set(__self__, "apic_refresh_time", apic_refresh_time)
        if apic_subscription_delay is not None:
            pulumi.set(__self__, "apic_subscription_delay", apic_subscription_delay)
        if capic is not None:
            pulumi.set(__self__, "capic", capic)
        if controller_log_level is not None:
            pulumi.set(__self__, "controller_log_level", controller_log_level)
        if disable_periodic_snat_global_info_sync is not None:
            pulumi.set(__self__, "disable_periodic_snat_global_info_sync", disable_periodic_snat_global_info_sync)
        if disable_wait_for_network is not None:
            pulumi.set(__self__, "disable_wait_for_network", disable_wait_for_network)
        if drop_log_enable is not None:
            pulumi.set(__self__, "drop_log_enable", drop_log_enable)
        if duration_wait_for_network is not None:
            pulumi.set(__self__, "duration_wait_for_network", duration_wait_for_network)
        if enable_endpoint_slice is not None:
            pulumi.set(__self__, "enable_endpoint_slice", enable_endpoint_slice)
        if ep_registry is not None:
            pulumi.set(__self__, "ep_registry", ep_registry)
        if gbp_pod_subnet is not None:
            pulumi.set(__self__, "gbp_pod_subnet", gbp_pod_subnet)
        if host_agent_log_level is not None:
            pulumi.set(__self__, "host_agent_log_level", host_agent_log_level)
        if image_pull_policy is not None:
            pulumi.set(__self__, "image_pull_policy", image_pull_policy)
        if image_pull_secret is not None:
            pulumi.set(__self__, "image_pull_secret", image_pull_secret)
        if infra_vlan is not None:
            pulumi.set(__self__, "infra_vlan", infra_vlan)
        if install_istio is not None:
            pulumi.set(__self__, "install_istio", install_istio)
        if istio_profile is not None:
            pulumi.set(__self__, "istio_profile", istio_profile)
        if kafka_brokers is not None:
            pulumi.set(__self__, "kafka_brokers", kafka_brokers)
        if kafka_client_crt is not None:
            pulumi.set(__self__, "kafka_client_crt", kafka_client_crt)
        if kafka_client_key is not None:
            pulumi.set(__self__, "kafka_client_key", kafka_client_key)
        if max_nodes_svc_graph is not None:
            pulumi.set(__self__, "max_nodes_svc_graph", max_nodes_svc_graph)
        if mtu_head_room is not None:
            pulumi.set(__self__, "mtu_head_room", mtu_head_room)
        if multus_disable is not None:
            pulumi.set(__self__, "multus_disable", multus_disable)
        if no_priority_class is not None:
            pulumi.set(__self__, "no_priority_class", no_priority_class)
        if node_pod_if_enable is not None:
            pulumi.set(__self__, "node_pod_if_enable", node_pod_if_enable)
        if opflex_client_ssl is not None:
            pulumi.set(__self__, "opflex_client_ssl", opflex_client_ssl)
        if opflex_device_delete_timeout is not None:
            pulumi.set(__self__, "opflex_device_delete_timeout", opflex_device_delete_timeout)
        if opflex_log_level is not None:
            pulumi.set(__self__, "opflex_log_level", opflex_log_level)
        if opflex_mode is not None:
            pulumi.set(__self__, "opflex_mode", opflex_mode)
        if opflex_server_port is not None:
            pulumi.set(__self__, "opflex_server_port", opflex_server_port)
        if overlay_vrf_name is not None:
            pulumi.set(__self__, "overlay_vrf_name", overlay_vrf_name)
        if ovs_memory_limit is not None:
            pulumi.set(__self__, "ovs_memory_limit", ovs_memory_limit)
        if pbr_tracking_non_snat is not None:
            pulumi.set(__self__, "pbr_tracking_non_snat", pbr_tracking_non_snat)
        if pod_subnet_chunk_size is not None:
            pulumi.set(__self__, "pod_subnet_chunk_size", pod_subnet_chunk_size)
        if run_gbp_container is not None:
            pulumi.set(__self__, "run_gbp_container", run_gbp_container)
        if run_opflex_server_container is not None:
            pulumi.set(__self__, "run_opflex_server_container", run_opflex_server_container)
        if service_monitor_interval is not None:
            pulumi.set(__self__, "service_monitor_interval", service_monitor_interval)
        if snat_contract_scope is not None:
            pulumi.set(__self__, "snat_contract_scope", snat_contract_scope)
        if snat_namespace is not None:
            pulumi.set(__self__, "snat_namespace", snat_namespace)
        if snat_port_range_end is not None:
            pulumi.set(__self__, "snat_port_range_end", snat_port_range_end)
        if snat_port_range_start is not None:
            pulumi.set(__self__, "snat_port_range_start", snat_port_range_start)
        if snat_ports_per_node is not None:
            pulumi.set(__self__, "snat_ports_per_node", snat_ports_per_node)
        if sriov_enable is not None:
            pulumi.set(__self__, "sriov_enable", sriov_enable)
        if subnet_domain_name is not None:
            pulumi.set(__self__, "subnet_domain_name", subnet_domain_name)
        if tenant is not None:
            pulumi.set(__self__, "tenant", tenant)
        if use_aci_anywhere_crd is not None:
            pulumi.set(__self__, "use_aci_anywhere_crd", use_aci_anywhere_crd)
        if use_aci_cni_priority_class is not None:
            pulumi.set(__self__, "use_aci_cni_priority_class", use_aci_cni_priority_class)
        if use_cluster_role is not None:
            pulumi.set(__self__, "use_cluster_role", use_cluster_role)
        if use_host_netns_volume is not None:
            pulumi.set(__self__, "use_host_netns_volume", use_host_netns_volume)
        if use_opflex_server_volume is not None:
            pulumi.set(__self__, "use_opflex_server_volume", use_opflex_server_volume)
        if use_privileged_container is not None:
            pulumi.set(__self__, "use_privileged_container", use_privileged_container)
        if vmm_controller is not None:
            pulumi.set(__self__, "vmm_controller", vmm_controller)
        if vmm_domain is not None:
            pulumi.set(__self__, "vmm_domain", vmm_domain)

    @_builtins.property
    @pulumi.getter
    def aep(self) -> _builtins.str:
        return pulumi.get(self, "aep")

    @_builtins.property
    @pulumi.getter(name="apicHosts")
    def apic_hosts(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "apic_hosts")

    @_builtins.property
    @pulumi.getter(name="apicUserCrt")
    def apic_user_crt(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_crt")

    @_builtins.property
    @pulumi.getter(name="apicUserKey")
    def apic_user_key(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_key")

    @_builtins.property
    @pulumi.getter(name="apicUserName")
    def apic_user_name(self) -> _builtins.str:
        return pulumi.get(self, "apic_user_name")

    @_builtins.property
    @pulumi.getter(name="encapType")
    def encap_type(self) -> _builtins.str:
        return pulumi.get(self, "encap_type")

    @_builtins.property
    @pulumi.getter(name="externDynamic")
    def extern_dynamic(self) -> _builtins.str:
        return pulumi.get(self, "extern_dynamic")

    @_builtins.property
    @pulumi.getter(name="externStatic")
    def extern_static(self) -> _builtins.str:
        return pulumi.get(self, "extern_static")

    @_builtins.property
    @pulumi.getter(name="kubeApiVlan")
    def kube_api_vlan(self) -> _builtins.str:
        return pulumi.get(self, "kube_api_vlan")

    @_builtins.property
    @pulumi.getter
    def l3out(self) -> _builtins.str:
        return pulumi.get(self, "l3out")

    @_builtins.property
    @pulumi.getter(name="l3outExternalNetworks")
    def l3out_external_networks(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "l3out_external_networks")

    @_builtins.property
    @pulumi.getter(name="mcastRangeEnd")
    def mcast_range_end(self) -> _builtins.str:
        return pulumi.get(self, "mcast_range_end")

    @_builtins.property
    @pulumi.getter(name="mcastRangeStart")
    def mcast_range_start(self) -> _builtins.str:
        return pulumi.get(self, "mcast_range_start")

    @_builtins.property
    @pulumi.getter(name="nodeSubnet")
    def node_subnet(self) -> _builtins.str:
        return pulumi.get(self, "node_subnet")

    @_builtins.property
    @pulumi.getter(name="nodeSvcSubnet")
    def node_svc_subnet(self) -> _builtins.str:
        return pulumi.get(self, "node_svc_subnet")

    @_builtins.property
    @pulumi.getter(name="serviceVlan")
    def service_vlan(self) -> _builtins.str:
        return pulumi.get(self, "service_vlan")

    @_builtins.property
    @pulumi.getter(name="systemId")
    def system_id(self) -> _builtins.str:
        return pulumi.get(self, "system_id")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="vrfName")
    def vrf_name(self) -> _builtins.str:
        return pulumi.get(self, "vrf_name")

    @_builtins.property
    @pulumi.getter(name="vrfTenant")
    def vrf_tenant(self) -> _builtins.str:
        return pulumi.get(self, "vrf_tenant")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTickerAdjust")
    def apic_refresh_ticker_adjust(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_refresh_ticker_adjust")

    @_builtins.property
    @pulumi.getter(name="apicRefreshTime")
    def apic_refresh_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_refresh_time")

    @_builtins.property
    @pulumi.getter(name="apicSubscriptionDelay")
    def apic_subscription_delay(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "apic_subscription_delay")

    @_builtins.property
    @pulumi.getter
    def capic(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "capic")

    @_builtins.property
    @pulumi.getter(name="controllerLogLevel")
    def controller_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "controller_log_level")

    @_builtins.property
    @pulumi.getter(name="disablePeriodicSnatGlobalInfoSync")
    def disable_periodic_snat_global_info_sync(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disable_periodic_snat_global_info_sync")

    @_builtins.property
    @pulumi.getter(name="disableWaitForNetwork")
    def disable_wait_for_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "disable_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="dropLogEnable")
    def drop_log_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "drop_log_enable")

    @_builtins.property
    @pulumi.getter(name="durationWaitForNetwork")
    def duration_wait_for_network(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "duration_wait_for_network")

    @_builtins.property
    @pulumi.getter(name="enableEndpointSlice")
    def enable_endpoint_slice(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "enable_endpoint_slice")

    @_builtins.property
    @pulumi.getter(name="epRegistry")
    def ep_registry(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ep_registry")

    @_builtins.property
    @pulumi.getter(name="gbpPodSubnet")
    def gbp_pod_subnet(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "gbp_pod_subnet")

    @_builtins.property
    @pulumi.getter(name="hostAgentLogLevel")
    def host_agent_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "host_agent_log_level")

    @_builtins.property
    @pulumi.getter(name="imagePullPolicy")
    def image_pull_policy(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_policy")

    @_builtins.property
    @pulumi.getter(name="imagePullSecret")
    def image_pull_secret(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "image_pull_secret")

    @_builtins.property
    @pulumi.getter(name="infraVlan")
    def infra_vlan(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "infra_vlan")

    @_builtins.property
    @pulumi.getter(name="installIstio")
    def install_istio(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "install_istio")

    @_builtins.property
    @pulumi.getter(name="istioProfile")
    def istio_profile(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "istio_profile")

    @_builtins.property
    @pulumi.getter(name="kafkaBrokers")
    def kafka_brokers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "kafka_brokers")

    @_builtins.property
    @pulumi.getter(name="kafkaClientCrt")
    def kafka_client_crt(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kafka_client_crt")

    @_builtins.property
    @pulumi.getter(name="kafkaClientKey")
    def kafka_client_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kafka_client_key")

    @_builtins.property
    @pulumi.getter(name="maxNodesSvcGraph")
    def max_nodes_svc_graph(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_nodes_svc_graph")

    @_builtins.property
    @pulumi.getter(name="mtuHeadRoom")
    def mtu_head_room(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mtu_head_room")

    @_builtins.property
    @pulumi.getter(name="multusDisable")
    def multus_disable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "multus_disable")

    @_builtins.property
    @pulumi.getter(name="noPriorityClass")
    def no_priority_class(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "no_priority_class")

    @_builtins.property
    @pulumi.getter(name="nodePodIfEnable")
    def node_pod_if_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_pod_if_enable")

    @_builtins.property
    @pulumi.getter(name="opflexClientSsl")
    def opflex_client_ssl(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_client_ssl")

    @_builtins.property
    @pulumi.getter(name="opflexDeviceDeleteTimeout")
    def opflex_device_delete_timeout(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_device_delete_timeout")

    @_builtins.property
    @pulumi.getter(name="opflexLogLevel")
    def opflex_log_level(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_log_level")

    @_builtins.property
    @pulumi.getter(name="opflexMode")
    def opflex_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_mode")

    @_builtins.property
    @pulumi.getter(name="opflexServerPort")
    def opflex_server_port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "opflex_server_port")

    @_builtins.property
    @pulumi.getter(name="overlayVrfName")
    def overlay_vrf_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "overlay_vrf_name")

    @_builtins.property
    @pulumi.getter(name="ovsMemoryLimit")
    def ovs_memory_limit(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ovs_memory_limit")

    @_builtins.property
    @pulumi.getter(name="pbrTrackingNonSnat")
    def pbr_tracking_non_snat(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pbr_tracking_non_snat")

    @_builtins.property
    @pulumi.getter(name="podSubnetChunkSize")
    def pod_subnet_chunk_size(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pod_subnet_chunk_size")

    @_builtins.property
    @pulumi.getter(name="runGbpContainer")
    def run_gbp_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_gbp_container")

    @_builtins.property
    @pulumi.getter(name="runOpflexServerContainer")
    def run_opflex_server_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "run_opflex_server_container")

    @_builtins.property
    @pulumi.getter(name="serviceMonitorInterval")
    def service_monitor_interval(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "service_monitor_interval")

    @_builtins.property
    @pulumi.getter(name="snatContractScope")
    def snat_contract_scope(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_contract_scope")

    @_builtins.property
    @pulumi.getter(name="snatNamespace")
    def snat_namespace(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_namespace")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeEnd")
    def snat_port_range_end(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_port_range_end")

    @_builtins.property
    @pulumi.getter(name="snatPortRangeStart")
    def snat_port_range_start(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_port_range_start")

    @_builtins.property
    @pulumi.getter(name="snatPortsPerNode")
    def snat_ports_per_node(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "snat_ports_per_node")

    @_builtins.property
    @pulumi.getter(name="sriovEnable")
    def sriov_enable(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sriov_enable")

    @_builtins.property
    @pulumi.getter(name="subnetDomainName")
    def subnet_domain_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "subnet_domain_name")

    @_builtins.property
    @pulumi.getter
    def tenant(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "tenant")

    @_builtins.property
    @pulumi.getter(name="useAciAnywhereCrd")
    def use_aci_anywhere_crd(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_aci_anywhere_crd")

    @_builtins.property
    @pulumi.getter(name="useAciCniPriorityClass")
    def use_aci_cni_priority_class(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_aci_cni_priority_class")

    @_builtins.property
    @pulumi.getter(name="useClusterRole")
    def use_cluster_role(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_cluster_role")

    @_builtins.property
    @pulumi.getter(name="useHostNetnsVolume")
    def use_host_netns_volume(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_host_netns_volume")

    @_builtins.property
    @pulumi.getter(name="useOpflexServerVolume")
    def use_opflex_server_volume(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_opflex_server_volume")

    @_builtins.property
    @pulumi.getter(name="usePrivilegedContainer")
    def use_privileged_container(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "use_privileged_container")

    @_builtins.property
    @pulumi.getter(name="vmmController")
    def vmm_controller(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vmm_controller")

    @_builtins.property
    @pulumi.getter(name="vmmDomain")
    def vmm_domain(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "vmm_domain")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProviderResult(dict):
    def __init__(__self__, *,
                 cloud_provider: _builtins.str):
        pulumi.set(__self__, "cloud_provider", cloud_provider)

    @_builtins.property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> _builtins.str:
        return pulumi.get(self, "cloud_provider")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProviderResult(dict):
    def __init__(__self__, *,
                 iface: _builtins.str):
        pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> _builtins.str:
        return pulumi.get(self, "iface")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProviderResult(dict):
    def __init__(__self__, *,
                 iface: _builtins.str):
        pulumi.set(__self__, "iface", iface)

    @_builtins.property
    @pulumi.getter
    def iface(self) -> _builtins.str:
        return pulumi.get(self, "iface")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkTolerationResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 seconds: _builtins.int,
                 effect: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "seconds", seconds)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> _builtins.int:
        return pulumi.get(self, "seconds")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProviderResult(dict):
    def __init__(__self__, *,
                 password: _builtins.str):
        pulumi.set(__self__, "password", password)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        return pulumi.get(self, "password")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 docker_socket: _builtins.str,
                 roles: Sequence[_builtins.str],
                 ssh_key: _builtins.str,
                 ssh_key_path: _builtins.str,
                 user: _builtins.str,
                 hostname_override: Optional[_builtins.str] = None,
                 internal_address: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 node_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.str] = None,
                 ssh_agent_auth: Optional[_builtins.bool] = None):
        """
        :param Mapping[str, _builtins.str] labels: (Computed) Labels for the cluster template (map)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "docker_socket", docker_socket)
        pulumi.set(__self__, "roles", roles)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "ssh_key_path", ssh_key_path)
        pulumi.set(__self__, "user", user)
        if hostname_override is not None:
            pulumi.set(__self__, "hostname_override", hostname_override)
        if internal_address is not None:
            pulumi.set(__self__, "internal_address", internal_address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_id is not None:
            pulumi.set(__self__, "node_id", node_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_agent_auth is not None:
            pulumi.set(__self__, "ssh_agent_auth", ssh_agent_auth)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="dockerSocket")
    def docker_socket(self) -> _builtins.str:
        return pulumi.get(self, "docker_socket")

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "roles")

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key")

    @_builtins.property
    @pulumi.getter(name="sshKeyPath")
    def ssh_key_path(self) -> _builtins.str:
        return pulumi.get(self, "ssh_key_path")

    @_builtins.property
    @pulumi.getter
    def user(self) -> _builtins.str:
        return pulumi.get(self, "user")

    @_builtins.property
    @pulumi.getter(name="hostnameOverride")
    def hostname_override(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "hostname_override")

    @_builtins.property
    @pulumi.getter(name="internalAddress")
    def internal_address(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "internal_address")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Computed) Labels for the cluster template (map)
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="sshAgentAuth")
    def ssh_agent_auth(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ssh_agent_auth")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryResult(dict):
    def __init__(__self__, *,
                 url: _builtins.str,
                 ecr_credential_plugin: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginResult'] = None,
                 is_default: Optional[_builtins.bool] = None,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginArgs' ecr_credential_plugin: ECR credential plugin config
        """
        pulumi.set(__self__, "url", url)
        if ecr_credential_plugin is not None:
            pulumi.set(__self__, "ecr_credential_plugin", ecr_credential_plugin)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="ecrCredentialPlugin")
    def ecr_credential_plugin(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginResult']:
        """
        ECR credential plugin config
        """
        return pulumi.get(self, "ecr_credential_plugin")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPluginResult(dict):
    def __init__(__self__, *,
                 aws_access_key_id: Optional[_builtins.str] = None,
                 aws_secret_access_key: Optional[_builtins.str] = None,
                 aws_session_token: Optional[_builtins.str] = None):
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @_builtins.property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_access_key_id")

    @_builtins.property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_secret_access_key")

    @_builtins.property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "aws_session_token")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesResult(dict):
    def __init__(__self__, *,
                 etcd: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdResult',
                 kube_api: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiResult',
                 kube_controller: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerResult',
                 kubelet: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletResult',
                 kubeproxy: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyResult',
                 scheduler: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerResult'):
        pulumi.set(__self__, "etcd", etcd)
        pulumi.set(__self__, "kube_api", kube_api)
        pulumi.set(__self__, "kube_controller", kube_controller)
        pulumi.set(__self__, "kubelet", kubelet)
        pulumi.set(__self__, "kubeproxy", kubeproxy)
        pulumi.set(__self__, "scheduler", scheduler)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdResult':
        return pulumi.get(self, "etcd")

    @_builtins.property
    @pulumi.getter(name="kubeApi")
    def kube_api(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiResult':
        return pulumi.get(self, "kube_api")

    @_builtins.property
    @pulumi.getter(name="kubeController")
    def kube_controller(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerResult':
        return pulumi.get(self, "kube_controller")

    @_builtins.property
    @pulumi.getter
    def kubelet(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletResult':
        return pulumi.get(self, "kubelet")

    @_builtins.property
    @pulumi.getter
    def kubeproxy(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyResult':
        return pulumi.get(self, "kubeproxy")

    @_builtins.property
    @pulumi.getter
    def scheduler(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerResult':
        return pulumi.get(self, "scheduler")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdResult(dict):
    def __init__(__self__, *,
                 backup_config: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigResult',
                 ca_cert: _builtins.str,
                 cert: _builtins.str,
                 creation: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 key: _builtins.str,
                 path: _builtins.str,
                 retention: _builtins.str,
                 snapshot: _builtins.bool,
                 external_urls: Optional[Sequence[_builtins.str]] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 gid: Optional[_builtins.int] = None,
                 uid: Optional[_builtins.int] = None):
        pulumi.set(__self__, "backup_config", backup_config)
        pulumi.set(__self__, "ca_cert", ca_cert)
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "creation", creation)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "retention", retention)
        pulumi.set(__self__, "snapshot", snapshot)
        if external_urls is not None:
            pulumi.set(__self__, "external_urls", external_urls)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter(name="backupConfig")
    def backup_config(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigResult':
        return pulumi.get(self, "backup_config")

    @_builtins.property
    @pulumi.getter(name="caCert")
    def ca_cert(self) -> _builtins.str:
        return pulumi.get(self, "ca_cert")

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter
    def creation(self) -> _builtins.str:
        return pulumi.get(self, "creation")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> _builtins.str:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter
    def snapshot(self) -> _builtins.bool:
        return pulumi.get(self, "snapshot")

    @_builtins.property
    @pulumi.getter(name="externalUrls")
    def external_urls(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "external_urls")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "gid")

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigResult(dict):
    def __init__(__self__, *,
                 timeout: _builtins.int,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None,
                 retention: Optional[_builtins.int] = None,
                 s3_backup_config: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigResult'] = None,
                 safe_timestamp: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "timeout", timeout)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "interval_hours")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigResult']:
        return pulumi.get(self, "s3_backup_config")

    @_builtins.property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safe_timestamp")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfigResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 endpoint: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 custom_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiResult(dict):
    def __init__(__self__, *,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 service_cluster_ip_range: _builtins.str,
                 service_node_port_range: _builtins.str,
                 admission_configuration: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationResult'] = None,
                 always_pull_images: Optional[_builtins.bool] = None,
                 audit_log: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogResult'] = None,
                 event_rate_limit: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitResult'] = None,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 secrets_encryption_config: Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigResult'] = None):
        """
        :param 'GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationArgs' admission_configuration: Cluster admission configuration
        """
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        pulumi.set(__self__, "service_node_port_range", service_node_port_range)
        if admission_configuration is not None:
            pulumi.set(__self__, "admission_configuration", admission_configuration)
        if always_pull_images is not None:
            pulumi.set(__self__, "always_pull_images", always_pull_images)
        if audit_log is not None:
            pulumi.set(__self__, "audit_log", audit_log)
        if event_rate_limit is not None:
            pulumi.set(__self__, "event_rate_limit", event_rate_limit)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if secrets_encryption_config is not None:
            pulumi.set(__self__, "secrets_encryption_config", secrets_encryption_config)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> _builtins.str:
        return pulumi.get(self, "service_cluster_ip_range")

    @_builtins.property
    @pulumi.getter(name="serviceNodePortRange")
    def service_node_port_range(self) -> _builtins.str:
        return pulumi.get(self, "service_node_port_range")

    @_builtins.property
    @pulumi.getter(name="admissionConfiguration")
    def admission_configuration(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationResult']:
        """
        Cluster admission configuration
        """
        return pulumi.get(self, "admission_configuration")

    @_builtins.property
    @pulumi.getter(name="alwaysPullImages")
    def always_pull_images(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "always_pull_images")

    @_builtins.property
    @pulumi.getter(name="auditLog")
    def audit_log(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogResult']:
        return pulumi.get(self, "audit_log")

    @_builtins.property
    @pulumi.getter(name="eventRateLimit")
    def event_rate_limit(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitResult']:
        return pulumi.get(self, "event_rate_limit")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter(name="secretsEncryptionConfig")
    def secrets_encryption_config(self) -> Optional['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigResult']:
        return pulumi.get(self, "secrets_encryption_config")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationResult(dict):
    def __init__(__self__, *,
                 plugins: Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginResult'],
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None):
        """
        :param Sequence['GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginArgs'] plugins: Admission configuration plugins
        :param _builtins.str api_version: Admission configuration ApiVersion
        :param _builtins.str kind: Admission configuration Kind
        """
        pulumi.set(__self__, "plugins", plugins)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @_builtins.property
    @pulumi.getter
    def plugins(self) -> Sequence['outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginResult']:
        """
        Admission configuration plugins
        """
        return pulumi.get(self, "plugins")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        Admission configuration ApiVersion
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Admission configuration Kind
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAdmissionConfigurationPluginResult(dict):
    def __init__(__self__, *,
                 configuration: _builtins.str,
                 name: _builtins.str,
                 path: Optional[_builtins.str] = None):
        """
        :param _builtins.str configuration: Plugin configuration
        :param _builtins.str name: The cluster template name (string)
        :param _builtins.str path: Plugin path
        """
        pulumi.set(__self__, "configuration", configuration)
        pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> _builtins.str:
        """
        Plugin configuration
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The cluster template name (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Plugin path
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogResult(dict):
    def __init__(__self__, *,
                 configuration: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationResult',
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationResult':
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfigurationResult(dict):
    def __init__(__self__, *,
                 policy: _builtins.str,
                 format: Optional[_builtins.str] = None,
                 max_age: Optional[_builtins.int] = None,
                 max_backup: Optional[_builtins.int] = None,
                 max_size: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None):
        pulumi.set(__self__, "policy", policy)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_backup is not None:
            pulumi.set(__self__, "max_backup", max_backup)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> _builtins.str:
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_age")

    @_builtins.property
    @pulumi.getter(name="maxBackup")
    def max_backup(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_backup")

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_size")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimitResult(dict):
    def __init__(__self__, *,
                 configuration: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "configuration", configuration)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> _builtins.str:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfigResult(dict):
    def __init__(__self__, *,
                 custom_config: _builtins.str,
                 enabled: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "custom_config", custom_config)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="customConfig")
    def custom_config(self) -> _builtins.str:
        return pulumi.get(self, "custom_config")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeControllerResult(dict):
    def __init__(__self__, *,
                 cluster_cidr: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 service_cluster_ip_range: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "cluster_cidr", cluster_cidr)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "service_cluster_ip_range", service_cluster_ip_range)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)

    @_builtins.property
    @pulumi.getter(name="clusterCidr")
    def cluster_cidr(self) -> _builtins.str:
        return pulumi.get(self, "cluster_cidr")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="serviceClusterIpRange")
    def service_cluster_ip_range(self) -> _builtins.str:
        return pulumi.get(self, "service_cluster_ip_range")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeletResult(dict):
    def __init__(__self__, *,
                 cluster_dns_server: _builtins.str,
                 cluster_domain: _builtins.str,
                 extra_args: Mapping[str, _builtins.str],
                 fail_swap_on: _builtins.bool,
                 image: _builtins.str,
                 infra_container_image: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None,
                 generate_serving_certificate: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "cluster_dns_server", cluster_dns_server)
        pulumi.set(__self__, "cluster_domain", cluster_domain)
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "fail_swap_on", fail_swap_on)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "infra_container_image", infra_container_image)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)
        if generate_serving_certificate is not None:
            pulumi.set(__self__, "generate_serving_certificate", generate_serving_certificate)

    @_builtins.property
    @pulumi.getter(name="clusterDnsServer")
    def cluster_dns_server(self) -> _builtins.str:
        return pulumi.get(self, "cluster_dns_server")

    @_builtins.property
    @pulumi.getter(name="clusterDomain")
    def cluster_domain(self) -> _builtins.str:
        return pulumi.get(self, "cluster_domain")

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter(name="failSwapOn")
    def fail_swap_on(self) -> _builtins.bool:
        return pulumi.get(self, "fail_swap_on")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="infraContainerImage")
    def infra_container_image(self) -> _builtins.str:
        return pulumi.get(self, "infra_container_image")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")

    @_builtins.property
    @pulumi.getter(name="generateServingCertificate")
    def generate_serving_certificate(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "generate_serving_certificate")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxyResult(dict):
    def __init__(__self__, *,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesSchedulerResult(dict):
    def __init__(__self__, *,
                 extra_args: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 extra_binds: Optional[Sequence[_builtins.str]] = None,
                 extra_envs: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "extra_args", extra_args)
        pulumi.set(__self__, "image", image)
        if extra_binds is not None:
            pulumi.set(__self__, "extra_binds", extra_binds)
        if extra_envs is not None:
            pulumi.set(__self__, "extra_envs", extra_envs)

    @_builtins.property
    @pulumi.getter(name="extraArgs")
    def extra_args(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "extra_args")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="extraBinds")
    def extra_binds(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_binds")

    @_builtins.property
    @pulumi.getter(name="extraEnvs")
    def extra_envs(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "extra_envs")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyResult(dict):
    def __init__(__self__, *,
                 drain_input: 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputResult',
                 drain: Optional[_builtins.bool] = None,
                 max_unavailable_controlplane: Optional[_builtins.str] = None,
                 max_unavailable_worker: Optional[_builtins.str] = None):
        pulumi.set(__self__, "drain_input", drain_input)
        if drain is not None:
            pulumi.set(__self__, "drain", drain)
        if max_unavailable_controlplane is not None:
            pulumi.set(__self__, "max_unavailable_controlplane", max_unavailable_controlplane)
        if max_unavailable_worker is not None:
            pulumi.set(__self__, "max_unavailable_worker", max_unavailable_worker)

    @_builtins.property
    @pulumi.getter(name="drainInput")
    def drain_input(self) -> 'outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputResult':
        return pulumi.get(self, "drain_input")

    @_builtins.property
    @pulumi.getter
    def drain(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "drain")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableControlplane")
    def max_unavailable_controlplane(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_unavailable_controlplane")

    @_builtins.property
    @pulumi.getter(name="maxUnavailableWorker")
    def max_unavailable_worker(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "max_unavailable_worker")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInputResult(dict):
    def __init__(__self__, *,
                 delete_local_data: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 grace_period: Optional[_builtins.int] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        if delete_local_data is not None:
            pulumi.set(__self__, "delete_local_data", delete_local_data)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if grace_period is not None:
            pulumi.set(__self__, "grace_period", grace_period)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter(name="deleteLocalData")
    def delete_local_data(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "delete_local_data")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class GetClusterTemplateTemplateRevisionQuestionResult(dict):
    def __init__(__self__, *,
                 default: _builtins.str,
                 variable: _builtins.str,
                 required: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str default: Default variable value
        :param _builtins.str variable: Variable name
        :param _builtins.bool required: Required variable
        :param _builtins.str type: Variable type
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "variable", variable)
        if required is not None:
            pulumi.set(__self__, "required", required)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def default(self) -> _builtins.str:
        """
        Default variable value
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def variable(self) -> _builtins.str:
        """
        Variable name
        """
        return pulumi.get(self, "variable")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Required variable
        """
        return pulumi.get(self, "required")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Variable type
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetClusterV2AgentEnvVarResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the Cluster v2 (string)
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetClusterV2ClusterRegistrationTokenResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, _builtins.str],
                 cluster_id: _builtins.str,
                 command: _builtins.str,
                 id: _builtins.str,
                 insecure_command: _builtins.str,
                 insecure_node_command: _builtins.str,
                 insecure_windows_node_command: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 manifest_url: _builtins.str,
                 name: _builtins.str,
                 node_command: _builtins.str,
                 token: _builtins.str,
                 windows_node_command: _builtins.str):
        """
        :param Mapping[str, _builtins.str] annotations: Annotations of the resource
        :param _builtins.str id: (Computed) The ID of the resource (string)
        :param Mapping[str, _builtins.str] labels: Labels of the resource
        :param _builtins.str name: The name of the Cluster v2 (string)
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "insecure_command", insecure_command)
        pulumi.set(__self__, "insecure_node_command", insecure_node_command)
        pulumi.set(__self__, "insecure_windows_node_command", insecure_windows_node_command)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "manifest_url", manifest_url)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_command", node_command)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "windows_node_command", windows_node_command)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Mapping[str, _builtins.str]:
        """
        Annotations of the resource
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter
    def command(self) -> _builtins.str:
        return pulumi.get(self, "command")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        (Computed) The ID of the resource (string)
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="insecureCommand")
    def insecure_command(self) -> _builtins.str:
        return pulumi.get(self, "insecure_command")

    @_builtins.property
    @pulumi.getter(name="insecureNodeCommand")
    def insecure_node_command(self) -> _builtins.str:
        return pulumi.get(self, "insecure_node_command")

    @_builtins.property
    @pulumi.getter(name="insecureWindowsNodeCommand")
    def insecure_windows_node_command(self) -> _builtins.str:
        return pulumi.get(self, "insecure_windows_node_command")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        Labels of the resource
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="manifestUrl")
    def manifest_url(self) -> _builtins.str:
        return pulumi.get(self, "manifest_url")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCommand")
    def node_command(self) -> _builtins.str:
        return pulumi.get(self, "node_command")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="windowsNodeCommand")
    def windows_node_command(self) -> _builtins.str:
        return pulumi.get(self, "windows_node_command")


@pulumi.output_type
class GetClusterV2RkeConfigResult(dict):
    def __init__(__self__, *,
                 etcd: 'outputs.GetClusterV2RkeConfigEtcdResult',
                 machine_pool_defaults: Sequence['outputs.GetClusterV2RkeConfigMachinePoolDefaultResult'],
                 machine_pools: Sequence['outputs.GetClusterV2RkeConfigMachinePoolResult'],
                 machine_selector_configs: Sequence['outputs.GetClusterV2RkeConfigMachineSelectorConfigResult'],
                 machine_selector_files: Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileResult'],
                 additional_manifest: Optional[_builtins.str] = None,
                 chart_values: Optional[_builtins.str] = None,
                 etcd_snapshot_create: Optional['outputs.GetClusterV2RkeConfigEtcdSnapshotCreateResult'] = None,
                 etcd_snapshot_restore: Optional['outputs.GetClusterV2RkeConfigEtcdSnapshotRestoreResult'] = None,
                 local_auth_endpoint: Optional['outputs.GetClusterV2RkeConfigLocalAuthEndpointResult'] = None,
                 machine_global_config: Optional[_builtins.str] = None,
                 registries: Optional['outputs.GetClusterV2RkeConfigRegistriesResult'] = None,
                 rotate_certificates: Optional['outputs.GetClusterV2RkeConfigRotateCertificatesResult'] = None,
                 upgrade_strategy: Optional['outputs.GetClusterV2RkeConfigUpgradeStrategyResult'] = None):
        """
        :param 'GetClusterV2RkeConfigEtcdArgs' etcd: Cluster V2 etcd
        :param Sequence['GetClusterV2RkeConfigMachinePoolDefaultArgs'] machine_pool_defaults: Default values for machine pool configurations if unset
        :param Sequence['GetClusterV2RkeConfigMachinePoolArgs'] machine_pools: Cluster V2 machine pools
        :param Sequence['GetClusterV2RkeConfigMachineSelectorConfigArgs'] machine_selector_configs: Cluster V2 machine selector config
        :param Sequence['GetClusterV2RkeConfigMachineSelectorFileArgs'] machine_selector_files: Cluster V2 machine selector files
        :param _builtins.str additional_manifest: Cluster V2 additional manifest
        :param _builtins.str chart_values: Cluster V2 chart values. It should be in YAML format
        :param 'GetClusterV2RkeConfigEtcdSnapshotCreateArgs' etcd_snapshot_create: Cluster V2 etcd snapshot create
        :param 'GetClusterV2RkeConfigEtcdSnapshotRestoreArgs' etcd_snapshot_restore: Cluster V2 etcd snapshot restore
        :param 'GetClusterV2RkeConfigLocalAuthEndpointArgs' local_auth_endpoint: Cluster V2 local auth endpoint
        :param _builtins.str machine_global_config: Cluster V2 machine global config
        :param 'GetClusterV2RkeConfigRegistriesArgs' registries: Cluster V2 registries
        :param 'GetClusterV2RkeConfigRotateCertificatesArgs' rotate_certificates: Cluster V2 certificate rotation
        :param 'GetClusterV2RkeConfigUpgradeStrategyArgs' upgrade_strategy: Cluster V2 upgrade strategy
        """
        pulumi.set(__self__, "etcd", etcd)
        pulumi.set(__self__, "machine_pool_defaults", machine_pool_defaults)
        pulumi.set(__self__, "machine_pools", machine_pools)
        pulumi.set(__self__, "machine_selector_configs", machine_selector_configs)
        pulumi.set(__self__, "machine_selector_files", machine_selector_files)
        if additional_manifest is not None:
            pulumi.set(__self__, "additional_manifest", additional_manifest)
        if chart_values is not None:
            pulumi.set(__self__, "chart_values", chart_values)
        if etcd_snapshot_create is not None:
            pulumi.set(__self__, "etcd_snapshot_create", etcd_snapshot_create)
        if etcd_snapshot_restore is not None:
            pulumi.set(__self__, "etcd_snapshot_restore", etcd_snapshot_restore)
        if local_auth_endpoint is not None:
            pulumi.set(__self__, "local_auth_endpoint", local_auth_endpoint)
        if machine_global_config is not None:
            pulumi.set(__self__, "machine_global_config", machine_global_config)
        if registries is not None:
            pulumi.set(__self__, "registries", registries)
        if rotate_certificates is not None:
            pulumi.set(__self__, "rotate_certificates", rotate_certificates)
        if upgrade_strategy is not None:
            pulumi.set(__self__, "upgrade_strategy", upgrade_strategy)

    @_builtins.property
    @pulumi.getter
    def etcd(self) -> 'outputs.GetClusterV2RkeConfigEtcdResult':
        """
        Cluster V2 etcd
        """
        return pulumi.get(self, "etcd")

    @_builtins.property
    @pulumi.getter(name="machinePoolDefaults")
    def machine_pool_defaults(self) -> Sequence['outputs.GetClusterV2RkeConfigMachinePoolDefaultResult']:
        """
        Default values for machine pool configurations if unset
        """
        return pulumi.get(self, "machine_pool_defaults")

    @_builtins.property
    @pulumi.getter(name="machinePools")
    def machine_pools(self) -> Sequence['outputs.GetClusterV2RkeConfigMachinePoolResult']:
        """
        Cluster V2 machine pools
        """
        return pulumi.get(self, "machine_pools")

    @_builtins.property
    @pulumi.getter(name="machineSelectorConfigs")
    def machine_selector_configs(self) -> Sequence['outputs.GetClusterV2RkeConfigMachineSelectorConfigResult']:
        """
        Cluster V2 machine selector config
        """
        return pulumi.get(self, "machine_selector_configs")

    @_builtins.property
    @pulumi.getter(name="machineSelectorFiles")
    def machine_selector_files(self) -> Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileResult']:
        """
        Cluster V2 machine selector files
        """
        return pulumi.get(self, "machine_selector_files")

    @_builtins.property
    @pulumi.getter(name="additionalManifest")
    def additional_manifest(self) -> Optional[_builtins.str]:
        """
        Cluster V2 additional manifest
        """
        return pulumi.get(self, "additional_manifest")

    @_builtins.property
    @pulumi.getter(name="chartValues")
    def chart_values(self) -> Optional[_builtins.str]:
        """
        Cluster V2 chart values. It should be in YAML format
        """
        return pulumi.get(self, "chart_values")

    @_builtins.property
    @pulumi.getter(name="etcdSnapshotCreate")
    def etcd_snapshot_create(self) -> Optional['outputs.GetClusterV2RkeConfigEtcdSnapshotCreateResult']:
        """
        Cluster V2 etcd snapshot create
        """
        return pulumi.get(self, "etcd_snapshot_create")

    @_builtins.property
    @pulumi.getter(name="etcdSnapshotRestore")
    def etcd_snapshot_restore(self) -> Optional['outputs.GetClusterV2RkeConfigEtcdSnapshotRestoreResult']:
        """
        Cluster V2 etcd snapshot restore
        """
        return pulumi.get(self, "etcd_snapshot_restore")

    @_builtins.property
    @pulumi.getter(name="localAuthEndpoint")
    @_utilities.deprecated("""Use rancher2_cluster_v2.local_auth_endpoint instead""")
    def local_auth_endpoint(self) -> Optional['outputs.GetClusterV2RkeConfigLocalAuthEndpointResult']:
        """
        Cluster V2 local auth endpoint
        """
        return pulumi.get(self, "local_auth_endpoint")

    @_builtins.property
    @pulumi.getter(name="machineGlobalConfig")
    def machine_global_config(self) -> Optional[_builtins.str]:
        """
        Cluster V2 machine global config
        """
        return pulumi.get(self, "machine_global_config")

    @_builtins.property
    @pulumi.getter
    def registries(self) -> Optional['outputs.GetClusterV2RkeConfigRegistriesResult']:
        """
        Cluster V2 registries
        """
        return pulumi.get(self, "registries")

    @_builtins.property
    @pulumi.getter(name="rotateCertificates")
    def rotate_certificates(self) -> Optional['outputs.GetClusterV2RkeConfigRotateCertificatesResult']:
        """
        Cluster V2 certificate rotation
        """
        return pulumi.get(self, "rotate_certificates")

    @_builtins.property
    @pulumi.getter(name="upgradeStrategy")
    def upgrade_strategy(self) -> Optional['outputs.GetClusterV2RkeConfigUpgradeStrategyResult']:
        """
        Cluster V2 upgrade strategy
        """
        return pulumi.get(self, "upgrade_strategy")


@pulumi.output_type
class GetClusterV2RkeConfigEtcdResult(dict):
    def __init__(__self__, *,
                 disable_snapshots: Optional[_builtins.bool] = None,
                 s3_config: Optional['outputs.GetClusterV2RkeConfigEtcdS3ConfigResult'] = None,
                 snapshot_retention: Optional[_builtins.int] = None,
                 snapshot_schedule_cron: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disable_snapshots: Disable ETCD snapshots
        :param 'GetClusterV2RkeConfigEtcdS3ConfigArgs' s3_config: ETCD snapshot S3 config
        :param _builtins.int snapshot_retention: ETCD snapshot retention
        :param _builtins.str snapshot_schedule_cron: ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
        if disable_snapshots is not None:
            pulumi.set(__self__, "disable_snapshots", disable_snapshots)
        if s3_config is not None:
            pulumi.set(__self__, "s3_config", s3_config)
        if snapshot_retention is not None:
            pulumi.set(__self__, "snapshot_retention", snapshot_retention)
        if snapshot_schedule_cron is not None:
            pulumi.set(__self__, "snapshot_schedule_cron", snapshot_schedule_cron)

    @_builtins.property
    @pulumi.getter(name="disableSnapshots")
    def disable_snapshots(self) -> Optional[_builtins.bool]:
        """
        Disable ETCD snapshots
        """
        return pulumi.get(self, "disable_snapshots")

    @_builtins.property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> Optional['outputs.GetClusterV2RkeConfigEtcdS3ConfigResult']:
        """
        ETCD snapshot S3 config
        """
        return pulumi.get(self, "s3_config")

    @_builtins.property
    @pulumi.getter(name="snapshotRetention")
    def snapshot_retention(self) -> Optional[_builtins.int]:
        """
        ETCD snapshot retention
        """
        return pulumi.get(self, "snapshot_retention")

    @_builtins.property
    @pulumi.getter(name="snapshotScheduleCron")
    def snapshot_schedule_cron(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot schedule cron (e.g `"0 */5 * * *"`)
        """
        return pulumi.get(self, "snapshot_schedule_cron")


@pulumi.output_type
class GetClusterV2RkeConfigEtcdS3ConfigResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 endpoint: _builtins.str,
                 cloud_credential_name: Optional[_builtins.str] = None,
                 endpoint_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 skip_ssl_verify: Optional[_builtins.bool] = None):
        """
        :param _builtins.str bucket: ETCD snapshot S3 bucket
        :param _builtins.str endpoint: ETCD snapshot S3 endpoint
        :param _builtins.str cloud_credential_name: ETCD snapshot S3 cloud credential name
        :param _builtins.str endpoint_ca: ETCD snapshot S3 endpoint CA
        :param _builtins.str folder: ETCD snapshot S3 folder
        :param _builtins.str region: ETCD snapshot S3 region
        :param _builtins.bool skip_ssl_verify: Disable ETCD skip ssl verify
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "endpoint", endpoint)
        if cloud_credential_name is not None:
            pulumi.set(__self__, "cloud_credential_name", cloud_credential_name)
        if endpoint_ca is not None:
            pulumi.set(__self__, "endpoint_ca", endpoint_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if skip_ssl_verify is not None:
            pulumi.set(__self__, "skip_ssl_verify", skip_ssl_verify)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        ETCD snapshot S3 bucket
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        ETCD snapshot S3 endpoint
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="cloudCredentialName")
    def cloud_credential_name(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 cloud credential name
        """
        return pulumi.get(self, "cloud_credential_name")

    @_builtins.property
    @pulumi.getter(name="endpointCa")
    def endpoint_ca(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 endpoint CA
        """
        return pulumi.get(self, "endpoint_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 folder
        """
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        ETCD snapshot S3 region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="skipSslVerify")
    def skip_ssl_verify(self) -> Optional[_builtins.bool]:
        """
        Disable ETCD skip ssl verify
        """
        return pulumi.get(self, "skip_ssl_verify")


@pulumi.output_type
class GetClusterV2RkeConfigEtcdSnapshotCreateResult(dict):
    def __init__(__self__, *,
                 generation: _builtins.int):
        """
        :param _builtins.int generation: ETCD generation to initiate a snapshot
        """
        pulumi.set(__self__, "generation", generation)

    @_builtins.property
    @pulumi.getter
    def generation(self) -> _builtins.int:
        """
        ETCD generation to initiate a snapshot
        """
        return pulumi.get(self, "generation")


@pulumi.output_type
class GetClusterV2RkeConfigEtcdSnapshotRestoreResult(dict):
    def __init__(__self__, *,
                 generation: _builtins.int,
                 name: _builtins.str,
                 restore_rke_config: Optional[_builtins.str] = None):
        """
        :param _builtins.int generation: ETCD snapshot desired generation
        :param _builtins.str name: The name of the Cluster v2 (string)
        :param _builtins.str restore_rke_config: ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "name", name)
        if restore_rke_config is not None:
            pulumi.set(__self__, "restore_rke_config", restore_rke_config)

    @_builtins.property
    @pulumi.getter
    def generation(self) -> _builtins.int:
        """
        ETCD snapshot desired generation
        """
        return pulumi.get(self, "generation")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="restoreRkeConfig")
    def restore_rke_config(self) -> Optional[_builtins.str]:
        """
        ETCD restore RKE config (set to none, all, or kubernetesVersion)
        """
        return pulumi.get(self, "restore_rke_config")


@pulumi.output_type
class GetClusterV2RkeConfigLocalAuthEndpointResult(dict):
    def __init__(__self__, *,
                 ca_certs: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 fqdn: Optional[_builtins.str] = None):
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ca_certs")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "fqdn")


@pulumi.output_type
class GetClusterV2RkeConfigMachinePoolResult(dict):
    def __init__(__self__, *,
                 machine_config: 'outputs.GetClusterV2RkeConfigMachinePoolMachineConfigResult',
                 name: _builtins.str,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 cloud_credential_secret_name: Optional[_builtins.str] = None,
                 control_plane_role: Optional[_builtins.bool] = None,
                 drain_before_delete: Optional[_builtins.bool] = None,
                 etcd_role: Optional[_builtins.bool] = None,
                 hostname_length_limit: Optional[_builtins.int] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 machine_labels: Optional[Mapping[str, _builtins.str]] = None,
                 machine_os: Optional[_builtins.str] = None,
                 max_unhealthy: Optional[_builtins.str] = None,
                 node_drain_timeout: Optional[_builtins.int] = None,
                 node_startup_timeout_seconds: Optional[_builtins.int] = None,
                 paused: Optional[_builtins.bool] = None,
                 quantity: Optional[_builtins.int] = None,
                 rolling_update: Optional['outputs.GetClusterV2RkeConfigMachinePoolRollingUpdateResult'] = None,
                 taints: Optional[Sequence['outputs.GetClusterV2RkeConfigMachinePoolTaintResult']] = None,
                 unhealthy_node_timeout_seconds: Optional[_builtins.int] = None,
                 unhealthy_range: Optional[_builtins.str] = None,
                 worker_role: Optional[_builtins.bool] = None):
        """
        :param 'GetClusterV2RkeConfigMachinePoolMachineConfigArgs' machine_config: Machine config data
        :param _builtins.str name: The name of the Cluster v2 (string)
        :param Mapping[str, _builtins.str] annotations: Annotations for the MachineDeployment object
        :param _builtins.str cloud_credential_secret_name: (Computed) Cluster V2 cloud credential secret name (string)
        :param _builtins.bool control_plane_role: Machine pool control plane role
        :param _builtins.bool drain_before_delete: Machine pool drain before delete
        :param _builtins.bool etcd_role: Machine pool etcd role
        :param _builtins.int hostname_length_limit: maximum length for autogenerated hostname
        :param Mapping[str, _builtins.str] labels: Labels for the MachineDeployment object
        :param Mapping[str, _builtins.str] machine_labels: Labels for the machine pool nodes
        :param _builtins.str machine_os: OS Type in machine pool
        :param _builtins.str max_unhealthy: max unhealthy nodes for automated replacement to be allowed
        :param _builtins.int node_drain_timeout: seconds to wait for machine pool drain to complete before machine deletion
        :param _builtins.int node_startup_timeout_seconds: seconds a new node has to become active before it is replaced
        :param _builtins.bool paused: Machine pool paused
        :param _builtins.int quantity: Machine pool quantity
        :param 'GetClusterV2RkeConfigMachinePoolRollingUpdateArgs' rolling_update: Machine pool rolling update
        :param Sequence['GetClusterV2RkeConfigMachinePoolTaintArgs'] taints: Machine pool taints
        :param _builtins.int unhealthy_node_timeout_seconds: seconds an unhealthy node has to become active before it is replaced
        :param _builtins.str unhealthy_range: range of unhealthy nodes for automated replacement to be allowed
        :param _builtins.bool worker_role: Machine pool worker role
        """
        pulumi.set(__self__, "machine_config", machine_config)
        pulumi.set(__self__, "name", name)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cloud_credential_secret_name is not None:
            pulumi.set(__self__, "cloud_credential_secret_name", cloud_credential_secret_name)
        if control_plane_role is not None:
            pulumi.set(__self__, "control_plane_role", control_plane_role)
        if drain_before_delete is not None:
            pulumi.set(__self__, "drain_before_delete", drain_before_delete)
        if etcd_role is not None:
            pulumi.set(__self__, "etcd_role", etcd_role)
        if hostname_length_limit is not None:
            pulumi.set(__self__, "hostname_length_limit", hostname_length_limit)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if machine_labels is not None:
            pulumi.set(__self__, "machine_labels", machine_labels)
        if machine_os is not None:
            pulumi.set(__self__, "machine_os", machine_os)
        if max_unhealthy is not None:
            pulumi.set(__self__, "max_unhealthy", max_unhealthy)
        if node_drain_timeout is not None:
            pulumi.set(__self__, "node_drain_timeout", node_drain_timeout)
        if node_startup_timeout_seconds is not None:
            pulumi.set(__self__, "node_startup_timeout_seconds", node_startup_timeout_seconds)
        if paused is not None:
            pulumi.set(__self__, "paused", paused)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)
        if rolling_update is not None:
            pulumi.set(__self__, "rolling_update", rolling_update)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if unhealthy_node_timeout_seconds is not None:
            pulumi.set(__self__, "unhealthy_node_timeout_seconds", unhealthy_node_timeout_seconds)
        if unhealthy_range is not None:
            pulumi.set(__self__, "unhealthy_range", unhealthy_range)
        if worker_role is not None:
            pulumi.set(__self__, "worker_role", worker_role)

    @_builtins.property
    @pulumi.getter(name="machineConfig")
    def machine_config(self) -> 'outputs.GetClusterV2RkeConfigMachinePoolMachineConfigResult':
        """
        Machine config data
        """
        return pulumi.get(self, "machine_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations for the MachineDeployment object
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter(name="cloudCredentialSecretName")
    def cloud_credential_secret_name(self) -> Optional[_builtins.str]:
        """
        (Computed) Cluster V2 cloud credential secret name (string)
        """
        return pulumi.get(self, "cloud_credential_secret_name")

    @_builtins.property
    @pulumi.getter(name="controlPlaneRole")
    def control_plane_role(self) -> Optional[_builtins.bool]:
        """
        Machine pool control plane role
        """
        return pulumi.get(self, "control_plane_role")

    @_builtins.property
    @pulumi.getter(name="drainBeforeDelete")
    def drain_before_delete(self) -> Optional[_builtins.bool]:
        """
        Machine pool drain before delete
        """
        return pulumi.get(self, "drain_before_delete")

    @_builtins.property
    @pulumi.getter(name="etcdRole")
    def etcd_role(self) -> Optional[_builtins.bool]:
        """
        Machine pool etcd role
        """
        return pulumi.get(self, "etcd_role")

    @_builtins.property
    @pulumi.getter(name="hostnameLengthLimit")
    def hostname_length_limit(self) -> Optional[_builtins.int]:
        """
        maximum length for autogenerated hostname
        """
        return pulumi.get(self, "hostname_length_limit")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the MachineDeployment object
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="machineLabels")
    def machine_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels for the machine pool nodes
        """
        return pulumi.get(self, "machine_labels")

    @_builtins.property
    @pulumi.getter(name="machineOs")
    def machine_os(self) -> Optional[_builtins.str]:
        """
        OS Type in machine pool
        """
        return pulumi.get(self, "machine_os")

    @_builtins.property
    @pulumi.getter(name="maxUnhealthy")
    def max_unhealthy(self) -> Optional[_builtins.str]:
        """
        max unhealthy nodes for automated replacement to be allowed
        """
        return pulumi.get(self, "max_unhealthy")

    @_builtins.property
    @pulumi.getter(name="nodeDrainTimeout")
    def node_drain_timeout(self) -> Optional[_builtins.int]:
        """
        seconds to wait for machine pool drain to complete before machine deletion
        """
        return pulumi.get(self, "node_drain_timeout")

    @_builtins.property
    @pulumi.getter(name="nodeStartupTimeoutSeconds")
    def node_startup_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        seconds a new node has to become active before it is replaced
        """
        return pulumi.get(self, "node_startup_timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def paused(self) -> Optional[_builtins.bool]:
        """
        Machine pool paused
        """
        return pulumi.get(self, "paused")

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> Optional[_builtins.int]:
        """
        Machine pool quantity
        """
        return pulumi.get(self, "quantity")

    @_builtins.property
    @pulumi.getter(name="rollingUpdate")
    def rolling_update(self) -> Optional['outputs.GetClusterV2RkeConfigMachinePoolRollingUpdateResult']:
        """
        Machine pool rolling update
        """
        return pulumi.get(self, "rolling_update")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigMachinePoolTaintResult']]:
        """
        Machine pool taints
        """
        return pulumi.get(self, "taints")

    @_builtins.property
    @pulumi.getter(name="unhealthyNodeTimeoutSeconds")
    def unhealthy_node_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        seconds an unhealthy node has to become active before it is replaced
        """
        return pulumi.get(self, "unhealthy_node_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="unhealthyRange")
    def unhealthy_range(self) -> Optional[_builtins.str]:
        """
        range of unhealthy nodes for automated replacement to be allowed
        """
        return pulumi.get(self, "unhealthy_range")

    @_builtins.property
    @pulumi.getter(name="workerRole")
    def worker_role(self) -> Optional[_builtins.bool]:
        """
        Machine pool worker role
        """
        return pulumi.get(self, "worker_role")


@pulumi.output_type
class GetClusterV2RkeConfigMachinePoolDefaultResult(dict):
    def __init__(__self__, *,
                 hostname_length_limit: Optional[_builtins.int] = None):
        """
        :param _builtins.int hostname_length_limit: maximum length for autogenerated hostname
        """
        if hostname_length_limit is not None:
            pulumi.set(__self__, "hostname_length_limit", hostname_length_limit)

    @_builtins.property
    @pulumi.getter(name="hostnameLengthLimit")
    def hostname_length_limit(self) -> Optional[_builtins.int]:
        """
        maximum length for autogenerated hostname
        """
        return pulumi.get(self, "hostname_length_limit")


@pulumi.output_type
class GetClusterV2RkeConfigMachinePoolMachineConfigResult(dict):
    def __init__(__self__, *,
                 kind: _builtins.str,
                 name: _builtins.str,
                 api_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str kind: Machine config kind
        :param _builtins.str name: The name of the Cluster v2 (string)
        :param _builtins.str api_version: Machine config API version
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> _builtins.str:
        """
        Machine config kind
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        Machine config API version
        """
        return pulumi.get(self, "api_version")


@pulumi.output_type
class GetClusterV2RkeConfigMachinePoolRollingUpdateResult(dict):
    def __init__(__self__, *,
                 max_surge: Optional[_builtins.str] = None,
                 max_unavailable: Optional[_builtins.str] = None):
        """
        :param _builtins.str max_surge: Rolling update max surge
        :param _builtins.str max_unavailable: Rolling update max unavailable
        """
        if max_surge is not None:
            pulumi.set(__self__, "max_surge", max_surge)
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[_builtins.str]:
        """
        Rolling update max surge
        """
        return pulumi.get(self, "max_surge")

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[_builtins.str]:
        """
        Rolling update max unavailable
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetClusterV2RkeConfigMachinePoolTaintResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str,
                 effect: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorConfigResult(dict):
    def __init__(__self__, *,
                 config: Optional[_builtins.str] = None,
                 machine_label_selector: Optional['outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorResult'] = None):
        """
        :param _builtins.str config: Machine selector config
        :param 'GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorArgs' machine_label_selector: Machine label selector
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if machine_label_selector is not None:
            pulumi.set(__self__, "machine_label_selector", machine_label_selector)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[_builtins.str]:
        """
        Machine selector config
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter(name="machineLabelSelector")
    def machine_label_selector(self) -> Optional['outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorResult']:
        """
        Machine label selector
        """
        return pulumi.get(self, "machine_label_selector")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionArgs'] match_expressions: Label selector match expressions
        :param Mapping[str, _builtins.str] match_labels: Label selector match labels
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionResult']]:
        """
        Label selector match expressions
        """
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Label selector match labels
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: Label selector requirement key
        :param _builtins.str operator: Label selector operator
        :param Sequence[_builtins.str] values: Label selector requirement values
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Label selector requirement key
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Label selector operator
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Label selector requirement values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileResult(dict):
    def __init__(__self__, *,
                 file_sources: Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceResult']] = None,
                 machine_label_selector: Optional['outputs.GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorResult'] = None):
        """
        :param Sequence['GetClusterV2RkeConfigMachineSelectorFileFileSourceArgs'] file_sources: File sources
        :param 'GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorArgs' machine_label_selector: Machine label selector
        """
        if file_sources is not None:
            pulumi.set(__self__, "file_sources", file_sources)
        if machine_label_selector is not None:
            pulumi.set(__self__, "machine_label_selector", machine_label_selector)

    @_builtins.property
    @pulumi.getter(name="fileSources")
    def file_sources(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceResult']]:
        """
        File sources
        """
        return pulumi.get(self, "file_sources")

    @_builtins.property
    @pulumi.getter(name="machineLabelSelector")
    def machine_label_selector(self) -> Optional['outputs.GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorResult']:
        """
        Machine label selector
        """
        return pulumi.get(self, "machine_label_selector")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileFileSourceResult(dict):
    def __init__(__self__, *,
                 configmap: Optional['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapResult'] = None,
                 secret: Optional['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretResult'] = None):
        """
        :param 'GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapArgs' configmap: The configmap which is the source of files
        :param 'GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretArgs' secret: The secret which is the source of files
        """
        if configmap is not None:
            pulumi.set(__self__, "configmap", configmap)
        if secret is not None:
            pulumi.set(__self__, "secret", secret)

    @_builtins.property
    @pulumi.getter
    def configmap(self) -> Optional['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapResult']:
        """
        The configmap which is the source of files
        """
        return pulumi.get(self, "configmap")

    @_builtins.property
    @pulumi.getter
    def secret(self) -> Optional['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretResult']:
        """
        The secret which is the source of files
        """
        return pulumi.get(self, "secret")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 default_permissions: Optional[_builtins.str] = None,
                 items: Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemResult']] = None):
        """
        :param _builtins.str name: The name of the Cluster v2 (string)
        :param _builtins.str default_permissions: The default permissions to be applied when they are not set at the item level
        :param Sequence['GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemArgs'] items: Items(files) to retrieve from the K8s object
        """
        pulumi.set(__self__, "name", name)
        if default_permissions is not None:
            pulumi.set(__self__, "default_permissions", default_permissions)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultPermissions")
    def default_permissions(self) -> Optional[_builtins.str]:
        """
        The default permissions to be applied when they are not set at the item level
        """
        return pulumi.get(self, "default_permissions")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemResult']]:
        """
        Items(files) to retrieve from the K8s object
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileFileSourceConfigmapItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 path: _builtins.str,
                 dynamic: Optional[_builtins.bool] = None,
                 hash: Optional[_builtins.str] = None,
                 permissions: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the item(file) to retrieve
        :param _builtins.str path: The path to put the file in the target node
        :param _builtins.bool dynamic: If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        :param _builtins.str hash: The base64 encoded value of the SHA256 checksum of the file's content
        :param _builtins.str permissions: The numeric representation of the file permissions
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the item(file) to retrieve
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to put the file in the target node
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[_builtins.bool]:
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        return pulumi.get(self, "dynamic")

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[_builtins.str]:
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[_builtins.str]:
        """
        The numeric representation of the file permissions
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 default_permissions: Optional[_builtins.str] = None,
                 items: Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemResult']] = None):
        """
        :param _builtins.str name: The name of the Cluster v2 (string)
        :param _builtins.str default_permissions: The default permissions to be applied when they are not set at the item level
        :param Sequence['GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemArgs'] items: Items(files) to retrieve from the K8s object
        """
        pulumi.set(__self__, "name", name)
        if default_permissions is not None:
            pulumi.set(__self__, "default_permissions", default_permissions)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Cluster v2 (string)
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="defaultPermissions")
    def default_permissions(self) -> Optional[_builtins.str]:
        """
        The default permissions to be applied when they are not set at the item level
        """
        return pulumi.get(self, "default_permissions")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemResult']]:
        """
        Items(files) to retrieve from the K8s object
        """
        return pulumi.get(self, "items")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileFileSourceSecretItemResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 path: _builtins.str,
                 dynamic: Optional[_builtins.bool] = None,
                 hash: Optional[_builtins.str] = None,
                 permissions: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The key of the item(file) to retrieve
        :param _builtins.str path: The path to put the file in the target node
        :param _builtins.bool dynamic: If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        :param _builtins.str hash: The base64 encoded value of the SHA256 checksum of the file's content
        :param _builtins.str permissions: The numeric representation of the file permissions
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "path", path)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key of the item(file) to retrieve
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        The path to put the file in the target node
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def dynamic(self) -> Optional[_builtins.bool]:
        """
        If ture, the file is ignored when determining whether the node should be drained before updating the node plan (default: true).
        """
        return pulumi.get(self, "dynamic")

    @_builtins.property
    @pulumi.getter
    def hash(self) -> Optional[_builtins.str]:
        """
        The base64 encoded value of the SHA256 checksum of the file's content
        """
        return pulumi.get(self, "hash")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[_builtins.str]:
        """
        The numeric representation of the file permissions
        """
        return pulumi.get(self, "permissions")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorResult(dict):
    def __init__(__self__, *,
                 match_expressions: Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionResult']] = None,
                 match_labels: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Sequence['GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionArgs'] match_expressions: Label selector match expressions
        :param Mapping[str, _builtins.str] match_labels: Label selector match labels
        """
        if match_expressions is not None:
            pulumi.set(__self__, "match_expressions", match_expressions)
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @_builtins.property
    @pulumi.getter(name="matchExpressions")
    def match_expressions(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionResult']]:
        """
        Label selector match expressions
        """
        return pulumi.get(self, "match_expressions")

    @_builtins.property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Label selector match labels
        """
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class GetClusterV2RkeConfigMachineSelectorFileMachineLabelSelectorMatchExpressionResult(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 operator: Optional[_builtins.str] = None,
                 values: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str key: Label selector requirement key
        :param _builtins.str operator: Label selector operator
        :param Sequence[_builtins.str] values: Label selector requirement values
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        Label selector requirement key
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Label selector operator
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[Sequence[_builtins.str]]:
        """
        Label selector requirement values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetClusterV2RkeConfigRegistriesResult(dict):
    def __init__(__self__, *,
                 configs: Optional[Sequence['outputs.GetClusterV2RkeConfigRegistriesConfigResult']] = None,
                 mirrors: Optional[Sequence['outputs.GetClusterV2RkeConfigRegistriesMirrorResult']] = None):
        """
        :param Sequence['GetClusterV2RkeConfigRegistriesConfigArgs'] configs: Registry config
        :param Sequence['GetClusterV2RkeConfigRegistriesMirrorArgs'] mirrors: Registry mirrors
        """
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)

    @_builtins.property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigRegistriesConfigResult']]:
        """
        Registry config
        """
        return pulumi.get(self, "configs")

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[Sequence['outputs.GetClusterV2RkeConfigRegistriesMirrorResult']]:
        """
        Registry mirrors
        """
        return pulumi.get(self, "mirrors")


@pulumi.output_type
class GetClusterV2RkeConfigRegistriesConfigResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 auth_config_secret_name: Optional[_builtins.str] = None,
                 ca_bundle: Optional[_builtins.str] = None,
                 insecure: Optional[_builtins.bool] = None,
                 tls_secret_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: Registry hostname
        :param _builtins.str auth_config_secret_name: Registry auth config secret name
        :param _builtins.str ca_bundle: Registry CA bundle
        :param _builtins.bool insecure: Registry insecure connectivity
        :param _builtins.str tls_secret_name: Registry TLS secret name. TLS is a pair of Cert/Key
        """
        pulumi.set(__self__, "hostname", hostname)
        if auth_config_secret_name is not None:
            pulumi.set(__self__, "auth_config_secret_name", auth_config_secret_name)
        if ca_bundle is not None:
            pulumi.set(__self__, "ca_bundle", ca_bundle)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if tls_secret_name is not None:
            pulumi.set(__self__, "tls_secret_name", tls_secret_name)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Registry hostname
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter(name="authConfigSecretName")
    def auth_config_secret_name(self) -> Optional[_builtins.str]:
        """
        Registry auth config secret name
        """
        return pulumi.get(self, "auth_config_secret_name")

    @_builtins.property
    @pulumi.getter(name="caBundle")
    def ca_bundle(self) -> Optional[_builtins.str]:
        """
        Registry CA bundle
        """
        return pulumi.get(self, "ca_bundle")

    @_builtins.property
    @pulumi.getter
    def insecure(self) -> Optional[_builtins.bool]:
        """
        Registry insecure connectivity
        """
        return pulumi.get(self, "insecure")

    @_builtins.property
    @pulumi.getter(name="tlsSecretName")
    def tls_secret_name(self) -> Optional[_builtins.str]:
        """
        Registry TLS secret name. TLS is a pair of Cert/Key
        """
        return pulumi.get(self, "tls_secret_name")


@pulumi.output_type
class GetClusterV2RkeConfigRegistriesMirrorResult(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 endpoints: Optional[Sequence[_builtins.str]] = None,
                 rewrites: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str hostname: Registry hostname
        :param Sequence[_builtins.str] endpoints: Registry mirror endpoints
        :param Mapping[str, _builtins.str] rewrites: Registry mirror rewrites
        """
        pulumi.set(__self__, "hostname", hostname)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if rewrites is not None:
            pulumi.set(__self__, "rewrites", rewrites)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Registry hostname
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[_builtins.str]]:
        """
        Registry mirror endpoints
        """
        return pulumi.get(self, "endpoints")

    @_builtins.property
    @pulumi.getter
    def rewrites(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Registry mirror rewrites
        """
        return pulumi.get(self, "rewrites")


@pulumi.output_type
class GetClusterV2RkeConfigRotateCertificatesResult(dict):
    def __init__(__self__, *,
                 generation: _builtins.int,
                 services: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int generation: Desired certificate rotation generation.
        :param Sequence[_builtins.str] services: Service certificates to rotate with this generation.
        """
        pulumi.set(__self__, "generation", generation)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def generation(self) -> _builtins.int:
        """
        Desired certificate rotation generation.
        """
        return pulumi.get(self, "generation")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence[_builtins.str]]:
        """
        Service certificates to rotate with this generation.
        """
        return pulumi.get(self, "services")


@pulumi.output_type
class GetClusterV2RkeConfigUpgradeStrategyResult(dict):
    def __init__(__self__, *,
                 control_plane_concurrency: Optional[_builtins.str] = None,
                 control_plane_drain_options: Optional['outputs.GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsResult'] = None,
                 worker_concurrency: Optional[_builtins.str] = None,
                 worker_drain_options: Optional['outputs.GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsResult'] = None):
        """
        :param _builtins.str control_plane_concurrency: How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        :param 'GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsArgs' control_plane_drain_options: Controlplane nodes drain options
        :param _builtins.str worker_concurrency: How many worker nodes should be upgrade at time
        :param 'GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsArgs' worker_drain_options: Worker nodes drain options
        """
        if control_plane_concurrency is not None:
            pulumi.set(__self__, "control_plane_concurrency", control_plane_concurrency)
        if control_plane_drain_options is not None:
            pulumi.set(__self__, "control_plane_drain_options", control_plane_drain_options)
        if worker_concurrency is not None:
            pulumi.set(__self__, "worker_concurrency", worker_concurrency)
        if worker_drain_options is not None:
            pulumi.set(__self__, "worker_drain_options", worker_drain_options)

    @_builtins.property
    @pulumi.getter(name="controlPlaneConcurrency")
    def control_plane_concurrency(self) -> Optional[_builtins.str]:
        """
        How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted
        """
        return pulumi.get(self, "control_plane_concurrency")

    @_builtins.property
    @pulumi.getter(name="controlPlaneDrainOptions")
    def control_plane_drain_options(self) -> Optional['outputs.GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsResult']:
        """
        Controlplane nodes drain options
        """
        return pulumi.get(self, "control_plane_drain_options")

    @_builtins.property
    @pulumi.getter(name="workerConcurrency")
    def worker_concurrency(self) -> Optional[_builtins.str]:
        """
        How many worker nodes should be upgrade at time
        """
        return pulumi.get(self, "worker_concurrency")

    @_builtins.property
    @pulumi.getter(name="workerDrainOptions")
    def worker_drain_options(self) -> Optional['outputs.GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsResult']:
        """
        Worker nodes drain options
        """
        return pulumi.get(self, "worker_drain_options")


@pulumi.output_type
class GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptionsResult(dict):
    def __init__(__self__, *,
                 grace_period: _builtins.int,
                 skip_wait_for_delete_timeout_seconds: _builtins.int,
                 timeout: _builtins.int,
                 delete_empty_dir_data: Optional[_builtins.bool] = None,
                 disable_eviction: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 ignore_errors: Optional[_builtins.bool] = None):
        """
        :param _builtins.int grace_period: Drain options grace period
        :param _builtins.int skip_wait_for_delete_timeout_seconds: Drain options skip wait for delete timeout seconds
        :param _builtins.int timeout: Drain options timeout
        :param _builtins.bool delete_empty_dir_data: Drain options delete empty dir data
        :param _builtins.bool disable_eviction: Drain options disable eviction
        :param _builtins.bool enabled: Drain options enabled?
        :param _builtins.bool force: Drain options force
        :param _builtins.bool ignore_daemon_sets: Drain options ignore daemon sets
        :param _builtins.bool ignore_errors: Drain options ignore errors
        """
        pulumi.set(__self__, "grace_period", grace_period)
        pulumi.set(__self__, "skip_wait_for_delete_timeout_seconds", skip_wait_for_delete_timeout_seconds)
        pulumi.set(__self__, "timeout", timeout)
        if delete_empty_dir_data is not None:
            pulumi.set(__self__, "delete_empty_dir_data", delete_empty_dir_data)
        if disable_eviction is not None:
            pulumi.set(__self__, "disable_eviction", disable_eviction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if ignore_errors is not None:
            pulumi.set(__self__, "ignore_errors", ignore_errors)

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> _builtins.int:
        """
        Drain options grace period
        """
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="skipWaitForDeleteTimeoutSeconds")
    def skip_wait_for_delete_timeout_seconds(self) -> _builtins.int:
        """
        Drain options skip wait for delete timeout seconds
        """
        return pulumi.get(self, "skip_wait_for_delete_timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        Drain options timeout
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="deleteEmptyDirData")
    def delete_empty_dir_data(self) -> Optional[_builtins.bool]:
        """
        Drain options delete empty dir data
        """
        return pulumi.get(self, "delete_empty_dir_data")

    @_builtins.property
    @pulumi.getter(name="disableEviction")
    def disable_eviction(self) -> Optional[_builtins.bool]:
        """
        Drain options disable eviction
        """
        return pulumi.get(self, "disable_eviction")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Drain options enabled?
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        Drain options force
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore daemon sets
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter(name="ignoreErrors")
    def ignore_errors(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore errors
        """
        return pulumi.get(self, "ignore_errors")


@pulumi.output_type
class GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptionsResult(dict):
    def __init__(__self__, *,
                 grace_period: _builtins.int,
                 skip_wait_for_delete_timeout_seconds: _builtins.int,
                 timeout: _builtins.int,
                 delete_empty_dir_data: Optional[_builtins.bool] = None,
                 disable_eviction: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 force: Optional[_builtins.bool] = None,
                 ignore_daemon_sets: Optional[_builtins.bool] = None,
                 ignore_errors: Optional[_builtins.bool] = None):
        """
        :param _builtins.int grace_period: Drain options grace period
        :param _builtins.int skip_wait_for_delete_timeout_seconds: Drain options skip wait for delete timeout seconds
        :param _builtins.int timeout: Drain options timeout
        :param _builtins.bool delete_empty_dir_data: Drain options delete empty dir data
        :param _builtins.bool disable_eviction: Drain options disable eviction
        :param _builtins.bool enabled: Drain options enabled?
        :param _builtins.bool force: Drain options force
        :param _builtins.bool ignore_daemon_sets: Drain options ignore daemon sets
        :param _builtins.bool ignore_errors: Drain options ignore errors
        """
        pulumi.set(__self__, "grace_period", grace_period)
        pulumi.set(__self__, "skip_wait_for_delete_timeout_seconds", skip_wait_for_delete_timeout_seconds)
        pulumi.set(__self__, "timeout", timeout)
        if delete_empty_dir_data is not None:
            pulumi.set(__self__, "delete_empty_dir_data", delete_empty_dir_data)
        if disable_eviction is not None:
            pulumi.set(__self__, "disable_eviction", disable_eviction)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if force is not None:
            pulumi.set(__self__, "force", force)
        if ignore_daemon_sets is not None:
            pulumi.set(__self__, "ignore_daemon_sets", ignore_daemon_sets)
        if ignore_errors is not None:
            pulumi.set(__self__, "ignore_errors", ignore_errors)

    @_builtins.property
    @pulumi.getter(name="gracePeriod")
    def grace_period(self) -> _builtins.int:
        """
        Drain options grace period
        """
        return pulumi.get(self, "grace_period")

    @_builtins.property
    @pulumi.getter(name="skipWaitForDeleteTimeoutSeconds")
    def skip_wait_for_delete_timeout_seconds(self) -> _builtins.int:
        """
        Drain options skip wait for delete timeout seconds
        """
        return pulumi.get(self, "skip_wait_for_delete_timeout_seconds")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        Drain options timeout
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="deleteEmptyDirData")
    def delete_empty_dir_data(self) -> Optional[_builtins.bool]:
        """
        Drain options delete empty dir data
        """
        return pulumi.get(self, "delete_empty_dir_data")

    @_builtins.property
    @pulumi.getter(name="disableEviction")
    def disable_eviction(self) -> Optional[_builtins.bool]:
        """
        Drain options disable eviction
        """
        return pulumi.get(self, "disable_eviction")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Drain options enabled?
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def force(self) -> Optional[_builtins.bool]:
        """
        Drain options force
        """
        return pulumi.get(self, "force")

    @_builtins.property
    @pulumi.getter(name="ignoreDaemonSets")
    def ignore_daemon_sets(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore daemon sets
        """
        return pulumi.get(self, "ignore_daemon_sets")

    @_builtins.property
    @pulumi.getter(name="ignoreErrors")
    def ignore_errors(self) -> Optional[_builtins.bool]:
        """
        Drain options ignore errors
        """
        return pulumi.get(self, "ignore_errors")


@pulumi.output_type
class GetEtcdBackupBackupConfigResult(dict):
    def __init__(__self__, *,
                 timeout: _builtins.int,
                 enabled: Optional[_builtins.bool] = None,
                 interval_hours: Optional[_builtins.int] = None,
                 retention: Optional[_builtins.int] = None,
                 s3_backup_config: Optional['outputs.GetEtcdBackupBackupConfigS3BackupConfigResult'] = None,
                 safe_timestamp: Optional[_builtins.bool] = None):
        pulumi.set(__self__, "timeout", timeout)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if interval_hours is not None:
            pulumi.set(__self__, "interval_hours", interval_hours)
        if retention is not None:
            pulumi.set(__self__, "retention", retention)
        if s3_backup_config is not None:
            pulumi.set(__self__, "s3_backup_config", s3_backup_config)
        if safe_timestamp is not None:
            pulumi.set(__self__, "safe_timestamp", safe_timestamp)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="intervalHours")
    def interval_hours(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "interval_hours")

    @_builtins.property
    @pulumi.getter
    def retention(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "retention")

    @_builtins.property
    @pulumi.getter(name="s3BackupConfig")
    def s3_backup_config(self) -> Optional['outputs.GetEtcdBackupBackupConfigS3BackupConfigResult']:
        return pulumi.get(self, "s3_backup_config")

    @_builtins.property
    @pulumi.getter(name="safeTimestamp")
    def safe_timestamp(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "safe_timestamp")


@pulumi.output_type
class GetEtcdBackupBackupConfigS3BackupConfigResult(dict):
    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 endpoint: _builtins.str,
                 access_key: Optional[_builtins.str] = None,
                 custom_ca: Optional[_builtins.str] = None,
                 folder: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if custom_ca is not None:
            pulumi.set(__self__, "custom_ca", custom_ca)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "access_key")

    @_builtins.property
    @pulumi.getter(name="customCa")
    def custom_ca(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "custom_ca")

    @_builtins.property
    @pulumi.getter
    def folder(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "folder")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class GetGlobalRoleRuleResult(dict):
    def __init__(__self__, *,
                 api_groups: Optional[Sequence[_builtins.str]] = None,
                 non_resource_urls: Optional[Sequence[_builtins.str]] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None,
                 verbs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_groups: Policy rule api groups
        :param Sequence[_builtins.str] non_resource_urls: Policy rule non resource urls
        :param Sequence[_builtins.str] resource_names: Policy rule resource names
        :param Sequence[_builtins.str] resources: Policy rule resources
        :param Sequence[_builtins.str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @_builtins.property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @_builtins.property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")


@pulumi.output_type
class GetNamespaceContainerResourceLimitResult(dict):
    def __init__(__self__, *,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None):
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_memory")


@pulumi.output_type
class GetNamespaceResourceQuotaResult(dict):
    def __init__(__self__, *,
                 limit: 'outputs.GetNamespaceResourceQuotaLimitResult'):
        pulumi.set(__self__, "limit", limit)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> 'outputs.GetNamespaceResourceQuotaLimitResult':
        return pulumi.get(self, "limit")


@pulumi.output_type
class GetNamespaceResourceQuotaLimitResult(dict):
    def __init__(__self__, *,
                 config_maps: Optional[_builtins.str] = None,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 persistent_volume_claims: Optional[_builtins.str] = None,
                 pods: Optional[_builtins.str] = None,
                 replication_controllers: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None,
                 requests_storage: Optional[_builtins.str] = None,
                 secrets: Optional[_builtins.str] = None,
                 services: Optional[_builtins.str] = None,
                 services_load_balancers: Optional[_builtins.str] = None,
                 services_node_ports: Optional[_builtins.str] = None):
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "config_maps")

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "replication_controllers")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_memory")

    @_builtins.property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_storage")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services_load_balancers")

    @_builtins.property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services_node_ports")


@pulumi.output_type
class GetNodePoolNodeTaintResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 time_added: _builtins.str,
                 value: _builtins.str,
                 effect: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "time_added", time_added)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> _builtins.str:
        return pulumi.get(self, "time_added")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")


@pulumi.output_type
class GetNodeTemplateNodeTaintResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 time_added: _builtins.str,
                 value: _builtins.str,
                 effect: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "time_added", time_added)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter(name="timeAdded")
    def time_added(self) -> _builtins.str:
        return pulumi.get(self, "time_added")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "effect")


@pulumi.output_type
class GetPodSecurityAdmissionConfigurationTemplateDefaultsResult(dict):
    def __init__(__self__, *,
                 audit: Optional[_builtins.str] = None,
                 audit_version: Optional[_builtins.str] = None,
                 enforce: Optional[_builtins.str] = None,
                 enforce_version: Optional[_builtins.str] = None,
                 warn: Optional[_builtins.str] = None,
                 warn_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str audit: Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param _builtins.str audit_version: Pod Security Admission Configuration audit version (default: latest)
        :param _builtins.str enforce: Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param _builtins.str enforce_version: Pod Security Admission Configuration enforce version (default: latest)
        :param _builtins.str warn: Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        :param _builtins.str warn_version: Pod Security Admission Configuration warn version (default: latest)
        """
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if audit_version is not None:
            pulumi.set(__self__, "audit_version", audit_version)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if enforce_version is not None:
            pulumi.set(__self__, "enforce_version", enforce_version)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)
        if warn_version is not None:
            pulumi.set(__self__, "warn_version", warn_version)

    @_builtins.property
    @pulumi.getter
    def audit(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration audit. This audits a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "audit")

    @_builtins.property
    @pulumi.getter(name="auditVersion")
    def audit_version(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration audit version (default: latest)
        """
        return pulumi.get(self, "audit_version")

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration enforce. This rejects a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "enforce")

    @_builtins.property
    @pulumi.getter(name="enforceVersion")
    def enforce_version(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration enforce version (default: latest)
        """
        return pulumi.get(self, "enforce_version")

    @_builtins.property
    @pulumi.getter
    def warn(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration warn. This warns the user about a pod in violation of privileged, baseline, or restricted policy (default: privileged)
        """
        return pulumi.get(self, "warn")

    @_builtins.property
    @pulumi.getter(name="warnVersion")
    def warn_version(self) -> Optional[_builtins.str]:
        """
        Pod Security Admission Configuration warn version (default: latest)
        """
        return pulumi.get(self, "warn_version")


@pulumi.output_type
class GetPodSecurityAdmissionConfigurationTemplateExemptionsResult(dict):
    def __init__(__self__, *,
                 namespaces: Optional[Sequence[_builtins.str]] = None,
                 runtime_classes: Optional[Sequence[_builtins.str]] = None,
                 usernames: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] namespaces: Pod Security Admission Configuration namespace exemptions
        :param Sequence[_builtins.str] runtime_classes: Pod Security Admission Configuration runtime class exemptions
        :param Sequence[_builtins.str] usernames: Pod Security Admission Configuration username exemptions
        """
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if runtime_classes is not None:
            pulumi.set(__self__, "runtime_classes", runtime_classes)
        if usernames is not None:
            pulumi.set(__self__, "usernames", usernames)

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod Security Admission Configuration namespace exemptions
        """
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter(name="runtimeClasses")
    def runtime_classes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod Security Admission Configuration runtime class exemptions
        """
        return pulumi.get(self, "runtime_classes")

    @_builtins.property
    @pulumi.getter
    def usernames(self) -> Optional[Sequence[_builtins.str]]:
        """
        Pod Security Admission Configuration username exemptions
        """
        return pulumi.get(self, "usernames")


@pulumi.output_type
class GetProjectContainerResourceLimitResult(dict):
    def __init__(__self__, *,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None):
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_memory")


@pulumi.output_type
class GetProjectResourceQuotaResult(dict):
    def __init__(__self__, *,
                 namespace_default_limit: 'outputs.GetProjectResourceQuotaNamespaceDefaultLimitResult',
                 project_limit: 'outputs.GetProjectResourceQuotaProjectLimitResult'):
        pulumi.set(__self__, "namespace_default_limit", namespace_default_limit)
        pulumi.set(__self__, "project_limit", project_limit)

    @_builtins.property
    @pulumi.getter(name="namespaceDefaultLimit")
    def namespace_default_limit(self) -> 'outputs.GetProjectResourceQuotaNamespaceDefaultLimitResult':
        return pulumi.get(self, "namespace_default_limit")

    @_builtins.property
    @pulumi.getter(name="projectLimit")
    def project_limit(self) -> 'outputs.GetProjectResourceQuotaProjectLimitResult':
        return pulumi.get(self, "project_limit")


@pulumi.output_type
class GetProjectResourceQuotaNamespaceDefaultLimitResult(dict):
    def __init__(__self__, *,
                 config_maps: Optional[_builtins.str] = None,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 persistent_volume_claims: Optional[_builtins.str] = None,
                 pods: Optional[_builtins.str] = None,
                 replication_controllers: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None,
                 requests_storage: Optional[_builtins.str] = None,
                 secrets: Optional[_builtins.str] = None,
                 services: Optional[_builtins.str] = None,
                 services_load_balancers: Optional[_builtins.str] = None,
                 services_node_ports: Optional[_builtins.str] = None):
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "config_maps")

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "replication_controllers")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_memory")

    @_builtins.property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_storage")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services_load_balancers")

    @_builtins.property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services_node_ports")


@pulumi.output_type
class GetProjectResourceQuotaProjectLimitResult(dict):
    def __init__(__self__, *,
                 config_maps: Optional[_builtins.str] = None,
                 limits_cpu: Optional[_builtins.str] = None,
                 limits_memory: Optional[_builtins.str] = None,
                 persistent_volume_claims: Optional[_builtins.str] = None,
                 pods: Optional[_builtins.str] = None,
                 replication_controllers: Optional[_builtins.str] = None,
                 requests_cpu: Optional[_builtins.str] = None,
                 requests_memory: Optional[_builtins.str] = None,
                 requests_storage: Optional[_builtins.str] = None,
                 secrets: Optional[_builtins.str] = None,
                 services: Optional[_builtins.str] = None,
                 services_load_balancers: Optional[_builtins.str] = None,
                 services_node_ports: Optional[_builtins.str] = None):
        if config_maps is not None:
            pulumi.set(__self__, "config_maps", config_maps)
        if limits_cpu is not None:
            pulumi.set(__self__, "limits_cpu", limits_cpu)
        if limits_memory is not None:
            pulumi.set(__self__, "limits_memory", limits_memory)
        if persistent_volume_claims is not None:
            pulumi.set(__self__, "persistent_volume_claims", persistent_volume_claims)
        if pods is not None:
            pulumi.set(__self__, "pods", pods)
        if replication_controllers is not None:
            pulumi.set(__self__, "replication_controllers", replication_controllers)
        if requests_cpu is not None:
            pulumi.set(__self__, "requests_cpu", requests_cpu)
        if requests_memory is not None:
            pulumi.set(__self__, "requests_memory", requests_memory)
        if requests_storage is not None:
            pulumi.set(__self__, "requests_storage", requests_storage)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if services_load_balancers is not None:
            pulumi.set(__self__, "services_load_balancers", services_load_balancers)
        if services_node_ports is not None:
            pulumi.set(__self__, "services_node_ports", services_node_ports)

    @_builtins.property
    @pulumi.getter(name="configMaps")
    def config_maps(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "config_maps")

    @_builtins.property
    @pulumi.getter(name="limitsCpu")
    def limits_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_cpu")

    @_builtins.property
    @pulumi.getter(name="limitsMemory")
    def limits_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "limits_memory")

    @_builtins.property
    @pulumi.getter(name="persistentVolumeClaims")
    def persistent_volume_claims(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "persistent_volume_claims")

    @_builtins.property
    @pulumi.getter
    def pods(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "pods")

    @_builtins.property
    @pulumi.getter(name="replicationControllers")
    def replication_controllers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "replication_controllers")

    @_builtins.property
    @pulumi.getter(name="requestsCpu")
    def requests_cpu(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_cpu")

    @_builtins.property
    @pulumi.getter(name="requestsMemory")
    def requests_memory(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_memory")

    @_builtins.property
    @pulumi.getter(name="requestsStorage")
    def requests_storage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "requests_storage")

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "secrets")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="servicesLoadBalancers")
    def services_load_balancers(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services_load_balancers")

    @_builtins.property
    @pulumi.getter(name="servicesNodePorts")
    def services_node_ports(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "services_node_ports")


@pulumi.output_type
class GetRegistryRegistryResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        pulumi.set(__self__, "address", address)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class GetRoleTemplateExternalRuleResult(dict):
    def __init__(__self__, *,
                 api_groups: Optional[Sequence[_builtins.str]] = None,
                 non_resource_urls: Optional[Sequence[_builtins.str]] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None,
                 verbs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_groups: Policy rule api groups
        :param Sequence[_builtins.str] non_resource_urls: Policy rule non resource urls
        :param Sequence[_builtins.str] resource_names: Policy rule resource names
        :param Sequence[_builtins.str] resources: Policy rule resources
        :param Sequence[_builtins.str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @_builtins.property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @_builtins.property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")


@pulumi.output_type
class GetRoleTemplateRuleResult(dict):
    def __init__(__self__, *,
                 api_groups: Optional[Sequence[_builtins.str]] = None,
                 non_resource_urls: Optional[Sequence[_builtins.str]] = None,
                 resource_names: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None,
                 verbs: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] api_groups: Policy rule api groups
        :param Sequence[_builtins.str] non_resource_urls: Policy rule non resource urls
        :param Sequence[_builtins.str] resource_names: Policy rule resource names
        :param Sequence[_builtins.str] resources: Policy rule resources
        :param Sequence[_builtins.str] verbs: Policy rule verbs
        """
        if api_groups is not None:
            pulumi.set(__self__, "api_groups", api_groups)
        if non_resource_urls is not None:
            pulumi.set(__self__, "non_resource_urls", non_resource_urls)
        if resource_names is not None:
            pulumi.set(__self__, "resource_names", resource_names)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)
        if verbs is not None:
            pulumi.set(__self__, "verbs", verbs)

    @_builtins.property
    @pulumi.getter(name="apiGroups")
    def api_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule api groups
        """
        return pulumi.get(self, "api_groups")

    @_builtins.property
    @pulumi.getter(name="nonResourceUrls")
    def non_resource_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule non resource urls
        """
        return pulumi.get(self, "non_resource_urls")

    @_builtins.property
    @pulumi.getter(name="resourceNames")
    def resource_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resource names
        """
        return pulumi.get(self, "resource_names")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule resources
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter
    def verbs(self) -> Optional[Sequence[_builtins.str]]:
        """
        Policy rule verbs
        """
        return pulumi.get(self, "verbs")


