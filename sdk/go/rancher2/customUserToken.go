// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rancher2

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-rancher2/sdk/v6/go/rancher2/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Rancher v2 Token resource, specifically to create tokens for custom users (i.e. not the 'admin' user configured with the provider config). Custom user tokens can f.e. be used as service account tokens with the Rancher v2 API having limited permissions. To create a custom user token the username/password for the Rancher User must be known.
//
// There are 2 kind of tokens:
// - not scoped: valid for global system.
// - scoped: valid for just a specific cluster (`clusterId` should be provided).
//
// Tokens can only be created for a Rancher User with at least the `user-base` global role binding in order to enable user login.
//
// Tokens can't be updated once created. Any diff in token data will recreate the token. If any token expire, Rancher2 provider will generate a diff to regenerate it.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-rancher2/sdk/v6/go/rancher2"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a rancher2 Token
//			fooUser, err := rancher2.NewUser(ctx, "fooUser", &rancher2.UserArgs{
//				Username: pulumi.String("foo"),
//				Password: pulumi.String("changeme"),
//				Enabled:  pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = rancher2.NewGlobalRoleBinding(ctx, "foo-login", &rancher2.GlobalRoleBindingArgs{
//				GlobalRoleId: pulumi.String("user-base"),
//				UserId:       fooUser.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = rancher2.NewCustomUserToken(ctx, "fooCustomUserToken", &rancher2.CustomUserTokenArgs{
//				Username:    fooUser.Username,
//				Password:    fooUser.Password,
//				Description: pulumi.String("foo token"),
//				Ttl:         pulumi.Int(0),
//			}, pulumi.DependsOn([]pulumi.Resource{
//				foo_login,
//			}))
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
type CustomUserToken struct {
	pulumi.CustomResourceState

	// (Computed) Token access key part (string)
	AccessKey pulumi.StringOutput `pulumi:"accessKey"`
	// (Computed) Annotations of the token (map)
	Annotations pulumi.MapOutput `pulumi:"annotations"`
	// Cluster ID for scoped token (string)
	ClusterId pulumi.StringPtrOutput `pulumi:"clusterId"`
	// Token description (string)
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// (Computed) Token is enabled (bool)
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// (Computed) Token is expired (bool)
	Expired pulumi.BoolOutput `pulumi:"expired"`
	// (Computed) Labels of the token (map)
	Labels pulumi.MapOutput `pulumi:"labels"`
	// (Computed) Token name (string)
	Name pulumi.StringOutput `pulumi:"name"`
	// The user password (string)
	Password pulumi.StringOutput `pulumi:"password"`
	// Renew expired or disabled token
	Renew pulumi.BoolPtrOutput `pulumi:"renew"`
	// (Computed/Sensitive) Token secret key part (string)
	SecretKey pulumi.StringOutput `pulumi:"secretKey"`
	// (Computed) Generated API temporary token as helper. Should be empty (string)
	TempToken pulumi.StringOutput `pulumi:"tempToken"`
	// (Computed) Generated API temporary token id as helper. Should be empty (string)
	TempTokenId pulumi.StringOutput `pulumi:"tempTokenId"`
	// (Computed/Sensitive) Token value (string)
	Token pulumi.StringOutput `pulumi:"token"`
	// Token time to live in seconds. Default `0` (int)
	//
	// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
	Ttl pulumi.IntPtrOutput `pulumi:"ttl"`
	// (Computed) Token user ID (string)
	UserId pulumi.StringOutput `pulumi:"userId"`
	// The user username (string)
	Username pulumi.StringOutput `pulumi:"username"`
}

// NewCustomUserToken registers a new resource with the given unique name, arguments, and options.
func NewCustomUserToken(ctx *pulumi.Context,
	name string, args *CustomUserTokenArgs, opts ...pulumi.ResourceOption) (*CustomUserToken, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Password == nil {
		return nil, errors.New("invalid value for required argument 'Password'")
	}
	if args.Username == nil {
		return nil, errors.New("invalid value for required argument 'Username'")
	}
	if args.Password != nil {
		args.Password = pulumi.ToSecret(args.Password).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"password",
		"secretKey",
		"tempToken",
		"token",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CustomUserToken
	err := ctx.RegisterResource("rancher2:index/customUserToken:CustomUserToken", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCustomUserToken gets an existing CustomUserToken resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCustomUserToken(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CustomUserTokenState, opts ...pulumi.ResourceOption) (*CustomUserToken, error) {
	var resource CustomUserToken
	err := ctx.ReadResource("rancher2:index/customUserToken:CustomUserToken", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CustomUserToken resources.
type customUserTokenState struct {
	// (Computed) Token access key part (string)
	AccessKey *string `pulumi:"accessKey"`
	// (Computed) Annotations of the token (map)
	Annotations map[string]interface{} `pulumi:"annotations"`
	// Cluster ID for scoped token (string)
	ClusterId *string `pulumi:"clusterId"`
	// Token description (string)
	Description *string `pulumi:"description"`
	// (Computed) Token is enabled (bool)
	Enabled *bool `pulumi:"enabled"`
	// (Computed) Token is expired (bool)
	Expired *bool `pulumi:"expired"`
	// (Computed) Labels of the token (map)
	Labels map[string]interface{} `pulumi:"labels"`
	// (Computed) Token name (string)
	Name *string `pulumi:"name"`
	// The user password (string)
	Password *string `pulumi:"password"`
	// Renew expired or disabled token
	Renew *bool `pulumi:"renew"`
	// (Computed/Sensitive) Token secret key part (string)
	SecretKey *string `pulumi:"secretKey"`
	// (Computed) Generated API temporary token as helper. Should be empty (string)
	TempToken *string `pulumi:"tempToken"`
	// (Computed) Generated API temporary token id as helper. Should be empty (string)
	TempTokenId *string `pulumi:"tempTokenId"`
	// (Computed/Sensitive) Token value (string)
	Token *string `pulumi:"token"`
	// Token time to live in seconds. Default `0` (int)
	//
	// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
	Ttl *int `pulumi:"ttl"`
	// (Computed) Token user ID (string)
	UserId *string `pulumi:"userId"`
	// The user username (string)
	Username *string `pulumi:"username"`
}

type CustomUserTokenState struct {
	// (Computed) Token access key part (string)
	AccessKey pulumi.StringPtrInput
	// (Computed) Annotations of the token (map)
	Annotations pulumi.MapInput
	// Cluster ID for scoped token (string)
	ClusterId pulumi.StringPtrInput
	// Token description (string)
	Description pulumi.StringPtrInput
	// (Computed) Token is enabled (bool)
	Enabled pulumi.BoolPtrInput
	// (Computed) Token is expired (bool)
	Expired pulumi.BoolPtrInput
	// (Computed) Labels of the token (map)
	Labels pulumi.MapInput
	// (Computed) Token name (string)
	Name pulumi.StringPtrInput
	// The user password (string)
	Password pulumi.StringPtrInput
	// Renew expired or disabled token
	Renew pulumi.BoolPtrInput
	// (Computed/Sensitive) Token secret key part (string)
	SecretKey pulumi.StringPtrInput
	// (Computed) Generated API temporary token as helper. Should be empty (string)
	TempToken pulumi.StringPtrInput
	// (Computed) Generated API temporary token id as helper. Should be empty (string)
	TempTokenId pulumi.StringPtrInput
	// (Computed/Sensitive) Token value (string)
	Token pulumi.StringPtrInput
	// Token time to live in seconds. Default `0` (int)
	//
	// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
	Ttl pulumi.IntPtrInput
	// (Computed) Token user ID (string)
	UserId pulumi.StringPtrInput
	// The user username (string)
	Username pulumi.StringPtrInput
}

func (CustomUserTokenState) ElementType() reflect.Type {
	return reflect.TypeOf((*customUserTokenState)(nil)).Elem()
}

type customUserTokenArgs struct {
	// (Computed) Annotations of the token (map)
	Annotations map[string]interface{} `pulumi:"annotations"`
	// Cluster ID for scoped token (string)
	ClusterId *string `pulumi:"clusterId"`
	// Token description (string)
	Description *string `pulumi:"description"`
	// (Computed) Labels of the token (map)
	Labels map[string]interface{} `pulumi:"labels"`
	// The user password (string)
	Password string `pulumi:"password"`
	// Renew expired or disabled token
	Renew *bool `pulumi:"renew"`
	// Token time to live in seconds. Default `0` (int)
	//
	// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
	Ttl *int `pulumi:"ttl"`
	// The user username (string)
	Username string `pulumi:"username"`
}

// The set of arguments for constructing a CustomUserToken resource.
type CustomUserTokenArgs struct {
	// (Computed) Annotations of the token (map)
	Annotations pulumi.MapInput
	// Cluster ID for scoped token (string)
	ClusterId pulumi.StringPtrInput
	// Token description (string)
	Description pulumi.StringPtrInput
	// (Computed) Labels of the token (map)
	Labels pulumi.MapInput
	// The user password (string)
	Password pulumi.StringInput
	// Renew expired or disabled token
	Renew pulumi.BoolPtrInput
	// Token time to live in seconds. Default `0` (int)
	//
	// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
	Ttl pulumi.IntPtrInput
	// The user username (string)
	Username pulumi.StringInput
}

func (CustomUserTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*customUserTokenArgs)(nil)).Elem()
}

type CustomUserTokenInput interface {
	pulumi.Input

	ToCustomUserTokenOutput() CustomUserTokenOutput
	ToCustomUserTokenOutputWithContext(ctx context.Context) CustomUserTokenOutput
}

func (*CustomUserToken) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomUserToken)(nil)).Elem()
}

func (i *CustomUserToken) ToCustomUserTokenOutput() CustomUserTokenOutput {
	return i.ToCustomUserTokenOutputWithContext(context.Background())
}

func (i *CustomUserToken) ToCustomUserTokenOutputWithContext(ctx context.Context) CustomUserTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomUserTokenOutput)
}

// CustomUserTokenArrayInput is an input type that accepts CustomUserTokenArray and CustomUserTokenArrayOutput values.
// You can construct a concrete instance of `CustomUserTokenArrayInput` via:
//
//	CustomUserTokenArray{ CustomUserTokenArgs{...} }
type CustomUserTokenArrayInput interface {
	pulumi.Input

	ToCustomUserTokenArrayOutput() CustomUserTokenArrayOutput
	ToCustomUserTokenArrayOutputWithContext(context.Context) CustomUserTokenArrayOutput
}

type CustomUserTokenArray []CustomUserTokenInput

func (CustomUserTokenArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CustomUserToken)(nil)).Elem()
}

func (i CustomUserTokenArray) ToCustomUserTokenArrayOutput() CustomUserTokenArrayOutput {
	return i.ToCustomUserTokenArrayOutputWithContext(context.Background())
}

func (i CustomUserTokenArray) ToCustomUserTokenArrayOutputWithContext(ctx context.Context) CustomUserTokenArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomUserTokenArrayOutput)
}

// CustomUserTokenMapInput is an input type that accepts CustomUserTokenMap and CustomUserTokenMapOutput values.
// You can construct a concrete instance of `CustomUserTokenMapInput` via:
//
//	CustomUserTokenMap{ "key": CustomUserTokenArgs{...} }
type CustomUserTokenMapInput interface {
	pulumi.Input

	ToCustomUserTokenMapOutput() CustomUserTokenMapOutput
	ToCustomUserTokenMapOutputWithContext(context.Context) CustomUserTokenMapOutput
}

type CustomUserTokenMap map[string]CustomUserTokenInput

func (CustomUserTokenMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CustomUserToken)(nil)).Elem()
}

func (i CustomUserTokenMap) ToCustomUserTokenMapOutput() CustomUserTokenMapOutput {
	return i.ToCustomUserTokenMapOutputWithContext(context.Background())
}

func (i CustomUserTokenMap) ToCustomUserTokenMapOutputWithContext(ctx context.Context) CustomUserTokenMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CustomUserTokenMapOutput)
}

type CustomUserTokenOutput struct{ *pulumi.OutputState }

func (CustomUserTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CustomUserToken)(nil)).Elem()
}

func (o CustomUserTokenOutput) ToCustomUserTokenOutput() CustomUserTokenOutput {
	return o
}

func (o CustomUserTokenOutput) ToCustomUserTokenOutputWithContext(ctx context.Context) CustomUserTokenOutput {
	return o
}

// (Computed) Token access key part (string)
func (o CustomUserTokenOutput) AccessKey() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.AccessKey }).(pulumi.StringOutput)
}

// (Computed) Annotations of the token (map)
func (o CustomUserTokenOutput) Annotations() pulumi.MapOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.MapOutput { return v.Annotations }).(pulumi.MapOutput)
}

// Cluster ID for scoped token (string)
func (o CustomUserTokenOutput) ClusterId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringPtrOutput { return v.ClusterId }).(pulumi.StringPtrOutput)
}

// Token description (string)
func (o CustomUserTokenOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// (Computed) Token is enabled (bool)
func (o CustomUserTokenOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// (Computed) Token is expired (bool)
func (o CustomUserTokenOutput) Expired() pulumi.BoolOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.BoolOutput { return v.Expired }).(pulumi.BoolOutput)
}

// (Computed) Labels of the token (map)
func (o CustomUserTokenOutput) Labels() pulumi.MapOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.MapOutput { return v.Labels }).(pulumi.MapOutput)
}

// (Computed) Token name (string)
func (o CustomUserTokenOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The user password (string)
func (o CustomUserTokenOutput) Password() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.Password }).(pulumi.StringOutput)
}

// Renew expired or disabled token
func (o CustomUserTokenOutput) Renew() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.BoolPtrOutput { return v.Renew }).(pulumi.BoolPtrOutput)
}

// (Computed/Sensitive) Token secret key part (string)
func (o CustomUserTokenOutput) SecretKey() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.SecretKey }).(pulumi.StringOutput)
}

// (Computed) Generated API temporary token as helper. Should be empty (string)
func (o CustomUserTokenOutput) TempToken() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.TempToken }).(pulumi.StringOutput)
}

// (Computed) Generated API temporary token id as helper. Should be empty (string)
func (o CustomUserTokenOutput) TempTokenId() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.TempTokenId }).(pulumi.StringOutput)
}

// (Computed/Sensitive) Token value (string)
func (o CustomUserTokenOutput) Token() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.Token }).(pulumi.StringOutput)
}

// Token time to live in seconds. Default `0` (int)
//
// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
func (o CustomUserTokenOutput) Ttl() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.IntPtrOutput { return v.Ttl }).(pulumi.IntPtrOutput)
}

// (Computed) Token user ID (string)
func (o CustomUserTokenOutput) UserId() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.UserId }).(pulumi.StringOutput)
}

// The user username (string)
func (o CustomUserTokenOutput) Username() pulumi.StringOutput {
	return o.ApplyT(func(v *CustomUserToken) pulumi.StringOutput { return v.Username }).(pulumi.StringOutput)
}

type CustomUserTokenArrayOutput struct{ *pulumi.OutputState }

func (CustomUserTokenArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CustomUserToken)(nil)).Elem()
}

func (o CustomUserTokenArrayOutput) ToCustomUserTokenArrayOutput() CustomUserTokenArrayOutput {
	return o
}

func (o CustomUserTokenArrayOutput) ToCustomUserTokenArrayOutputWithContext(ctx context.Context) CustomUserTokenArrayOutput {
	return o
}

func (o CustomUserTokenArrayOutput) Index(i pulumi.IntInput) CustomUserTokenOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CustomUserToken {
		return vs[0].([]*CustomUserToken)[vs[1].(int)]
	}).(CustomUserTokenOutput)
}

type CustomUserTokenMapOutput struct{ *pulumi.OutputState }

func (CustomUserTokenMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CustomUserToken)(nil)).Elem()
}

func (o CustomUserTokenMapOutput) ToCustomUserTokenMapOutput() CustomUserTokenMapOutput {
	return o
}

func (o CustomUserTokenMapOutput) ToCustomUserTokenMapOutputWithContext(ctx context.Context) CustomUserTokenMapOutput {
	return o
}

func (o CustomUserTokenMapOutput) MapIndex(k pulumi.StringInput) CustomUserTokenOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CustomUserToken {
		return vs[0].(map[string]*CustomUserToken)[vs[1].(string)]
	}).(CustomUserTokenOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CustomUserTokenInput)(nil)).Elem(), &CustomUserToken{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomUserTokenArrayInput)(nil)).Elem(), CustomUserTokenArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CustomUserTokenMapInput)(nil)).Elem(), CustomUserTokenMap{})
	pulumi.RegisterOutputType(CustomUserTokenOutput{})
	pulumi.RegisterOutputType(CustomUserTokenArrayOutput{})
	pulumi.RegisterOutputType(CustomUserTokenMapOutput{})
}
