// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Rancher2
{
    /// <summary>
    /// Provides a Rancher v2 Token resource, specifically to create tokens for custom users (i.e. not the 'admin' user configured with the provider config). Custom user tokens can f.e. be used as service account tokens with the Rancher v2 API having limited permissions. To create a custom user token the username/password for the Rancher User must be known.
    /// 
    /// There are 2 kind of tokens:
    /// - not scoped: valid for global system.
    /// - scoped: valid for just a specific cluster (`cluster_id` should be provided).
    /// 
    /// Tokens can only be created for a Rancher User with at least the `user-base` global role binding in order to enable user login.
    /// 
    /// Tokens can't be updated once created. Any diff in token data will recreate the token. If any token expire, Rancher2 provider will generate a diff to regenerate it.
    /// 
    /// ## Example Usage
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Rancher2 = Pulumi.Rancher2;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     // Create a rancher2 Token
    ///     var fooUser = new Rancher2.User("fooUser", new()
    ///     {
    ///         Username = "foo",
    ///         Password = "changeme",
    ///         Enabled = true,
    ///     });
    /// 
    ///     var foo_login = new Rancher2.GlobalRoleBinding("foo-login", new()
    ///     {
    ///         GlobalRoleId = "user-base",
    ///         UserId = fooUser.Id,
    ///     });
    /// 
    ///     var fooCustomUserToken = new Rancher2.CustomUserToken("fooCustomUserToken", new()
    ///     {
    ///         Username = fooUser.Username,
    ///         Password = fooUser.Password,
    ///         Description = "foo token",
    ///         Ttl = 0,
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn =
    ///         {
    ///             foo_login, 
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// </summary>
    [Rancher2ResourceType("rancher2:index/customUserToken:CustomUserToken")]
    public partial class CustomUserToken : global::Pulumi.CustomResource
    {
        /// <summary>
        /// (Computed) Token access key part (string)
        /// </summary>
        [Output("accessKey")]
        public Output<string> AccessKey { get; private set; } = null!;

        /// <summary>
        /// (Computed) Annotations of the token (map)
        /// </summary>
        [Output("annotations")]
        public Output<ImmutableDictionary<string, object>> Annotations { get; private set; } = null!;

        /// <summary>
        /// Cluster ID for scoped token (string)
        /// </summary>
        [Output("clusterId")]
        public Output<string?> ClusterId { get; private set; } = null!;

        /// <summary>
        /// Token description (string)
        /// </summary>
        [Output("description")]
        public Output<string?> Description { get; private set; } = null!;

        /// <summary>
        /// (Computed) Token is enabled (bool)
        /// </summary>
        [Output("enabled")]
        public Output<bool> Enabled { get; private set; } = null!;

        /// <summary>
        /// (Computed) Token is expired (bool)
        /// </summary>
        [Output("expired")]
        public Output<bool> Expired { get; private set; } = null!;

        /// <summary>
        /// (Computed) Labels of the token (map)
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, object>> Labels { get; private set; } = null!;

        /// <summary>
        /// (Computed) Token name (string)
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// The user password (string)
        /// </summary>
        [Output("password")]
        public Output<string> Password { get; private set; } = null!;

        /// <summary>
        /// Renew expired or disabled token
        /// </summary>
        [Output("renew")]
        public Output<bool?> Renew { get; private set; } = null!;

        /// <summary>
        /// (Computed/Sensitive) Token secret key part (string)
        /// </summary>
        [Output("secretKey")]
        public Output<string> SecretKey { get; private set; } = null!;

        /// <summary>
        /// (Computed) Generated API temporary token as helper. Should be empty (string)
        /// </summary>
        [Output("tempToken")]
        public Output<string> TempToken { get; private set; } = null!;

        /// <summary>
        /// (Computed) Generated API temporary token id as helper. Should be empty (string)
        /// </summary>
        [Output("tempTokenId")]
        public Output<string> TempTokenId { get; private set; } = null!;

        /// <summary>
        /// (Computed/Sensitive) Token value (string)
        /// </summary>
        [Output("token")]
        public Output<string> Token { get; private set; } = null!;

        /// <summary>
        /// Token time to live in seconds. Default `0` (int) 
        /// 
        /// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
        /// </summary>
        [Output("ttl")]
        public Output<int?> Ttl { get; private set; } = null!;

        /// <summary>
        /// (Computed) Token user ID (string)
        /// </summary>
        [Output("userId")]
        public Output<string> UserId { get; private set; } = null!;

        /// <summary>
        /// The user username (string)
        /// </summary>
        [Output("username")]
        public Output<string> Username { get; private set; } = null!;


        /// <summary>
        /// Create a CustomUserToken resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public CustomUserToken(string name, CustomUserTokenArgs args, CustomResourceOptions? options = null)
            : base("rancher2:index/customUserToken:CustomUserToken", name, args ?? new CustomUserTokenArgs(), MakeResourceOptions(options, ""))
        {
        }

        private CustomUserToken(string name, Input<string> id, CustomUserTokenState? state = null, CustomResourceOptions? options = null)
            : base("rancher2:index/customUserToken:CustomUserToken", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "password",
                    "secretKey",
                    "tempToken",
                    "token",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing CustomUserToken resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static CustomUserToken Get(string name, Input<string> id, CustomUserTokenState? state = null, CustomResourceOptions? options = null)
        {
            return new CustomUserToken(name, id, state, options);
        }
    }

    public sealed class CustomUserTokenArgs : global::Pulumi.ResourceArgs
    {
        [Input("annotations")]
        private InputMap<object>? _annotations;

        /// <summary>
        /// (Computed) Annotations of the token (map)
        /// </summary>
        public InputMap<object> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<object>());
            set => _annotations = value;
        }

        /// <summary>
        /// Cluster ID for scoped token (string)
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        /// <summary>
        /// Token description (string)
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("labels")]
        private InputMap<object>? _labels;

        /// <summary>
        /// (Computed) Labels of the token (map)
        /// </summary>
        public InputMap<object> Labels
        {
            get => _labels ?? (_labels = new InputMap<object>());
            set => _labels = value;
        }

        [Input("password", required: true)]
        private Input<string>? _password;

        /// <summary>
        /// The user password (string)
        /// </summary>
        public Input<string>? Password
        {
            get => _password;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _password = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Renew expired or disabled token
        /// </summary>
        [Input("renew")]
        public Input<bool>? Renew { get; set; }

        /// <summary>
        /// Token time to live in seconds. Default `0` (int) 
        /// 
        /// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
        /// </summary>
        [Input("ttl")]
        public Input<int>? Ttl { get; set; }

        /// <summary>
        /// The user username (string)
        /// </summary>
        [Input("username", required: true)]
        public Input<string> Username { get; set; } = null!;

        public CustomUserTokenArgs()
        {
        }
        public static new CustomUserTokenArgs Empty => new CustomUserTokenArgs();
    }

    public sealed class CustomUserTokenState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// (Computed) Token access key part (string)
        /// </summary>
        [Input("accessKey")]
        public Input<string>? AccessKey { get; set; }

        [Input("annotations")]
        private InputMap<object>? _annotations;

        /// <summary>
        /// (Computed) Annotations of the token (map)
        /// </summary>
        public InputMap<object> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<object>());
            set => _annotations = value;
        }

        /// <summary>
        /// Cluster ID for scoped token (string)
        /// </summary>
        [Input("clusterId")]
        public Input<string>? ClusterId { get; set; }

        /// <summary>
        /// Token description (string)
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// (Computed) Token is enabled (bool)
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// (Computed) Token is expired (bool)
        /// </summary>
        [Input("expired")]
        public Input<bool>? Expired { get; set; }

        [Input("labels")]
        private InputMap<object>? _labels;

        /// <summary>
        /// (Computed) Labels of the token (map)
        /// </summary>
        public InputMap<object> Labels
        {
            get => _labels ?? (_labels = new InputMap<object>());
            set => _labels = value;
        }

        /// <summary>
        /// (Computed) Token name (string)
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        [Input("password")]
        private Input<string>? _password;

        /// <summary>
        /// The user password (string)
        /// </summary>
        public Input<string>? Password
        {
            get => _password;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _password = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Renew expired or disabled token
        /// </summary>
        [Input("renew")]
        public Input<bool>? Renew { get; set; }

        [Input("secretKey")]
        private Input<string>? _secretKey;

        /// <summary>
        /// (Computed/Sensitive) Token secret key part (string)
        /// </summary>
        public Input<string>? SecretKey
        {
            get => _secretKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _secretKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("tempToken")]
        private Input<string>? _tempToken;

        /// <summary>
        /// (Computed) Generated API temporary token as helper. Should be empty (string)
        /// </summary>
        public Input<string>? TempToken
        {
            get => _tempToken;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _tempToken = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// (Computed) Generated API temporary token id as helper. Should be empty (string)
        /// </summary>
        [Input("tempTokenId")]
        public Input<string>? TempTokenId { get; set; }

        [Input("token")]
        private Input<string>? _token;

        /// <summary>
        /// (Computed/Sensitive) Token value (string)
        /// </summary>
        public Input<string>? Token
        {
            get => _token;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _token = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Token time to live in seconds. Default `0` (int) 
        /// 
        /// From Rancher v2.4.6 `ttl` is read in minutes at Rancher API. To avoid breaking change on the provider, we still read in seconds but rounding up division if required.
        /// </summary>
        [Input("ttl")]
        public Input<int>? Ttl { get; set; }

        /// <summary>
        /// (Computed) Token user ID (string)
        /// </summary>
        [Input("userId")]
        public Input<string>? UserId { get; set; }

        /// <summary>
        /// The user username (string)
        /// </summary>
        [Input("username")]
        public Input<string>? Username { get; set; }

        public CustomUserTokenState()
        {
        }
        public static new CustomUserTokenState Empty => new CustomUserTokenState();
    }
}
