// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Rancher2.Inputs
{

    public sealed class ClusterOkeConfigArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
        /// </summary>
        [Input("compartmentId", required: true)]
        public Input<string> CompartmentId { get; set; } = null!;

        /// <summary>
        /// An optional custom boot volume size (in GB) for the nodes
        /// </summary>
        [Input("customBootVolumeSize")]
        public Input<int>? CustomBootVolumeSize { get; set; }

        /// <summary>
        /// The description for Cluster (string)
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Enable the kubernetes dashboard
        /// </summary>
        [Input("enableKubernetesDashboard")]
        public Input<bool>? EnableKubernetesDashboard { get; set; }

        /// <summary>
        /// Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
        /// </summary>
        [Input("enablePrivateControlPlane")]
        public Input<bool>? EnablePrivateControlPlane { get; set; }

        /// <summary>
        /// Whether worker nodes are deployed into a new private subnet
        /// </summary>
        [Input("enablePrivateNodes")]
        public Input<bool>? EnablePrivateNodes { get; set; }

        /// <summary>
        /// The fingerprint corresponding to the specified user's private API Key
        /// </summary>
        [Input("fingerprint", required: true)]
        public Input<string> Fingerprint { get; set; } = null!;

        /// <summary>
        /// Optional number of OCPUs for nodes (requires flexible node_shape)
        /// </summary>
        [Input("flexOcpus")]
        public Input<int>? FlexOcpus { get; set; }

        [Input("kmsKeyId")]
        private Input<string>? _kmsKeyId;

        /// <summary>
        /// Optional specify the OCID of the KMS Vault master key
        /// </summary>
        public Input<string>? KmsKeyId
        {
            get => _kmsKeyId;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _kmsKeyId = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.19.7
        /// </summary>
        [Input("kubernetesVersion", required: true)]
        public Input<string> KubernetesVersion { get; set; } = null!;

        /// <summary>
        /// Optional limit on the total number of nodes in the pool
        /// </summary>
        [Input("limitNodeCount")]
        public Input<int>? LimitNodeCount { get; set; }

        /// <summary>
        /// The name of the first existing subnet to use for Kubernetes services / LB
        /// </summary>
        [Input("loadBalancerSubnetName1")]
        public Input<string>? LoadBalancerSubnetName1 { get; set; }

        /// <summary>
        /// The (optional) name of a second existing subnet to use for Kubernetes services / LB
        /// </summary>
        [Input("loadBalancerSubnetName2")]
        public Input<string>? LoadBalancerSubnetName2 { get; set; }

        /// <summary>
        /// The OS for the node image
        /// </summary>
        [Input("nodeImage", required: true)]
        public Input<string> NodeImage { get; set; } = null!;

        /// <summary>
        /// Optional name for DNS domain of node pool subnet
        /// </summary>
        [Input("nodePoolDnsDomainName")]
        public Input<string>? NodePoolDnsDomainName { get; set; }

        /// <summary>
        /// Optional name for node pool subnet
        /// </summary>
        [Input("nodePoolSubnetName")]
        public Input<string>? NodePoolSubnetName { get; set; }

        /// <summary>
        /// The contents of the SSH public key file to use for the nodes
        /// </summary>
        [Input("nodePublicKeyContents")]
        public Input<string>? NodePublicKeyContents { get; set; }

        /// <summary>
        /// The shape of the node (determines number of CPUs and  amount of memory on each node)
        /// </summary>
        [Input("nodeShape", required: true)]
        public Input<string> NodeShape { get; set; } = null!;

        /// <summary>
        /// Optional specify the pod CIDR, defaults to 10.244.0.0/16
        /// </summary>
        [Input("podCidr")]
        public Input<string>? PodCidr { get; set; }

        [Input("privateKeyContents", required: true)]
        private Input<string>? _privateKeyContents;

        /// <summary>
        /// The private API key file contents for the specified user, in PEM format
        /// </summary>
        public Input<string>? PrivateKeyContents
        {
            get => _privateKeyContents;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _privateKeyContents = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("privateKeyPassphrase")]
        private Input<string>? _privateKeyPassphrase;

        /// <summary>
        /// The passphrase of the private key for the OKE cluster
        /// </summary>
        public Input<string>? PrivateKeyPassphrase
        {
            get => _privateKeyPassphrase;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _privateKeyPassphrase = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// Number of node subnets (defaults to creating 1 regional subnet)
        /// </summary>
        [Input("quantityOfNodeSubnets")]
        public Input<int>? QuantityOfNodeSubnets { get; set; }

        /// <summary>
        /// Number of worker nodes in each subnet / availability domain
        /// </summary>
        [Input("quantityPerSubnet")]
        public Input<int>? QuantityPerSubnet { get; set; }

        /// <summary>
        /// The availability domain within the region to host the OKE cluster
        /// </summary>
        [Input("region", required: true)]
        public Input<string> Region { get; set; } = null!;

        /// <summary>
        /// Optional specify the service CIDR, defaults to 10.96.0.0/16
        /// </summary>
        [Input("serviceCidr")]
        public Input<string>? ServiceCidr { get; set; }

        /// <summary>
        /// Optional name for DNS domain of service subnet
        /// </summary>
        [Input("serviceDnsDomainName")]
        public Input<string>? ServiceDnsDomainName { get; set; }

        /// <summary>
        /// Whether to skip deleting VCN
        /// </summary>
        [Input("skipVcnDelete")]
        public Input<bool>? SkipVcnDelete { get; set; }

        /// <summary>
        /// The OCID of the tenancy in which to create resources
        /// </summary>
        [Input("tenancyId", required: true)]
        public Input<string> TenancyId { get; set; } = null!;

        /// <summary>
        /// The OCID of a user who has access to the tenancy/compartment
        /// </summary>
        [Input("userOcid", required: true)]
        public Input<string> UserOcid { get; set; } = null!;

        /// <summary>
        /// The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
        /// </summary>
        [Input("vcnCompartmentId")]
        public Input<string>? VcnCompartmentId { get; set; }

        /// <summary>
        /// The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
        /// </summary>
        [Input("vcnName")]
        public Input<string>? VcnName { get; set; }

        /// <summary>
        /// Additional CIDR from which to allow ingress to worker nodes
        /// </summary>
        [Input("workerNodeIngressCidr")]
        public Input<string>? WorkerNodeIngressCidr { get; set; }

        public ClusterOkeConfigArgs()
        {
        }
        public static new ClusterOkeConfigArgs Empty => new ClusterOkeConfigArgs();
    }
}
