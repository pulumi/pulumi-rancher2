// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Rancher2.Inputs
{

    public sealed class ClusterGkeConfigArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// The IP address range of the container pods
        /// </summary>
        [Input("clusterIpv4Cidr", required: true)]
        public Input<string> ClusterIpv4Cidr { get; set; } = null!;

        [Input("credential", required: true)]
        private Input<string>? _credential;

        /// <summary>
        /// The contents of the GC credential file
        /// </summary>
        public Input<string>? Credential
        {
            get => _credential;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _credential = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The description for Cluster (string)
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        /// <summary>
        /// Size of the disk attached to each node
        /// </summary>
        [Input("diskSizeGb")]
        public Input<int>? DiskSizeGb { get; set; }

        /// <summary>
        /// Type of the disk attached to each node
        /// </summary>
        [Input("diskType", required: true)]
        public Input<string> DiskType { get; set; } = null!;

        /// <summary>
        /// To enable kubernetes alpha feature
        /// </summary>
        [Input("enableAlphaFeature")]
        public Input<bool>? EnableAlphaFeature { get; set; }

        /// <summary>
        /// Specifies whether the node auto-repair is enabled for the node pool
        /// </summary>
        [Input("enableAutoRepair")]
        public Input<bool>? EnableAutoRepair { get; set; }

        /// <summary>
        /// Specifies whether node auto-upgrade is enabled for the node pool
        /// </summary>
        [Input("enableAutoUpgrade")]
        public Input<bool>? EnableAutoUpgrade { get; set; }

        /// <summary>
        /// Enable horizontal pod autoscaling for the cluster
        /// </summary>
        [Input("enableHorizontalPodAutoscaling")]
        public Input<bool>? EnableHorizontalPodAutoscaling { get; set; }

        /// <summary>
        /// Enable http load balancing for the cluster
        /// </summary>
        [Input("enableHttpLoadBalancing")]
        public Input<bool>? EnableHttpLoadBalancing { get; set; }

        /// <summary>
        /// Whether to enable the kubernetes dashboard
        /// </summary>
        [Input("enableKubernetesDashboard")]
        public Input<bool>? EnableKubernetesDashboard { get; set; }

        /// <summary>
        /// Whether to enable legacy abac on the cluster
        /// </summary>
        [Input("enableLegacyAbac")]
        public Input<bool>? EnableLegacyAbac { get; set; }

        /// <summary>
        /// Whether or not master authorized network is enabled
        /// </summary>
        [Input("enableMasterAuthorizedNetwork")]
        public Input<bool>? EnableMasterAuthorizedNetwork { get; set; }

        /// <summary>
        /// Enable network policy config for the cluster
        /// </summary>
        [Input("enableNetworkPolicyConfig")]
        public Input<bool>? EnableNetworkPolicyConfig { get; set; }

        /// <summary>
        /// Enable nodepool autoscaling
        /// </summary>
        [Input("enableNodepoolAutoscaling")]
        public Input<bool>? EnableNodepoolAutoscaling { get; set; }

        /// <summary>
        /// Whether the master's internal IP address is used as the cluster endpoint
        /// </summary>
        [Input("enablePrivateEndpoint")]
        public Input<bool>? EnablePrivateEndpoint { get; set; }

        /// <summary>
        /// Whether nodes have internal IP address only
        /// </summary>
        [Input("enablePrivateNodes")]
        public Input<bool>? EnablePrivateNodes { get; set; }

        /// <summary>
        /// Enable stackdriver logging
        /// </summary>
        [Input("enableStackdriverLogging")]
        public Input<bool>? EnableStackdriverLogging { get; set; }

        /// <summary>
        /// Enable stackdriver monitoring
        /// </summary>
        [Input("enableStackdriverMonitoring")]
        public Input<bool>? EnableStackdriverMonitoring { get; set; }

        /// <summary>
        /// The image to use for the worker nodes
        /// </summary>
        [Input("imageType", required: true)]
        public Input<string> ImageType { get; set; } = null!;

        /// <summary>
        /// The IP address range for the cluster pod IPs
        /// </summary>
        [Input("ipPolicyClusterIpv4CidrBlock", required: true)]
        public Input<string> IpPolicyClusterIpv4CidrBlock { get; set; } = null!;

        /// <summary>
        /// The name of the secondary range to be used for the cluster CIDR block
        /// </summary>
        [Input("ipPolicyClusterSecondaryRangeName", required: true)]
        public Input<string> IpPolicyClusterSecondaryRangeName { get; set; } = null!;

        /// <summary>
        /// Whether a new subnetwork will be created automatically for the cluster
        /// </summary>
        [Input("ipPolicyCreateSubnetwork")]
        public Input<bool>? IpPolicyCreateSubnetwork { get; set; }

        /// <summary>
        /// The IP address range of the instance IPs in this cluster
        /// </summary>
        [Input("ipPolicyNodeIpv4CidrBlock", required: true)]
        public Input<string> IpPolicyNodeIpv4CidrBlock { get; set; } = null!;

        /// <summary>
        /// The IP address range of the services IPs in this cluster
        /// </summary>
        [Input("ipPolicyServicesIpv4CidrBlock", required: true)]
        public Input<string> IpPolicyServicesIpv4CidrBlock { get; set; } = null!;

        /// <summary>
        /// The name of the secondary range to be used for the services CIDR block
        /// </summary>
        [Input("ipPolicyServicesSecondaryRangeName", required: true)]
        public Input<string> IpPolicyServicesSecondaryRangeName { get; set; } = null!;

        /// <summary>
        /// A custom subnetwork name to be used if createSubnetwork is true
        /// </summary>
        [Input("ipPolicySubnetworkName", required: true)]
        public Input<string> IpPolicySubnetworkName { get; set; } = null!;

        /// <summary>
        /// Issue a client certificate
        /// </summary>
        [Input("issueClientCertificate")]
        public Input<bool>? IssueClientCertificate { get; set; }

        /// <summary>
        /// Enable the kubernetes dashboard
        /// </summary>
        [Input("kubernetesDashboard")]
        public Input<bool>? KubernetesDashboard { get; set; }

        [Input("labels")]
        private InputMap<string>? _labels;

        /// <summary>
        /// Labels for the Cluster (map)
        /// </summary>
        public InputMap<string> Labels
        {
            get => _labels ?? (_labels = new InputMap<string>());
            set => _labels = value;
        }

        /// <summary>
        /// The number of local SSD disks to be attached to the node
        /// </summary>
        [Input("localSsdCount")]
        public Input<int>? LocalSsdCount { get; set; }

        [Input("locations", required: true)]
        private InputList<string>? _locations;

        /// <summary>
        /// Locations to use for the cluster
        /// </summary>
        public InputList<string> Locations
        {
            get => _locations ?? (_locations = new InputList<string>());
            set => _locations = value;
        }

        /// <summary>
        /// The machine type to use for the worker nodes
        /// </summary>
        [Input("machineType", required: true)]
        public Input<string> MachineType { get; set; } = null!;

        /// <summary>
        /// When to performance updates on the nodes, in 24-hour time
        /// </summary>
        [Input("maintenanceWindow", required: true)]
        public Input<string> MaintenanceWindow { get; set; } = null!;

        [Input("masterAuthorizedNetworkCidrBlocks")]
        private InputList<string>? _masterAuthorizedNetworkCidrBlocks;

        /// <summary>
        /// Define up to 10 external networks that could access Kubernetes master through HTTPS
        /// </summary>
        public InputList<string> MasterAuthorizedNetworkCidrBlocks
        {
            get => _masterAuthorizedNetworkCidrBlocks ?? (_masterAuthorizedNetworkCidrBlocks = new InputList<string>());
            set => _masterAuthorizedNetworkCidrBlocks = value;
        }

        /// <summary>
        /// The IP range in CIDR notation to use for the hosted master network
        /// </summary>
        [Input("masterIpv4CidrBlock", required: true)]
        public Input<string> MasterIpv4CidrBlock { get; set; } = null!;

        /// <summary>
        /// The kubernetes master version
        /// </summary>
        [Input("masterVersion", required: true)]
        public Input<string> MasterVersion { get; set; } = null!;

        /// <summary>
        /// Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
        /// </summary>
        [Input("maxNodeCount")]
        public Input<int>? MaxNodeCount { get; set; }

        /// <summary>
        /// Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
        /// </summary>
        [Input("minNodeCount")]
        public Input<int>? MinNodeCount { get; set; }

        /// <summary>
        /// The network to use for the cluster
        /// </summary>
        [Input("network", required: true)]
        public Input<string> Network { get; set; } = null!;

        /// <summary>
        /// The number of nodes to create in this cluster
        /// </summary>
        [Input("nodeCount")]
        public Input<int>? NodeCount { get; set; }

        /// <summary>
        /// The ID of the cluster node pool
        /// </summary>
        [Input("nodePool", required: true)]
        public Input<string> NodePool { get; set; } = null!;

        /// <summary>
        /// The version of kubernetes to use on the nodes
        /// </summary>
        [Input("nodeVersion", required: true)]
        public Input<string> NodeVersion { get; set; } = null!;

        [Input("oauthScopes", required: true)]
        private InputList<string>? _oauthScopes;

        /// <summary>
        /// The set of Google API scopes to be made available on all of the node VMs under the default service account
        /// </summary>
        public InputList<string> OauthScopes
        {
            get => _oauthScopes ?? (_oauthScopes = new InputList<string>());
            set => _oauthScopes = value;
        }

        /// <summary>
        /// Whether the nodes are created as preemptible VM instances
        /// </summary>
        [Input("preemptible")]
        public Input<bool>? Preemptible { get; set; }

        /// <summary>
        /// The ID of your project to use when creating a cluster
        /// </summary>
        [Input("projectId", required: true)]
        public Input<string> ProjectId { get; set; } = null!;

        /// <summary>
        /// The region to launch the cluster. Region or zone should be used
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        [Input("resourceLabels")]
        private InputMap<string>? _resourceLabels;

        /// <summary>
        /// The map of Kubernetes labels (key/value pairs) to be applied to each cluster
        /// </summary>
        public InputMap<string> ResourceLabels
        {
            get => _resourceLabels ?? (_resourceLabels = new InputMap<string>());
            set => _resourceLabels = value;
        }

        /// <summary>
        /// The Google Cloud Platform Service Account to be used by the node VMs
        /// </summary>
        [Input("serviceAccount", required: true)]
        public Input<string> ServiceAccount { get; set; } = null!;

        /// <summary>
        /// The sub-network to use for the cluster
        /// </summary>
        [Input("subNetwork", required: true)]
        public Input<string> SubNetwork { get; set; } = null!;

        [Input("taints")]
        private InputList<string>? _taints;

        /// <summary>
        /// List of kubernetes taints to be applied to each node
        /// </summary>
        public InputList<string> Taints
        {
            get => _taints ?? (_taints = new InputList<string>());
            set => _taints = value;
        }

        /// <summary>
        /// Whether alias IPs will be used for pod IPs in the cluster
        /// </summary>
        [Input("useIpAliases")]
        public Input<bool>? UseIpAliases { get; set; }

        /// <summary>
        /// The zone to launch the cluster. Zone or region should be used
        /// </summary>
        [Input("zone")]
        public Input<string>? Zone { get; set; }

        public ClusterGkeConfigArgs()
        {
        }
        public static new ClusterGkeConfigArgs Empty => new ClusterGkeConfigArgs();
    }
}
