// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Rancher2
{
    public static partial class Invokes
    {
        /// <summary>
        /// Use this data source to retrieve information about a Rancher v2 cluster.
        /// 
        /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-rancher2/blob/master/website/docs/d/cluster.html.markdown.
        /// </summary>
        [Obsolete("Use GetCluster.InvokeAsync() instead")]
        public static Task<GetClusterResult> GetCluster(GetClusterArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetClusterResult>("rancher2:index/getCluster:getCluster", args ?? InvokeArgs.Empty, options.WithVersion());
    }
    public static class GetCluster
    {
        /// <summary>
        /// Use this data source to retrieve information about a Rancher v2 cluster.
        /// 
        /// &gt; This content is derived from https://github.com/terraform-providers/terraform-provider-rancher2/blob/master/website/docs/d/cluster.html.markdown.
        /// </summary>
        public static Task<GetClusterResult> InvokeAsync(GetClusterArgs args, InvokeOptions? options = null)
            => Pulumi.Deployment.Instance.InvokeAsync<GetClusterResult>("rancher2:index/getCluster:getCluster", args ?? InvokeArgs.Empty, options.WithVersion());
    }

    public sealed class GetClusterArgs : Pulumi.InvokeArgs
    {
        /// <summary>
        /// The name of the Cluster (string)
        /// </summary>
        [Input("name", required: true)]
        public string Name { get; set; } = null!;

        public GetClusterArgs()
        {
        }
    }

    [OutputType]
    public sealed class GetClusterResult
    {
        /// <summary>
        /// (Computed) The Azure aks configuration for `aks` Clusters. Conflicts with `eks_config`, `gke_config` and `rke_config` (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterAksConfigResult AksConfig;
        /// <summary>
        /// (Computed) Annotations for Node Pool object (map)
        /// </summary>
        public readonly ImmutableDictionary<string, object> Annotations;
        /// <summary>
        /// (Computed) Enabling the [local cluster authorized endpoint](https://rancher.com/docs/rancher/v2.x/en/cluster-provisioning/rke-clusters/options/#local-cluster-auth-endpoint) allows direct communication with the cluster, bypassing the Rancher API proxy. (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterClusterAuthEndpointResult ClusterAuthEndpoint;
        /// <summary>
        /// (Computed) Cluster monitoring config (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterClusterMonitoringInputResult ClusterMonitoringInput;
        /// <summary>
        /// (Computed) Cluster Registration Token generated for the cluster (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterClusterRegistrationTokenResult ClusterRegistrationToken;
        /// <summary>
        /// (Computed) Cluster template answers (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterClusterTemplateAnswersResult ClusterTemplateAnswers;
        /// <summary>
        /// (Computed) Cluster template ID (string)
        /// </summary>
        public readonly string ClusterTemplateId;
        /// <summary>
        /// (Computed) Cluster template questions (list)
        /// </summary>
        public readonly ImmutableArray<Outputs.GetClusterClusterTemplateQuestionsResult> ClusterTemplateQuestions;
        /// <summary>
        /// (Computed) Cluster template revision ID (string)
        /// </summary>
        public readonly string ClusterTemplateRevisionId;
        /// <summary>
        /// (Optional/Computed) [Default pod security policy template id](https://rancher.com/docs/rancher/v2.x/en/cluster-provisioning/rke-clusters/options/#pod-security-policy-support) (string)
        /// </summary>
        public readonly string DefaultPodSecurityPolicyTemplateId;
        /// <summary>
        /// (Computed) Default project ID for the cluster (string)
        /// </summary>
        public readonly string DefaultProjectId;
        /// <summary>
        /// (Computed) The description for Cluster (string)
        /// </summary>
        public readonly string Description;
        /// <summary>
        /// (Computed) The driver used for the Cluster. `imported`, `azurekubernetesservice`, `amazonelasticcontainerservice`, `googlekubernetesengine` and `rancherKubernetesEngine` are supported (string)
        /// </summary>
        public readonly string Driver;
        /// <summary>
        /// (Computed) The Amazon eks configuration for `eks` Clusters. Conflicts with `aks_config`, `gke_config` and `rke_config` (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterEksConfigResult EksConfig;
        public readonly bool EnableClusterAlerting;
        /// <summary>
        /// (Computed) Enable built-in cluster monitoring. Default `false` (bool)
        /// </summary>
        public readonly bool EnableClusterMonitoring;
        /// <summary>
        /// (Computed) Enable project network isolation. Default `false` (bool)
        /// </summary>
        public readonly bool EnableNetworkPolicy;
        /// <summary>
        /// (Computed) The Google gke configuration for `gke` Clusters. Conflicts with `aks_config`, `eks_config` and `rke_config` (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterGkeConfigResult GkeConfig;
        /// <summary>
        /// (Computed) The K3S configuration for `k3s` imported Clusters. Conflicts with `aks_config`, `eks_config`, `gke_config` and `rke_config` (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterK3sConfigResult K3sConfig;
        /// <summary>
        /// (Computed) Kube Config generated for the cluster (string)
        /// </summary>
        public readonly string KubeConfig;
        /// <summary>
        /// (Computed) Labels for Node Pool object (map)
        /// </summary>
        public readonly ImmutableDictionary<string, object> Labels;
        public readonly string Name;
        /// <summary>
        /// (Computed) The RKE configuration for `rke` Clusters. Conflicts with `aks_config`, `eks_config` and `gke_config` (list maxitems:1)
        /// </summary>
        public readonly Outputs.GetClusterRkeConfigResult RkeConfig;
        public readonly ImmutableArray<Outputs.GetClusterScheduledClusterScansResult> ScheduledClusterScans;
        /// <summary>
        /// (Computed) System project ID for the cluster (string)
        /// </summary>
        public readonly string SystemProjectId;
        /// <summary>
        /// id is the provider-assigned unique ID for this managed resource.
        /// </summary>
        public readonly string Id;

        [OutputConstructor]
        private GetClusterResult(
            Outputs.GetClusterAksConfigResult aksConfig,
            ImmutableDictionary<string, object> annotations,
            Outputs.GetClusterClusterAuthEndpointResult clusterAuthEndpoint,
            Outputs.GetClusterClusterMonitoringInputResult clusterMonitoringInput,
            Outputs.GetClusterClusterRegistrationTokenResult clusterRegistrationToken,
            Outputs.GetClusterClusterTemplateAnswersResult clusterTemplateAnswers,
            string clusterTemplateId,
            ImmutableArray<Outputs.GetClusterClusterTemplateQuestionsResult> clusterTemplateQuestions,
            string clusterTemplateRevisionId,
            string defaultPodSecurityPolicyTemplateId,
            string defaultProjectId,
            string description,
            string driver,
            Outputs.GetClusterEksConfigResult eksConfig,
            bool enableClusterAlerting,
            bool enableClusterMonitoring,
            bool enableNetworkPolicy,
            Outputs.GetClusterGkeConfigResult gkeConfig,
            Outputs.GetClusterK3sConfigResult k3sConfig,
            string kubeConfig,
            ImmutableDictionary<string, object> labels,
            string name,
            Outputs.GetClusterRkeConfigResult rkeConfig,
            ImmutableArray<Outputs.GetClusterScheduledClusterScansResult> scheduledClusterScans,
            string systemProjectId,
            string id)
        {
            AksConfig = aksConfig;
            Annotations = annotations;
            ClusterAuthEndpoint = clusterAuthEndpoint;
            ClusterMonitoringInput = clusterMonitoringInput;
            ClusterRegistrationToken = clusterRegistrationToken;
            ClusterTemplateAnswers = clusterTemplateAnswers;
            ClusterTemplateId = clusterTemplateId;
            ClusterTemplateQuestions = clusterTemplateQuestions;
            ClusterTemplateRevisionId = clusterTemplateRevisionId;
            DefaultPodSecurityPolicyTemplateId = defaultPodSecurityPolicyTemplateId;
            DefaultProjectId = defaultProjectId;
            Description = description;
            Driver = driver;
            EksConfig = eksConfig;
            EnableClusterAlerting = enableClusterAlerting;
            EnableClusterMonitoring = enableClusterMonitoring;
            EnableNetworkPolicy = enableNetworkPolicy;
            GkeConfig = gkeConfig;
            K3sConfig = k3sConfig;
            KubeConfig = kubeConfig;
            Labels = labels;
            Name = name;
            RkeConfig = rkeConfig;
            ScheduledClusterScans = scheduledClusterScans;
            SystemProjectId = systemProjectId;
            Id = id;
        }
    }

    namespace Outputs
    {

    [OutputType]
    public sealed class GetClusterAksConfigResult
    {
        public readonly string? AadServerAppSecret;
        public readonly string? AadTenantId;
        public readonly string? AddClientAppId;
        public readonly string? AddServerAppId;
        public readonly string? AdminUsername;
        public readonly string AgentDnsPrefix;
        public readonly int? AgentOsDiskSize;
        public readonly string? AgentPoolName;
        public readonly string? AgentStorageProfile;
        public readonly string? AgentVmSize;
        public readonly string? AuthBaseUrl;
        public readonly string? BaseUrl;
        public readonly string ClientId;
        public readonly string ClientSecret;
        public readonly int? Count;
        public readonly string? DnsServiceIp;
        public readonly string? DockerBridgeCidr;
        public readonly bool? EnableHttpApplicationRouting;
        public readonly bool? EnableMonitoring;
        public readonly string KubernetesVersion;
        public readonly string? Location;
        public readonly string? LogAnalyticsWorkspace;
        public readonly string? LogAnalyticsWorkspaceResourceGroup;
        public readonly string MasterDnsPrefix;
        public readonly int? MaxPods;
        public readonly string? NetworkPlugin;
        public readonly string? NetworkPolicy;
        public readonly string? PodCidr;
        public readonly string ResourceGroup;
        public readonly string? ServiceCidr;
        public readonly string SshPublicKeyContents;
        public readonly string Subnet;
        public readonly string SubscriptionId;
        public readonly ImmutableDictionary<string, object> Tag;
        public readonly string TenantId;
        public readonly string VirtualNetwork;
        public readonly string VirtualNetworkResourceGroup;

        [OutputConstructor]
        private GetClusterAksConfigResult(
            string? aadServerAppSecret,
            string? aadTenantId,
            string? addClientAppId,
            string? addServerAppId,
            string? adminUsername,
            string agentDnsPrefix,
            int? agentOsDiskSize,
            string? agentPoolName,
            string? agentStorageProfile,
            string? agentVmSize,
            string? authBaseUrl,
            string? baseUrl,
            string clientId,
            string clientSecret,
            int? count,
            string? dnsServiceIp,
            string? dockerBridgeCidr,
            bool? enableHttpApplicationRouting,
            bool? enableMonitoring,
            string kubernetesVersion,
            string? location,
            string? logAnalyticsWorkspace,
            string? logAnalyticsWorkspaceResourceGroup,
            string masterDnsPrefix,
            int? maxPods,
            string? networkPlugin,
            string? networkPolicy,
            string? podCidr,
            string resourceGroup,
            string? serviceCidr,
            string sshPublicKeyContents,
            string subnet,
            string subscriptionId,
            ImmutableDictionary<string, object> tag,
            string tenantId,
            string virtualNetwork,
            string virtualNetworkResourceGroup)
        {
            AadServerAppSecret = aadServerAppSecret;
            AadTenantId = aadTenantId;
            AddClientAppId = addClientAppId;
            AddServerAppId = addServerAppId;
            AdminUsername = adminUsername;
            AgentDnsPrefix = agentDnsPrefix;
            AgentOsDiskSize = agentOsDiskSize;
            AgentPoolName = agentPoolName;
            AgentStorageProfile = agentStorageProfile;
            AgentVmSize = agentVmSize;
            AuthBaseUrl = authBaseUrl;
            BaseUrl = baseUrl;
            ClientId = clientId;
            ClientSecret = clientSecret;
            Count = count;
            DnsServiceIp = dnsServiceIp;
            DockerBridgeCidr = dockerBridgeCidr;
            EnableHttpApplicationRouting = enableHttpApplicationRouting;
            EnableMonitoring = enableMonitoring;
            KubernetesVersion = kubernetesVersion;
            Location = location;
            LogAnalyticsWorkspace = logAnalyticsWorkspace;
            LogAnalyticsWorkspaceResourceGroup = logAnalyticsWorkspaceResourceGroup;
            MasterDnsPrefix = masterDnsPrefix;
            MaxPods = maxPods;
            NetworkPlugin = networkPlugin;
            NetworkPolicy = networkPolicy;
            PodCidr = podCidr;
            ResourceGroup = resourceGroup;
            ServiceCidr = serviceCidr;
            SshPublicKeyContents = sshPublicKeyContents;
            Subnet = subnet;
            SubscriptionId = subscriptionId;
            Tag = tag;
            TenantId = tenantId;
            VirtualNetwork = virtualNetwork;
            VirtualNetworkResourceGroup = virtualNetworkResourceGroup;
        }
    }

    [OutputType]
    public sealed class GetClusterClusterAuthEndpointResult
    {
        public readonly string? CaCerts;
        public readonly bool? Enabled;
        public readonly string? Fqdn;

        [OutputConstructor]
        private GetClusterClusterAuthEndpointResult(
            string? caCerts,
            bool? enabled,
            string? fqdn)
        {
            CaCerts = caCerts;
            Enabled = enabled;
            Fqdn = fqdn;
        }
    }

    [OutputType]
    public sealed class GetClusterClusterMonitoringInputResult
    {
        public readonly ImmutableDictionary<string, object>? Answers;
        public readonly string? Version;

        [OutputConstructor]
        private GetClusterClusterMonitoringInputResult(
            ImmutableDictionary<string, object>? answers,
            string? version)
        {
            Answers = answers;
            Version = version;
        }
    }

    [OutputType]
    public sealed class GetClusterClusterRegistrationTokenResult
    {
        /// <summary>
        /// (Computed) Annotations for Node Pool object (map)
        /// </summary>
        public readonly ImmutableDictionary<string, object> Annotations;
        public readonly string ClusterId;
        public readonly string Command;
        /// <summary>
        /// (Computed) The ID of the resource (string)
        /// </summary>
        public readonly string Id;
        public readonly string InsecureCommand;
        /// <summary>
        /// (Computed) Labels for Node Pool object (map)
        /// </summary>
        public readonly ImmutableDictionary<string, object> Labels;
        public readonly string ManifestUrl;
        /// <summary>
        /// The name of the Cluster (string)
        /// </summary>
        public readonly string Name;
        public readonly string NodeCommand;
        public readonly string Token;
        public readonly string WindowsNodeCommand;

        [OutputConstructor]
        private GetClusterClusterRegistrationTokenResult(
            ImmutableDictionary<string, object> annotations,
            string clusterId,
            string command,
            string id,
            string insecureCommand,
            ImmutableDictionary<string, object> labels,
            string manifestUrl,
            string name,
            string nodeCommand,
            string token,
            string windowsNodeCommand)
        {
            Annotations = annotations;
            ClusterId = clusterId;
            Command = command;
            Id = id;
            InsecureCommand = insecureCommand;
            Labels = labels;
            ManifestUrl = manifestUrl;
            Name = name;
            NodeCommand = nodeCommand;
            Token = token;
            WindowsNodeCommand = windowsNodeCommand;
        }
    }

    [OutputType]
    public sealed class GetClusterClusterTemplateAnswersResult
    {
        public readonly string ClusterId;
        public readonly string ProjectId;
        public readonly ImmutableDictionary<string, object> Values;

        [OutputConstructor]
        private GetClusterClusterTemplateAnswersResult(
            string clusterId,
            string projectId,
            ImmutableDictionary<string, object> values)
        {
            ClusterId = clusterId;
            ProjectId = projectId;
            Values = values;
        }
    }

    [OutputType]
    public sealed class GetClusterClusterTemplateQuestionsResult
    {
        public readonly string Default;
        public readonly bool? Required;
        public readonly string? Type;
        public readonly string Variable;

        [OutputConstructor]
        private GetClusterClusterTemplateQuestionsResult(
            string @default,
            bool? required,
            string? type,
            string variable)
        {
            Default = @default;
            Required = required;
            Type = type;
            Variable = variable;
        }
    }

    [OutputType]
    public sealed class GetClusterEksConfigResult
    {
        public readonly string AccessKey;
        public readonly string? Ami;
        public readonly bool? AssociateWorkerNodePublicIp;
        public readonly int? DesiredNodes;
        public readonly string? InstanceType;
        public readonly string? KeyPairName;
        public readonly string KubernetesVersion;
        public readonly int? MaximumNodes;
        public readonly int? MinimumNodes;
        public readonly int? NodeVolumeSize;
        public readonly string? Region;
        public readonly string SecretKey;
        public readonly ImmutableArray<string> SecurityGroups;
        public readonly string? ServiceRole;
        public readonly string? SessionToken;
        public readonly ImmutableArray<string> Subnets;
        public readonly string UserData;
        public readonly string? VirtualNetwork;

        [OutputConstructor]
        private GetClusterEksConfigResult(
            string accessKey,
            string? ami,
            bool? associateWorkerNodePublicIp,
            int? desiredNodes,
            string? instanceType,
            string? keyPairName,
            string kubernetesVersion,
            int? maximumNodes,
            int? minimumNodes,
            int? nodeVolumeSize,
            string? region,
            string secretKey,
            ImmutableArray<string> securityGroups,
            string? serviceRole,
            string? sessionToken,
            ImmutableArray<string> subnets,
            string userData,
            string? virtualNetwork)
        {
            AccessKey = accessKey;
            Ami = ami;
            AssociateWorkerNodePublicIp = associateWorkerNodePublicIp;
            DesiredNodes = desiredNodes;
            InstanceType = instanceType;
            KeyPairName = keyPairName;
            KubernetesVersion = kubernetesVersion;
            MaximumNodes = maximumNodes;
            MinimumNodes = minimumNodes;
            NodeVolumeSize = nodeVolumeSize;
            Region = region;
            SecretKey = secretKey;
            SecurityGroups = securityGroups;
            ServiceRole = serviceRole;
            SessionToken = sessionToken;
            Subnets = subnets;
            UserData = userData;
            VirtualNetwork = virtualNetwork;
        }
    }

    [OutputType]
    public sealed class GetClusterGkeConfigResult
    {
        public readonly string ClusterIpv4Cidr;
        public readonly string Credential;
        /// <summary>
        /// (Computed) The description for Cluster (string)
        /// </summary>
        public readonly string? Description;
        public readonly int? DiskSizeGb;
        public readonly string DiskType;
        public readonly bool? EnableAlphaFeature;
        public readonly bool? EnableAutoRepair;
        public readonly bool? EnableAutoUpgrade;
        public readonly bool? EnableHorizontalPodAutoscaling;
        public readonly bool? EnableHttpLoadBalancing;
        public readonly bool? EnableKubernetesDashboard;
        public readonly bool? EnableLegacyAbac;
        public readonly bool? EnableMasterAuthorizedNetwork;
        public readonly bool? EnableNetworkPolicyConfig;
        public readonly bool? EnableNodepoolAutoscaling;
        public readonly bool? EnablePrivateEndpoint;
        public readonly bool? EnablePrivateNodes;
        public readonly bool? EnableStackdriverLogging;
        public readonly bool? EnableStackdriverMonitoring;
        public readonly string ImageType;
        public readonly string IpPolicyClusterIpv4CidrBlock;
        public readonly string IpPolicyClusterSecondaryRangeName;
        public readonly bool? IpPolicyCreateSubnetwork;
        public readonly string IpPolicyNodeIpv4CidrBlock;
        public readonly string IpPolicyServicesIpv4CidrBlock;
        public readonly string IpPolicyServicesSecondaryRangeName;
        public readonly string IpPolicySubnetworkName;
        public readonly bool? IssueClientCertificate;
        public readonly bool? KubernetesDashboard;
        /// <summary>
        /// (Computed) Labels for Node Pool object (map)
        /// </summary>
        public readonly ImmutableDictionary<string, object> Labels;
        public readonly int? LocalSsdCount;
        public readonly ImmutableArray<string> Locations;
        public readonly string MachineType;
        public readonly string MaintenanceWindow;
        public readonly ImmutableArray<string> MasterAuthorizedNetworkCidrBlocks;
        public readonly string MasterIpv4CidrBlock;
        public readonly string MasterVersion;
        public readonly int? MaxNodeCount;
        public readonly int? MinNodeCount;
        public readonly string Network;
        public readonly int? NodeCount;
        public readonly string NodePool;
        public readonly string NodeVersion;
        public readonly ImmutableArray<string> OauthScopes;
        public readonly bool? Preemptible;
        public readonly string ProjectId;
        public readonly ImmutableDictionary<string, object> ResourceLabels;
        public readonly string ServiceAccount;
        public readonly string SubNetwork;
        public readonly ImmutableArray<string> Taints;
        public readonly bool? UseIpAliases;
        public readonly string? Zone;

        [OutputConstructor]
        private GetClusterGkeConfigResult(
            string clusterIpv4Cidr,
            string credential,
            string? description,
            int? diskSizeGb,
            string diskType,
            bool? enableAlphaFeature,
            bool? enableAutoRepair,
            bool? enableAutoUpgrade,
            bool? enableHorizontalPodAutoscaling,
            bool? enableHttpLoadBalancing,
            bool? enableKubernetesDashboard,
            bool? enableLegacyAbac,
            bool? enableMasterAuthorizedNetwork,
            bool? enableNetworkPolicyConfig,
            bool? enableNodepoolAutoscaling,
            bool? enablePrivateEndpoint,
            bool? enablePrivateNodes,
            bool? enableStackdriverLogging,
            bool? enableStackdriverMonitoring,
            string imageType,
            string ipPolicyClusterIpv4CidrBlock,
            string ipPolicyClusterSecondaryRangeName,
            bool? ipPolicyCreateSubnetwork,
            string ipPolicyNodeIpv4CidrBlock,
            string ipPolicyServicesIpv4CidrBlock,
            string ipPolicyServicesSecondaryRangeName,
            string ipPolicySubnetworkName,
            bool? issueClientCertificate,
            bool? kubernetesDashboard,
            ImmutableDictionary<string, object> labels,
            int? localSsdCount,
            ImmutableArray<string> locations,
            string machineType,
            string maintenanceWindow,
            ImmutableArray<string> masterAuthorizedNetworkCidrBlocks,
            string masterIpv4CidrBlock,
            string masterVersion,
            int? maxNodeCount,
            int? minNodeCount,
            string network,
            int? nodeCount,
            string nodePool,
            string nodeVersion,
            ImmutableArray<string> oauthScopes,
            bool? preemptible,
            string projectId,
            ImmutableDictionary<string, object> resourceLabels,
            string serviceAccount,
            string subNetwork,
            ImmutableArray<string> taints,
            bool? useIpAliases,
            string? zone)
        {
            ClusterIpv4Cidr = clusterIpv4Cidr;
            Credential = credential;
            Description = description;
            DiskSizeGb = diskSizeGb;
            DiskType = diskType;
            EnableAlphaFeature = enableAlphaFeature;
            EnableAutoRepair = enableAutoRepair;
            EnableAutoUpgrade = enableAutoUpgrade;
            EnableHorizontalPodAutoscaling = enableHorizontalPodAutoscaling;
            EnableHttpLoadBalancing = enableHttpLoadBalancing;
            EnableKubernetesDashboard = enableKubernetesDashboard;
            EnableLegacyAbac = enableLegacyAbac;
            EnableMasterAuthorizedNetwork = enableMasterAuthorizedNetwork;
            EnableNetworkPolicyConfig = enableNetworkPolicyConfig;
            EnableNodepoolAutoscaling = enableNodepoolAutoscaling;
            EnablePrivateEndpoint = enablePrivateEndpoint;
            EnablePrivateNodes = enablePrivateNodes;
            EnableStackdriverLogging = enableStackdriverLogging;
            EnableStackdriverMonitoring = enableStackdriverMonitoring;
            ImageType = imageType;
            IpPolicyClusterIpv4CidrBlock = ipPolicyClusterIpv4CidrBlock;
            IpPolicyClusterSecondaryRangeName = ipPolicyClusterSecondaryRangeName;
            IpPolicyCreateSubnetwork = ipPolicyCreateSubnetwork;
            IpPolicyNodeIpv4CidrBlock = ipPolicyNodeIpv4CidrBlock;
            IpPolicyServicesIpv4CidrBlock = ipPolicyServicesIpv4CidrBlock;
            IpPolicyServicesSecondaryRangeName = ipPolicyServicesSecondaryRangeName;
            IpPolicySubnetworkName = ipPolicySubnetworkName;
            IssueClientCertificate = issueClientCertificate;
            KubernetesDashboard = kubernetesDashboard;
            Labels = labels;
            LocalSsdCount = localSsdCount;
            Locations = locations;
            MachineType = machineType;
            MaintenanceWindow = maintenanceWindow;
            MasterAuthorizedNetworkCidrBlocks = masterAuthorizedNetworkCidrBlocks;
            MasterIpv4CidrBlock = masterIpv4CidrBlock;
            MasterVersion = masterVersion;
            MaxNodeCount = maxNodeCount;
            MinNodeCount = minNodeCount;
            Network = network;
            NodeCount = nodeCount;
            NodePool = nodePool;
            NodeVersion = nodeVersion;
            OauthScopes = oauthScopes;
            Preemptible = preemptible;
            ProjectId = projectId;
            ResourceLabels = resourceLabels;
            ServiceAccount = serviceAccount;
            SubNetwork = subNetwork;
            Taints = taints;
            UseIpAliases = useIpAliases;
            Zone = zone;
        }
    }

    [OutputType]
    public sealed class GetClusterK3sConfigResult
    {
        public readonly GetClusterK3sConfigUpgradeStrategyResult UpgradeStrategy;
        public readonly string Version;

        [OutputConstructor]
        private GetClusterK3sConfigResult(
            GetClusterK3sConfigUpgradeStrategyResult upgradeStrategy,
            string version)
        {
            UpgradeStrategy = upgradeStrategy;
            Version = version;
        }
    }

    [OutputType]
    public sealed class GetClusterK3sConfigUpgradeStrategyResult
    {
        public readonly bool? DrainServerNodes;
        public readonly bool? DrainWorkerNodes;
        public readonly int? ServerConcurrency;
        public readonly int? WorkerConcurrency;

        [OutputConstructor]
        private GetClusterK3sConfigUpgradeStrategyResult(
            bool? drainServerNodes,
            bool? drainWorkerNodes,
            int? serverConcurrency,
            int? workerConcurrency)
        {
            DrainServerNodes = drainServerNodes;
            DrainWorkerNodes = drainWorkerNodes;
            ServerConcurrency = serverConcurrency;
            WorkerConcurrency = workerConcurrency;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigAuthenticationResult
    {
        public readonly ImmutableArray<string> Sans;
        public readonly string Strategy;

        [OutputConstructor]
        private GetClusterRkeConfigAuthenticationResult(
            ImmutableArray<string> sans,
            string strategy)
        {
            Sans = sans;
            Strategy = strategy;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigAuthorizationResult
    {
        public readonly string? Mode;
        public readonly ImmutableDictionary<string, object> Options;

        [OutputConstructor]
        private GetClusterRkeConfigAuthorizationResult(
            string? mode,
            ImmutableDictionary<string, object> options)
        {
            Mode = mode;
            Options = options;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigBastionHostResult
    {
        public readonly string Address;
        public readonly string? Port;
        public readonly bool? SshAgentAuth;
        public readonly string SshKey;
        public readonly string SshKeyPath;
        public readonly string User;

        [OutputConstructor]
        private GetClusterRkeConfigBastionHostResult(
            string address,
            string? port,
            bool? sshAgentAuth,
            string sshKey,
            string sshKeyPath,
            string user)
        {
            Address = address;
            Port = port;
            SshAgentAuth = sshAgentAuth;
            SshKey = sshKey;
            SshKeyPath = sshKeyPath;
            User = user;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult
    {
        public readonly bool? DisableSecurityGroupIngress;
        public readonly bool? DisableStrictZoneCheck;
        public readonly string ElbSecurityGroup;
        public readonly string KubernetesClusterId;
        public readonly string KubernetesClusterTag;
        public readonly string RoleArn;
        public readonly string RouteTableId;
        public readonly string SubnetId;
        public readonly string Vpc;
        public readonly string Zone;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult(
            bool? disableSecurityGroupIngress,
            bool? disableStrictZoneCheck,
            string elbSecurityGroup,
            string kubernetesClusterId,
            string kubernetesClusterTag,
            string roleArn,
            string routeTableId,
            string subnetId,
            string vpc,
            string zone)
        {
            DisableSecurityGroupIngress = disableSecurityGroupIngress;
            DisableStrictZoneCheck = disableStrictZoneCheck;
            ElbSecurityGroup = elbSecurityGroup;
            KubernetesClusterId = kubernetesClusterId;
            KubernetesClusterTag = kubernetesClusterTag;
            RoleArn = roleArn;
            RouteTableId = routeTableId;
            SubnetId = subnetId;
            Vpc = vpc;
            Zone = zone;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderAwsCloudProviderResult
    {
        public readonly GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult Global;
        public readonly ImmutableArray<GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverridesResult> ServiceOverrides;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderAwsCloudProviderResult(
            GetClusterRkeConfigCloudProviderAwsCloudProviderGlobalResult global,
            ImmutableArray<GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverridesResult> serviceOverrides)
        {
            Global = global;
            ServiceOverrides = serviceOverrides;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverridesResult
    {
        public readonly string Region;
        public readonly string Service;
        public readonly string SigningMethod;
        public readonly string SigningName;
        public readonly string SigningRegion;
        public readonly string Url;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverridesResult(
            string region,
            string service,
            string signingMethod,
            string signingName,
            string signingRegion,
            string url)
        {
            Region = region;
            Service = service;
            SigningMethod = signingMethod;
            SigningName = signingName;
            SigningRegion = signingRegion;
            Url = url;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderAzureCloudProviderResult
    {
        public readonly string AadClientCertPassword;
        public readonly string AadClientCertPath;
        public readonly string AadClientId;
        public readonly string AadClientSecret;
        public readonly string Cloud;
        public readonly bool CloudProviderBackoff;
        public readonly int CloudProviderBackoffDuration;
        public readonly int CloudProviderBackoffExponent;
        public readonly int CloudProviderBackoffJitter;
        public readonly int CloudProviderBackoffRetries;
        public readonly bool CloudProviderRateLimit;
        public readonly int CloudProviderRateLimitBucket;
        public readonly int CloudProviderRateLimitQps;
        public readonly string Location;
        public readonly int MaximumLoadBalancerRuleCount;
        public readonly string PrimaryAvailabilitySetName;
        public readonly string PrimaryScaleSetName;
        public readonly string ResourceGroup;
        public readonly string RouteTableName;
        public readonly string SecurityGroupName;
        public readonly string SubnetName;
        public readonly string SubscriptionId;
        public readonly string TenantId;
        public readonly bool UseInstanceMetadata;
        public readonly bool UseManagedIdentityExtension;
        public readonly string VmType;
        public readonly string VnetName;
        public readonly string VnetResourceGroup;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderAzureCloudProviderResult(
            string aadClientCertPassword,
            string aadClientCertPath,
            string aadClientId,
            string aadClientSecret,
            string cloud,
            bool cloudProviderBackoff,
            int cloudProviderBackoffDuration,
            int cloudProviderBackoffExponent,
            int cloudProviderBackoffJitter,
            int cloudProviderBackoffRetries,
            bool cloudProviderRateLimit,
            int cloudProviderRateLimitBucket,
            int cloudProviderRateLimitQps,
            string location,
            int maximumLoadBalancerRuleCount,
            string primaryAvailabilitySetName,
            string primaryScaleSetName,
            string resourceGroup,
            string routeTableName,
            string securityGroupName,
            string subnetName,
            string subscriptionId,
            string tenantId,
            bool useInstanceMetadata,
            bool useManagedIdentityExtension,
            string vmType,
            string vnetName,
            string vnetResourceGroup)
        {
            AadClientCertPassword = aadClientCertPassword;
            AadClientCertPath = aadClientCertPath;
            AadClientId = aadClientId;
            AadClientSecret = aadClientSecret;
            Cloud = cloud;
            CloudProviderBackoff = cloudProviderBackoff;
            CloudProviderBackoffDuration = cloudProviderBackoffDuration;
            CloudProviderBackoffExponent = cloudProviderBackoffExponent;
            CloudProviderBackoffJitter = cloudProviderBackoffJitter;
            CloudProviderBackoffRetries = cloudProviderBackoffRetries;
            CloudProviderRateLimit = cloudProviderRateLimit;
            CloudProviderRateLimitBucket = cloudProviderRateLimitBucket;
            CloudProviderRateLimitQps = cloudProviderRateLimitQps;
            Location = location;
            MaximumLoadBalancerRuleCount = maximumLoadBalancerRuleCount;
            PrimaryAvailabilitySetName = primaryAvailabilitySetName;
            PrimaryScaleSetName = primaryScaleSetName;
            ResourceGroup = resourceGroup;
            RouteTableName = routeTableName;
            SecurityGroupName = securityGroupName;
            SubnetName = subnetName;
            SubscriptionId = subscriptionId;
            TenantId = tenantId;
            UseInstanceMetadata = useInstanceMetadata;
            UseManagedIdentityExtension = useManagedIdentityExtension;
            VmType = vmType;
            VnetName = vnetName;
            VnetResourceGroup = vnetResourceGroup;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult
    {
        public readonly string BsVersion;
        public readonly bool IgnoreVolumeAz;
        public readonly bool TrustDevicePath;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult(
            string bsVersion,
            bool ignoreVolumeAz,
            bool trustDevicePath)
        {
            BsVersion = bsVersion;
            IgnoreVolumeAz = ignoreVolumeAz;
            TrustDevicePath = trustDevicePath;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult
    {
        public readonly string AuthUrl;
        public readonly string CaFile;
        public readonly string DomainId;
        public readonly string DomainName;
        public readonly string Password;
        public readonly string Region;
        public readonly string TenantId;
        public readonly string TenantName;
        public readonly string TrustId;
        public readonly string Username;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult(
            string authUrl,
            string caFile,
            string domainId,
            string domainName,
            string password,
            string region,
            string tenantId,
            string tenantName,
            string trustId,
            string username)
        {
            AuthUrl = authUrl;
            CaFile = caFile;
            DomainId = domainId;
            DomainName = domainName;
            Password = password;
            Region = region;
            TenantId = tenantId;
            TenantName = tenantName;
            TrustId = trustId;
            Username = username;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult
    {
        public readonly bool CreateMonitor;
        public readonly string FloatingNetworkId;
        public readonly string LbMethod;
        public readonly string LbProvider;
        public readonly string LbVersion;
        public readonly bool ManageSecurityGroups;
        public readonly string? MonitorDelay;
        public readonly int? MonitorMaxRetries;
        public readonly string? MonitorTimeout;
        public readonly string SubnetId;
        public readonly bool UseOctavia;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult(
            bool createMonitor,
            string floatingNetworkId,
            string lbMethod,
            string lbProvider,
            string lbVersion,
            bool manageSecurityGroups,
            string? monitorDelay,
            int? monitorMaxRetries,
            string? monitorTimeout,
            string subnetId,
            bool useOctavia)
        {
            CreateMonitor = createMonitor;
            FloatingNetworkId = floatingNetworkId;
            LbMethod = lbMethod;
            LbProvider = lbProvider;
            LbVersion = lbVersion;
            ManageSecurityGroups = manageSecurityGroups;
            MonitorDelay = monitorDelay;
            MonitorMaxRetries = monitorMaxRetries;
            MonitorTimeout = monitorTimeout;
            SubnetId = subnetId;
            UseOctavia = useOctavia;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult
    {
        public readonly int RequestTimeout;
        public readonly string SearchOrder;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult(
            int requestTimeout,
            string searchOrder)
        {
            RequestTimeout = requestTimeout;
            SearchOrder = searchOrder;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult
    {
        public readonly GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult BlockStorage;
        public readonly GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult Global;
        public readonly GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult LoadBalancer;
        public readonly GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult Metadata;
        public readonly GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult Route;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult(
            GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorageResult blockStorage,
            GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobalResult global,
            GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancerResult loadBalancer,
            GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadataResult metadata,
            GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult route)
        {
            BlockStorage = blockStorage;
            Global = global;
            LoadBalancer = loadBalancer;
            Metadata = metadata;
            Route = route;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult
    {
        public readonly string RouterId;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderOpenstackCloudProviderRouteResult(string routerId)
        {
            RouterId = routerId;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderResult
    {
        public readonly GetClusterRkeConfigCloudProviderAwsCloudProviderResult? AwsCloudProvider;
        public readonly GetClusterRkeConfigCloudProviderAzureCloudProviderResult? AzureCloudProvider;
        public readonly string CustomCloudProvider;
        /// <summary>
        /// The name of the Cluster (string)
        /// </summary>
        public readonly string Name;
        public readonly GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult? OpenstackCloudProvider;
        public readonly GetClusterRkeConfigCloudProviderVsphereCloudProviderResult? VsphereCloudProvider;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderResult(
            GetClusterRkeConfigCloudProviderAwsCloudProviderResult? awsCloudProvider,
            GetClusterRkeConfigCloudProviderAzureCloudProviderResult? azureCloudProvider,
            string customCloudProvider,
            string name,
            GetClusterRkeConfigCloudProviderOpenstackCloudProviderResult? openstackCloudProvider,
            GetClusterRkeConfigCloudProviderVsphereCloudProviderResult? vsphereCloudProvider)
        {
            AwsCloudProvider = awsCloudProvider;
            AzureCloudProvider = azureCloudProvider;
            CustomCloudProvider = customCloudProvider;
            Name = name;
            OpenstackCloudProvider = openstackCloudProvider;
            VsphereCloudProvider = vsphereCloudProvider;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult
    {
        public readonly string ScsiControllerType;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult(string scsiControllerType)
        {
            ScsiControllerType = scsiControllerType;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult
    {
        public readonly string Datacenters;
        public readonly bool InsecureFlag;
        public readonly string Password;
        public readonly string Port;
        public readonly int SoapRoundtripCount;
        public readonly string User;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult(
            string datacenters,
            bool insecureFlag,
            string password,
            string port,
            int soapRoundtripCount,
            string user)
        {
            Datacenters = datacenters;
            InsecureFlag = insecureFlag;
            Password = password;
            Port = port;
            SoapRoundtripCount = soapRoundtripCount;
            User = user;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult
    {
        public readonly string PublicNetwork;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult(string publicNetwork)
        {
            PublicNetwork = publicNetwork;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderVsphereCloudProviderResult
    {
        public readonly GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult Disk;
        public readonly GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult Global;
        public readonly GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult Network;
        public readonly ImmutableArray<GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCentersResult> VirtualCenters;
        public readonly GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult Workspace;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderVsphereCloudProviderResult(
            GetClusterRkeConfigCloudProviderVsphereCloudProviderDiskResult disk,
            GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobalResult global,
            GetClusterRkeConfigCloudProviderVsphereCloudProviderNetworkResult network,
            ImmutableArray<GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCentersResult> virtualCenters,
            GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult workspace)
        {
            Disk = disk;
            Global = global;
            Network = network;
            VirtualCenters = virtualCenters;
            Workspace = workspace;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCentersResult
    {
        public readonly string Datacenters;
        /// <summary>
        /// The name of the Cluster (string)
        /// </summary>
        public readonly string Name;
        public readonly string Password;
        public readonly string Port;
        public readonly int SoapRoundtripCount;
        public readonly string User;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCentersResult(
            string datacenters,
            string name,
            string password,
            string port,
            int soapRoundtripCount,
            string user)
        {
            Datacenters = datacenters;
            Name = name;
            Password = password;
            Port = port;
            SoapRoundtripCount = soapRoundtripCount;
            User = user;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult
    {
        public readonly string Datacenter;
        public readonly string DefaultDatastore;
        public readonly string Folder;
        public readonly string ResourcepoolPath;
        public readonly string Server;

        [OutputConstructor]
        private GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspaceResult(
            string datacenter,
            string defaultDatastore,
            string folder,
            string resourcepoolPath,
            string server)
        {
            Datacenter = datacenter;
            DefaultDatastore = defaultDatastore;
            Folder = folder;
            ResourcepoolPath = resourcepoolPath;
            Server = server;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigDnsResult
    {
        public readonly ImmutableDictionary<string, object> NodeSelector;
        public readonly string? Provider;
        public readonly ImmutableArray<string> ReverseCidrs;
        public readonly ImmutableArray<string> UpstreamNameservers;

        [OutputConstructor]
        private GetClusterRkeConfigDnsResult(
            ImmutableDictionary<string, object> nodeSelector,
            string? provider,
            ImmutableArray<string> reverseCidrs,
            ImmutableArray<string> upstreamNameservers)
        {
            NodeSelector = nodeSelector;
            Provider = provider;
            ReverseCidrs = reverseCidrs;
            UpstreamNameservers = upstreamNameservers;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigIngressResult
    {
        public readonly string DnsPolicy;
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableDictionary<string, object> NodeSelector;
        public readonly ImmutableDictionary<string, object> Options;
        public readonly string Provider;

        [OutputConstructor]
        private GetClusterRkeConfigIngressResult(
            string dnsPolicy,
            ImmutableDictionary<string, object> extraArgs,
            ImmutableDictionary<string, object> nodeSelector,
            ImmutableDictionary<string, object> options,
            string provider)
        {
            DnsPolicy = dnsPolicy;
            ExtraArgs = extraArgs;
            NodeSelector = nodeSelector;
            Options = options;
            Provider = provider;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigMonitoringResult
    {
        public readonly ImmutableDictionary<string, object> Options;
        public readonly string Provider;

        [OutputConstructor]
        private GetClusterRkeConfigMonitoringResult(
            ImmutableDictionary<string, object> options,
            string provider)
        {
            Options = options;
            Provider = provider;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigNetworkCalicoNetworkProviderResult
    {
        public readonly string CloudProvider;

        [OutputConstructor]
        private GetClusterRkeConfigNetworkCalicoNetworkProviderResult(string cloudProvider)
        {
            CloudProvider = cloudProvider;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigNetworkCanalNetworkProviderResult
    {
        public readonly string Iface;

        [OutputConstructor]
        private GetClusterRkeConfigNetworkCanalNetworkProviderResult(string iface)
        {
            Iface = iface;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigNetworkFlannelNetworkProviderResult
    {
        public readonly string Iface;

        [OutputConstructor]
        private GetClusterRkeConfigNetworkFlannelNetworkProviderResult(string iface)
        {
            Iface = iface;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigNetworkResult
    {
        public readonly GetClusterRkeConfigNetworkCalicoNetworkProviderResult? CalicoNetworkProvider;
        public readonly GetClusterRkeConfigNetworkCanalNetworkProviderResult? CanalNetworkProvider;
        public readonly GetClusterRkeConfigNetworkFlannelNetworkProviderResult? FlannelNetworkProvider;
        public readonly int? Mtu;
        public readonly ImmutableDictionary<string, object> Options;
        public readonly string Plugin;
        public readonly GetClusterRkeConfigNetworkWeaveNetworkProviderResult? WeaveNetworkProvider;

        [OutputConstructor]
        private GetClusterRkeConfigNetworkResult(
            GetClusterRkeConfigNetworkCalicoNetworkProviderResult? calicoNetworkProvider,
            GetClusterRkeConfigNetworkCanalNetworkProviderResult? canalNetworkProvider,
            GetClusterRkeConfigNetworkFlannelNetworkProviderResult? flannelNetworkProvider,
            int? mtu,
            ImmutableDictionary<string, object> options,
            string plugin,
            GetClusterRkeConfigNetworkWeaveNetworkProviderResult? weaveNetworkProvider)
        {
            CalicoNetworkProvider = calicoNetworkProvider;
            CanalNetworkProvider = canalNetworkProvider;
            FlannelNetworkProvider = flannelNetworkProvider;
            Mtu = mtu;
            Options = options;
            Plugin = plugin;
            WeaveNetworkProvider = weaveNetworkProvider;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigNetworkWeaveNetworkProviderResult
    {
        public readonly string Password;

        [OutputConstructor]
        private GetClusterRkeConfigNetworkWeaveNetworkProviderResult(string password)
        {
            Password = password;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigNodesResult
    {
        public readonly string Address;
        public readonly string DockerSocket;
        public readonly string? HostnameOverride;
        public readonly string? InternalAddress;
        /// <summary>
        /// (Computed) Labels for Node Pool object (map)
        /// </summary>
        public readonly ImmutableDictionary<string, object>? Labels;
        public readonly string? NodeId;
        public readonly string? Port;
        public readonly ImmutableArray<string> Roles;
        public readonly bool? SshAgentAuth;
        public readonly string SshKey;
        public readonly string SshKeyPath;
        public readonly string User;

        [OutputConstructor]
        private GetClusterRkeConfigNodesResult(
            string address,
            string dockerSocket,
            string? hostnameOverride,
            string? internalAddress,
            ImmutableDictionary<string, object>? labels,
            string? nodeId,
            string? port,
            ImmutableArray<string> roles,
            bool? sshAgentAuth,
            string sshKey,
            string sshKeyPath,
            string user)
        {
            Address = address;
            DockerSocket = dockerSocket;
            HostnameOverride = hostnameOverride;
            InternalAddress = internalAddress;
            Labels = labels;
            NodeId = nodeId;
            Port = port;
            Roles = roles;
            SshAgentAuth = sshAgentAuth;
            SshKey = sshKey;
            SshKeyPath = sshKeyPath;
            User = user;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigPrivateRegistriesResult
    {
        public readonly bool? IsDefault;
        public readonly string? Password;
        public readonly string Url;
        public readonly string? User;

        [OutputConstructor]
        private GetClusterRkeConfigPrivateRegistriesResult(
            bool? isDefault,
            string? password,
            string url,
            string? user)
        {
            IsDefault = isDefault;
            Password = password;
            Url = url;
            User = user;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigResult
    {
        public readonly int AddonJobTimeout;
        public readonly string? Addons;
        public readonly ImmutableArray<string> AddonsIncludes;
        public readonly GetClusterRkeConfigAuthenticationResult Authentication;
        public readonly GetClusterRkeConfigAuthorizationResult Authorization;
        public readonly GetClusterRkeConfigBastionHostResult BastionHost;
        public readonly GetClusterRkeConfigCloudProviderResult CloudProvider;
        public readonly GetClusterRkeConfigDnsResult Dns;
        public readonly bool? IgnoreDockerVersion;
        public readonly GetClusterRkeConfigIngressResult Ingress;
        public readonly string KubernetesVersion;
        public readonly GetClusterRkeConfigMonitoringResult Monitoring;
        public readonly GetClusterRkeConfigNetworkResult Network;
        public readonly ImmutableArray<GetClusterRkeConfigNodesResult> Nodes;
        public readonly string PrefixPath;
        public readonly ImmutableArray<GetClusterRkeConfigPrivateRegistriesResult> PrivateRegistries;
        public readonly GetClusterRkeConfigServicesResult Services;
        public readonly bool? SshAgentAuth;
        public readonly string SshCertPath;
        public readonly string SshKeyPath;
        public readonly GetClusterRkeConfigUpgradeStrategyResult UpgradeStrategy;

        [OutputConstructor]
        private GetClusterRkeConfigResult(
            int addonJobTimeout,
            string? addons,
            ImmutableArray<string> addonsIncludes,
            GetClusterRkeConfigAuthenticationResult authentication,
            GetClusterRkeConfigAuthorizationResult authorization,
            GetClusterRkeConfigBastionHostResult bastionHost,
            GetClusterRkeConfigCloudProviderResult cloudProvider,
            GetClusterRkeConfigDnsResult dns,
            bool? ignoreDockerVersion,
            GetClusterRkeConfigIngressResult ingress,
            string kubernetesVersion,
            GetClusterRkeConfigMonitoringResult monitoring,
            GetClusterRkeConfigNetworkResult network,
            ImmutableArray<GetClusterRkeConfigNodesResult> nodes,
            string prefixPath,
            ImmutableArray<GetClusterRkeConfigPrivateRegistriesResult> privateRegistries,
            GetClusterRkeConfigServicesResult services,
            bool? sshAgentAuth,
            string sshCertPath,
            string sshKeyPath,
            GetClusterRkeConfigUpgradeStrategyResult upgradeStrategy)
        {
            AddonJobTimeout = addonJobTimeout;
            Addons = addons;
            AddonsIncludes = addonsIncludes;
            Authentication = authentication;
            Authorization = authorization;
            BastionHost = bastionHost;
            CloudProvider = cloudProvider;
            Dns = dns;
            IgnoreDockerVersion = ignoreDockerVersion;
            Ingress = ingress;
            KubernetesVersion = kubernetesVersion;
            Monitoring = monitoring;
            Network = network;
            Nodes = nodes;
            PrefixPath = prefixPath;
            PrivateRegistries = privateRegistries;
            Services = services;
            SshAgentAuth = sshAgentAuth;
            SshCertPath = sshCertPath;
            SshKeyPath = sshKeyPath;
            UpgradeStrategy = upgradeStrategy;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesEtcdBackupConfigResult
    {
        public readonly bool? Enabled;
        public readonly int? IntervalHours;
        public readonly int? Retention;
        public readonly GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult? S3BackupConfig;
        public readonly bool? SafeTimestamp;

        [OutputConstructor]
        private GetClusterRkeConfigServicesEtcdBackupConfigResult(
            bool? enabled,
            int? intervalHours,
            int? retention,
            GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult? s3BackupConfig,
            bool? safeTimestamp)
        {
            Enabled = enabled;
            IntervalHours = intervalHours;
            Retention = retention;
            S3BackupConfig = s3BackupConfig;
            SafeTimestamp = safeTimestamp;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult
    {
        public readonly string? AccessKey;
        public readonly string BucketName;
        public readonly string? CustomCa;
        public readonly string Endpoint;
        public readonly string? Folder;
        public readonly string? Region;
        public readonly string? SecretKey;

        [OutputConstructor]
        private GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfigResult(
            string? accessKey,
            string bucketName,
            string? customCa,
            string endpoint,
            string? folder,
            string? region,
            string? secretKey)
        {
            AccessKey = accessKey;
            BucketName = bucketName;
            CustomCa = customCa;
            Endpoint = endpoint;
            Folder = folder;
            Region = region;
            SecretKey = secretKey;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesEtcdResult
    {
        public readonly GetClusterRkeConfigServicesEtcdBackupConfigResult BackupConfig;
        public readonly string CaCert;
        public readonly string Cert;
        public readonly string Creation;
        public readonly ImmutableArray<string> ExternalUrls;
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableArray<string> ExtraBinds;
        public readonly ImmutableArray<string> ExtraEnvs;
        public readonly int? Gid;
        public readonly string Image;
        public readonly string Key;
        public readonly string Path;
        public readonly string Retention;
        public readonly bool Snapshot;
        public readonly int? Uid;

        [OutputConstructor]
        private GetClusterRkeConfigServicesEtcdResult(
            GetClusterRkeConfigServicesEtcdBackupConfigResult backupConfig,
            string caCert,
            string cert,
            string creation,
            ImmutableArray<string> externalUrls,
            ImmutableDictionary<string, object> extraArgs,
            ImmutableArray<string> extraBinds,
            ImmutableArray<string> extraEnvs,
            int? gid,
            string image,
            string key,
            string path,
            string retention,
            bool snapshot,
            int? uid)
        {
            BackupConfig = backupConfig;
            CaCert = caCert;
            Cert = cert;
            Creation = creation;
            ExternalUrls = externalUrls;
            ExtraArgs = extraArgs;
            ExtraBinds = extraBinds;
            ExtraEnvs = extraEnvs;
            Gid = gid;
            Image = image;
            Key = key;
            Path = path;
            Retention = retention;
            Snapshot = snapshot;
            Uid = uid;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult
    {
        public readonly string? Format;
        public readonly int? MaxAge;
        public readonly int? MaxBackup;
        public readonly int? MaxSize;
        public readonly string? Path;
        public readonly string Policy;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult(
            string? format,
            int? maxAge,
            int? maxBackup,
            int? maxSize,
            string? path,
            string policy)
        {
            Format = format;
            MaxAge = maxAge;
            MaxBackup = maxBackup;
            MaxSize = maxSize;
            Path = path;
            Policy = policy;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeApiAuditLogResult
    {
        public readonly GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult Configuration;
        public readonly bool? Enabled;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeApiAuditLogResult(
            GetClusterRkeConfigServicesKubeApiAuditLogConfigurationResult configuration,
            bool? enabled)
        {
            Configuration = configuration;
            Enabled = enabled;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeApiEventRateLimitResult
    {
        public readonly ImmutableDictionary<string, object>? Configuration;
        public readonly bool? Enabled;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeApiEventRateLimitResult(
            ImmutableDictionary<string, object>? configuration,
            bool? enabled)
        {
            Configuration = configuration;
            Enabled = enabled;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeApiResult
    {
        public readonly ImmutableDictionary<string, object>? AdmissionConfiguration;
        public readonly bool? AlwaysPullImages;
        public readonly GetClusterRkeConfigServicesKubeApiAuditLogResult? AuditLog;
        public readonly GetClusterRkeConfigServicesKubeApiEventRateLimitResult? EventRateLimit;
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableArray<string> ExtraBinds;
        public readonly ImmutableArray<string> ExtraEnvs;
        public readonly string Image;
        public readonly bool? PodSecurityPolicy;
        public readonly GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult? SecretsEncryptionConfig;
        public readonly string ServiceClusterIpRange;
        public readonly string ServiceNodePortRange;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeApiResult(
            ImmutableDictionary<string, object>? admissionConfiguration,
            bool? alwaysPullImages,
            GetClusterRkeConfigServicesKubeApiAuditLogResult? auditLog,
            GetClusterRkeConfigServicesKubeApiEventRateLimitResult? eventRateLimit,
            ImmutableDictionary<string, object> extraArgs,
            ImmutableArray<string> extraBinds,
            ImmutableArray<string> extraEnvs,
            string image,
            bool? podSecurityPolicy,
            GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult? secretsEncryptionConfig,
            string serviceClusterIpRange,
            string serviceNodePortRange)
        {
            AdmissionConfiguration = admissionConfiguration;
            AlwaysPullImages = alwaysPullImages;
            AuditLog = auditLog;
            EventRateLimit = eventRateLimit;
            ExtraArgs = extraArgs;
            ExtraBinds = extraBinds;
            ExtraEnvs = extraEnvs;
            Image = image;
            PodSecurityPolicy = podSecurityPolicy;
            SecretsEncryptionConfig = secretsEncryptionConfig;
            ServiceClusterIpRange = serviceClusterIpRange;
            ServiceNodePortRange = serviceNodePortRange;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult
    {
        public readonly ImmutableDictionary<string, object>? CustomConfig;
        public readonly bool? Enabled;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfigResult(
            ImmutableDictionary<string, object>? customConfig,
            bool? enabled)
        {
            CustomConfig = customConfig;
            Enabled = enabled;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeControllerResult
    {
        public readonly string ClusterCidr;
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableArray<string> ExtraBinds;
        public readonly ImmutableArray<string> ExtraEnvs;
        public readonly string Image;
        public readonly string ServiceClusterIpRange;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeControllerResult(
            string clusterCidr,
            ImmutableDictionary<string, object> extraArgs,
            ImmutableArray<string> extraBinds,
            ImmutableArray<string> extraEnvs,
            string image,
            string serviceClusterIpRange)
        {
            ClusterCidr = clusterCidr;
            ExtraArgs = extraArgs;
            ExtraBinds = extraBinds;
            ExtraEnvs = extraEnvs;
            Image = image;
            ServiceClusterIpRange = serviceClusterIpRange;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeletResult
    {
        public readonly string ClusterDnsServer;
        public readonly string ClusterDomain;
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableArray<string> ExtraBinds;
        public readonly ImmutableArray<string> ExtraEnvs;
        public readonly bool FailSwapOn;
        public readonly bool? GenerateServingCertificate;
        public readonly string Image;
        public readonly string InfraContainerImage;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeletResult(
            string clusterDnsServer,
            string clusterDomain,
            ImmutableDictionary<string, object> extraArgs,
            ImmutableArray<string> extraBinds,
            ImmutableArray<string> extraEnvs,
            bool failSwapOn,
            bool? generateServingCertificate,
            string image,
            string infraContainerImage)
        {
            ClusterDnsServer = clusterDnsServer;
            ClusterDomain = clusterDomain;
            ExtraArgs = extraArgs;
            ExtraBinds = extraBinds;
            ExtraEnvs = extraEnvs;
            FailSwapOn = failSwapOn;
            GenerateServingCertificate = generateServingCertificate;
            Image = image;
            InfraContainerImage = infraContainerImage;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesKubeproxyResult
    {
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableArray<string> ExtraBinds;
        public readonly ImmutableArray<string> ExtraEnvs;
        public readonly string Image;

        [OutputConstructor]
        private GetClusterRkeConfigServicesKubeproxyResult(
            ImmutableDictionary<string, object> extraArgs,
            ImmutableArray<string> extraBinds,
            ImmutableArray<string> extraEnvs,
            string image)
        {
            ExtraArgs = extraArgs;
            ExtraBinds = extraBinds;
            ExtraEnvs = extraEnvs;
            Image = image;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesResult
    {
        public readonly GetClusterRkeConfigServicesEtcdResult Etcd;
        public readonly GetClusterRkeConfigServicesKubeApiResult KubeApi;
        public readonly GetClusterRkeConfigServicesKubeControllerResult KubeController;
        public readonly GetClusterRkeConfigServicesKubeletResult Kubelet;
        public readonly GetClusterRkeConfigServicesKubeproxyResult Kubeproxy;
        public readonly GetClusterRkeConfigServicesSchedulerResult Scheduler;

        [OutputConstructor]
        private GetClusterRkeConfigServicesResult(
            GetClusterRkeConfigServicesEtcdResult etcd,
            GetClusterRkeConfigServicesKubeApiResult kubeApi,
            GetClusterRkeConfigServicesKubeControllerResult kubeController,
            GetClusterRkeConfigServicesKubeletResult kubelet,
            GetClusterRkeConfigServicesKubeproxyResult kubeproxy,
            GetClusterRkeConfigServicesSchedulerResult scheduler)
        {
            Etcd = etcd;
            KubeApi = kubeApi;
            KubeController = kubeController;
            Kubelet = kubelet;
            Kubeproxy = kubeproxy;
            Scheduler = scheduler;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigServicesSchedulerResult
    {
        public readonly ImmutableDictionary<string, object> ExtraArgs;
        public readonly ImmutableArray<string> ExtraBinds;
        public readonly ImmutableArray<string> ExtraEnvs;
        public readonly string Image;

        [OutputConstructor]
        private GetClusterRkeConfigServicesSchedulerResult(
            ImmutableDictionary<string, object> extraArgs,
            ImmutableArray<string> extraBinds,
            ImmutableArray<string> extraEnvs,
            string image)
        {
            ExtraArgs = extraArgs;
            ExtraBinds = extraBinds;
            ExtraEnvs = extraEnvs;
            Image = image;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigUpgradeStrategyDrainInputResult
    {
        public readonly bool? DeleteLocalData;
        public readonly bool? Force;
        public readonly int? GracePeriod;
        public readonly bool? IgnoreDaemonSets;
        public readonly int? Timeout;

        [OutputConstructor]
        private GetClusterRkeConfigUpgradeStrategyDrainInputResult(
            bool? deleteLocalData,
            bool? force,
            int? gracePeriod,
            bool? ignoreDaemonSets,
            int? timeout)
        {
            DeleteLocalData = deleteLocalData;
            Force = force;
            GracePeriod = gracePeriod;
            IgnoreDaemonSets = ignoreDaemonSets;
            Timeout = timeout;
        }
    }

    [OutputType]
    public sealed class GetClusterRkeConfigUpgradeStrategyResult
    {
        public readonly bool? Drain;
        public readonly GetClusterRkeConfigUpgradeStrategyDrainInputResult DrainInput;
        public readonly string? MaxUnavailableControlplane;
        public readonly string? MaxUnavailableWorker;

        [OutputConstructor]
        private GetClusterRkeConfigUpgradeStrategyResult(
            bool? drain,
            GetClusterRkeConfigUpgradeStrategyDrainInputResult drainInput,
            string? maxUnavailableControlplane,
            string? maxUnavailableWorker)
        {
            Drain = drain;
            DrainInput = drainInput;
            MaxUnavailableControlplane = maxUnavailableControlplane;
            MaxUnavailableWorker = maxUnavailableWorker;
        }
    }

    [OutputType]
    public sealed class GetClusterScheduledClusterScansResult
    {
        public readonly bool? Enabled;
        public readonly GetClusterScheduledClusterScansScanConfigResult ScanConfig;
        public readonly GetClusterScheduledClusterScansScheduleConfigResult ScheduleConfig;

        [OutputConstructor]
        private GetClusterScheduledClusterScansResult(
            bool? enabled,
            GetClusterScheduledClusterScansScanConfigResult scanConfig,
            GetClusterScheduledClusterScansScheduleConfigResult scheduleConfig)
        {
            Enabled = enabled;
            ScanConfig = scanConfig;
            ScheduleConfig = scheduleConfig;
        }
    }

    [OutputType]
    public sealed class GetClusterScheduledClusterScansScanConfigCisScanConfigResult
    {
        public readonly bool? DebugMaster;
        public readonly bool? DebugWorker;
        public readonly string? OverrideBenchmarkVersion;
        public readonly ImmutableArray<string> OverrideSkips;
        public readonly string? Profile;

        [OutputConstructor]
        private GetClusterScheduledClusterScansScanConfigCisScanConfigResult(
            bool? debugMaster,
            bool? debugWorker,
            string? overrideBenchmarkVersion,
            ImmutableArray<string> overrideSkips,
            string? profile)
        {
            DebugMaster = debugMaster;
            DebugWorker = debugWorker;
            OverrideBenchmarkVersion = overrideBenchmarkVersion;
            OverrideSkips = overrideSkips;
            Profile = profile;
        }
    }

    [OutputType]
    public sealed class GetClusterScheduledClusterScansScanConfigResult
    {
        public readonly GetClusterScheduledClusterScansScanConfigCisScanConfigResult CisScanConfig;

        [OutputConstructor]
        private GetClusterScheduledClusterScansScanConfigResult(GetClusterScheduledClusterScansScanConfigCisScanConfigResult cisScanConfig)
        {
            CisScanConfig = cisScanConfig;
        }
    }

    [OutputType]
    public sealed class GetClusterScheduledClusterScansScheduleConfigResult
    {
        public readonly string CronSchedule;
        public readonly int Retention;

        [OutputConstructor]
        private GetClusterScheduledClusterScansScheduleConfigResult(
            string cronSchedule,
            int retention)
        {
            CronSchedule = cronSchedule;
            Retention = retention;
        }
    }
    }
}
