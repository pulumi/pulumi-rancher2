// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CloudCredentialAmazonec2CredentialConfig {
    /**
     * AWS access key (string)
     */
    accessKey: string;
    /**
     * AWS default region (string)
     */
    defaultRegion?: string;
    /**
     * AWS secret key (string)
     */
    secretKey: string;
}

export interface CloudCredentialAzureCredentialConfig {
    /**
     * Azure Service Principal Account ID (string)
     */
    clientId: string;
    /**
     * Azure Service Principal Account password (string)
     */
    clientSecret: string;
    /**
     * Azure environment (e.g. AzurePublicCloud, AzureChinaCloud) (string)
     */
    environment: string;
    /**
     * Azure Subscription ID (string)
     */
    subscriptionId: string;
    /**
     * Azure Tenant ID (string)
     */
    tenantId: string;
}

export interface CloudCredentialDigitaloceanCredentialConfig {
    /**
     * DigitalOcean access token (string)
     */
    accessToken: string;
}

export interface CloudCredentialGoogleCredentialConfig {
    /**
     * Google auth encoded json (string)
     */
    authEncodedJson: string;
}

export interface CloudCredentialHarvesterCredentialConfig {
    /**
     * Imported Harvester Cluster ID (string)
     */
    clusterId?: string;
    /**
     * Harvester Cluster Type. Supported values : `"imported" | "external"` (string)
     */
    clusterType: string;
    /**
     * Harvester Cluster KubeConfig Content (string)
     */
    kubeconfigContent: string;
}

export interface CloudCredentialLinodeCredentialConfig {
    /**
     * Linode API token (string)
     */
    token: string;
}

export interface CloudCredentialOpenstackCredentialConfig {
    /**
     * OpenStack password (string)
     */
    password: string;
}

export interface CloudCredentialS3CredentialConfig {
    /**
     * AWS access key (string)
     */
    accessKey: string;
    /**
     * AWS default bucket (string)
     */
    defaultBucket?: string;
    /**
     * AWS default endpoint (string)
     */
    defaultEndpoint?: string;
    /**
     * AWS default endpoint CA (string)
     */
    defaultEndpointCa?: string;
    /**
     * AWS default folder (string)
     */
    defaultFolder?: string;
    /**
     * AWS default region (string)
     */
    defaultRegion?: string;
    /**
     * AWS default skip ssl verify. Default: `false` (bool)
     */
    defaultSkipSslVerify?: boolean;
    /**
     * AWS secret key (string)
     */
    secretKey: string;
}

export interface CloudCredentialVsphereCredentialConfig {
    /**
     * OpenStack password (string)
     */
    password: string;
    /**
     * vSphere username (string)
     */
    username: string;
    /**
     * vSphere IP/hostname for vCenter (string)
     */
    vcenter: string;
    /**
     * vSphere Port for vCenter. Default `443` (string)
     */
    vcenterPort?: string;
}

export interface ClusterAgentEnvVar {
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * Rancher agent env var value (string)
     */
    value: string;
}

export interface ClusterAksConfig {
    /**
     * The secret of an Azure Active Directory server application (string)
     */
    aadServerAppSecret?: string;
    /**
     * The ID of an Azure Active Directory tenant (string)
     */
    aadTenantId?: string;
    /**
     * The ID of an Azure Active Directory client application of type \"Native\". This application is for user login via kubectl (string)
     */
    addClientAppId?: string;
    /**
     * The ID of an Azure Active Directory server application of type \"Web app/API\". This application represents the managed cluster's apiserver (Server application) (string)
     */
    addServerAppId?: string;
    /**
     * The administrator username to use for Linux hosts. Default `azureuser` (string)
     */
    adminUsername?: string;
    /**
     * DNS prefix to be used to create the FQDN for the agent pool (string)
     */
    agentDnsPrefix: string;
    /**
     * GB size to be used to specify the disk for every machine in the agent pool. If you specify 0, it will apply the default according to the \"agent vm size\" specified. Default `0` (int)
     */
    agentOsDiskSize?: number;
    /**
     * Name for the agent pool, upto 12 alphanumeric characters. Default `agentpool0` (string)
     */
    agentPoolName?: string;
    /**
     * Storage profile specifies what kind of storage used on machine in the agent pool. Chooses from [ManagedDisks StorageAccount]. Default `ManagedDisks` (string)
     */
    agentStorageProfile?: string;
    /**
     * Size of machine in the agent pool. Default `Standard_D1_v2` (string)
     */
    agentVmSize?: string;
    /**
     * Different authentication API url to use. Default `https://login.microsoftonline.com/` (string)
     */
    authBaseUrl?: string;
    /**
     * Different resource management API url to use. Default `https://management.azure.com/` (string)
     */
    baseUrl?: string;
    /**
     * Azure client ID to use (string)
     */
    clientId: string;
    /**
     * Azure client secret associated with the \"client id\" (string)
     */
    clientSecret: string;
    /**
     * Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive). Default `1` (int)
     */
    count?: number;
    /**
     * An IP address assigned to the Kubernetes DNS service. It must be within the Kubernetes Service address range specified in \"service cidr\". Default `10.0.0.10` (string)
     */
    dnsServiceIp?: string;
    /**
     * A CIDR notation IP range assigned to the Docker bridge network. It must not overlap with any Subnet IP ranges or the Kubernetes Service address range specified in \"service cidr\". Default `172.17.0.1/16` (string)
     */
    dockerBridgeCidr?: string;
    /**
     * Enable the Kubernetes ingress with automatic public DNS name creation. Default `false` (bool)
     */
    enableHttpApplicationRouting?: boolean;
    /**
     * Turn on Azure Log Analytics monitoring. Uses the Log Analytics \"Default\" workspace if it exists, else creates one. if using an existing workspace, specifies \"log analytics workspace resource id\". Default `true` (bool)
     */
    enableMonitoring?: boolean;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion: string;
    /**
     * Allowed values: `basic` (default) `standard` (string)
     */
    loadBalancerSku: string;
    /**
     * (string)
     */
    location?: string;
    /**
     * The name of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses '{resource group}-{subscription id}-{location code}' (string)
     */
    logAnalyticsWorkspace?: string;
    /**
     * The resource group of an existing Azure Log Analytics Workspace to use for storing monitoring data. If not specified, uses the 'Cluster' resource group (string)
     */
    logAnalyticsWorkspaceResourceGroup?: string;
    /**
     * DNS prefix to use the Kubernetes cluster control pane (string)
     */
    masterDnsPrefix: string;
    /**
     * Maximum number of pods that can run on a node. Default `110` (int)
     */
    maxPods?: number;
    /**
     * Network plugin used for building Kubernetes network. Chooses from `azure` or `kubenet`. Default `azure` (string)
     */
    networkPlugin?: string;
    /**
     * Network policy used for building Kubernetes network. Chooses from `calico` (string)
     */
    networkPolicy?: string;
    /**
     * A CIDR notation IP range from which to assign Kubernetes Pod IPs when \"network plugin\" is specified in \"kubenet\". Default `172.244.0.0/16` (string)
     */
    podCidr?: string;
    /**
     * (string)
     */
    resourceGroup: string;
    /**
     * A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges. Default `10.0.0.0/16` (string)
     */
    serviceCidr?: string;
    /**
     * Contents of the SSH public key used to authenticate with Linux hosts (string)
     */
    sshPublicKeyContents: string;
    /**
     * The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID (string)
     */
    subnet: string;
    /**
     * (string)
     */
    subscriptionId: string;
    /**
     * Use `tags` argument instead as []string
     *
     * @deprecated Use tags argument instead as []string
     */
    tag: {[key: string]: any};
    /**
     * Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]` (list)
     */
    tags: string[];
    /**
     * (string)
     */
    tenantId: string;
    /**
     * The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID (string)
     */
    virtualNetwork: string;
    /**
     * The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID (string)
     */
    virtualNetworkResourceGroup: string;
}

export interface ClusterAksConfigV2 {
    /**
     * Different authentication API url to use. Default `https://login.microsoftonline.com/` (string)
     */
    authBaseUrl?: string;
    /**
     * The AKS authorized ip ranges (list)
     */
    authorizedIpRanges?: string[];
    /**
     * Different resource management API url to use. Default `https://management.azure.com/` (string)
     */
    baseUrl?: string;
    /**
     * The AKS Cloud Credential ID to use (string)
     */
    cloudCredentialId: string;
    /**
     * The AKS dns prefix. Required if `imported=false` (string)
     */
    dnsPrefix?: string;
    /**
     * Enable AKS http application routing? (bool)
     */
    httpApplicationRouting: boolean;
    /**
     * Is AKS cluster imported? Defaul: `false` (bool)
     *
     * The following arguments are supported just for creating new AKS clusters (`imported=false`):
     */
    imported?: boolean;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion?: string;
    /**
     * The AKS linux admin username (string)
     */
    linuxAdminUsername: string;
    /**
     * The AKS linux ssh public key (string)
     */
    linuxSshPublicKey: string;
    /**
     * Allowed values: `basic` (default) `standard` (string)
     */
    loadBalancerSku: string;
    /**
     * The AKS log analytics workspace group (string)
     */
    logAnalyticsWorkspaceGroup: string;
    /**
     * The AKS log analytics workspace name (string)
     */
    logAnalyticsWorkspaceName: string;
    /**
     * Kubernetes cluster monitoring (list maxitems:1)
     */
    monitoring: boolean;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * The AKS network dns service ip (string)
     */
    networkDnsServiceIp: string;
    /**
     * The AKS network docker bridge cidr (string)
     */
    networkDockerBridgeCidr: string;
    /**
     * Network plugin used for building Kubernetes network. Chooses from `azure` or `kubenet`. Default `azure` (string)
     */
    networkPlugin?: string;
    /**
     * The AKS network pod cidr (string)
     */
    networkPodCidr: string;
    /**
     * Network policy used for building Kubernetes network. Chooses from `calico` (string)
     */
    networkPolicy: string;
    /**
     * The AKS network service cidr (string)
     */
    networkServiceCidr: string;
    /**
     * The AKS nnode pools. Required if `imported=false` (list)
     */
    nodePools?: outputs.ClusterAksConfigV2NodePool[];
    /**
     * Is AKS cluster private? (bool)
     */
    privateCluster: boolean;
    /**
     * (string)
     */
    resourceGroup: string;
    /**
     * The AKS resource location (string)
     */
    resourceLocation: string;
    /**
     * The name of an existing Azure Virtual Subnet. Composite of agent virtual network subnet ID (string)
     */
    subnet: string;
    /**
     * Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]` (list)
     */
    tags: {[key: string]: any};
    /**
     * The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID (string)
     */
    virtualNetwork: string;
    /**
     * The resource group of an existing Azure Virtual Network. Composite of agent virtual network subnet ID (string)
     */
    virtualNetworkResourceGroup: string;
}

export interface ClusterAksConfigV2NodePool {
    /**
     * The AKS node pool availability zones (list)
     */
    availabilityZones?: string[];
    /**
     * Number of machines (VMs) in the agent pool. Allowed values must be in the range of 1 to 100 (inclusive). Default `1` (int)
     */
    count?: number;
    /**
     * Is AKS node pool auto scaling enabled? Default: `false` (bool)
     */
    enableAutoScaling?: boolean;
    /**
     * The AKS node pool max count. Required if `enable_auto_scaling=true` (int)
     */
    maxCount?: number;
    /**
     * Maximum number of pods that can run on a node. Default `110` (int)
     */
    maxPods?: number;
    /**
     * The AKS node pool min count. Required if `enable_auto_scaling=true` (int)
     */
    minCount?: number;
    /**
     * RKE mode for authorization. `rbac` and `none` modes are available. Default `rbac` (string)
     */
    mode?: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * The AKS node pool orchestrator version (string)
     */
    orchestratorVersion?: string;
    /**
     * The AKS node pool os disk size gb. Default: `128` (int)
     */
    osDiskSizeGb?: number;
    /**
     * The AKS node pool os disk type. Default: `Managed` (string)
     */
    osDiskType?: string;
    /**
     * The AKS node pool os type. Default: `Linux` (string)
     */
    osType?: string;
    /**
     * The AKS node pool orchestrator version (string)
     */
    vmSize: string;
}

export interface ClusterAlertGroupRecipient {
    /**
     * Use notifier default recipient, overriding `recipient` argument if set.  Default: `false` (bool)
     */
    defaultRecipient?: boolean;
    /**
     * Recipient notifier ID (string)
     */
    notifierId: string;
    /**
     * Recipient notifier ID. Supported values : `"dingtalk" | "msteams" | "pagerduty" | "slack" | "email" | "webhook" | "wechat"` (string)
     */
    notifierType: string;
    /**
     * Recipient (string)
     */
    recipient: string;
}

export interface ClusterAlertRuleEventRule {
    /**
     * Event type. Supported values : `"Warning" | "Normal"`. Default: `Warning` (string)
     */
    eventType?: string;
    /**
     * Resource kind. Supported values : `"DaemonSet" | "Deployment" | "Node" | "Pod" | "StatefulSet"` (string)
     */
    resourceKind: string;
}

export interface ClusterAlertRuleMetricRule {
    /**
     * Metric rule comparison. Supported values : `"equal" | "greater-or-equal" | "greater-than" | "less-or-equal" | "less-than" | "not-equal" | "has-value"`. Default: `equal`  (string)
     */
    comparison?: string;
    /**
     * Metric rule description (string)
     */
    description?: string;
    /**
     * Metric rule duration (string)
     */
    duration: string;
    /**
     * Metric rule expression (string)
     */
    expression: string;
    /**
     * Metric rule threshold value (float64)
     */
    thresholdValue: number;
}

export interface ClusterAlertRuleNodeRule {
    /**
     * Node rule condition. Supported values : `"cpu" | "mem" | "notready"`. Default: `notready` (string)
     */
    condition?: string;
    /**
     * Node rule cpu threshold. Default: `70` (int)
     */
    cpuThreshold?: number;
    /**
     * Node rule mem threshold. Default: `70` (int)
     */
    memThreshold?: number;
    /**
     * Node ID (string)
     */
    nodeId?: string;
    /**
     * Node rule selector (map)
     */
    selector?: {[key: string]: any};
}

export interface ClusterAlertRuleSystemServiceRule {
    /**
     * Node rule condition. Supported values : `"cpu" | "mem" | "notready"`. Default: `notready` (string)
     */
    condition?: string;
}

export interface ClusterAlterGroupRecipient {
    /**
     * Use notifier default recipient, overriding `recipient` argument if set.  Default: `false` (bool)
     */
    defaultRecipient?: boolean;
    /**
     * Recipient notifier ID (string)
     */
    notifierId: string;
    /**
     * Recipient notifier ID. Supported values : `"dingtalk" | "msteams" | "pagerduty" | "slack" | "email" | "webhook" | "wechat"` (string)
     */
    notifierType: string;
    /**
     * Recipient (string)
     */
    recipient: string;
}

export interface ClusterAlterRuleEventRule {
    eventType?: string;
    resourceKind: string;
}

export interface ClusterAlterRuleMetricRule {
    comparison?: string;
    /**
     * The cluster alert group description (string)
     */
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface ClusterAlterRuleNodeRule {
    condition?: string;
    cpuThreshold?: number;
    memThreshold?: number;
    nodeId?: string;
    selector?: {[key: string]: any};
}

export interface ClusterAlterRuleSystemServiceRule {
    condition?: string;
}

export interface ClusterClusterAuthEndpoint {
    /**
     * CA certs for the authorized cluster endpoint (string)
     */
    caCerts?: string;
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
    /**
     * FQDN for the authorized cluster endpoint (string)
     */
    fqdn?: string;
}

export interface ClusterClusterMonitoringInput {
    /**
     * Key/value answers for monitor input (map)
     */
    answers?: {[key: string]: any};
    /**
     * RKE2 kubernetes version (string)
     */
    version?: string;
}

export interface ClusterClusterRegistrationToken {
    /**
     * Annotations for the Cluster (map)
     */
    annotations: {[key: string]: any};
    /**
     * Cluster ID to apply answer (string)
     */
    clusterId: string;
    /**
     * Command to execute in a imported k8s cluster (string)
     */
    command: string;
    /**
     * The EKS node group launch template ID (string)
     */
    id: string;
    /**
     * Insecure command to execute in a imported k8s cluster (string)
     */
    insecureCommand: string;
    /**
     * Insecure node command to execute in a imported k8s cluster (string)
     */
    insecureNodeCommand: string;
    /**
     * Insecure windows command to execute in a imported k8s cluster (string)
     */
    insecureWindowsNodeCommand: string;
    /**
     * Labels for the Cluster (map)
     */
    labels: {[key: string]: any};
    /**
     * K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
     */
    manifestUrl: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * Node command to execute in linux nodes for custom k8s cluster (string)
     */
    nodeCommand: string;
    /**
     * ACI token (string)
     */
    token: string;
    /**
     * Node command to execute in windows nodes for custom k8s cluster (string)
     */
    windowsNodeCommand: string;
}

export interface ClusterClusterTemplateAnswers {
    /**
     * Cluster ID to apply answer (string)
     */
    clusterId: string;
    /**
     * Project ID for GKE cluster (string)
     */
    projectId: string;
    /**
     * Key/values for answer (map)
     */
    values: {[key: string]: any};
}

export interface ClusterClusterTemplateQuestion {
    /**
     * Default variable value (string)
     */
    default: string;
    /**
     * Required variable. Default `false` (bool)
     */
    required?: boolean;
    /**
     * Variable type. `boolean`, `int`, `password`, and `string` are allowed. Default `string` (string)
     */
    type?: string;
    /**
     * Variable name (string)
     */
    variable: string;
}

export interface ClusterEksConfig {
    /**
     * Access key for S3 service (string)
     */
    accessKey: string;
    /**
     * AMI ID to use for the worker nodes instead of the default (string)
     */
    ami?: string;
    /**
     * Associate public ip EKS worker nodes. Default `true` (bool)
     */
    associateWorkerNodePublicIp?: boolean;
    /**
     * The desired number of worker nodes. Just for Rancher v2.3.x and above. Default `3` (int)
     */
    desiredNodes?: number;
    ebsEncryption?: boolean;
    /**
     * The type of machine to use for worker nodes. Default `t2.medium` (string)
     */
    instanceType?: string;
    /**
     * Allow user to specify key name to use. Just for Rancher v2.2.7 and above (string)
     */
    keyPairName?: string;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion: string;
    /**
     * The maximum number of worker nodes. Default `3` (int)
     */
    maximumNodes?: number;
    /**
     * The minimum number of worker nodes. Default `1` (int)
     */
    minimumNodes?: number;
    /**
     * The volume size for each node. Default `20` (int)
     */
    nodeVolumeSize?: number;
    /**
     * (string)
     */
    region?: string;
    /**
     * Secret key for S3 service (string)
     */
    secretKey: string;
    /**
     * List of security groups to use for the cluster. If it's not specified Rancher will create a new security group (list)
     */
    securityGroups?: string[];
    /**
     * The service role to use to perform the cluster operations in AWS. If it's not specified Rancher will create a new service role (string)
     */
    serviceRole?: string;
    /**
     * A session token to use with the client key and secret if applicable (string)
     */
    sessionToken?: string;
    /**
     * List of subnets in the virtual network to use. If it's not specified Rancher will create 3 news subnets (list)
     */
    subnets?: string[];
    /**
     * Pass user-data to the nodes to perform automated configuration tasks (string)
     */
    userData: string;
    /**
     * The name of an existing Azure Virtual Network. Composite of agent virtual network subnet ID (string)
     */
    virtualNetwork?: string;
}

export interface ClusterEksConfigV2 {
    /**
     * The AKS Cloud Credential ID to use (string)
     */
    cloudCredentialId: string;
    /**
     * Is AKS cluster imported? Defaul: `false` (bool)
     *
     * The following arguments are supported just for creating new AKS clusters (`imported=false`):
     */
    imported?: boolean;
    /**
     * The AWS kms key to use (string)
     */
    kmsKey?: string;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion: string;
    /**
     * The AWS cloudwatch logging types. `audit`, `api`, `scheduler`, `controllerManager` and `authenticator` values are allowed (list)
     */
    loggingTypes?: string[];
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * The EKS cluster name to import. Required to create a new cluster (list)
     */
    nodeGroups: outputs.ClusterEksConfigV2NodeGroup[];
    /**
     * The EKS cluster has private access (bool)
     */
    privateAccess: boolean;
    /**
     * The EKS cluster has public access (bool)
     */
    publicAccess: boolean;
    /**
     * The EKS cluster public access sources (map)
     */
    publicAccessSources: string[];
    /**
     * (string)
     */
    region?: string;
    /**
     * Enable EKS cluster secret encryption (bool)
     */
    secretsEncryption: boolean;
    /**
     * List of security groups to use for the cluster. If it's not specified Rancher will create a new security group (list)
     */
    securityGroups?: string[];
    /**
     * The service role to use to perform the cluster operations in AWS. If it's not specified Rancher will create a new service role (string)
     */
    serviceRole?: string;
    /**
     * List of subnets in the virtual network to use. If it's not specified Rancher will create 3 news subnets (list)
     */
    subnets?: string[];
    /**
     * Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]` (list)
     */
    tags?: {[key: string]: any};
}

export interface ClusterEksConfigV2NodeGroup {
    /**
     * The EKS node group desired size. Default: `2` (int)
     */
    desiredSize?: number;
    /**
     * The EKS node group disk size (Gb). Default: `20` (int)
     */
    diskSize?: number;
    /**
     * The EKS node group ssh key (string)
     */
    ec2SshKey?: string;
    /**
     * Set true to EKS use gpu. Default: `false` (bool)
     */
    gpu?: boolean;
    /**
     * The EKS node group image ID (string)
     */
    imageId?: string;
    /**
     * The type of machine to use for worker nodes. Default `t2.medium` (string)
     */
    instanceType?: string;
    /**
     * Labels for the Cluster (map)
     */
    labels?: {[key: string]: any};
    /**
     * The EKS node groups launch template (list Maxitem: 1)
     */
    launchTemplates?: outputs.ClusterEksConfigV2NodeGroupLaunchTemplate[];
    /**
     * Audit log max size. Default: `100` (int)
     */
    maxSize?: number;
    /**
     * The EKS node group maximum size. Default `2` (int)
     */
    minSize?: number;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * The EKS node group node role ARN. Default `""` (string)
     */
    nodeRole?: string;
    /**
     * Enable EKS node group request spot instances (bool)
     */
    requestSpotInstances?: boolean;
    /**
     * The EKS node group resource tags (map)
     */
    resourceTags?: {[key: string]: any};
    /**
     * The EKS node group sport instace types (list string)
     */
    spotInstanceTypes?: string[];
    /**
     * List of subnets in the virtual network to use. If it's not specified Rancher will create 3 news subnets (list)
     */
    subnets: string[];
    /**
     * Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]` (list)
     */
    tags?: {[key: string]: any};
    /**
     * Pass user-data to the nodes to perform automated configuration tasks (string)
     */
    userData: string;
    /**
     * RKE2 kubernetes version (string)
     */
    version: string;
}

export interface ClusterEksConfigV2NodeGroupLaunchTemplate {
    /**
     * The EKS node group launch template ID (string)
     */
    id: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * RKE2 kubernetes version (string)
     */
    version?: number;
}

export interface ClusterGkeConfig {
    /**
     * The IP address range of the container pods (string)
     */
    clusterIpv4Cidr: string;
    /**
     * The contents of the GC credential file (string)
     */
    credential: string;
    /**
     * The description for Cluster (string)
     */
    description?: string;
    /**
     * Size of the disk attached to each node. Default `100` (int)
     */
    diskSizeGb?: number;
    /**
     * Type of the disk attached to each node (string)
     */
    diskType: string;
    /**
     * To enable Kubernetes alpha feature. Default `true` (bool)
     */
    enableAlphaFeature?: boolean;
    /**
     * Specifies whether the node auto-repair is enabled for the node pool. Default `false` (bool)
     */
    enableAutoRepair?: boolean;
    /**
     * Specifies whether node auto-upgrade is enabled for the node pool. Default `false` (bool)
     */
    enableAutoUpgrade?: boolean;
    /**
     * Enable horizontal pod autoscaling for the cluster. Default `true` (bool)
     */
    enableHorizontalPodAutoscaling?: boolean;
    /**
     * Enable HTTP load balancing on GKE cluster. Default `true` (bool)
     */
    enableHttpLoadBalancing?: boolean;
    /**
     * Whether to enable the Kubernetes dashboard. Default `false` (bool)
     */
    enableKubernetesDashboard?: boolean;
    /**
     * Whether to enable legacy abac on the cluster. Default `false` (bool)
     */
    enableLegacyAbac?: boolean;
    /**
     * Enable master authorized network. Set to `true` if `masterAuthorizedNetworkCidrBlocks` is set. Default `false` (bool)
     */
    enableMasterAuthorizedNetwork?: boolean;
    /**
     * Enable network policy config for the cluster. Default `true` (bool)
     */
    enableNetworkPolicyConfig?: boolean;
    /**
     * Enable nodepool autoscaling. Default `false` (bool)
     */
    enableNodepoolAutoscaling?: boolean;
    /**
     * Whether the master's internal IP address is used as the cluster endpoint. Default `false` (bool)
     */
    enablePrivateEndpoint?: boolean;
    /**
     * Whether nodes have internal IP address only. Default `false` (bool)
     */
    enablePrivateNodes?: boolean;
    /**
     * Enable stackdriver monitoring. Default `true` (bool)
     */
    enableStackdriverLogging?: boolean;
    /**
     * Enable stackdriver monitoring on GKE cluster (bool)
     */
    enableStackdriverMonitoring?: boolean;
    /**
     * The image to use for the worker nodes (string)
     */
    imageType: string;
    /**
     * The IP address range for the cluster pod IPs (string)
     */
    ipPolicyClusterIpv4CidrBlock: string;
    /**
     * The name of the secondary range to be used for the cluster CIDR block (string)
     */
    ipPolicyClusterSecondaryRangeName: string;
    /**
     * Whether a new subnetwork will be created automatically for the cluster. Default `false` (bool)
     */
    ipPolicyCreateSubnetwork?: boolean;
    /**
     * The IP address range of the instance IPs in this cluster (string)
     */
    ipPolicyNodeIpv4CidrBlock: string;
    /**
     * The IP address range of the services IPs in this cluster (string)
     */
    ipPolicyServicesIpv4CidrBlock: string;
    /**
     * The name of the secondary range to be used for the services CIDR block (string)
     */
    ipPolicyServicesSecondaryRangeName: string;
    /**
     * A custom subnetwork name to be used if createSubnetwork is true (string)
     */
    ipPolicySubnetworkName: string;
    /**
     * Issue a client certificate. Default `false` (bool)
     */
    issueClientCertificate?: boolean;
    /**
     * Enable the Kubernetes dashboard. Default `false` (bool)
     */
    kubernetesDashboard?: boolean;
    /**
     * Labels for the Cluster (map)
     */
    labels: {[key: string]: any};
    /**
     * The number of local SSD disks to be attached to the node. Default `0` (int)
     */
    localSsdCount?: number;
    /**
     * Locations for GKE cluster (list)
     */
    locations: string[];
    /**
     * Machine type for GKE cluster (string)
     */
    machineType: string;
    /**
     * Maintenance window for GKE cluster (string)
     */
    maintenanceWindow: string;
    /**
     * Define up to 10 external networks that could access Kubernetes master through HTTPS (list)
     */
    masterAuthorizedNetworkCidrBlocks?: string[];
    /**
     * The IP range in CIDR notation to use for the hosted master network (string)
     */
    masterIpv4CidrBlock: string;
    /**
     * Master version for GKE cluster (string)
     */
    masterVersion: string;
    /**
     * Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster. Default `0` (int)
     */
    maxNodeCount?: number;
    /**
     * Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount. Default `0` (int)
     */
    minNodeCount?: number;
    /**
     * Kubernetes cluster networking (list maxitems:1)
     */
    network: string;
    /**
     * Node count for GKE cluster. Default `3` (int)
     */
    nodeCount?: number;
    /**
     * The ID of the cluster node pool (string)
     */
    nodePool: string;
    /**
     * Node version for GKE cluster (string)
     */
    nodeVersion: string;
    /**
     * The set of Google API scopes to be made available on all of the node VMs under the default service account (list)
     */
    oauthScopes: string[];
    /**
     * Whether the nodes are created as preemptible VM instances. Default `false` (bool)
     */
    preemptible?: boolean;
    /**
     * Project ID for GKE cluster (string)
     */
    projectId: string;
    /**
     * (string)
     */
    region?: string;
    /**
     * The map of Kubernetes labels to be applied to each cluster (map)
     */
    resourceLabels: {[key: string]: any};
    /**
     * The Google Cloud Platform Service Account to be used by the node VMs (string)
     */
    serviceAccount: string;
    /**
     * Subnetwork for GKE cluster (string)
     */
    subNetwork: string;
    /**
     * List of Kubernetes taints to be applied to each node (list)
     */
    taints?: string[];
    /**
     * Whether alias IPs will be used for pod IPs in the cluster. Default `false` (bool)
     */
    useIpAliases?: boolean;
    /**
     * (string)
     */
    zone?: string;
}

export interface ClusterGkeConfigV2 {
    /**
     * The GKE cluster addons (List maxitems:1)
     */
    clusterAddons: outputs.ClusterGkeConfigV2ClusterAddons;
    /**
     * The GKE ip v4 cidr block (string)
     */
    clusterIpv4CidrBlock: string;
    /**
     * The description for Cluster (string)
     */
    description: string;
    /**
     * Enable Kubernetes alpha. Default: `false` (bool)
     */
    enableKubernetesAlpha: boolean;
    /**
     * Google credential secret (string)
     */
    googleCredentialSecret: string;
    /**
     * Is AKS cluster imported? Defaul: `false` (bool)
     *
     * The following arguments are supported just for creating new AKS clusters (`imported=false`):
     */
    imported?: boolean;
    /**
     * The GKE ip allocation policy (List maxitems:1)
     */
    ipAllocationPolicy: outputs.ClusterGkeConfigV2IpAllocationPolicy;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion: string;
    /**
     * Labels for the Cluster (map)
     */
    labels: {[key: string]: any};
    /**
     * Locations for GKE cluster (list)
     */
    locations: string[];
    /**
     * The GKE cluster logging service (string)
     */
    loggingService: string;
    /**
     * Maintenance window for GKE cluster (string)
     */
    maintenanceWindow: string;
    /**
     * The GKE cluster master authorized networks config (List maxitems:1)
     */
    masterAuthorizedNetworksConfig: outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfig;
    /**
     * The GKE cluster monitoring service (string)
     */
    monitoringService: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * Kubernetes cluster networking (list maxitems:1)
     */
    network: string;
    /**
     * Is GKE cluster network policy enabled? Default: `false` (bool)
     */
    networkPolicyEnabled: boolean;
    /**
     * The AKS nnode pools. Required if `imported=false` (list)
     */
    nodePools: outputs.ClusterGkeConfigV2NodePool[];
    /**
     * The GKE private cluster config (List maxitems:1)
     */
    privateClusterConfig: outputs.ClusterGkeConfigV2PrivateClusterConfig;
    /**
     * Project ID for GKE cluster (string)
     */
    projectId: string;
    /**
     * (string)
     */
    region: string;
    /**
     * The GKE cluster subnetwork. Required for create new cluster (string)
     */
    subnetwork: string;
    /**
     * (string)
     */
    zone: string;
}

export interface ClusterGkeConfigV2ClusterAddons {
    /**
     * Enable GKE horizontal pod autoscaling. Default: `false` (bool)
     */
    horizontalPodAutoscaling: boolean;
    /**
     * Enable GKE HTTP load balancing. Default: `false` (bool)
     */
    httpLoadBalancing: boolean;
    /**
     * Enable GKE network policy config. Default: `false` (bool)
     */
    networkPolicyConfig: boolean;
}

export interface ClusterGkeConfigV2IpAllocationPolicy {
    /**
     * The GKE ip v4 cidr block (string)
     */
    clusterIpv4CidrBlock: string;
    /**
     * The GKE cluster ip v4 allocation secondary range name(string)
     */
    clusterSecondaryRangeName: string;
    /**
     * Create GKE subnetwork? Default: `false` (bool)
     */
    createSubnetwork: boolean;
    /**
     * The GKE node ip v4 allocation cidr block (string)
     */
    nodeIpv4CidrBlock: string;
    /**
     * The GKE services ip v4 allocation cidr block (string)
     */
    servicesIpv4CidrBlock: string;
    /**
     * The GKE services ip v4 allocation secondary range name (string)
     */
    servicesSecondaryRangeName: string;
    /**
     * The GKE cluster subnetwork name (string)
     */
    subnetworkName: string;
    /**
     * Whether alias IPs will be used for pod IPs in the cluster. Default `false` (bool)
     */
    useIpAliases: boolean;
}

export interface ClusterGkeConfigV2MasterAuthorizedNetworksConfig {
    /**
     * The GKE master authorized network config cidr blocks (List)
     */
    cidrBlocks: outputs.ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock[];
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
}

export interface ClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock {
    /**
     * The GKE master authorized network config cidr block (string)
     */
    cidrBlock: string;
    /**
     * The GKE master authorized network config cidr block dispaly name (string)
     */
    displayName?: string;
}

export interface ClusterGkeConfigV2NodePool {
    /**
     * The GKE node pool config autoscaling (List maxitems:1)
     */
    autoscaling: outputs.ClusterGkeConfigV2NodePoolAutoscaling;
    /**
     * The GKE node pool node config (List maxitems:1)
     */
    config: outputs.ClusterGkeConfigV2NodePoolConfig;
    /**
     * The GKE node pool config initial node count (int)
     */
    initialNodeCount: number;
    /**
     * The GKE node pool config management (List maxitems:1)
     */
    management: outputs.ClusterGkeConfigV2NodePoolManagement;
    /**
     * The GKE node pool config max pods constraint. Required for create new cluster if `ip_allocation_policy.use_ip_aliases = true` (int)
     */
    maxPodsConstraint: number;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * RKE2 kubernetes version (string)
     */
    version: string;
}

export interface ClusterGkeConfigV2NodePoolAutoscaling {
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
    /**
     * Maximum number of nodes in the NodePool. Must be >= minNodeCount. There has to enough quota to scale up the cluster. Default `0` (int)
     */
    maxNodeCount: number;
    /**
     * Minimmum number of nodes in the NodePool. Must be >= 1 and <= maxNodeCount. Default `0` (int)
     */
    minNodeCount: number;
}

export interface ClusterGkeConfigV2NodePoolConfig {
    /**
     * Size of the disk attached to each node. Default `100` (int)
     */
    diskSizeGb?: number;
    /**
     * Type of the disk attached to each node (string)
     */
    diskType?: string;
    /**
     * The image to use for the worker nodes (string)
     */
    imageType?: string;
    /**
     * Labels for the Cluster (map)
     */
    labels: {[key: string]: any};
    /**
     * The number of local SSD disks to be attached to the node. Default `0` (int)
     */
    localSsdCount?: number;
    /**
     * Machine type for GKE cluster (string)
     */
    machineType?: string;
    /**
     * The set of Google API scopes to be made available on all of the node VMs under the default service account (list)
     */
    oauthScopes: string[];
    /**
     * Whether the nodes are created as preemptible VM instances. Default `false` (bool)
     */
    preemptible?: boolean;
    /**
     * Tags for Kubernetes cluster. For example, `["foo=bar","bar=foo"]` (list)
     */
    tags: string[];
    /**
     * List of Kubernetes taints to be applied to each node (list)
     */
    taints?: outputs.ClusterGkeConfigV2NodePoolConfigTaint[];
}

export interface ClusterGkeConfigV2NodePoolConfigTaint {
    /**
     * The toleration effect. `NoExecute`, `NoSchedule`, and `PreferNoSchedule` are supported. Default: `NoExecute` (string)
     */
    effect: string;
    /**
     * The toleration key (string)
     */
    key: string;
    /**
     * Rancher agent env var value (string)
     */
    value: string;
}

export interface ClusterGkeConfigV2NodePoolManagement {
    /**
     * Enable GKE node pool config management auto repair. Default: `false` (bool)
     */
    autoRepair: boolean;
    /**
     * Enable GKE node pool config management auto upgrade. Default: `false` (bool)
     */
    autoUpgrade: boolean;
}

export interface ClusterGkeConfigV2PrivateClusterConfig {
    /**
     * Whether the master's internal IP address is used as the cluster endpoint. Default `false` (bool)
     */
    enablePrivateEndpoint?: boolean;
    /**
     * Whether nodes have internal IP address only. Default `false` (bool)
     */
    enablePrivateNodes?: boolean;
    /**
     * The IP range in CIDR notation to use for the hosted master network (string)
     */
    masterIpv4CidrBlock: string;
}

export interface ClusterK3sConfig {
    /**
     * RKE upgrade strategy (list maxitems:1)
     */
    upgradeStrategy: outputs.ClusterK3sConfigUpgradeStrategy;
    /**
     * RKE2 kubernetes version (string)
     */
    version: string;
}

export interface ClusterK3sConfigUpgradeStrategy {
    /**
     * Drain server nodes. Default: `false` (bool)
     */
    drainServerNodes?: boolean;
    /**
     * Drain worker nodes. Default: `false` (bool)
     */
    drainWorkerNodes?: boolean;
    /**
     * Server concurrency. Default: `1` (int)
     */
    serverConcurrency?: number;
    /**
     * Worker concurrency. Default: `1` (int)
     */
    workerConcurrency?: number;
}

export interface ClusterOkeConfig {
    /**
     * The OCID of the compartment in which to create resources OKE cluster and related resources (string)
     */
    compartmentId: string;
    /**
     * Optional custom boot volume size (GB) for all nodes. If you specify 0, it will apply the default according to the `nodeImage` specified. Default `0` (int)
     */
    customBootVolumeSize?: number;
    /**
     * The description for Cluster (string)
     */
    description?: string;
    /**
     * Whether to enable the Kubernetes dashboard. Default `false` (bool)
     */
    enableKubernetesDashboard?: boolean;
    /**
     * Specifies whether Kubernetes API endpoint is a private IP only accessible from within the VCN. Default `false` Just for Rancher v2.5.10 or above (bool)
     */
    enablePrivateControlPlane?: boolean;
    /**
     * Whether nodes have internal IP address only. Default `false` (bool)
     */
    enablePrivateNodes?: boolean;
    /**
     * The fingerprint corresponding to the specified user's private API Key (string)
     */
    fingerprint: string;
    /**
     * Specifies number of OCPUs for nodes (requires flexible shape specified with `nodeShape`) (int)
     */
    flexOcpus?: number;
    /**
     * The OCID of a KMS vault master key used to encrypt secrets at rest. See [here](https://docs.oracle.com/en-us/iaas/Content/ContEng/Tasks/contengencryptingdata.htm) for help creating a vault and master encryption key. Just for Rancher v2.5.9 or above (string)
     */
    kmsKeyId?: string;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion: string;
    /**
     * The maximum number of worker nodes. Can limit `quantityPerSubnet`. Default `0` (no limit) (int)
     */
    limitNodeCount?: number;
    /**
     * The name of the first existing subnet to use for Kubernetes services / LB. `vcnName` is also required when specifying an existing subnet. (string)
     */
    loadBalancerSubnetName1?: string;
    /**
     * The name of a second existing subnet to use for Kubernetes services / LB. A second subnet is only required when it is AD-specific (non-regional) (string)
     */
    loadBalancerSubnetName2?: string;
    /**
     * The Oracle Linux OS image name to use for the OKE node(s). See [here](https://docs.cloud.oracle.com/en-us/iaas/images/) for a list of images. (string)
     */
    nodeImage: string;
    /**
     * Name for DNS domain of node pool subnet. Default `nodedns` (string)
     */
    nodePoolDnsDomainName?: string;
    /**
     * Name for node pool subnet. Default `nodedns` (string)
     */
    nodePoolSubnetName?: string;
    /**
     * The contents of the SSH public key file to use for the nodes (string)
     */
    nodePublicKeyContents?: string;
    /**
     * The shape of the node (determines number of CPUs and  amount of memory on each OKE node) (string)
     */
    nodeShape: string;
    /**
     * A CIDR notation IP range from which to assign Kubernetes Pod IPs when \"network plugin\" is specified in \"kubenet\". Default `172.244.0.0/16` (string)
     */
    podCidr?: string;
    /**
     * The private API key file contents for the specified user, in PEM format (string)
     */
    privateKeyContents: string;
    /**
     * The passphrase (if any) of the private key for the OKE cluster (string)
     */
    privateKeyPassphrase?: string;
    /**
     * Number of node subnets. Default `1` (int)
     */
    quantityOfNodeSubnets?: number;
    /**
     * Number of OKE worker nodes in each subnet / availability domain. Default `1` (int)
     */
    quantityPerSubnet?: number;
    /**
     * (string)
     */
    region: string;
    /**
     * A CIDR notation IP range from which to assign Kubernetes Service cluster IPs. It must not overlap with any Subnet IP ranges. Default `10.0.0.0/16` (string)
     */
    serviceCidr?: string;
    /**
     * Name for DNS domain of service subnet. Default `svcdns` (string)
     */
    serviceDnsDomainName?: string;
    /**
     * Specifies whether to skip deleting the virtual cloud network (VCN) on destroy. Default `false` (bool)
     */
    skipVcnDelete?: boolean;
    /**
     * The OCID of the tenancy in which to create resources (string)
     */
    tenancyId: string;
    /**
     * The OCID of a user who has access to the tenancy/compartment (string)
     */
    userOcid: string;
    /**
     * The OCID of the compartment (if different from `compartmentId`) in which to find the pre-existing virtual network set with `vcnName`. (string)
     */
    vcnCompartmentId?: string;
    /**
     * The name of an existing virtual network to use for the cluster creation. If set, you must also set `loadBalancerSubnetName1`. A VCN and subnets will be created if none are specified. (string)
     */
    vcnName?: string;
    /**
     * Additional CIDR from which to allow ingress to worker nodes (string)
     */
    workerNodeIngressCidr?: string;
}

export interface ClusterRke2Config {
    /**
     * RKE upgrade strategy (list maxitems:1)
     */
    upgradeStrategy: outputs.ClusterRke2ConfigUpgradeStrategy;
    /**
     * RKE2 kubernetes version (string)
     */
    version: string;
}

export interface ClusterRke2ConfigUpgradeStrategy {
    /**
     * Drain server nodes. Default: `false` (bool)
     */
    drainServerNodes?: boolean;
    /**
     * Drain worker nodes. Default: `false` (bool)
     */
    drainWorkerNodes?: boolean;
    /**
     * Server concurrency. Default: `1` (int)
     */
    serverConcurrency?: number;
    /**
     * Worker concurrency. Default: `1` (int)
     */
    workerConcurrency?: number;
}

export interface ClusterRkeConfig {
    /**
     * Duration in seconds of addon job (int)
     */
    addonJobTimeout: number;
    /**
     * Addons descripton to deploy on RKE cluster.
     */
    addons?: string;
    /**
     * Addons yaml manifests to deploy on RKE cluster (list)
     */
    addonsIncludes?: string[];
    /**
     * Kubernetes cluster authentication (list maxitems:1)
     */
    authentication: outputs.ClusterRkeConfigAuthentication;
    /**
     * Kubernetes cluster authorization (list maxitems:1)
     */
    authorization: outputs.ClusterRkeConfigAuthorization;
    /**
     * RKE bastion host (list maxitems:1)
     */
    bastionHost: outputs.ClusterRkeConfigBastionHost;
    /**
     * RKE cloud provider [rke-cloud-providers](https://rancher.com/docs/rke/v0.1.x/en/config-options/cloud-providers/) (list maxitems:1)
     */
    cloudProvider: outputs.ClusterRkeConfigCloudProvider;
    /**
     * RKE dns add-on. Just for Rancher v2.2.x (list maxitems:1)
     */
    dns: outputs.ClusterRkeConfigDns;
    /**
     * Enable/disable using cri-dockerd. Deafult: `false` [enableCriDockerd](https://rancher.com/docs/rke/latest/en/config-options/#cri-dockerd) (bool)
     */
    enableCriDockerd?: boolean;
    /**
     * Ignore docker version. Default `true` (bool)
     */
    ignoreDockerVersion?: boolean;
    /**
     * Kubernetes ingress configuration (list maxitems:1)
     */
    ingress: outputs.ClusterRkeConfigIngress;
    /**
     * K8s version to deploy. Default: `Rancher default` (string) (Note - if rkeConfig is set at cluster_template, kubernetesVersion must be set to the active cluster version so Rancher can clone the RKE template)
     */
    kubernetesVersion: string;
    /**
     * Kubernetes cluster monitoring (list maxitems:1)
     */
    monitoring: outputs.ClusterRkeConfigMonitoring;
    /**
     * Kubernetes cluster networking (list maxitems:1)
     */
    network: outputs.ClusterRkeConfigNetwork;
    /**
     * RKE cluster nodes (list)
     */
    nodes?: outputs.ClusterRkeConfigNode[];
    /**
     * Prefix to customize Kubernetes path (string)
     */
    prefixPath: string;
    /**
     * private registries for docker images (list)
     */
    privateRegistries?: outputs.ClusterRkeConfigPrivateRegistry[];
    /**
     * Kubernetes cluster services (list maxitems:1)
     */
    services: outputs.ClusterRkeConfigServices;
    /**
     * Use ssh agent auth. Default `false`
     */
    sshAgentAuth?: boolean;
    /**
     * Cluster level SSH certificate path (string)
     */
    sshCertPath: string;
    /**
     * Cluster level SSH private key path (string)
     */
    sshKeyPath: string;
    /**
     * RKE upgrade strategy (list maxitems:1)
     */
    upgradeStrategy: outputs.ClusterRkeConfigUpgradeStrategy;
    /**
     * Prefix to customize Kubernetes path for windows (string)
     */
    winPrefixPath: string;
}

export interface ClusterRkeConfigAuthentication {
    /**
     * RKE sans for authentication ([]string)
     */
    sans: string[];
    /**
     * RKE strategy for authentication (string)
     */
    strategy: string;
}

export interface ClusterRkeConfigAuthorization {
    /**
     * RKE mode for authorization. `rbac` and `none` modes are available. Default `rbac` (string)
     */
    mode?: string;
    /**
     * RKE options for authorization (map)
     */
    options: {[key: string]: any};
}

export interface ClusterRkeConfigBastionHost {
    /**
     * Address ip for the bastion host (string)
     */
    address: string;
    /**
     * Port for bastion host. Default `22` (string)
     */
    port?: string;
    /**
     * Use ssh agent auth. Default `false`
     */
    sshAgentAuth?: boolean;
    /**
     * Bastion host SSH private key (string)
     */
    sshKey: string;
    /**
     * Cluster level SSH private key path (string)
     */
    sshKeyPath: string;
    /**
     * User to connect bastion host (string)
     */
    user: string;
}

export interface ClusterRkeConfigCloudProvider {
    /**
     * RKE AWS Cloud Provider config for Cloud Provider [rke-aws-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/aws/) (list maxitems:1)
     */
    awsCloudProvider?: outputs.ClusterRkeConfigCloudProviderAwsCloudProvider;
    /**
     * RKE Azure Cloud Provider config for Cloud Provider [rke-azure-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/azure/) (list maxitems:1)
     */
    azureCloudProvider?: outputs.ClusterRkeConfigCloudProviderAzureCloudProvider;
    /**
     * RKE Custom Cloud Provider config for Cloud Provider (string)
     */
    customCloudProvider: string;
    /**
     * The name of the Cluster (string)
     */
    name?: string;
    /**
     * RKE Openstack Cloud Provider config for Cloud Provider [rke-openstack-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/openstack/) (list maxitems:1)
     */
    openstackCloudProvider?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProvider;
    /**
     * RKE Vsphere Cloud Provider config for Cloud Provider [rke-vsphere-cloud-provider](https://rancher.com/docs/rke/latest/en/config-options/cloud-providers/vsphere/) Extra argument `name` is required on `virtualCenter` configuration. (list maxitems:1)
     */
    vsphereCloudProvider?: outputs.ClusterRkeConfigCloudProviderVsphereCloudProvider;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProvider {
    /**
     * (list maxitems:1)
     */
    global: outputs.ClusterRkeConfigCloudProviderAwsCloudProviderGlobal;
    /**
     * (list)
     */
    serviceOverrides?: outputs.ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    /**
     * Default `false` (bool)
     */
    disableSecurityGroupIngress?: boolean;
    /**
     * Default `false` (bool)
     */
    disableStrictZoneCheck?: boolean;
    /**
     * (string)
     */
    elbSecurityGroup: string;
    /**
     * (string)
     */
    kubernetesClusterId: string;
    /**
     * (string)
     */
    kubernetesClusterTag: string;
    /**
     * (string)
     */
    roleArn: string;
    /**
     * (string)
     */
    routeTableId: string;
    /**
     * (string)
     */
    subnetId: string;
    /**
     * (string)
     */
    vpc: string;
    /**
     * (string)
     */
    zone: string;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    /**
     * (string)
     */
    region: string;
    /**
     * (string)
     */
    service: string;
    /**
     * (string)
     */
    signingMethod: string;
    /**
     * (string)
     */
    signingName: string;
    /**
     * (string)
     */
    signingRegion: string;
    /**
     * (string)
     */
    url: string;
}

export interface ClusterRkeConfigCloudProviderAzureCloudProvider {
    /**
     * (string)
     */
    aadClientCertPassword: string;
    /**
     * (string)
     */
    aadClientCertPath: string;
    /**
     * (string)
     */
    aadClientId: string;
    /**
     * (string)
     */
    aadClientSecret: string;
    /**
     * (string)
     */
    cloud: string;
    /**
     * (bool)
     */
    cloudProviderBackoff: boolean;
    /**
     * (int)
     */
    cloudProviderBackoffDuration: number;
    /**
     * (int)
     */
    cloudProviderBackoffExponent: number;
    /**
     * (int)
     */
    cloudProviderBackoffJitter: number;
    /**
     * (int)
     */
    cloudProviderBackoffRetries: number;
    /**
     * (bool)
     */
    cloudProviderRateLimit: boolean;
    /**
     * (int)
     */
    cloudProviderRateLimitBucket: number;
    /**
     * (int)
     */
    cloudProviderRateLimitQps: number;
    /**
     * Allowed values: `basic` (default) `standard` (string)
     */
    loadBalancerSku?: string;
    /**
     * (string)
     */
    location: string;
    /**
     * (int)
     */
    maximumLoadBalancerRuleCount: number;
    /**
     * (string)
     */
    primaryAvailabilitySetName: string;
    /**
     * (string)
     */
    primaryScaleSetName: string;
    /**
     * (string)
     */
    resourceGroup: string;
    /**
     * (string)
     */
    routeTableName: string;
    /**
     * (string)
     */
    securityGroupName: string;
    /**
     * (string)
     */
    subnetName: string;
    /**
     * (string)
     */
    subscriptionId: string;
    /**
     * (string)
     */
    tenantId: string;
    /**
     * (bool)
     */
    useInstanceMetadata: boolean;
    /**
     * (bool)
     */
    useManagedIdentityExtension: boolean;
    /**
     * (string)
     */
    vmType: string;
    /**
     * (string)
     */
    vnetName: string;
    /**
     * (string)
     */
    vnetResourceGroup: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProvider {
    /**
     * (list maxitems:1)
     */
    blockStorage: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    /**
     * (list maxitems:1)
     */
    global: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    /**
     * (list maxitems:1)
     */
    loadBalancer: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    /**
     * (list maxitems:1)
     */
    metadata: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    /**
     * (list maxitems:1)
     */
    route: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    /**
     * (string)
     */
    bsVersion: string;
    /**
     * (string)
     */
    ignoreVolumeAz: boolean;
    /**
     * (string)
     */
    trustDevicePath: boolean;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    /**
     * (string)
     */
    authUrl: string;
    /**
     * (string)
     */
    caFile: string;
    /**
     * Required if `domainName` not provided. (string)
     */
    domainId: string;
    /**
     * Required if `domainId` not provided. (string)
     */
    domainName: string;
    /**
     * (string)
     */
    password: string;
    /**
     * (string)
     */
    region: string;
    /**
     * (string)
     */
    tenantId: string;
    /**
     * Required if `tenantId` not provided. (string)
     */
    tenantName: string;
    /**
     * (string)
     */
    trustId: string;
    /**
     * (string)
     */
    username: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    /**
     * (bool)
     */
    createMonitor: boolean;
    /**
     * (string)
     */
    floatingNetworkId: string;
    /**
     * (string)
     */
    lbMethod: string;
    /**
     * (string)
     */
    lbProvider: string;
    /**
     * (string)
     */
    lbVersion: string;
    /**
     * (bool)
     */
    manageSecurityGroups: boolean;
    /**
     * Default `60s` (string)
     */
    monitorDelay?: string;
    /**
     * Default 5 (int)
     */
    monitorMaxRetries?: number;
    /**
     * Default `30s` (string)
     */
    monitorTimeout?: string;
    /**
     * (string)
     */
    subnetId: string;
    /**
     * (bool)
     */
    useOctavia: boolean;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    /**
     * (int)
     */
    requestTimeout: number;
    /**
     * (string)
     */
    searchOrder: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    /**
     * (string)
     */
    routerId: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProvider {
    /**
     * (list maxitems:1)
     */
    disk: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderDisk;
    /**
     * (list maxitems:1)
     */
    global: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal;
    /**
     * Kubernetes cluster networking (list maxitems:1)
     */
    network: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork;
    /**
     * (List)
     */
    virtualCenters: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    /**
     * (list maxitems:1)
     */
    workspace: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    /**
     * (string)
     */
    scsiControllerType: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    /**
     * (string)
     */
    datacenters: string;
    /**
     * (bool)
     */
    insecureFlag: boolean;
    /**
     * (string)
     */
    password: string;
    /**
     * Port for bastion host. Default `22` (string)
     */
    port: string;
    /**
     * (int)
     */
    soapRoundtripCount: number;
    /**
     * User to connect bastion host (string)
     */
    user: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    /**
     * (string)
     */
    publicNetwork: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    /**
     * (string)
     */
    datacenters: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    /**
     * (string)
     */
    password: string;
    /**
     * Port for bastion host. Default `22` (string)
     */
    port: string;
    /**
     * (int)
     */
    soapRoundtripCount: number;
    /**
     * User to connect bastion host (string)
     */
    user: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    /**
     * (string)
     */
    datacenter: string;
    /**
     * (string)
     */
    defaultDatastore: string;
    /**
     * (string)
     */
    folder: string;
    /**
     * (string)
     */
    resourcepoolPath: string;
    /**
     * (string)
     */
    server: string;
}

export interface ClusterRkeConfigDns {
    /**
     * LinearAutoScalerParams dns config (list Maxitem: 1)
     */
    linearAutoscalerParams?: outputs.ClusterRkeConfigDnsLinearAutoscalerParams;
    /**
     * DNS add-on node selector (map)
     */
    nodeSelector: {[key: string]: any};
    /**
     * Nodelocal dns config  (list Maxitem: 1)
     */
    nodelocal?: outputs.ClusterRkeConfigDnsNodelocal;
    /**
     * RKE options for authorization (map)
     */
    options: {[key: string]: any};
    /**
     * DNS add-on provider. `kube-dns`, `coredns` (default), and `none` are supported (string)
     */
    provider?: string;
    /**
     * DNS add-on reverse cidr  (list)
     */
    reverseCidrs: string[];
    /**
     * DNS add-on tolerations (list)
     */
    tolerations?: outputs.ClusterRkeConfigDnsToleration[];
    /**
     * DNS update strategy (list Maxitems: 1)
     */
    updateStrategy?: outputs.ClusterRkeConfigDnsUpdateStrategy;
    /**
     * DNS add-on upstream nameservers  (list)
     */
    upstreamNameservers: string[];
}

export interface ClusterRkeConfigDnsLinearAutoscalerParams {
    /**
     * number of replicas per cluster cores (float64)
     */
    coresPerReplica?: number;
    /**
     * maximum number of replicas (int64)
     */
    max?: number;
    /**
     * minimum number of replicas (int64)
     */
    min?: number;
    /**
     * number of replica per cluster nodes (float64)
     */
    nodesPerReplica?: number;
    /**
     * prevent single point of failure
     */
    preventSinglePointFailure?: boolean;
}

export interface ClusterRkeConfigDnsNodelocal {
    /**
     * Nodelocal dns ip address (string)
     */
    ipAddress?: string;
    /**
     * DNS add-on node selector (map)
     */
    nodeSelector?: {[key: string]: any};
}

export interface ClusterRkeConfigDnsToleration {
    /**
     * The toleration effect. `NoExecute`, `NoSchedule`, and `PreferNoSchedule` are supported. Default: `NoExecute` (string)
     */
    effect?: string;
    /**
     * The toleration key (string)
     */
    key: string;
    /**
     * The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
     */
    operator?: string;
    /**
     * The toleration seconds (int)
     */
    seconds: number;
    /**
     * Rancher agent env var value (string)
     */
    value?: string;
}

export interface ClusterRkeConfigDnsUpdateStrategy {
    /**
     * Monitoring daemon set rolling update (list Maxitems: 1)
     */
    rollingUpdate?: outputs.ClusterRkeConfigDnsUpdateStrategyRollingUpdate;
    /**
     * RKE strategy for authentication (string)
     */
    strategy?: string;
}

export interface ClusterRkeConfigDnsUpdateStrategyRollingUpdate {
    /**
     * Monitoring deployment rolling update max surge. Default: `1` (int)
     */
    maxSurge?: number;
    /**
     * Monitoring deployment rolling update max unavailable. Default: `1` (int)
     */
    maxUnavailable?: number;
}

export interface ClusterRkeConfigIngress {
    /**
     * Enable ingress default backend. Default: `true` (bool)
     */
    defaultBackend?: boolean;
    /**
     * Ingress controller DNS policy. `ClusterFirstWithHostNet`, `ClusterFirst`, `Default`, and `None` are supported. [K8S dns Policy](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#pod-s-dns-policy) (string)
     */
    dnsPolicy: string;
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * HTTP port for RKE Ingress (int)
     */
    httpPort: number;
    /**
     * HTTPS port for RKE Ingress (int)
     */
    httpsPort: number;
    /**
     * Network mode for RKE Ingress (string)
     */
    networkMode: string;
    /**
     * DNS add-on node selector (map)
     */
    nodeSelector: {[key: string]: any};
    /**
     * RKE options for authorization (map)
     */
    options: {[key: string]: any};
    /**
     * DNS add-on provider. `kube-dns`, `coredns` (default), and `none` are supported (string)
     */
    provider: string;
    /**
     * DNS add-on tolerations (list)
     */
    tolerations?: outputs.ClusterRkeConfigIngressToleration[];
    /**
     * DNS update strategy (list Maxitems: 1)
     */
    updateStrategy?: outputs.ClusterRkeConfigIngressUpdateStrategy;
}

export interface ClusterRkeConfigIngressToleration {
    /**
     * The toleration effect. `NoExecute`, `NoSchedule`, and `PreferNoSchedule` are supported. Default: `NoExecute` (string)
     */
    effect?: string;
    /**
     * The toleration key (string)
     */
    key: string;
    /**
     * The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
     */
    operator?: string;
    /**
     * The toleration seconds (int)
     */
    seconds: number;
    /**
     * Rancher agent env var value (string)
     */
    value?: string;
}

export interface ClusterRkeConfigIngressUpdateStrategy {
    /**
     * Monitoring daemon set rolling update (list Maxitems: 1)
     */
    rollingUpdate?: outputs.ClusterRkeConfigIngressUpdateStrategyRollingUpdate;
    /**
     * RKE strategy for authentication (string)
     */
    strategy?: string;
}

export interface ClusterRkeConfigIngressUpdateStrategyRollingUpdate {
    /**
     * Monitoring deployment rolling update max unavailable. Default: `1` (int)
     */
    maxUnavailable?: number;
}

export interface ClusterRkeConfigMonitoring {
    /**
     * DNS add-on node selector (map)
     */
    nodeSelector?: {[key: string]: any};
    /**
     * RKE options for authorization (map)
     */
    options: {[key: string]: any};
    /**
     * DNS add-on provider. `kube-dns`, `coredns` (default), and `none` are supported (string)
     */
    provider: string;
    /**
     * RKE monitoring replicas (int)
     */
    replicas: number;
    /**
     * DNS add-on tolerations (list)
     */
    tolerations?: outputs.ClusterRkeConfigMonitoringToleration[];
    /**
     * DNS update strategy (list Maxitems: 1)
     */
    updateStrategy?: outputs.ClusterRkeConfigMonitoringUpdateStrategy;
}

export interface ClusterRkeConfigMonitoringToleration {
    /**
     * The toleration effect. `NoExecute`, `NoSchedule`, and `PreferNoSchedule` are supported. Default: `NoExecute` (string)
     */
    effect?: string;
    /**
     * The toleration key (string)
     */
    key: string;
    /**
     * The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
     */
    operator?: string;
    /**
     * The toleration seconds (int)
     */
    seconds: number;
    /**
     * Rancher agent env var value (string)
     */
    value?: string;
}

export interface ClusterRkeConfigMonitoringUpdateStrategy {
    /**
     * Monitoring daemon set rolling update (list Maxitems: 1)
     */
    rollingUpdate?: outputs.ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate;
    /**
     * RKE strategy for authentication (string)
     */
    strategy?: string;
}

export interface ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    /**
     * Monitoring deployment rolling update max surge. Default: `1` (int)
     */
    maxSurge?: number;
    /**
     * Monitoring deployment rolling update max unavailable. Default: `1` (int)
     */
    maxUnavailable?: number;
}

export interface ClusterRkeConfigNetwork {
    /**
     * ACI provider config for RKE network (list maxitems:63)
     */
    aciNetworkProvider?: outputs.ClusterRkeConfigNetworkAciNetworkProvider;
    /**
     * Calico provider config for RKE network (list maxitems:1)
     */
    calicoNetworkProvider?: outputs.ClusterRkeConfigNetworkCalicoNetworkProvider;
    /**
     * Canal provider config for RKE network (list maxitems:1)
     */
    canalNetworkProvider?: outputs.ClusterRkeConfigNetworkCanalNetworkProvider;
    /**
     * Flannel provider config for RKE network (list maxitems:1)
     */
    flannelNetworkProvider?: outputs.ClusterRkeConfigNetworkFlannelNetworkProvider;
    /**
     * Network provider MTU. Default `0` (int)
     */
    mtu?: number;
    /**
     * RKE options for authorization (map)
     */
    options: {[key: string]: any};
    /**
     * Plugin for RKE network. `canal` (default), `flannel`, `calico`, `none` and `weave` are supported. (string)
     */
    plugin: string;
    /**
     * DNS add-on tolerations (list)
     */
    tolerations?: outputs.ClusterRkeConfigNetworkToleration[];
    /**
     * Weave provider config for RKE network (list maxitems:1)
     */
    weaveNetworkProvider?: outputs.ClusterRkeConfigNetworkWeaveNetworkProvider;
}

export interface ClusterRkeConfigNetworkAciNetworkProvider {
    /**
     * Attachable entity profile (string)
     */
    aep: string;
    /**
     * List of APIC hosts to connect for APIC API (list)
     */
    apicHosts: string[];
    /**
     * APIC refresh ticker adjust amount (string)
     */
    apicRefreshTickerAdjust?: string;
    /**
     * APIC refresh time in seconds (string)
     */
    apicRefreshTime?: string;
    /**
     * APIC subscription delay amount (string)
     */
    apicSubscriptionDelay?: string;
    /**
     * APIC user certificate (string)
     */
    apicUserCrt: string;
    /**
     * APIC user key (string)
     */
    apicUserKey: string;
    /**
     * APIC user name (string)
     */
    apicUserName: string;
    /**
     * cAPIC cloud (string)
     */
    capic?: string;
    /**
     * Log level for ACI controller (string)
     */
    controllerLogLevel?: string;
    /**
     * Whether to disable periodic SNAT global info sync (string)
     */
    disablePeriodicSnatGlobalInfoSync?: string;
    /**
     * Whether to disable waiting for network (string)
     */
    disableWaitForNetwork?: string;
    /**
     * Whether to enable drop log (string)
     */
    dropLogEnable?: string;
    /**
     * The duration to wait for network (string)
     */
    durationWaitForNetwork?: string;
    /**
     * Whether to enable endpoint slices (string)
     */
    enableEndpointSlice?: string;
    /**
     * Encap type: vxlan or vlan (string)
     */
    encapType: string;
    /**
     * EP registry (string)
     */
    epRegistry?: string;
    /**
     * Subnet to use for dynamic external IPs (string)
     */
    externDynamic: string;
    /**
     * Subnet to use for static external IPs (string)
     */
    externStatic: string;
    /**
     * GBH pod subnet (string)
     */
    gbpPodSubnet?: string;
    /**
     * Log level for ACI host agent (string)
     */
    hostAgentLogLevel?: string;
    /**
     * Image pull policy (string)
     */
    imagePullPolicy?: string;
    /**
     * Image pull policy (string)
     */
    imagePullSecret?: string;
    /**
     * The VLAN used by ACI infra (string)
     */
    infraVlan?: string;
    /**
     * Whether to install Istio (string)
     */
    installIstio?: string;
    /**
     * Istio profile name (string)
     */
    istioProfile?: string;
    /**
     * List of Kafka broker hosts (list)
     */
    kafkaBrokers?: string[];
    /**
     * Kafka client certificate (string)
     */
    kafkaClientCrt?: string;
    /**
     * Kafka client key (string)
     */
    kafkaClientKey?: string;
    /**
     * The VLAN used by the physdom for nodes (string)
     */
    kubeApiVlan: string;
    /**
     * L3out (string)
     */
    l3out: string;
    /**
     * L3out external networks (list)
     */
    l3outExternalNetworks: string[];
    /**
     * Max nodes in service graph (string)
     */
    maxNodesSvcGraph?: string;
    /**
     * End of mcast range (string)
     */
    mcastRangeEnd: string;
    /**
     * Start of mcast range (string)
     */
    mcastRangeStart: string;
    /**
     * MTU head room amount (string)
     */
    mtuHeadRoom?: string;
    /**
     * Whether to disable Multus (string)
     */
    multusDisable?: string;
    /**
     * Whether to use priority class (string)
     */
    noPriorityClass?: string;
    /**
     * Whether to enable node pod interface (string)
     */
    nodePodIfEnable?: string;
    /**
     * Subnet to use for nodes (string)
     */
    nodeSubnet: string;
    /**
     * Subnet to use for service graph (string)
     */
    nodeSvcSubnet: string;
    /**
     * Whether to use client SSL for Opflex (string)
     */
    opflexClientSsl?: string;
    /**
     * Opflex device delete timeout (string)
     */
    opflexDeviceDeleteTimeout?: string;
    /**
     * Log level for ACI opflex (string)
     */
    opflexLogLevel?: string;
    /**
     * Opflex mode (string)
     */
    opflexMode?: string;
    /**
     * Opflex server port (string)
     */
    opflexServerPort?: string;
    /**
     * Overlay VRF name (string)
     */
    overlayVrfName?: string;
    /**
     * OVS memory limit (string)
     */
    ovsMemoryLimit?: string;
    /**
     * Policy-based routing tracking non snat (string)
     */
    pbrTrackingNonSnat?: string;
    /**
     * Pod subnet chunk size (string)
     */
    podSubnetChunkSize?: string;
    /**
     * Whether to run GBP container (string)
     */
    runGbpContainer?: string;
    /**
     * Whether to run Opflex server container (string)
     */
    runOpflexServerContainer?: string;
    /**
     * Service monitor interval (string)
     */
    serviceMonitorInterval?: string;
    /**
     * The VLAN used by LoadBalancer services (string)
     */
    serviceVlan: string;
    /**
     * Snat contract scope (string)
     */
    snatContractScope?: string;
    /**
     * Snat namespace (string)
     */
    snatNamespace?: string;
    /**
     * End of snat port range (string)
     */
    snatPortRangeEnd?: string;
    /**
     * End of snat port range (string)
     */
    snatPortRangeStart?: string;
    /**
     * Snat ports per node (string)
     */
    snatPortsPerNode?: string;
    /**
     * Whether to enable SR-IOV (string)
     */
    sriovEnable?: string;
    /**
     * Subnet domain name (string)
     */
    subnetDomainName?: string;
    /**
     * ACI system ID (string)
     */
    systemId: string;
    /**
     * ACI tenant (string)
     */
    tenant?: string;
    /**
     * ACI token (string)
     */
    token: string;
    /**
     * Whether to use ACI anywhere CRD (string)
     */
    useAciAnywhereCrd?: string;
    /**
     * Whether to use ACI CNI priority class (string)
     */
    useAciCniPriorityClass?: string;
    /**
     * Whether to use cluster role (string)
     */
    useClusterRole?: string;
    /**
     * Whether to use host netns volume (string)
     */
    useHostNetnsVolume?: string;
    /**
     * Whether use Opflex server volume (string)
     */
    useOpflexServerVolume?: string;
    /**
     * Whether ACI containers should run as privileged (string)
     */
    usePrivilegedContainer?: string;
    /**
     * VMM controller configuration (string)
     */
    vmmController?: string;
    /**
     * VMM domain configuration (string)
     */
    vmmDomain?: string;
    /**
     * VRF name (string)
     */
    vrfName: string;
    /**
     * VRF tenant (string)
     */
    vrfTenant: string;
}

export interface ClusterRkeConfigNetworkCalicoNetworkProvider {
    /**
     * RKE cloud provider [rke-cloud-providers](https://rancher.com/docs/rke/v0.1.x/en/config-options/cloud-providers/) (list maxitems:1)
     */
    cloudProvider: string;
}

export interface ClusterRkeConfigNetworkCanalNetworkProvider {
    /**
     * Iface config Canal network provider (string)
     */
    iface: string;
}

export interface ClusterRkeConfigNetworkFlannelNetworkProvider {
    /**
     * Iface config Canal network provider (string)
     */
    iface: string;
}

export interface ClusterRkeConfigNetworkToleration {
    /**
     * The toleration effect. `NoExecute`, `NoSchedule`, and `PreferNoSchedule` are supported. Default: `NoExecute` (string)
     */
    effect?: string;
    /**
     * The toleration key (string)
     */
    key: string;
    /**
     * The toleration operator. `Equal`, and `Exists` are supported. Default: `Equal` (string)
     */
    operator?: string;
    /**
     * The toleration seconds (int)
     */
    seconds: number;
    /**
     * Rancher agent env var value (string)
     */
    value?: string;
}

export interface ClusterRkeConfigNetworkWeaveNetworkProvider {
    /**
     * (string)
     */
    password: string;
}

export interface ClusterRkeConfigNode {
    /**
     * Address ip for the bastion host (string)
     */
    address: string;
    /**
     * Docker socket for node (string)
     */
    dockerSocket: string;
    /**
     * Hostname override for node (string)
     */
    hostnameOverride?: string;
    /**
     * Internal ip for node (string)
     */
    internalAddress?: string;
    /**
     * Labels for the Cluster (map)
     */
    labels?: {[key: string]: any};
    /**
     * Id for the node (string)
     */
    nodeId?: string;
    /**
     * Port for bastion host. Default `22` (string)
     */
    port?: string;
    /**
     * Roles for the node. `controlplane`, `etcd` and `worker` are supported. (list)
     */
    roles: string[];
    /**
     * Use ssh agent auth. Default `false`
     */
    sshAgentAuth?: boolean;
    /**
     * Bastion host SSH private key (string)
     */
    sshKey: string;
    /**
     * Cluster level SSH private key path (string)
     */
    sshKeyPath: string;
    /**
     * User to connect bastion host (string)
     */
    user: string;
}

export interface ClusterRkeConfigPrivateRegistry {
    /**
     * ECR credential plugin config (list maxitems:1)
     */
    ecrCredentialPlugin?: outputs.ClusterRkeConfigPrivateRegistryEcrCredentialPlugin;
    /**
     * Set as default registry. Default `false` (bool)
     */
    isDefault?: boolean;
    /**
     * (string)
     */
    password?: string;
    /**
     * (string)
     */
    url: string;
    /**
     * User to connect bastion host (string)
     */
    user?: string;
}

export interface ClusterRkeConfigPrivateRegistryEcrCredentialPlugin {
    /**
     * AWS access key ID (string)
     */
    awsAccessKeyId?: string;
    /**
     * AWS secret access key (string)
     */
    awsSecretAccessKey?: string;
    /**
     * AWS session token (string)
     */
    awsSessionToken?: string;
}

export interface ClusterRkeConfigServices {
    /**
     * Etcd options for RKE services (list maxitems:1)
     */
    etcd: outputs.ClusterRkeConfigServicesEtcd;
    /**
     * Kube API options for RKE services (list maxitems:1)
     */
    kubeApi: outputs.ClusterRkeConfigServicesKubeApi;
    /**
     * Kube Controller options for RKE services (list maxitems:1)
     */
    kubeController: outputs.ClusterRkeConfigServicesKubeController;
    /**
     * Kubelet options for RKE services (list maxitems:1)
     */
    kubelet: outputs.ClusterRkeConfigServicesKubelet;
    /**
     * Kubeproxy options for RKE services (list maxitems:1)
     */
    kubeproxy: outputs.ClusterRkeConfigServicesKubeproxy;
    /**
     * Scheduler options for RKE services (list maxitems:1)
     */
    scheduler: outputs.ClusterRkeConfigServicesScheduler;
}

export interface ClusterRkeConfigServicesEtcd {
    /**
     * Backup options for etcd service. Just for Rancher v2.2.x (list maxitems:1)
     */
    backupConfig: outputs.ClusterRkeConfigServicesEtcdBackupConfig;
    /**
     * TLS CA certificate for etcd service (string)
     */
    caCert: string;
    /**
     * TLS certificate for etcd service (string)
     */
    cert: string;
    /**
     * Creation option for etcd service (string)
     */
    creation: string;
    /**
     * External urls for etcd service (list)
     */
    externalUrls?: string[];
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds for etcd service (list)
     */
    extraBinds?: string[];
    /**
     * Extra environment for etcd service (list)
     */
    extraEnvs?: string[];
    /**
     * Etcd service GID. Default: `0`. For Rancher v2.3.x or above (int)
     */
    gid?: number;
    /**
     * Docker image for etcd service (string)
     */
    image: string;
    /**
     * The toleration key (string)
     */
    key: string;
    /**
     * Path for etcd service (string)
     */
    path: string;
    /**
     * Retention option for etcd service (string)
     */
    retention: string;
    /**
     * Snapshot option for etcd service (bool)
     */
    snapshot: boolean;
    /**
     * Etcd service UID. Default: `0`. For Rancher v2.3.x or above (int)
     */
    uid?: number;
}

export interface ClusterRkeConfigServicesEtcdBackupConfig {
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
    /**
     * Interval hours for etcd backup. Default `12` (int)
     */
    intervalHours?: number;
    /**
     * Retention option for etcd service (string)
     */
    retention?: number;
    /**
     * S3 config options for etcd backup (list maxitems:1)
     */
    s3BackupConfig?: outputs.ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    /**
     * Safe timestamp for etcd backup. Default: `false` (bool)
     */
    safeTimestamp?: boolean;
    /**
     * Timeout in seconds for etcd backup. Default: `300`. Just for Rancher v2.5.6 and above (int)
     */
    timeout: number;
}

export interface ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    /**
     * Access key for S3 service (string)
     */
    accessKey?: string;
    /**
     * Bucket name for S3 service (string)
     */
    bucketName: string;
    /**
     * Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
     */
    customCa?: string;
    /**
     * Endpoint for S3 service (string)
     */
    endpoint: string;
    /**
     * (string)
     */
    folder?: string;
    /**
     * (string)
     */
    region?: string;
    /**
     * Secret key for S3 service (string)
     */
    secretKey?: string;
}

export interface ClusterRkeConfigServicesKubeApi {
    /**
     * Admission configuration (map)
     */
    admissionConfiguration?: {[key: string]: any};
    /**
     * Enable [AlwaysPullImages](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages) Admission controller plugin. [Rancher docs](https://rancher.com/docs/rke/latest/en/config-options/services/#kubernetes-api-server-options) Default: `false` (bool)
     */
    alwaysPullImages?: boolean;
    /**
     * K8s audit log configuration. (list maxitems: 1)
     */
    auditLog?: outputs.ClusterRkeConfigServicesKubeApiAuditLog;
    /**
     * K8s event rate limit configuration. (list maxitems: 1)
     */
    eventRateLimit?: outputs.ClusterRkeConfigServicesKubeApiEventRateLimit;
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds for etcd service (list)
     */
    extraBinds?: string[];
    /**
     * Extra environment for etcd service (list)
     */
    extraEnvs?: string[];
    /**
     * Docker image for etcd service (string)
     */
    image: string;
    /**
     * Pod Security Policy option for kube API service. Default `false` (bool)
     */
    podSecurityPolicy?: boolean;
    /**
     * [Encrypt k8s secret data configration](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/). (list maxitem: 1)
     */
    secretsEncryptionConfig?: outputs.ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig;
    /**
     * Service Cluster IP Range option for kube API service (string)
     */
    serviceClusterIpRange: string;
    /**
     * Service Node Port Range option for kube API service (string)
     */
    serviceNodePortRange: string;
}

export interface ClusterRkeConfigServicesKubeApiAuditLog {
    /**
     * Audit log configuration. (list maxitems: 1)
     */
    configuration: outputs.ClusterRkeConfigServicesKubeApiAuditLogConfiguration;
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeApiAuditLogConfiguration {
    /**
     * Audit log format. Default: 'json' (string)
     */
    format?: string;
    /**
     * Audit log max age. Default: `30` (int)
     */
    maxAge?: number;
    /**
     * Audit log max backup. Default: `10` (int)
     */
    maxBackup?: number;
    /**
     * Audit log max size. Default: `100` (int)
     */
    maxSize?: number;
    /**
     * Path for etcd service (string)
     */
    path?: string;
    /**
     * Audit policy yaml encoded definition. `apiVersion` and `kind: Policy\nrules:"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/audit-log/) (string) Ex:
     */
    policy: string;
}

export interface ClusterRkeConfigServicesKubeApiEventRateLimit {
    /**
     * Audit log configuration. (list maxitems: 1)
     */
    configuration: string;
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
    /**
     * Secrets encryption yaml encoded custom configuration. `"apiVersion"` and `"kind":"EncryptionConfiguration"` fields are required in the yaml. [More info](https://rancher.com/docs/rke/latest/en/config-options/secrets-encryption/) (string) Ex:
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * ```
     */
    customConfig?: string;
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeController {
    /**
     * Cluster CIDR option for kube controller service (string)
     */
    clusterCidr: string;
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds for etcd service (list)
     */
    extraBinds?: string[];
    /**
     * Extra environment for etcd service (list)
     */
    extraEnvs?: string[];
    /**
     * Docker image for etcd service (string)
     */
    image: string;
    /**
     * Service Cluster IP Range option for kube API service (string)
     */
    serviceClusterIpRange: string;
}

export interface ClusterRkeConfigServicesKubelet {
    /**
     * Cluster DNS Server option for kubelet service (string)
     */
    clusterDnsServer: string;
    /**
     * Cluster Domain option for kubelet service (string)
     */
    clusterDomain: string;
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds for etcd service (list)
     */
    extraBinds?: string[];
    /**
     * Extra environment for etcd service (list)
     */
    extraEnvs?: string[];
    /**
     * Enable or disable failing when swap on is not supported (bool)
     */
    failSwapOn: boolean;
    /**
     * [Generate a certificate signed by the kube-ca](https://rancher.com/docs/rke/latest/en/config-options/services/#kubelet-serving-certificate-requirements). Default `false` (bool)
     */
    generateServingCertificate?: boolean;
    /**
     * Docker image for etcd service (string)
     */
    image: string;
    /**
     * Infra container image for kubelet service (string)
     */
    infraContainerImage: string;
}

export interface ClusterRkeConfigServicesKubeproxy {
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds for etcd service (list)
     */
    extraBinds?: string[];
    /**
     * Extra environment for etcd service (list)
     */
    extraEnvs?: string[];
    /**
     * Docker image for etcd service (string)
     */
    image: string;
}

export interface ClusterRkeConfigServicesScheduler {
    /**
     * Extra arguments for RKE Ingress (map)
     */
    extraArgs: {[key: string]: any};
    /**
     * Extra binds for etcd service (list)
     */
    extraBinds?: string[];
    /**
     * Extra environment for etcd service (list)
     */
    extraEnvs?: string[];
    /**
     * Docker image for etcd service (string)
     */
    image: string;
}

export interface ClusterRkeConfigUpgradeStrategy {
    /**
     * RKE drain nodes. Default: `false` (bool)
     */
    drain?: boolean;
    /**
     * RKE drain node input (list Maxitems: 1)
     */
    drainInput: outputs.ClusterRkeConfigUpgradeStrategyDrainInput;
    /**
     * RKE max unavailable controlplane nodes. Default: `1` (string)
     */
    maxUnavailableControlplane?: string;
    /**
     * RKE max unavailable worker nodes. Default: `10%` (string)
     */
    maxUnavailableWorker?: string;
}

export interface ClusterRkeConfigUpgradeStrategyDrainInput {
    /**
     * Delete RKE node local data. Default: `false` (bool)
     */
    deleteLocalData?: boolean;
    /**
     * Force RKE node drain. Default: `false` (bool)
     */
    force?: boolean;
    /**
     * RKE node drain grace period. Default: `-1` (int)
     */
    gracePeriod?: number;
    /**
     * Ignore RKE daemon sets. Default: `true` (bool)
     */
    ignoreDaemonSets?: boolean;
    /**
     * Timeout in seconds for etcd backup. Default: `300`. Just for Rancher v2.5.6 and above (int)
     */
    timeout?: number;
}

export interface ClusterSyncNode {
    /**
     * Annotations of the node (map).
     */
    annotations: {[key: string]: any};
    /**
     * The total resources of a node (map).
     */
    capacity: {[key: string]: any};
    /**
     * The cluster ID that is syncing (string)
     */
    clusterId: string;
    /**
     * The external IP address of the node (string).
     */
    externalIpAddress: string;
    /**
     * The hostname of the node (string).
     */
    hostname: string;
    /**
     * The ID of the node (string)
     */
    id: string;
    /**
     * The private IP address of the node (string).
     */
    ipAddress: string;
    /**
     * Labels of the node (map).
     */
    labels: {[key: string]: any};
    /**
     * The name of the node (string).
     */
    name: string;
    /**
     * The Node Pool ID of the node (string).
     */
    nodePoolId: string;
    /**
     * The Node Template ID of the node (string).
     */
    nodeTemplateId: string;
    /**
     * The Provider ID of the node (string).
     */
    providerId: string;
    /**
     * The requested hostname (string).
     */
    requestedHostname: string;
    /**
     * Roles of the node. `controlplane`, `etcd` and `worker`. (list)
     */
    roles: string[];
    /**
     * The user to connect to the node (string).
     */
    sshUser: string;
    /**
     * General information about the node, such as kernel version, kubelet and kube-proxy version, Docker version (if used), and OS name.
     */
    systemInfo: {[key: string]: any};
}

export interface ClusterTemplateMember {
    /**
     * Member access type. Valid values: `["read-only" | "owner"]` (string)
     */
    accessType?: string;
    /**
     * Member group principal id (string)
     */
    groupPrincipalId?: string;
    /**
     * Member user principal id (string)
     */
    userPrincipalId?: string;
}

export interface ClusterTemplateTemplateRevision {
    /**
     * Annotations for the cluster template (map)
     */
    annotations: {[key: string]: any};
    /**
     * Cluster configuration (list maxitem: 1)
     */
    clusterConfig: outputs.ClusterTemplateTemplateRevisionClusterConfig;
    /**
     * Cluster template ID (string)
     */
    clusterTemplateId: string;
    /**
     * Default cluster template revision. Default `false` (bool)
     */
    default?: boolean;
    /**
     * Enable cluster template revision. Default `true` (bool)
     */
    enabled?: boolean;
    /**
     * The cluster template revision ID (string)
     */
    id: string;
    /**
     * Labels for the cluster template (map)
     */
    labels: {[key: string]: any};
    /**
     * The cluster template name (string)
     */
    name: string;
    /**
     * Cluster template questions (list)
     */
    questions?: outputs.ClusterTemplateTemplateRevisionQuestion[];
}

export interface ClusterTemplateTemplateRevisionClusterConfig {
    /**
     * Local cluster auth endpoint (list maxitems: 1)
     */
    clusterAuthEndpoint: outputs.ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint;
    /**
     * Default cluster role for project members (string)
     */
    defaultClusterRoleForProjectMembers: string;
    /**
     * Default pod security policy template ID (string)
     */
    defaultPodSecurityPolicyTemplateId: string;
    /**
     * Desired agent image (string)
     */
    desiredAgentImage: string;
    /**
     * Desired auth image (string)
     */
    desiredAuthImage: string;
    /**
     * Desired auth image (string)
     */
    dockerRootDir: string;
    /**
     * Enable built-in cluster alerting. Default: `false` (bool)
     */
    enableClusterAlerting?: boolean;
    /**
     * Enable built-in cluster monitoring. Default: `false` (bool)
     */
    enableClusterMonitoring?: boolean;
    /**
     * Enable project network isolation. Default: `false` (bool)
     */
    enableNetworkPolicy?: boolean;
    /**
     * Rancher Kubernetes Engine Config (list maxitems: 1)
     */
    rkeConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfig;
    /**
     * Windows prefered cluster. Default: `false` (bool)
     */
    windowsPreferedCluster?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts?: string;
    /**
     * Enable cluster template revision. Default `true` (bool)
     */
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication;
    authorization: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization;
    bastionHost: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost;
    cloudProvider: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider;
    dns: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns;
    enableCriDockerd?: boolean;
    ignoreDockerVersion?: boolean;
    ingress: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring;
    network: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork;
    nodes?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry[];
    services: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy;
    winPrefixPath: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    /**
     * The cluster template name (string)
     */
    name?: string;
    openstackCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    /**
     * The cluster template name (string)
     */
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns {
    linearAutoscalerParams?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams;
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal;
    options: {[key: string]: any};
    provider?: string;
    reverseCidrs: string[];
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration[];
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy;
    upstreamNameservers: string[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams {
    coresPerReplica?: number;
    max?: number;
    min?: number;
    nodesPerReplica?: number;
    preventSinglePointFailure?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy {
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    defaultBackend?: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration[];
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy {
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate {
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration[];
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    aciNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider;
    calicoNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    tolerations?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration[];
    weaveNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust?: string;
    apicRefreshTime?: string;
    apicSubscriptionDelay?: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic?: string;
    controllerLogLevel?: string;
    disablePeriodicSnatGlobalInfoSync?: string;
    disableWaitForNetwork?: string;
    dropLogEnable?: string;
    durationWaitForNetwork?: string;
    enableEndpointSlice?: string;
    encapType: string;
    epRegistry?: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet?: string;
    hostAgentLogLevel?: string;
    imagePullPolicy?: string;
    imagePullSecret?: string;
    infraVlan?: string;
    installIstio?: string;
    istioProfile?: string;
    kafkaBrokers?: string[];
    kafkaClientCrt?: string;
    kafkaClientKey?: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph?: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom?: string;
    multusDisable?: string;
    noPriorityClass?: string;
    nodePodIfEnable?: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl?: string;
    opflexDeviceDeleteTimeout?: string;
    opflexLogLevel?: string;
    opflexMode?: string;
    opflexServerPort?: string;
    overlayVrfName?: string;
    ovsMemoryLimit?: string;
    pbrTrackingNonSnat?: string;
    podSubnetChunkSize?: string;
    runGbpContainer?: string;
    runOpflexServerContainer?: string;
    serviceMonitorInterval?: string;
    serviceVlan: string;
    snatContractScope?: string;
    snatNamespace?: string;
    snatPortRangeEnd?: string;
    snatPortRangeStart?: string;
    snatPortsPerNode?: string;
    sriovEnable?: string;
    subnetDomainName?: string;
    systemId: string;
    tenant?: string;
    token: string;
    useAciAnywhereCrd?: string;
    useAciCniPriorityClass?: string;
    useClusterRole?: string;
    useHostNetnsVolume?: string;
    useOpflexServerVolume?: string;
    usePrivilegedContainer?: string;
    vmmController?: string;
    vmmDomain?: string;
    vrfName: string;
    vrfTenant: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    /**
     * Labels for the cluster template (map)
     */
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    ecrCredentialPlugin?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin;
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    awsSessionToken?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices {
    etcd: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd;
    kubeApi: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi;
    kubeController: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController;
    kubelet: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet;
    kubeproxy: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy;
    scheduler: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd {
    backupConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig {
    /**
     * Enable cluster template revision. Default `true` (bool)
     */
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration;
    /**
     * Enable cluster template revision. Default `true` (bool)
     */
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    /**
     * Enable cluster template revision. Default `true` (bool)
     */
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    /**
     * Enable cluster template revision. Default `true` (bool)
     */
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface ClusterTemplateTemplateRevisionQuestion {
    /**
     * Default cluster template revision. Default `false` (bool)
     */
    default: string;
    /**
     * Required variable. Default `false` (bool)
     */
    required?: boolean;
    /**
     * Variable type. `boolean`, `int` and `string` are allowed. Default `string` (string)
     */
    type?: string;
    /**
     * Variable name (string)
     */
    variable: string;
}

export interface ClusterV2AgentEnvVar {
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    /**
     * Rancher agent env var value (string)
     */
    value: string;
}

export interface ClusterV2ClusterRegistrationToken {
    /**
     * Annotations for the Cluster V2 (map)
     */
    annotations: {[key: string]: any};
    /**
     * Cluster ID (string)
     */
    clusterId: string;
    /**
     * Command to execute in a imported k8s cluster (string)
     */
    command: string;
    /**
     * (Computed) The ID of the resource (string)
     */
    id: string;
    /**
     * Insecure command to execute in a imported k8s cluster (string)
     */
    insecureCommand: string;
    /**
     * Insecure node command to execute in a imported k8s cluster (string)
     */
    insecureNodeCommand: string;
    /**
     * Insecure windows command to execute in a imported k8s cluster (string)
     */
    insecureWindowsNodeCommand: string;
    /**
     * Labels for the Cluster V2 (map)
     */
    labels: {[key: string]: any};
    /**
     * K8s manifest url to execute with `kubectl` to import an existing k8s cluster (string)
     */
    manifestUrl: string;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    /**
     * Node command to execute in linux nodes for custom k8s cluster (string)
     */
    nodeCommand: string;
    /**
     * Token for cluster registration token object (string)
     */
    token: string;
    /**
     * Node command to execute in windows nodes for custom k8s cluster (string)
     */
    windowsNodeCommand: string;
}

export interface ClusterV2LocalAuthEndpoint {
    /**
     * CA certs for the authorized cluster endpoint (string)
     */
    caCerts?: string;
    /**
     * Enable the authorized cluster endpoint. Default `false` (bool)
     */
    enabled?: boolean;
    /**
     * FQDN for the authorized cluster endpoint (string)
     */
    fqdn?: string;
}

export interface ClusterV2RkeConfig {
    /**
     * Cluster V2 additional manifest (string)
     */
    additionalManifest?: string;
    /**
     * Cluster V2 chart values. Must be in YAML format (string)
     */
    chartValues?: string;
    /**
     * Cluster V2 etcd (list maxitems:1)
     */
    etcd: outputs.ClusterV2RkeConfigEtcd;
    /**
     * Cluster V2 etcd snapshot create (list maxitems:1)
     */
    etcdSnapshotCreate?: outputs.ClusterV2RkeConfigEtcdSnapshotCreate;
    /**
     * Cluster V2 etcd snapshot restore (list maxitems:1)
     */
    etcdSnapshotRestore?: outputs.ClusterV2RkeConfigEtcdSnapshotRestore;
    /**
     * Cluster V2 local auth endpoint (list maxitems:1)
     *
     * @deprecated Use rancher2_cluster_v2.local_auth_endpoint instead
     */
    localAuthEndpoint?: outputs.ClusterV2RkeConfigLocalAuthEndpoint;
    /**
     * Cluster V2 machine global config. Must be in YAML format (string)
     */
    machineGlobalConfig?: string;
    /**
     * Cluster V2 machine pools (list)
     */
    machinePools: outputs.ClusterV2RkeConfigMachinePool[];
    /**
     * Cluster V2 machine selector config (list)
     */
    machineSelectorConfigs: outputs.ClusterV2RkeConfigMachineSelectorConfig[];
    /**
     * Cluster V2 docker registries (list maxitems:1)
     */
    registries?: outputs.ClusterV2RkeConfigRegistries;
    /**
     * Cluster V2 certificate rotation (list maxitems:1)
     */
    rotateCertificates?: outputs.ClusterV2RkeConfigRotateCertificates;
    /**
     * Cluster V2 upgrade strategy (list maxitems:1)
     */
    upgradeStrategy?: outputs.ClusterV2RkeConfigUpgradeStrategy;
}

export interface ClusterV2RkeConfigEtcd {
    /**
     * Disable ETCD snapshots. Default: `false` (bool)
     */
    disableSnapshots?: boolean;
    /**
     * Creation option for etcd service (list maxitems:1)
     */
    s3Config?: outputs.ClusterV2RkeConfigEtcdS3Config;
    /**
     * ETCD snapshot retention (int)
     */
    snapshotRetention?: number;
    /**
     * ETCD snapshot schedule cron (e.g `\"0 *&#47;5 * * *\"`) (string)
     */
    snapshotScheduleCron?: string;
}

export interface ClusterV2RkeConfigEtcdS3Config {
    /**
     * Bucket name for S3 service (string)
     */
    bucket: string;
    /**
     * ETCD snapshot S3 cloud credential name (string)
     */
    cloudCredentialName?: string;
    /**
     * ETCD snapshot S3 endpoint (string)
     */
    endpoint: string;
    /**
     * ETCD snapshot S3 endpoint CA (string)
     */
    endpointCa?: string;
    /**
     * ETCD snapshot S3 folder (string)
     */
    folder?: string;
    /**
     * ETCD snapshot S3 region (string)
     */
    region?: string;
    /**
     * Disable ETCD skip ssl verify. Default: `false` (bool)
     */
    skipSslVerify?: boolean;
}

export interface ClusterV2RkeConfigEtcdSnapshotCreate {
    /**
     * Desired certificate rotation generation (int)
     */
    generation: number;
}

export interface ClusterV2RkeConfigEtcdSnapshotRestore {
    /**
     * Desired certificate rotation generation (int)
     */
    generation: number;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    /**
     * ETCD restore RKE config (set to none, all, or kubernetesVersion) (string)
     */
    restoreRkeConfig?: string;
}

export interface ClusterV2RkeConfigLocalAuthEndpoint {
    /**
     * CA certs for the authorized cluster endpoint (string)
     */
    caCerts?: string;
    /**
     * Enable the authorized cluster endpoint. Default `false` (bool)
     */
    enabled?: boolean;
    /**
     * FQDN for the authorized cluster endpoint (string)
     */
    fqdn?: string;
}

export interface ClusterV2RkeConfigMachinePool {
    /**
     * Annotations for the Cluster V2 (map)
     */
    annotations: {[key: string]: any};
    /**
     * Cluster V2 cloud credential secret name (string)
     */
    cloudCredentialSecretName?: string;
    /**
     * Machine pool control plane role? (bool)
     */
    controlPlaneRole?: boolean;
    /**
     * Machine Pool Drain Before Delete? (bool)
     */
    drainBeforeDelete?: boolean;
    /**
     * Machine pool etcd role? (bool)
     */
    etcdRole?: boolean;
    /**
     * Labels for the Cluster V2 (map)
     */
    labels: {[key: string]: any};
    /**
     * Machine pool node config (list)
     */
    machineConfig: outputs.ClusterV2RkeConfigMachinePoolMachineConfig;
    /**
     * Labels for Machine pool nodes (map)
     */
    machineLabels: {[key: string]: any};
    /**
     * Max unhealthy nodes for automated replacement to be allowed (string)
     */
    maxUnhealthy?: string;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    /**
     * Seconds a machine has to drain before deletion (int)
     */
    nodeDrainTimeout?: number;
    /**
     * Seconds a new node has to become active before it is replaced (int)
     */
    nodeStartupTimeoutSeconds?: number;
    /**
     * Machine pool paused? (bool)
     */
    paused?: boolean;
    /**
     * Machine pool quantity (int)
     */
    quantity?: number;
    /**
     * Machine pool rolling update (List maxitems:1)
     */
    rollingUpdate?: outputs.ClusterV2RkeConfigMachinePoolRollingUpdate;
    /**
     * Machine pool taints (list)
     */
    taints?: outputs.ClusterV2RkeConfigMachinePoolTaint[];
    /**
     * Seconds an unhealthy node has to become active before it is replaced (int)
     */
    unhealthyNodeTimeoutSeconds?: number;
    /**
     * Range of unhealthy nodes for automated replacement to be allowed (string)
     */
    unhealthyRange?: string;
    /**
     * Machine pool worker role? (bool)
     */
    workerRole?: boolean;
}

export interface ClusterV2RkeConfigMachinePoolMachineConfig {
    /**
     * Machine config kind (string)
     */
    kind: string;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
}

export interface ClusterV2RkeConfigMachinePoolRollingUpdate {
    /**
     * Rolling update max surge (string)
     */
    maxSurge?: string;
    /**
     * Rolling update max unavailable (string)
     */
    maxUnavailable?: string;
}

export interface ClusterV2RkeConfigMachinePoolTaint {
    /**
     * The taint effect. Default: `\"NoExecute\"` (string)
     */
    effect?: string;
    /**
     * The taint key (string)
     */
    key: string;
    /**
     * Rancher agent env var value (string)
     */
    value: string;
}

export interface ClusterV2RkeConfigMachineSelectorConfig {
    /**
     * Machine selector config (map)
     */
    config?: {[key: string]: any};
    /**
     * Machine selector label (list maxitems:1)
     */
    machineLabelSelector?: outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector;
}

export interface ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector {
    /**
     * Machine selector label match expressions (list)
     */
    matchExpressions?: outputs.ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression[];
    /**
     * Machine selector label match labels (map)
     */
    matchLabels?: {[key: string]: any};
}

export interface ClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression {
    /**
     * The taint key (string)
     */
    key?: string;
    /**
     * Machine selector label match expressions operator (string)
     */
    operator?: string;
    /**
     * Machine selector label match expressions values (List string)
     */
    values?: string[];
}

export interface ClusterV2RkeConfigRegistries {
    /**
     * Cluster V2 docker registries config (list)
     */
    configs?: outputs.ClusterV2RkeConfigRegistriesConfig[];
    /**
     * Cluster V2 docker registries mirror (list)
     */
    mirrors?: outputs.ClusterV2RkeConfigRegistriesMirror[];
}

export interface ClusterV2RkeConfigRegistriesConfig {
    /**
     * Registry auth config secret name (string)
     */
    authConfigSecretName?: string;
    /**
     * Registry CA bundle (string)
     */
    caBundle?: string;
    /**
     * Registry hostname (string)
     */
    hostname: string;
    /**
     * Registry insecure connectivity (bool)
     */
    insecure?: boolean;
    /**
     * Registry TLS secret name. TLS is a pair of Cert/Key (string)
     */
    tlsSecretName?: string;
}

export interface ClusterV2RkeConfigRegistriesMirror {
    /**
     * Registry mirror endpoints (List)
     */
    endpoints?: string[];
    /**
     * Registry hostname (string)
     */
    hostname: string;
    /**
     * Registry mirror rewrites (map)
     */
    rewrites?: {[key: string]: any};
}

export interface ClusterV2RkeConfigRotateCertificates {
    /**
     * Desired certificate rotation generation (int)
     */
    generation: number;
    /**
     * Service certificates to rotate with this generation (string)
     */
    services?: string[];
}

export interface ClusterV2RkeConfigUpgradeStrategy {
    /**
     * How many controlplane nodes should be upgrade at time, 0 is infinite. Percentages are also accepted (string)
     */
    controlPlaneConcurrency?: string;
    /**
     * Controlplane nodes drain options (list maxitems:1)
     */
    controlPlaneDrainOptions?: outputs.ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions;
    /**
     * How many worker nodes should be upgrade at time. Percentages are also accepted (string)
     */
    workerConcurrency?: string;
    /**
     * Worker nodes drain options (list maxitems:1)
     */
    workerDrainOptions?: outputs.ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions;
}

export interface ClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions {
    /**
     * Drain options delete empty dir data. Default `false` (bool)
     */
    deleteEmptyDirData?: boolean;
    /**
     * Drain options disable eviction. Default `false` (bool)
     */
    disableEviction?: boolean;
    /**
     * Enable the authorized cluster endpoint. Default `false` (bool)
     */
    enabled?: boolean;
    /**
     * Drain options force. Default `false` (bool)
     */
    force?: boolean;
    /**
     * Drain options grace period (int)
     */
    gracePeriod: number;
    /**
     * Drain options ignore daemon sets. Default `true` (bool)
     */
    ignoreDaemonSets?: boolean;
    /**
     * Drain options ignore errors. Default `false` (bool)
     */
    ignoreErrors?: boolean;
    /**
     * Drain options skip wait for delete timeout seconds (int)
     */
    skipWaitForDeleteTimeoutSeconds: number;
    /**
     * Drain options timeout (int)
     */
    timeout: number;
}

export interface ClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions {
    /**
     * Drain options delete empty dir data. Default `false` (bool)
     */
    deleteEmptyDirData?: boolean;
    /**
     * Drain options disable eviction. Default `false` (bool)
     */
    disableEviction?: boolean;
    /**
     * Enable the authorized cluster endpoint. Default `false` (bool)
     */
    enabled?: boolean;
    /**
     * Drain options force. Default `false` (bool)
     */
    force?: boolean;
    /**
     * Drain options grace period (int)
     */
    gracePeriod: number;
    /**
     * Drain options ignore daemon sets. Default `true` (bool)
     */
    ignoreDaemonSets?: boolean;
    /**
     * Drain options ignore errors. Default `false` (bool)
     */
    ignoreErrors?: boolean;
    /**
     * Drain options skip wait for delete timeout seconds (int)
     */
    skipWaitForDeleteTimeoutSeconds: number;
    /**
     * Drain options timeout (int)
     */
    timeout: number;
}

export interface EtcdBackupBackupConfig {
    /**
     * Enable etcd backup (bool)
     */
    enabled?: boolean;
    /**
     * Interval hours for etcd backup. Default `12` (int)
     */
    intervalHours?: number;
    /**
     * Retention for etcd backup. Default `6` (int)
     */
    retention?: number;
    /**
     * S3 config options for etcd backup. Valid for `imported` and `rke` clusters. (list maxitems:1)
     */
    s3BackupConfig?: outputs.EtcdBackupBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface EtcdBackupBackupConfigS3BackupConfig {
    /**
     * Access key for S3 service (string)
     */
    accessKey?: string;
    /**
     * Bucket name for S3 service (string)
     */
    bucketName: string;
    /**
     * Base64 encoded custom CA for S3 service. Use filebase64(<FILE>) for encoding file. Available from Rancher v2.2.5 (string)
     */
    customCa?: string;
    /**
     * Endpoint for S3 service (string)
     */
    endpoint: string;
    /**
     * Folder for S3 service. Available from Rancher v2.2.7 (string)
     */
    folder?: string;
    /**
     * Region for S3 service (string)
     */
    region?: string;
    /**
     * Secret key for S3 service (string)
     */
    secretKey?: string;
}

export interface GetClusterAksConfig {
    aadServerAppSecret?: string;
    aadTenantId?: string;
    addClientAppId?: string;
    addServerAppId?: string;
    adminUsername?: string;
    agentDnsPrefix: string;
    agentOsDiskSize?: number;
    agentPoolName?: string;
    agentStorageProfile?: string;
    agentVmSize?: string;
    authBaseUrl?: string;
    baseUrl?: string;
    clientId: string;
    clientSecret: string;
    count?: number;
    dnsServiceIp?: string;
    dockerBridgeCidr?: string;
    enableHttpApplicationRouting?: boolean;
    enableMonitoring?: boolean;
    kubernetesVersion: string;
    loadBalancerSku: string;
    location?: string;
    logAnalyticsWorkspace?: string;
    logAnalyticsWorkspaceResourceGroup?: string;
    masterDnsPrefix: string;
    maxPods?: number;
    networkPlugin?: string;
    networkPolicy?: string;
    podCidr?: string;
    resourceGroup: string;
    serviceCidr?: string;
    sshPublicKeyContents: string;
    subnet: string;
    subscriptionId: string;
    /**
     * @deprecated Use tags argument instead as []string
     */
    tag: {[key: string]: any};
    tags: string[];
    tenantId: string;
    virtualNetwork: string;
    virtualNetworkResourceGroup: string;
}

export interface GetClusterAksConfigV2 {
    authBaseUrl?: string;
    authorizedIpRanges?: string[];
    baseUrl?: string;
    cloudCredentialId: string;
    dnsPrefix?: string;
    httpApplicationRouting: boolean;
    imported?: boolean;
    kubernetesVersion?: string;
    linuxAdminUsername: string;
    linuxSshPublicKey: string;
    loadBalancerSku: string;
    logAnalyticsWorkspaceGroup: string;
    logAnalyticsWorkspaceName: string;
    monitoring: boolean;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    networkDnsServiceIp: string;
    networkDockerBridgeCidr: string;
    networkPlugin?: string;
    networkPodCidr: string;
    networkPolicy: string;
    networkServiceCidr: string;
    nodePools?: outputs.GetClusterAksConfigV2NodePool[];
    privateCluster: boolean;
    resourceGroup: string;
    resourceLocation: string;
    subnet: string;
    tags: {[key: string]: any};
    virtualNetwork: string;
    virtualNetworkResourceGroup: string;
}

export interface GetClusterAksConfigV2NodePool {
    availabilityZones?: string[];
    count?: number;
    enableAutoScaling?: boolean;
    maxCount?: number;
    maxPods?: number;
    minCount?: number;
    mode?: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    orchestratorVersion?: string;
    osDiskSizeGb?: number;
    osDiskType?: string;
    osType?: string;
    vmSize: string;
}

export interface GetClusterAlertGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface GetClusterAlterRuleEventRule {
    eventType?: string;
    resourceKind: string;
}

export interface GetClusterAlterRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface GetClusterAlterRuleNodeRule {
    condition?: string;
    cpuThreshold?: number;
    memThreshold?: number;
    nodeId?: string;
    selector?: {[key: string]: any};
}

export interface GetClusterAlterRuleSystemServiceRule {
    condition?: string;
}

export interface GetClusterClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface GetClusterClusterMonitoringInput {
    answers?: {[key: string]: any};
    version?: string;
}

export interface GetClusterClusterRegistrationToken {
    /**
     * (Computed) Annotations for Node Pool object (map)
     */
    annotations: {[key: string]: any};
    clusterId: string;
    command: string;
    /**
     * (Computed) The ID of the resource (string)
     */
    id: string;
    insecureCommand: string;
    insecureNodeCommand: string;
    insecureWindowsNodeCommand: string;
    /**
     * (Computed) Labels for Node Pool object (map)
     */
    labels: {[key: string]: any};
    manifestUrl: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface GetClusterClusterTemplateAnswers {
    clusterId: string;
    projectId: string;
    values: {[key: string]: any};
}

export interface GetClusterClusterTemplateQuestion {
    default: string;
    required?: boolean;
    type?: string;
    variable: string;
}

export interface GetClusterEksConfig {
    accessKey: string;
    ami?: string;
    associateWorkerNodePublicIp?: boolean;
    desiredNodes?: number;
    ebsEncryption?: boolean;
    instanceType?: string;
    keyPairName?: string;
    kubernetesVersion: string;
    maximumNodes?: number;
    minimumNodes?: number;
    nodeVolumeSize?: number;
    region?: string;
    secretKey: string;
    securityGroups?: string[];
    serviceRole?: string;
    sessionToken?: string;
    subnets?: string[];
    userData: string;
    virtualNetwork?: string;
}

export interface GetClusterEksConfigV2 {
    cloudCredentialId: string;
    imported?: boolean;
    kmsKey?: string;
    kubernetesVersion: string;
    loggingTypes?: string[];
    /**
     * The name of the Cluster (string)
     */
    name: string;
    nodeGroups: outputs.GetClusterEksConfigV2NodeGroup[];
    privateAccess: boolean;
    publicAccess: boolean;
    publicAccessSources: string[];
    region?: string;
    secretsEncryption: boolean;
    securityGroups?: string[];
    serviceRole?: string;
    subnets?: string[];
    tags?: {[key: string]: any};
}

export interface GetClusterEksConfigV2NodeGroup {
    desiredSize?: number;
    diskSize?: number;
    ec2SshKey?: string;
    gpu?: boolean;
    imageId?: string;
    instanceType?: string;
    /**
     * (Computed) Labels for Node Pool object (map)
     */
    labels?: {[key: string]: any};
    launchTemplates?: outputs.GetClusterEksConfigV2NodeGroupLaunchTemplate[];
    maxSize?: number;
    minSize?: number;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    nodeRole?: string;
    requestSpotInstances?: boolean;
    resourceTags?: {[key: string]: any};
    spotInstanceTypes?: string[];
    subnets: string[];
    tags?: {[key: string]: any};
    userData: string;
    version: string;
}

export interface GetClusterEksConfigV2NodeGroupLaunchTemplate {
    /**
     * (Computed) The ID of the resource (string)
     */
    id: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    version?: number;
}

export interface GetClusterGkeConfig {
    clusterIpv4Cidr: string;
    credential: string;
    /**
     * (Computed) The description for Cluster (string)
     */
    description?: string;
    diskSizeGb?: number;
    diskType: string;
    enableAlphaFeature?: boolean;
    enableAutoRepair?: boolean;
    enableAutoUpgrade?: boolean;
    enableHorizontalPodAutoscaling?: boolean;
    enableHttpLoadBalancing?: boolean;
    enableKubernetesDashboard?: boolean;
    enableLegacyAbac?: boolean;
    enableMasterAuthorizedNetwork?: boolean;
    enableNetworkPolicyConfig?: boolean;
    enableNodepoolAutoscaling?: boolean;
    enablePrivateEndpoint?: boolean;
    enablePrivateNodes?: boolean;
    enableStackdriverLogging?: boolean;
    enableStackdriverMonitoring?: boolean;
    imageType: string;
    ipPolicyClusterIpv4CidrBlock: string;
    ipPolicyClusterSecondaryRangeName: string;
    ipPolicyCreateSubnetwork?: boolean;
    ipPolicyNodeIpv4CidrBlock: string;
    ipPolicyServicesIpv4CidrBlock: string;
    ipPolicyServicesSecondaryRangeName: string;
    ipPolicySubnetworkName: string;
    issueClientCertificate?: boolean;
    kubernetesDashboard?: boolean;
    /**
     * (Computed) Labels for Node Pool object (map)
     */
    labels: {[key: string]: any};
    localSsdCount?: number;
    locations: string[];
    machineType: string;
    maintenanceWindow: string;
    masterAuthorizedNetworkCidrBlocks?: string[];
    masterIpv4CidrBlock: string;
    masterVersion: string;
    maxNodeCount?: number;
    minNodeCount?: number;
    network: string;
    nodeCount?: number;
    nodePool: string;
    nodeVersion: string;
    oauthScopes: string[];
    preemptible?: boolean;
    projectId: string;
    region?: string;
    resourceLabels: {[key: string]: any};
    serviceAccount: string;
    subNetwork: string;
    taints?: string[];
    useIpAliases?: boolean;
    zone?: string;
}

export interface GetClusterGkeConfigV2 {
    clusterAddons: outputs.GetClusterGkeConfigV2ClusterAddons;
    clusterIpv4CidrBlock: string;
    /**
     * (Computed) The description for Cluster (string)
     */
    description: string;
    enableKubernetesAlpha: boolean;
    googleCredentialSecret: string;
    imported?: boolean;
    ipAllocationPolicy: outputs.GetClusterGkeConfigV2IpAllocationPolicy;
    kubernetesVersion: string;
    /**
     * (Computed) Labels for Node Pool object (map)
     */
    labels: {[key: string]: any};
    locations: string[];
    loggingService: string;
    maintenanceWindow: string;
    masterAuthorizedNetworksConfig: outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfig;
    monitoringService: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    network: string;
    networkPolicyEnabled: boolean;
    nodePools: outputs.GetClusterGkeConfigV2NodePool[];
    privateClusterConfig: outputs.GetClusterGkeConfigV2PrivateClusterConfig;
    projectId: string;
    region: string;
    subnetwork: string;
    zone: string;
}

export interface GetClusterGkeConfigV2ClusterAddons {
    horizontalPodAutoscaling: boolean;
    httpLoadBalancing: boolean;
    networkPolicyConfig: boolean;
}

export interface GetClusterGkeConfigV2IpAllocationPolicy {
    clusterIpv4CidrBlock: string;
    clusterSecondaryRangeName: string;
    createSubnetwork: boolean;
    nodeIpv4CidrBlock: string;
    servicesIpv4CidrBlock: string;
    servicesSecondaryRangeName: string;
    subnetworkName: string;
    useIpAliases: boolean;
}

export interface GetClusterGkeConfigV2MasterAuthorizedNetworksConfig {
    cidrBlocks: outputs.GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock[];
    enabled?: boolean;
}

export interface GetClusterGkeConfigV2MasterAuthorizedNetworksConfigCidrBlock {
    cidrBlock: string;
    displayName?: string;
}

export interface GetClusterGkeConfigV2NodePool {
    autoscaling: outputs.GetClusterGkeConfigV2NodePoolAutoscaling;
    config: outputs.GetClusterGkeConfigV2NodePoolConfig;
    initialNodeCount: number;
    management: outputs.GetClusterGkeConfigV2NodePoolManagement;
    maxPodsConstraint: number;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    version: string;
}

export interface GetClusterGkeConfigV2NodePoolAutoscaling {
    enabled?: boolean;
    maxNodeCount: number;
    minNodeCount: number;
}

export interface GetClusterGkeConfigV2NodePoolConfig {
    diskSizeGb?: number;
    diskType?: string;
    imageType?: string;
    /**
     * (Computed) Labels for Node Pool object (map)
     */
    labels: {[key: string]: any};
    localSsdCount?: number;
    machineType?: string;
    oauthScopes: string[];
    preemptible?: boolean;
    tags: string[];
    taints?: outputs.GetClusterGkeConfigV2NodePoolConfigTaint[];
}

export interface GetClusterGkeConfigV2NodePoolConfigTaint {
    effect: string;
    key: string;
    value: string;
}

export interface GetClusterGkeConfigV2NodePoolManagement {
    autoRepair: boolean;
    autoUpgrade: boolean;
}

export interface GetClusterGkeConfigV2PrivateClusterConfig {
    enablePrivateEndpoint?: boolean;
    enablePrivateNodes?: boolean;
    masterIpv4CidrBlock: string;
}

export interface GetClusterK3sConfig {
    upgradeStrategy: outputs.GetClusterK3sConfigUpgradeStrategy;
    version: string;
}

export interface GetClusterK3sConfigUpgradeStrategy {
    drainServerNodes?: boolean;
    drainWorkerNodes?: boolean;
    serverConcurrency?: number;
    workerConcurrency?: number;
}

export interface GetClusterOkeConfig {
    compartmentId: string;
    customBootVolumeSize?: number;
    /**
     * (Computed) The description for Cluster (string)
     */
    description?: string;
    enableKubernetesDashboard?: boolean;
    enablePrivateControlPlane?: boolean;
    enablePrivateNodes?: boolean;
    fingerprint: string;
    flexOcpus?: number;
    kmsKeyId?: string;
    kubernetesVersion: string;
    limitNodeCount?: number;
    loadBalancerSubnetName1?: string;
    loadBalancerSubnetName2?: string;
    nodeImage: string;
    nodePoolDnsDomainName?: string;
    nodePoolSubnetName?: string;
    nodePublicKeyContents?: string;
    nodeShape: string;
    podCidr?: string;
    privateKeyContents: string;
    privateKeyPassphrase?: string;
    quantityOfNodeSubnets?: number;
    quantityPerSubnet?: number;
    region: string;
    serviceCidr?: string;
    serviceDnsDomainName?: string;
    skipVcnDelete?: boolean;
    tenancyId: string;
    userOcid: string;
    vcnCompartmentId?: string;
    vcnName?: string;
    workerNodeIngressCidr?: string;
}

export interface GetClusterRke2Config {
    upgradeStrategy: outputs.GetClusterRke2ConfigUpgradeStrategy;
    version: string;
}

export interface GetClusterRke2ConfigUpgradeStrategy {
    drainServerNodes?: boolean;
    drainWorkerNodes?: boolean;
    serverConcurrency?: number;
    workerConcurrency?: number;
}

export interface GetClusterRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.GetClusterRkeConfigAuthentication;
    authorization: outputs.GetClusterRkeConfigAuthorization;
    bastionHost: outputs.GetClusterRkeConfigBastionHost;
    cloudProvider: outputs.GetClusterRkeConfigCloudProvider;
    dns: outputs.GetClusterRkeConfigDns;
    enableCriDockerd?: boolean;
    ignoreDockerVersion?: boolean;
    ingress: outputs.GetClusterRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.GetClusterRkeConfigMonitoring;
    network: outputs.GetClusterRkeConfigNetwork;
    nodes?: outputs.GetClusterRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.GetClusterRkeConfigPrivateRegistry[];
    services: outputs.GetClusterRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.GetClusterRkeConfigUpgradeStrategy;
    winPrefixPath: string;
}

export interface GetClusterRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface GetClusterRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface GetClusterRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterRkeConfigCloudProvider {
    awsCloudProvider?: outputs.GetClusterRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.GetClusterRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    /**
     * The name of the Cluster (string)
     */
    name?: string;
    openstackCloudProvider?: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProvider;
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface GetClusterRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    /**
     * The name of the Cluster (string)
     */
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface GetClusterRkeConfigDns {
    linearAutoscalerParams?: outputs.GetClusterRkeConfigDnsLinearAutoscalerParams;
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.GetClusterRkeConfigDnsNodelocal;
    options: {[key: string]: any};
    provider?: string;
    reverseCidrs: string[];
    tolerations?: outputs.GetClusterRkeConfigDnsToleration[];
    updateStrategy?: outputs.GetClusterRkeConfigDnsUpdateStrategy;
    upstreamNameservers: string[];
}

export interface GetClusterRkeConfigDnsLinearAutoscalerParams {
    coresPerReplica?: number;
    max?: number;
    min?: number;
    nodesPerReplica?: number;
    preventSinglePointFailure?: boolean;
}

export interface GetClusterRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface GetClusterRkeConfigDnsToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterRkeConfigDnsUpdateStrategy {
    rollingUpdate?: outputs.GetClusterRkeConfigDnsUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterRkeConfigDnsUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface GetClusterRkeConfigIngress {
    defaultBackend?: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    tolerations?: outputs.GetClusterRkeConfigIngressToleration[];
    updateStrategy?: outputs.GetClusterRkeConfigIngressUpdateStrategy;
}

export interface GetClusterRkeConfigIngressToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterRkeConfigIngressUpdateStrategy {
    rollingUpdate?: outputs.GetClusterRkeConfigIngressUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterRkeConfigIngressUpdateStrategyRollingUpdate {
    maxUnavailable?: number;
}

export interface GetClusterRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    tolerations?: outputs.GetClusterRkeConfigMonitoringToleration[];
    updateStrategy?: outputs.GetClusterRkeConfigMonitoringUpdateStrategy;
}

export interface GetClusterRkeConfigMonitoringToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface GetClusterRkeConfigNetwork {
    aciNetworkProvider?: outputs.GetClusterRkeConfigNetworkAciNetworkProvider;
    calicoNetworkProvider?: outputs.GetClusterRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.GetClusterRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.GetClusterRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    tolerations?: outputs.GetClusterRkeConfigNetworkToleration[];
    weaveNetworkProvider?: outputs.GetClusterRkeConfigNetworkWeaveNetworkProvider;
}

export interface GetClusterRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust?: string;
    apicRefreshTime?: string;
    apicSubscriptionDelay?: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic?: string;
    controllerLogLevel?: string;
    disablePeriodicSnatGlobalInfoSync?: string;
    disableWaitForNetwork?: string;
    dropLogEnable?: string;
    durationWaitForNetwork?: string;
    enableEndpointSlice?: string;
    encapType: string;
    epRegistry?: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet?: string;
    hostAgentLogLevel?: string;
    imagePullPolicy?: string;
    imagePullSecret?: string;
    infraVlan?: string;
    installIstio?: string;
    istioProfile?: string;
    kafkaBrokers?: string[];
    kafkaClientCrt?: string;
    kafkaClientKey?: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph?: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom?: string;
    multusDisable?: string;
    noPriorityClass?: string;
    nodePodIfEnable?: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl?: string;
    opflexDeviceDeleteTimeout?: string;
    opflexLogLevel?: string;
    opflexMode?: string;
    opflexServerPort?: string;
    overlayVrfName?: string;
    ovsMemoryLimit?: string;
    pbrTrackingNonSnat?: string;
    podSubnetChunkSize?: string;
    runGbpContainer?: string;
    runOpflexServerContainer?: string;
    serviceMonitorInterval?: string;
    serviceVlan: string;
    snatContractScope?: string;
    snatNamespace?: string;
    snatPortRangeEnd?: string;
    snatPortRangeStart?: string;
    snatPortsPerNode?: string;
    sriovEnable?: string;
    subnetDomainName?: string;
    systemId: string;
    tenant?: string;
    token: string;
    useAciAnywhereCrd?: string;
    useAciCniPriorityClass?: string;
    useClusterRole?: string;
    useHostNetnsVolume?: string;
    useOpflexServerVolume?: string;
    usePrivilegedContainer?: string;
    vmmController?: string;
    vmmDomain?: string;
    vrfName: string;
    vrfTenant: string;
}

export interface GetClusterRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface GetClusterRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface GetClusterRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface GetClusterRkeConfigNetworkToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface GetClusterRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    /**
     * (Computed) Labels for Node Pool object (map)
     */
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterRkeConfigPrivateRegistry {
    ecrCredentialPlugin?: outputs.GetClusterRkeConfigPrivateRegistryEcrCredentialPlugin;
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface GetClusterRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    awsSessionToken?: string;
}

export interface GetClusterRkeConfigServices {
    etcd: outputs.GetClusterRkeConfigServicesEtcd;
    kubeApi: outputs.GetClusterRkeConfigServicesKubeApi;
    kubeController: outputs.GetClusterRkeConfigServicesKubeController;
    kubelet: outputs.GetClusterRkeConfigServicesKubelet;
    kubeproxy: outputs.GetClusterRkeConfigServicesKubeproxy;
    scheduler: outputs.GetClusterRkeConfigServicesScheduler;
}

export interface GetClusterRkeConfigServicesEtcd {
    backupConfig: outputs.GetClusterRkeConfigServicesEtcdBackupConfig;
    /**
     * (Computed) K8s cluster ca cert (string)
     */
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface GetClusterRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetClusterRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.GetClusterRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.GetClusterRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface GetClusterRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.GetClusterRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface GetClusterRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface GetClusterRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig: string;
    enabled?: boolean;
}

export interface GetClusterRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface GetClusterRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface GetClusterRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.GetClusterRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface GetClusterRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface GetClusterTemplateMember {
    accessType?: string;
    groupPrincipalId?: string;
    userPrincipalId?: string;
}

export interface GetClusterTemplateTemplateRevision {
    /**
     * (Computed) Annotations for the cluster template (map)
     */
    annotations: {[key: string]: any};
    clusterConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfig;
    clusterTemplateId: string;
    default?: boolean;
    enabled?: boolean;
    /**
     * (Computed) The ID of the resource (string)
     */
    id: string;
    /**
     * (Computed) Labels for the cluster template (map)
     */
    labels: {[key: string]: any};
    /**
     * The cluster template name (string)
     */
    name: string;
    questions?: outputs.GetClusterTemplateTemplateRevisionQuestion[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfig {
    clusterAuthEndpoint: outputs.GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint;
    defaultClusterRoleForProjectMembers: string;
    defaultPodSecurityPolicyTemplateId: string;
    desiredAgentImage: string;
    desiredAuthImage: string;
    dockerRootDir: string;
    enableClusterAlerting?: boolean;
    enableClusterMonitoring?: boolean;
    enableNetworkPolicy?: boolean;
    rkeConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfig;
    windowsPreferedCluster?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication;
    authorization: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization;
    bastionHost: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost;
    cloudProvider: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider;
    dns: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDns;
    enableCriDockerd?: boolean;
    ignoreDockerVersion?: boolean;
    ingress: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring;
    network: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork;
    nodes?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry[];
    services: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy;
    winPrefixPath: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    /**
     * The cluster template name (string)
     */
    name?: string;
    openstackCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    /**
     * The cluster template name (string)
     */
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDns {
    linearAutoscalerParams?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams;
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal;
    options: {[key: string]: any};
    provider?: string;
    reverseCidrs: string[];
    tolerations?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration[];
    updateStrategy?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy;
    upstreamNameservers: string[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsLinearAutoscalerParams {
    coresPerReplica?: number;
    max?: number;
    min?: number;
    nodesPerReplica?: number;
    preventSinglePointFailure?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategy {
    rollingUpdate?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    defaultBackend?: boolean;
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    httpPort: number;
    httpsPort: number;
    networkMode: string;
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    tolerations?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration[];
    updateStrategy?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategy {
    rollingUpdate?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngressUpdateStrategyRollingUpdate {
    maxUnavailable?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    tolerations?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration[];
    updateStrategy?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    aciNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider;
    calicoNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    tolerations?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration[];
    weaveNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkAciNetworkProvider {
    aep: string;
    apicHosts: string[];
    apicRefreshTickerAdjust?: string;
    apicRefreshTime?: string;
    apicSubscriptionDelay?: string;
    apicUserCrt: string;
    apicUserKey: string;
    apicUserName: string;
    capic?: string;
    controllerLogLevel?: string;
    disablePeriodicSnatGlobalInfoSync?: string;
    disableWaitForNetwork?: string;
    dropLogEnable?: string;
    durationWaitForNetwork?: string;
    enableEndpointSlice?: string;
    encapType: string;
    epRegistry?: string;
    externDynamic: string;
    externStatic: string;
    gbpPodSubnet?: string;
    hostAgentLogLevel?: string;
    imagePullPolicy?: string;
    imagePullSecret?: string;
    infraVlan?: string;
    installIstio?: string;
    istioProfile?: string;
    kafkaBrokers?: string[];
    kafkaClientCrt?: string;
    kafkaClientKey?: string;
    kubeApiVlan: string;
    l3out: string;
    l3outExternalNetworks: string[];
    maxNodesSvcGraph?: string;
    mcastRangeEnd: string;
    mcastRangeStart: string;
    mtuHeadRoom?: string;
    multusDisable?: string;
    noPriorityClass?: string;
    nodePodIfEnable?: string;
    nodeSubnet: string;
    nodeSvcSubnet: string;
    opflexClientSsl?: string;
    opflexDeviceDeleteTimeout?: string;
    opflexLogLevel?: string;
    opflexMode?: string;
    opflexServerPort?: string;
    overlayVrfName?: string;
    ovsMemoryLimit?: string;
    pbrTrackingNonSnat?: string;
    podSubnetChunkSize?: string;
    runGbpContainer?: string;
    runOpflexServerContainer?: string;
    serviceMonitorInterval?: string;
    serviceVlan: string;
    snatContractScope?: string;
    snatNamespace?: string;
    snatPortRangeEnd?: string;
    snatPortRangeStart?: string;
    snatPortsPerNode?: string;
    sriovEnable?: string;
    subnetDomainName?: string;
    systemId: string;
    tenant?: string;
    token: string;
    useAciAnywhereCrd?: string;
    useAciCniPriorityClass?: string;
    useClusterRole?: string;
    useHostNetnsVolume?: string;
    useOpflexServerVolume?: string;
    usePrivilegedContainer?: string;
    vmmController?: string;
    vmmDomain?: string;
    vrfName: string;
    vrfTenant: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkToleration {
    effect?: string;
    key: string;
    operator?: string;
    seconds: number;
    value?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    /**
     * (Computed) Labels for the cluster template (map)
     */
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    ecrCredentialPlugin?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin;
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistryEcrCredentialPlugin {
    awsAccessKeyId?: string;
    awsSecretAccessKey?: string;
    awsSessionToken?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServices {
    etcd: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd;
    kubeApi: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi;
    kubeController: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController;
    kubelet: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet;
    kubeproxy: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy;
    scheduler: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd {
    backupConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig: string;
    enabled?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface GetClusterTemplateTemplateRevisionQuestion {
    default: string;
    required?: boolean;
    type?: string;
    variable: string;
}

export interface GetClusterV2AgentEnvVar {
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    value: string;
}

export interface GetClusterV2ClusterRegistrationToken {
    annotations: {[key: string]: any};
    clusterId: string;
    command: string;
    /**
     * (Computed) The ID of the resource (string)
     */
    id: string;
    insecureCommand: string;
    insecureNodeCommand: string;
    insecureWindowsNodeCommand: string;
    labels: {[key: string]: any};
    manifestUrl: string;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface GetClusterV2RkeConfig {
    additionalManifest?: string;
    chartValues?: string;
    etcd: outputs.GetClusterV2RkeConfigEtcd;
    etcdSnapshotCreate?: outputs.GetClusterV2RkeConfigEtcdSnapshotCreate;
    etcdSnapshotRestore?: outputs.GetClusterV2RkeConfigEtcdSnapshotRestore;
    /**
     * @deprecated Use rancher2_cluster_v2.local_auth_endpoint instead
     */
    localAuthEndpoint?: outputs.GetClusterV2RkeConfigLocalAuthEndpoint;
    machineGlobalConfig?: string;
    machinePools: outputs.GetClusterV2RkeConfigMachinePool[];
    machineSelectorConfigs: outputs.GetClusterV2RkeConfigMachineSelectorConfig[];
    registries?: outputs.GetClusterV2RkeConfigRegistries;
    rotateCertificates?: outputs.GetClusterV2RkeConfigRotateCertificates;
    upgradeStrategy?: outputs.GetClusterV2RkeConfigUpgradeStrategy;
}

export interface GetClusterV2RkeConfigEtcd {
    disableSnapshots?: boolean;
    s3Config?: outputs.GetClusterV2RkeConfigEtcdS3Config;
    snapshotRetention?: number;
    snapshotScheduleCron?: string;
}

export interface GetClusterV2RkeConfigEtcdS3Config {
    bucket: string;
    cloudCredentialName?: string;
    endpoint: string;
    endpointCa?: string;
    folder?: string;
    region?: string;
    skipSslVerify?: boolean;
}

export interface GetClusterV2RkeConfigEtcdSnapshotCreate {
    generation: number;
}

export interface GetClusterV2RkeConfigEtcdSnapshotRestore {
    generation: number;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    restoreRkeConfig?: string;
}

export interface GetClusterV2RkeConfigLocalAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface GetClusterV2RkeConfigMachinePool {
    annotations: {[key: string]: any};
    /**
     * (Computed) Cluster V2 cloud credential secret name (string)
     */
    cloudCredentialSecretName?: string;
    controlPlaneRole?: boolean;
    drainBeforeDelete?: boolean;
    etcdRole?: boolean;
    labels: {[key: string]: any};
    machineConfig: outputs.GetClusterV2RkeConfigMachinePoolMachineConfig;
    machineLabels: {[key: string]: any};
    maxUnhealthy?: string;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
    nodeDrainTimeout?: number;
    nodeStartupTimeoutSeconds?: number;
    paused?: boolean;
    quantity?: number;
    rollingUpdate?: outputs.GetClusterV2RkeConfigMachinePoolRollingUpdate;
    taints?: outputs.GetClusterV2RkeConfigMachinePoolTaint[];
    unhealthyNodeTimeoutSeconds?: number;
    unhealthyRange?: string;
    workerRole?: boolean;
}

export interface GetClusterV2RkeConfigMachinePoolMachineConfig {
    kind: string;
    /**
     * The name of the Cluster v2 (string)
     */
    name: string;
}

export interface GetClusterV2RkeConfigMachinePoolRollingUpdate {
    maxSurge?: string;
    maxUnavailable?: string;
}

export interface GetClusterV2RkeConfigMachinePoolTaint {
    effect?: string;
    key: string;
    value: string;
}

export interface GetClusterV2RkeConfigMachineSelectorConfig {
    config?: {[key: string]: any};
    machineLabelSelector?: outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector;
}

export interface GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelector {
    matchExpressions?: outputs.GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression[];
    matchLabels?: {[key: string]: any};
}

export interface GetClusterV2RkeConfigMachineSelectorConfigMachineLabelSelectorMatchExpression {
    key?: string;
    operator?: string;
    values?: string[];
}

export interface GetClusterV2RkeConfigRegistries {
    configs?: outputs.GetClusterV2RkeConfigRegistriesConfig[];
    mirrors?: outputs.GetClusterV2RkeConfigRegistriesMirror[];
}

export interface GetClusterV2RkeConfigRegistriesConfig {
    authConfigSecretName?: string;
    caBundle?: string;
    hostname: string;
    insecure?: boolean;
    tlsSecretName?: string;
}

export interface GetClusterV2RkeConfigRegistriesMirror {
    endpoints?: string[];
    hostname: string;
    rewrites?: {[key: string]: any};
}

export interface GetClusterV2RkeConfigRotateCertificates {
    generation: number;
    services?: string[];
}

export interface GetClusterV2RkeConfigUpgradeStrategy {
    controlPlaneConcurrency?: string;
    controlPlaneDrainOptions?: outputs.GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions;
    workerConcurrency?: string;
    workerDrainOptions?: outputs.GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions;
}

export interface GetClusterV2RkeConfigUpgradeStrategyControlPlaneDrainOptions {
    deleteEmptyDirData?: boolean;
    disableEviction?: boolean;
    enabled?: boolean;
    force?: boolean;
    gracePeriod: number;
    ignoreDaemonSets?: boolean;
    ignoreErrors?: boolean;
    skipWaitForDeleteTimeoutSeconds: number;
    timeout: number;
}

export interface GetClusterV2RkeConfigUpgradeStrategyWorkerDrainOptions {
    deleteEmptyDirData?: boolean;
    disableEviction?: boolean;
    enabled?: boolean;
    force?: boolean;
    gracePeriod: number;
    ignoreDaemonSets?: boolean;
    ignoreErrors?: boolean;
    skipWaitForDeleteTimeoutSeconds: number;
    timeout: number;
}

export interface GetEtcdBackupBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.GetEtcdBackupBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
    timeout: number;
}

export interface GetEtcdBackupBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetGlobalDnsProviderAlidnsConfig {
    accessKey: string;
    secretKey: string;
}

export interface GetGlobalDnsProviderCloudflareConfig {
    apiEmail: string;
    apiKey: string;
    proxySetting?: boolean;
}

export interface GetGlobalDnsProviderRoute53Config {
    accessKey: string;
    credentialsPath?: string;
    region?: string;
    roleArn?: string;
    secretKey: string;
    zoneType?: string;
}

export interface GetGlobalRoleRule {
    apiGroups?: string[];
    nonResourceUrls?: string[];
    resourceNames?: string[];
    resources?: string[];
    verbs?: string[];
}

export interface GetMultiClusterAppAnswer {
    clusterId: string;
    projectId: string;
    values: {[key: string]: any};
}

export interface GetMultiClusterAppMember {
    accessType?: string;
    groupPrincipalId?: string;
    userPrincipalId?: string;
}

export interface GetMultiClusterAppTarget {
    appId: string;
    healthState: string;
    projectId: string;
    state: string;
}

export interface GetMultiClusterAppUpgradeStrategy {
    rollingUpdate?: outputs.GetMultiClusterAppUpgradeStrategyRollingUpdate;
}

export interface GetMultiClusterAppUpgradeStrategyRollingUpdate {
    batchSize?: number;
    interval?: number;
}

export interface GetNamespaceContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface GetNamespaceResourceQuota {
    limit: outputs.GetNamespaceResourceQuotaLimit;
}

export interface GetNamespaceResourceQuotaLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface GetNodePoolNodeTaint {
    effect?: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface GetNodeTemplateNodeTaint {
    effect?: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface GetNotifierDingtalkConfig {
    proxyUrl?: string;
    secret?: string;
    url: string;
}

export interface GetNotifierMsteamsConfig {
    proxyUrl?: string;
    url: string;
}

export interface GetNotifierPagerdutyConfig {
    proxyUrl?: string;
    serviceKey: string;
}

export interface GetNotifierSlackConfig {
    defaultRecipient: string;
    proxyUrl?: string;
    url: string;
}

export interface GetNotifierSmtpConfig {
    defaultRecipient: string;
    host: string;
    password?: string;
    port: number;
    sender: string;
    tls?: boolean;
    username?: string;
}

export interface GetNotifierWebhookConfig {
    proxyUrl?: string;
    url: string;
}

export interface GetNotifierWechatConfig {
    agent: string;
    corp: string;
    defaultRecipient: string;
    proxyUrl?: string;
    recipientType?: string;
    secret: string;
}

export interface GetPodSecurityPolicyTemplateAllowedCsiDriver {
    /**
     * The name of the PodSecurityPolicyTemplate (string)
     */
    name: string;
}

export interface GetPodSecurityPolicyTemplateAllowedFlexVolume {
    driver: string;
}

export interface GetPodSecurityPolicyTemplateAllowedHostPath {
    pathPrefix: string;
    readOnly?: boolean;
}

export interface GetPodSecurityPolicyTemplateFsGroup {
    ranges: outputs.GetPodSecurityPolicyTemplateFsGroupRange[];
    rule?: string;
}

export interface GetPodSecurityPolicyTemplateFsGroupRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateHostPort {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRunAsGroup {
    ranges?: outputs.GetPodSecurityPolicyTemplateRunAsGroupRange[];
    rule: string;
}

export interface GetPodSecurityPolicyTemplateRunAsGroupRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRunAsUser {
    ranges?: outputs.GetPodSecurityPolicyTemplateRunAsUserRange[];
    rule: string;
}

export interface GetPodSecurityPolicyTemplateRunAsUserRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRuntimeClass {
    allowedRuntimeClassNames: string[];
    defaultRuntimeClassName?: string;
}

export interface GetPodSecurityPolicyTemplateSeLinux {
    rule: string;
    seLinuxOption?: outputs.GetPodSecurityPolicyTemplateSeLinuxSeLinuxOption;
}

export interface GetPodSecurityPolicyTemplateSeLinuxSeLinuxOption {
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}

export interface GetPodSecurityPolicyTemplateSupplementalGroup {
    ranges: outputs.GetPodSecurityPolicyTemplateSupplementalGroupRange[];
    rule?: string;
}

export interface GetPodSecurityPolicyTemplateSupplementalGroupRange {
    max: number;
    min: number;
}

export interface GetProjectAlertGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface GetProjectAlertRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface GetProjectAlertRulePodRule {
    condition?: string;
    podId: string;
    restartIntervalSeconds?: number;
    restartTimes?: number;
}

export interface GetProjectAlertRuleWorkloadRule {
    availablePercentage?: number;
    selector?: {[key: string]: any};
    workloadId?: string;
}

export interface GetProjectContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface GetProjectResourceQuota {
    namespaceDefaultLimit: outputs.GetProjectResourceQuotaNamespaceDefaultLimit;
    projectLimit: outputs.GetProjectResourceQuotaProjectLimit;
}

export interface GetProjectResourceQuotaNamespaceDefaultLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface GetProjectResourceQuotaProjectLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface GetRegistryRegistry {
    address: string;
    password?: string;
    username?: string;
}

export interface GetRoleTempalteRule {
    apiGroups?: string[];
    nonResourceUrls?: string[];
    resourceNames?: string[];
    resources?: string[];
    verbs?: string[];
}

export interface GetRoleTemplateRule {
    apiGroups?: string[];
    nonResourceUrls?: string[];
    resourceNames?: string[];
    resources?: string[];
    verbs?: string[];
}

export interface GlobalDnsProviderAlidnsConfig {
    /**
     * The AliDNS Access key (string)
     */
    accessKey: string;
    /**
     * The AliDNS Secret key (string)
     */
    secretKey: string;
}

export interface GlobalDnsProviderCloudflareConfig {
    /**
     * The CloudFlare API Email (string)
     */
    apiEmail: string;
    /**
     * The CloudFlare API Key (string)
     */
    apiKey: string;
    /**
     * CloudFlare Proxy Setting. Default: `false` (bool)
     */
    proxySetting?: boolean;
}

export interface GlobalDnsProviderRoute53Config {
    /**
     * The AliDNS Access key (string)
     */
    accessKey: string;
    /**
     * The AWS credentials path. Default: `"/.aws"` (string)
     */
    credentialsPath?: string;
    /**
     * The AWS Region. Default: `"us-west-2"` (string)
     */
    region?: string;
    /**
     * The AWS Role ARN (string)
     */
    roleArn?: string;
    /**
     * The AliDNS Secret key (string)
     */
    secretKey: string;
    /**
     * The Route53 zone type `public, private`. Default: `"public"` (string)
     */
    zoneType?: string;
}

export interface GlobalRoleRule {
    /**
     * Policy rule api groups (list)
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls (list)
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names (list)
     */
    resourceNames?: string[];
    /**
     * Policy rule resources (list)
     */
    resources?: string[];
    /**
     * Policy rule verbs. `bind`, `create`, `delete`, `deletecollection`, `escalate`, `get`, `impersonate`, `list`, `patch`, `update`, `use`, `view`, `watch`, `own` and `*` values are supported (list)
     */
    verbs?: string[];
}

export interface MachineConfigV2Amazonec2Config {
    accessKey?: string;
    /**
     * AWS machine image (string)
     */
    ami: string;
    /**
     * AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360). Default `0` (string)
     */
    blockDurationMinutes?: string;
    /**
     * AWS root device name. Default `/dev/sda1` (string)
     */
    deviceName?: string;
    /**
     * Encrypt EBS volume. Default `false` (bool)
     */
    encryptEbsVolume?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI) (string)
     */
    endpoint?: string;
    /**
     * Enables or disables the HTTP metadata endpoint on your instances (string)
     */
    httpEndpoint?: string;
    /**
     * The state of token usage for your instance metadata requests (string)
     */
    httpTokens?: string;
    /**
     * AWS IAM Instance Profile (string)
     */
    iamInstanceProfile?: string;
    /**
     * Disable SSL when sending requests (bool)
     */
    insecureTransport?: boolean;
    /**
     * AWS instance type. Default `t3a.medium` (string)
     */
    instanceType?: string;
    /**
     * AWS keypair to use; requires --amazonec2-ssh-keypath (string)
     */
    keypairName?: string;
    /**
     * Custom KMS key ID using the AWS Managed CMK (string)
     */
    kmsKey?: string;
    /**
     * Set this flag to enable CloudWatch monitoring. Deafult `false` (bool)
     */
    monitoring?: boolean;
    /**
     * Make the specified port number accessible from the Internet. (list)
     */
    openPorts?: string[];
    /**
     * Only use a private IP address. Default `false` (bool)
     */
    privateAddressOnly?: boolean;
    /**
     * AWS region. (string)
     */
    region: string;
    /**
     * Set this flag to request spot instance. Default `false` (bool)
     */
    requestSpotInstance?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable). Default `5` (string)
     */
    retries?: string;
    /**
     * AWS root disk size (in GB). Default `16` (string)
     */
    rootSize?: string;
    secretKey?: string;
    /**
     * Skip adding default rules to security groups (bool)
     */
    securityGroupReadonly?: boolean;
    /**
     * AWS VPC security group. (list)
     */
    securityGroups: string[];
    /**
     * AWS Session Token (string)
     */
    sessionToken?: string;
    /**
     * AWS spot instance bid price (in dollar). Default `0.50` (string)
     */
    spotPrice?: string;
    /**
     * SSH Key for Instance (string)
     */
    sshKeyContents?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * AWS VPC subnet id (string)
     */
    subnetId: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Create an EBS optimized instance. Default `false` (bool)
     */
    useEbsOptimizedInstance?: boolean;
    /**
     * Force the usage of private IP address. Default `false` (bool)
     */
    usePrivateAddress?: boolean;
    /**
     * Path to file with cloud-init user data (string)
     */
    userdata?: string;
    /**
     * Amazon EBS volume type. Default `gp2` (string)
     */
    volumeType?: string;
    /**
     * AWS VPC id. (string)
     */
    vpcId: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e) (string)
     */
    zone: string;
}

export interface MachineConfigV2AzureConfig {
    acceleratedNetworking?: boolean;
    /**
     * Azure Availability Set to place the virtual machine into. Default `docker-machine` (string)
     */
    availabilitySet?: string;
    /**
     * OpenStack availability zone (string)
     */
    availabilityZone?: string;
    /**
     * Azure Service Principal Account ID. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    clientId?: string;
    /**
     * Azure Service Principal Account password. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    clientSecret?: string;
    /**
     * Path to file with custom-data (string)
     */
    customData?: string;
    /**
     * Disk size if using managed disk. Just for Rancher v2.3.x and above. Default `30` (string)
     */
    diskSize?: string;
    /**
     * A unique DNS label for the public IP adddress (string)
     */
    dns?: string;
    /**
     * Port number for Docker engine. Default `2376` (string)
     */
    dockerPort?: string;
    /**
     * Azure environment (e.g. AzurePublicCloud, AzureChinaCloud). Default `AzurePublicCloud` (string)
     */
    environment?: string;
    /**
     * Fault domain count to use for availability set. Default `3` (string)
     */
    faultDomainCount?: string;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * Azure region to create the virtual machine. Default `westus` (string)
     */
    location?: string;
    /**
     * Configures VM and availability set for managed disks. Just for Rancher v2.3.x and above. Default `false` (bool)
     */
    managedDisks?: boolean;
    /**
     * Do not create a public IP address for the machine. Default `false` (bool)
     */
    noPublicIp?: boolean;
    /**
     * Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine). Default `docker-machine-nsg` (string)
     */
    nsg?: string;
    /**
     * Make the specified port number accessible from the Internet. (list)
     */
    openPorts?: string[];
    /**
     * Only use a private IP address. Default `false` (bool)
     */
    privateAddressOnly?: boolean;
    /**
     * Specify a static private IP address for the machine. (string)
     */
    privateIpAddress?: string;
    /**
     * Azure Resource Group name (will be created if missing). Default `docker-machine` (string)
     */
    resourceGroup?: string;
    /**
     * Size for Azure Virtual Machine. Default `Standard_A2` (string)
     */
    size?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * Assign a static public IP address to the machine. Default `false` (bool)
     */
    staticPublicIp?: boolean;
    /**
     * Type of Storage Account to host the OS Disk for the machine. Default `Standard_LRS` (string)
     */
    storageType?: string;
    /**
     * Azure Subnet Name to be used within the Virtual Network. Default `docker-machine` (string)
     */
    subnet?: string;
    /**
     * Private CIDR block to be used for the new subnet, should comply RFC 1918. Default `192.168.0.0/16` (string)
     */
    subnetPrefix?: string;
    /**
     * Azure Subscription ID. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    subscriptionId?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Azure Tenant ID (string)
     */
    tenantId?: string;
    /**
     * Update domain count to use for availability set. Default `5` (string)
     */
    updateDomainCount?: string;
    /**
     * Use private IP address of the machine to connect. Default `false` (bool)
     */
    usePrivateIp?: boolean;
    usePublicIpStandardSku?: boolean;
    /**
     * Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format). Default `docker-machine-vnet` (string)
     */
    vnet?: string;
}

export interface MachineConfigV2DigitaloceanConfig {
    /**
     * Digital Ocean access token. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    accessToken?: string;
    /**
     * Enable backups for droplet. Default `false` (bool)
     */
    backups?: boolean;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * Enable ipv6 for droplet. Default `false` (bool)
     */
    ipv6?: boolean;
    /**
     * Set this flag to enable CloudWatch monitoring. Deafult `false` (bool)
     */
    monitoring?: boolean;
    /**
     * Enable private networking for droplet. Default `false` (bool)
     */
    privateNetworking?: boolean;
    /**
     * AWS region. (string)
     */
    region?: string;
    /**
     * Size for Azure Virtual Machine. Default `Standard_A2` (string)
     */
    size?: string;
    /**
     * SSH Key for Instance (string)
     */
    sshKeyContents?: string;
    /**
     * SSH key fingerprint (string)
     */
    sshKeyFingerprint?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Path to file with cloud-init user data (string)
     */
    userdata?: string;
}

export interface MachineConfigV2HarvesterConfig {
    /**
     * CPU count, Default `2` (string)
     */
    cpuCount?: string;
    /**
     * Use `diskInfo` instead
     *
     * @deprecated Use disk_info instead
     */
    diskBus?: string;
    /**
     * A JSON string specifying info for the disks e.g. `{\"disks\":[{\"imageName\":\"harvester-public/image-57hzg\",\"bootOrder\":1,\"size\":40},{\"storageClassName\":\"node-driver-test\",\"bootOrder\":2,\"size\":1}]}` (string)
     */
    diskInfo: string;
    /**
     * Disk size if using managed disk. Just for Rancher v2.3.x and above. Default `30` (string)
     *
     * @deprecated Use disk_info instead
     */
    diskSize?: string;
    /**
     * Use `diskInfo` instead
     *
     * @deprecated Use disk_info instead
     */
    imageName?: string;
    /**
     * Memory size (in GiB), Default `4` (string)
     */
    memorySize?: string;
    /**
     * NetworkData content of cloud-init, base64 is supported (string)
     */
    networkData?: string;
    /**
     * A JSON string specifying info for the networks e.g. `{\"interfaces\":[{\"networkName\":\"harvester-public/vlan1\"},{\"networkName\":\"harvester-public/vlan2\"}]}` (string)
     */
    networkInfo: string;
    /**
     * Use `networkInfo` instead
     *
     * @deprecated Use network_info instead
     */
    networkModel?: string;
    /**
     * Use `networkInfo` instead
     *
     * @deprecated Use network_info instead
     */
    networkName?: string;
    /**
     * SSH password (string)
     */
    sshPassword?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser: string;
    /**
     * UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata (string)
     */
    userData?: string;
    /**
     * Virtual machine affinity, only base64 format is supported. For Rancher v2.6.7 or above (string)
     */
    vmAffinity?: string;
    /**
     * Virtual machine namespace e.g. `default` (string)
     */
    vmNamespace: string;
}

export interface MachineConfigV2LinodeConfig {
    /**
     * Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node. (string)
     */
    authorizedUsers?: string;
    /**
     * Create private IP for the instance. Default `false` (bool)
     */
    createPrivateIp?: boolean;
    /**
     * Port number for Docker engine. Default `2376` (string)
     */
    dockerPort?: string;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * AWS instance type. Default `t3a.medium` (string)
     */
    instanceType?: string;
    /**
     * Linode Instance Label. (string)
     */
    label?: string;
    /**
     * AWS region. (string)
     */
    region?: string;
    /**
     * Root Password (string)
     */
    rootPass?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * Specifies the Linode StackScript to use to create the instance. (string)
     */
    stackscript?: string;
    /**
     * A JSON string specifying data for the selected StackScript. (string)
     */
    stackscriptData?: string;
    /**
     * Linode Instance Swap Size (MB). Default `512` (string)
     */
    swapSize?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Linode API token. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    token?: string;
    /**
     * Prefix the User-Agent in Linode API calls with some 'product/version' (string)
     */
    uaPrefix?: string;
}

export interface MachineConfigV2OpenstackConfig {
    /**
     * OpenStack active timeout Default `200` (string)
     */
    activeTimeout?: string;
    /**
     * OpenStack application credential id. Conflicts with `applicationCredentialName` (string)
     */
    applicationCredentialId?: string;
    /**
     * OpenStack application credential name. Conflicts with `applicationCredentialId` (string)
     */
    applicationCredentialName?: string;
    /**
     * OpenStack application credential secret (string)
     */
    applicationCredentialSecret?: string;
    /**
     * OpenStack authentication URL (string)
     */
    authUrl: string;
    /**
     * OpenStack availability zone (string)
     */
    availabilityZone: string;
    /**
     * Enable booting from volume. Default is `false` (bool)
     */
    bootFromVolume?: boolean;
    /**
     * CA certificate bundle to verify against (string)
     */
    cacert?: string;
    /**
     * Enables the OpenStack config drive for the instance. Default `false` (bool)
     */
    configDrive?: boolean;
    /**
     * OpenStack domain ID. Identity v3 only. Conflicts with `domainName` (string)
     */
    domainId?: string;
    /**
     * OpenStack domain name. Identity v3 only. Conflicts with `domainId` (string)
     */
    domainName?: string;
    /**
     * OpenStack endpoint type. adminURL, internalURL or publicURL (string)
     */
    endpointType?: string;
    /**
     * OpenStack flavor id to use for the instance. Conflicts with `flavorName` (string)
     */
    flavorId?: string;
    /**
     * OpenStack flavor name to use for the instance. Conflicts with `flavorId` (string)
     */
    flavorName?: string;
    /**
     * OpenStack floating IP pool to get an IP from to assign to the instance (string)
     */
    floatingIpPool?: string;
    /**
     * OpenStack image id to use for the instance. Conflicts with `imageName` (string)
     */
    imageId?: string;
    /**
     * Use `diskInfo` instead
     */
    imageName?: string;
    /**
     * Disable TLS credential checking. Default `false` (bool)
     */
    insecure?: boolean;
    /**
     * OpenStack version of IP address assigned for the machine Default `4` (string)
     */
    ipVersion?: string;
    /**
     * AWS keypair to use; requires --amazonec2-ssh-keypath (string)
     */
    keypairName?: string;
    /**
     * OpenStack network id the machine will be connected on. Conflicts with `netName` (string)
     */
    netId?: string;
    /**
     * OpenStack network name the machine will be connected on. Conflicts with `netId` (string)
     */
    netName?: string;
    /**
     * Use the nova networking services instead of neutron (string)
     */
    novaNetwork?: boolean;
    /**
     * OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    password?: string;
    /**
     * Private key content to use for SSH (string)
     */
    privateKeyFile?: string;
    /**
     * AWS region. (string)
     */
    region: string;
    /**
     * OpenStack comma separated security groups for the machine (string)
     */
    secGroups?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * OpenStack tenant domain id. Conflicts with `tenantDomainName` (string)
     */
    tenantDomainId?: string;
    /**
     * OpenStack tenant domain name. Conflicts with `tenantDomainId` (string)
     */
    tenantDomainName?: string;
    /**
     * Azure Tenant ID (string)
     */
    tenantId?: string;
    /**
     * OpenStack tenant name. Conflicts with `tenantId` (string)
     */
    tenantName?: string;
    /**
     * File containing an openstack userdata script (string)
     */
    userDataFile?: string;
    /**
     * OpenStack user domain id. Conflicts with `userDomainName` (string)
     */
    userDomainId?: string;
    /**
     * OpenStack user domain name. Conflicts with `userDomainId` (string)
     */
    userDomainName?: string;
    /**
     * OpenStack username (string)
     */
    username?: string;
    /**
     * OpenStack volume device path (attaching). Applicable only when `bootFromVolume` is `true`. Omit for auto `/dev/vdb`. (string)
     * > **Note**: `Required+` denotes that either the _name or _id is required but you cannot use both.
     * > **Note**: `Required++` denotes that either the _name or _id is required unless `applicationCredentialId` is defined.
     */
    volumeDevicePath?: string;
    /**
     * OpenStack volume id of existing volume. Applicable only when `bootFromVolume` is `true` (string)
     */
    volumeId?: string;
    /**
     * OpenStack volume name of existing volume. Applicable only when `bootFromVolume` is `true` (string)
     */
    volumeName?: string;
    /**
     * OpenStack volume size (GiB). Required when `bootFromVolume` is `true` (string)
     */
    volumeSize?: string;
    /**
     * Amazon EBS volume type. Default `gp2` (string)
     */
    volumeType?: string;
}

export interface MachineConfigV2VsphereConfig {
    /**
     * vSphere URL for boot2docker iso image. Default `https://releases.rancher.com/os/latest/rancheros-vmware.iso` (string)
     */
    boot2dockerUrl?: string;
    /**
     * vSphere vm configuration parameters (used for guestinfo) (list)
     */
    cfgparams?: string[];
    /**
     * If you choose creation type vm (clone vm) a name of what vm you want to clone is required (string)
     */
    cloneFrom?: string;
    /**
     * Filepath to a cloud-config yaml file to put into the ISO user-data (string)
     */
    cloudConfig?: string;
    /**
     * vSphere cloud-init file or url to set in the guestinfo (string)
     */
    cloudinit?: string;
    /**
     * If you choose to clone from a content library template specify the name of the library (string)
     */
    contentLibrary?: string;
    /**
     * CPU count, Default `2` (string)
     */
    cpuCount?: string;
    /**
     * Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy. Default `legacy` (string)
     */
    creationType?: string;
    /**
     * vSphere custom attributes, format key/value e.g. `200=my custom value` (List)
     */
    customAttributes?: string[];
    /**
     * vSphere datacenter for docker VM (string)
     */
    datacenter?: string;
    /**
     * vSphere datastore for docker VM (string)
     */
    datastore?: string;
    /**
     * vSphere datastore cluster for virtual machine (string)
     */
    datastoreCluster?: string;
    /**
     * Disk size if using managed disk. Just for Rancher v2.3.x and above. Default `30` (string)
     */
    diskSize?: string;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter (string)
     */
    folder?: string;
    /**
     * vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS (string)
     */
    hostsystem?: string;
    /**
     * Memory size (in GiB), Default `4` (string)
     */
    memorySize?: string;
    /**
     * vSphere network where the docker VM will be attached (list)
     */
    networks?: string[];
    /**
     * OpenStack password. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    password?: string;
    /**
     * vSphere resource pool for docker VM (string)
     */
    pool?: string;
    /**
     * SSH password (string)
     */
    sshPassword?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown'ed. Default `staff` (string)
     */
    sshUserGroup?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string[];
    /**
     * OpenStack username (string)
     */
    username?: string;
    /**
     * vSphere vApp IP allocation policy. Supported values are: `dhcp`, `fixed`, `transient` and `fixedAllocated` (string)
     */
    vappIpAllocationPolicy?: string;
    /**
     * vSphere vApp IP protocol for this deployment. Supported values are: `IPv4` and `IPv6` (string)
     */
    vappIpProtocol?: string;
    /**
     * vSphere vApp properties (list)
     */
    vappProperties?: string[];
    /**
     * vSphere OVF environment transports to use for properties. Supported values are: `iso` and `com.vmware.guestInfo` (string)
     */
    vappTransport?: string;
    /**
     * vSphere IP/hostname for vCenter (string)
     */
    vcenter?: string;
    /**
     * vSphere Port for vCenter Default `443` (string)
     */
    vcenterPort?: string;
}

export interface MultiClusterAppAnswer {
    /**
     * Cluster ID for answer (string)
     */
    clusterId: string;
    /**
     * Project ID for target (string)
     */
    projectId: string;
    /**
     * Key/values for answer (map)
     */
    values: {[key: string]: any};
}

export interface MultiClusterAppMember {
    /**
     * Member access type. Valid values: `["member" | "owner" | "read-only"]` (string)
     */
    accessType?: string;
    /**
     * Member group principal id (string)
     */
    groupPrincipalId?: string;
    /**
     * Member user principal id (string)
     */
    userPrincipalId?: string;
}

export interface MultiClusterAppTarget {
    /**
     * App ID for target (string)
     */
    appId: string;
    /**
     * App health state for target (string)
     */
    healthState: string;
    /**
     * Project ID for target (string)
     */
    projectId: string;
    /**
     * App state for target (string)
     */
    state: string;
}

export interface MultiClusterAppUpgradeStrategy {
    /**
     * Upgrade strategy rolling update (list MaxItems:1)
     */
    rollingUpdate?: outputs.MultiClusterAppUpgradeStrategyRollingUpdate;
}

export interface MultiClusterAppUpgradeStrategyRollingUpdate {
    /**
     * Rolling update batch size. Default `1` (int)
     */
    batchSize?: number;
    /**
     * Rolling update interval. Default `1` (int)
     */
    interval?: number;
}

export interface NamespaceContainerResourceLimit {
    /**
     * CPU limit for containers (string)
     */
    limitsCpu?: string;
    /**
     * Memory limit for containers (string)
     */
    limitsMemory?: string;
    /**
     * CPU reservation for containers (string)
     */
    requestsCpu?: string;
    /**
     * Memory reservation for containers (string)
     */
    requestsMemory?: string;
}

export interface NamespaceResourceQuota {
    /**
     * Resource quota limit for namespace (list maxitems:1)
     */
    limit: outputs.NamespaceResourceQuotaLimit;
}

export interface NamespaceResourceQuotaLimit {
    /**
     * Limit for config maps in namespace (string)
     */
    configMaps?: string;
    /**
     * CPU limit for containers (string)
     */
    limitsCpu?: string;
    /**
     * Memory limit for containers (string)
     */
    limitsMemory?: string;
    /**
     * Limit for persistent volume claims in namespace (string)
     */
    persistentVolumeClaims?: string;
    /**
     * Limit for pods in namespace (string)
     */
    pods?: string;
    /**
     * Limit for replication controllers in namespace (string)
     */
    replicationControllers?: string;
    /**
     * CPU reservation for containers (string)
     */
    requestsCpu?: string;
    /**
     * Memory reservation for containers (string)
     */
    requestsMemory?: string;
    /**
     * Limit for requests storage in namespace (string)
     */
    requestsStorage?: string;
    /**
     * Limit for secrets in namespace (string)
     */
    secrets?: string;
    services?: string;
    /**
     * Limit for services load balancers in namespace (string)
     */
    servicesLoadBalancers?: string;
    /**
     * Limit for services node ports in namespace (string)
     *
     * More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
     */
    servicesNodePorts?: string;
}

export interface NodePoolNodeTaint {
    /**
     * Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
     */
    effect?: string;
    /**
     * Taint key (string)
     */
    key: string;
    /**
     * Taint time added (string)
     */
    timeAdded: string;
    /**
     * Taint value (string)
     */
    value: string;
}

export interface NodeTemplateAmazonec2Config {
    /**
     * AWS access key. Required on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    accessKey?: string;
    /**
     * AWS machine image (string)
     */
    ami: string;
    /**
     * AWS spot instance duration in minutes (60, 120, 180, 240, 300, or 360). Default `0` (string)
     */
    blockDurationMinutes?: string;
    /**
     * AWS root device name. Default `/dev/sda1` (string)
     */
    deviceName?: string;
    /**
     * Encrypt EBS volume. Default `false` (bool)
     */
    encryptEbsVolume?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI) (string)
     */
    endpoint?: string;
    /**
     * Enables or disables the HTTP metadata endpoint on your instances (string)
     */
    httpEndpoint?: string;
    /**
     * The state of token usage for your instance metadata requests (string)
     */
    httpTokens?: string;
    /**
     * AWS IAM Instance Profile (string)
     */
    iamInstanceProfile?: string;
    /**
     * Disable SSL when sending requests (bool)
     */
    insecureTransport?: boolean;
    /**
     * AWS instance type. Default `t2.micro` (string)
     */
    instanceType?: string;
    /**
     * OpenStack keypair to use to SSH to the instance (string)
     */
    keypairName?: string;
    /**
     * Custom KMS key ID using the AWS Managed CMK (string)
     */
    kmsKey?: string;
    /**
     * Set this flag to enable CloudWatch monitoring. Deafult `false` (bool)
     */
    monitoring?: boolean;
    /**
     * Make the specified port number accessible from the Internet. (list)
     */
    openPorts?: string[];
    /**
     * Only use a private IP address. Default `false` (bool)
     */
    privateAddressOnly?: boolean;
    /**
     * AWS region. (string)
     */
    region: string;
    /**
     * Set this flag to request spot instance. Default `false` (bool)
     */
    requestSpotInstance?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable). Default `5` (string)
     */
    retries?: string;
    /**
     * AWS root disk size (in GB). Default `16` (string)
     */
    rootSize?: string;
    /**
     * AWS secret key. Required on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    secretKey?: string;
    /**
     * Skip adding default rules to security groups (bool)
     */
    securityGroupReadonly?: boolean;
    /**
     * AWS VPC security group. (list)
     */
    securityGroups: string[];
    /**
     * AWS Session Token (string)
     */
    sessionToken?: string;
    /**
     * AWS spot instance bid price (in dollar). Default `0.50` (string)
     */
    spotPrice?: string;
    sshKeypath?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * AWS VPC subnet id (string)
     */
    subnetId: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Create an EBS optimized instance. Default `false` (bool)
     */
    useEbsOptimizedInstance?: boolean;
    /**
     * Force the usage of private IP address. Default `false` (bool)
     */
    usePrivateAddress?: boolean;
    /**
     * Path to file with cloud-init user data (string)
     *
     * > **Note**: You need to install the Hetzner Docker Machine Driver first as shown as in the examples section.
     */
    userdata?: string;
    /**
     * Amazon EBS volume type. Default `gp2` (string)
     */
    volumeType?: string;
    /**
     * AWS VPC id. (string)
     */
    vpcId: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e) (string)
     */
    zone: string;
}

export interface NodeTemplateAzureConfig {
    acceleratedNetworking?: boolean;
    /**
     * Azure Availability Set to place the virtual machine into. Default `docker-machine` (string)
     */
    availabilitySet?: string;
    /**
     * OpenStack availability zone (string)
     */
    availabilityZone?: string;
    /**
     * Azure Service Principal Account ID. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    clientId?: string;
    /**
     * Azure Service Principal Account password. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    clientSecret?: string;
    /**
     * Path to file with custom-data (string)
     */
    customData?: string;
    /**
     * Disk size if using managed disk. Just for Rancher v2.3.x and above. Default `30` (string)
     */
    diskSize?: string;
    /**
     * A unique DNS label for the public IP adddress (string)
     */
    dns?: string;
    /**
     * Port number for Docker engine. Default `2376` (string)
     */
    dockerPort?: string;
    /**
     * Azure environment (e.g. AzurePublicCloud, AzureChinaCloud). Default `AzurePublicCloud` (string)
     */
    environment?: string;
    /**
     * Fault domain count to use for availability set. Default `3` (string)
     */
    faultDomainCount?: string;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * Azure region to create the virtual machine. Default `westus` (string)
     */
    location?: string;
    /**
     * Configures VM and availability set for managed disks. Just for Rancher v2.3.x and above. Default `false` (bool)
     */
    managedDisks?: boolean;
    /**
     * Do not create a public IP address for the machine. Default `false` (bool)
     */
    noPublicIp?: boolean;
    /**
     * Azure Network Security Group to assign this node to (accepts either a name or resource ID, default is to create a new NSG for each machine). Default `docker-machine-nsg` (string)
     */
    nsg?: string;
    /**
     * Make the specified port number accessible from the Internet. (list)
     */
    openPorts?: string[];
    /**
     * Azure marketplace purchase plan for Azure Virtual Machine. Format is `<publisher>:<product>:<plan>`. Just for Rancher v2.6.3 and above. (string)
     */
    plan?: string;
    /**
     * Specify a static private IP address for the machine. (string)
     */
    privateIpAddress?: string;
    /**
     * Azure Resource Group name (will be created if missing). Default `docker-machine` (string)
     */
    resourceGroup?: string;
    /**
     * Size for Azure Virtual Machine. Default `Standard_A2` (string)
     */
    size?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * Assign a static public IP address to the machine. Default `false` (bool)
     */
    staticPublicIp?: boolean;
    /**
     * Type of Storage Account to host the OS Disk for the machine. Default `Standard_LRS` (string)
     */
    storageType?: string;
    /**
     * Azure Subnet Name to be used within the Virtual Network. Default `docker-machine` (string)
     */
    subnet?: string;
    /**
     * Private CIDR block to be used for the new subnet, should comply RFC 1918. Default `192.168.0.0/16` (string)
     */
    subnetPrefix?: string;
    /**
     * Azure Subscription ID. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    subscriptionId?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Update domain count to use for availability set. Default `5` (string)
     */
    updateDomainCount?: string;
    /**
     * Use private IP address of the machine to connect. Default `false` (bool)
     */
    usePrivateIp?: boolean;
    usePublicIpStandardSku?: boolean;
    /**
     * Azure Virtual Network name to connect the virtual machine (in [resourcegroup:]name format). Default `docker-machine-vnet` (string)
     */
    vnet?: string;
}

export interface NodeTemplateDigitaloceanConfig {
    /**
     * Digital Ocean access token. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    accessToken?: string;
    /**
     * Enable backups for droplet. Default `false` (bool)
     */
    backups?: boolean;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * Enable ipv6 for droplet. Default `false` (bool)
     */
    ipv6?: boolean;
    /**
     * Set this flag to enable CloudWatch monitoring. Deafult `false` (bool)
     */
    monitoring?: boolean;
    /**
     * Enable private networking for droplet. Default `false` (bool)
     */
    privateNetworking?: boolean;
    /**
     * AWS region. (string)
     */
    region?: string;
    /**
     * Size for Azure Virtual Machine. Default `Standard_A2` (string)
     */
    size?: string;
    /**
     * SSH key fingerprint (string)
     */
    sshKeyFingerprint?: string;
    /**
     * SSH private key path (string)
     */
    sshKeyPath?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Path to file with cloud-init user data (string)
     *
     * > **Note**: You need to install the Hetzner Docker Machine Driver first as shown as in the examples section.
     */
    userdata?: string;
}

export interface NodeTemplateHarvesterConfig {
    /**
     * CPU count, Default `2` (string)
     */
    cpuCount?: string;
    /**
     * Use `diskInfo` instead
     *
     * @deprecated Use disk_info instead
     */
    diskBus?: string;
    /**
     * A JSON string specifying info for the disks e.g. `{\"disks\":[{\"imageName\":\"harvester-public/image-57hzg\",\"bootOrder\":1,\"size\":40},{\"storageClassName\":\"node-driver-test\",\"bootOrder\":2,\"size\":1}]}` (string)
     */
    diskInfo: string;
    /**
     * Disk size if using managed disk. Just for Rancher v2.3.x and above. Default `30` (string)
     *
     * @deprecated Use disk_info instead
     */
    diskSize?: string;
    /**
     * Use `diskInfo` instead
     *
     * @deprecated Use disk_info instead
     */
    imageName?: string;
    /**
     * Memory size (in GiB), Default `4` (string)
     */
    memorySize?: string;
    /**
     * NetworkData content of cloud-init, base64 is supported (string)
     */
    networkData?: string;
    /**
     * A JSON string specifying info for the networks e.g. `{\"interfaces\":[{\"networkName\":\"harvester-public/vlan1\"},{\"networkName\":\"harvester-public/vlan2\"}]}` (string)
     */
    networkInfo: string;
    /**
     * Use `networkInfo` instead
     *
     * @deprecated Use network_info instead
     */
    networkModel?: string;
    /**
     * Use `networkInfo` instead
     *
     * @deprecated Use network_info instead
     */
    networkName?: string;
    /**
     * SSH password (string)
     */
    sshPassword?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser: string;
    /**
     * UserData content of cloud-init, base64 is supported. If the image does not contain the qemu-guest-agent package, you must install and start qemu-guest-agent using userdata (string)
     */
    userData?: string;
    /**
     * Virtual machine affinity, only base64 format is supported. For Rancher v2.6.7 or above (string)
     */
    vmAffinity?: string;
    /**
     * Virtual machine namespace e.g. `default` (string)
     */
    vmNamespace: string;
}

export interface NodeTemplateHetznerConfig {
    /**
     * Hetzner Cloud project API token (string)
     */
    apiToken: string;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * Comma-separated list of network IDs or names which should be attached to the server private network interface (string)
     */
    networks?: string;
    /**
     * Map of the labels which will be assigned to the server. This argument is only available on [Hetzner Docker Node Driver:v3.6.0](https://github.com/JonasProgrammer/docker-machine-driver-hetzner/releases/tag/3.6.0) and above (map)
     */
    serverLabels?: {[key: string]: any};
    /**
     * Hetzner Cloud datacenter. Default `nbg1` (string)
     */
    serverLocation?: string;
    /**
     * Hetzner Cloud server type. Default `cx11` (string)
     */
    serverType?: string;
    /**
     * Use private network. Default `false` (bool)
     */
    usePrivateNetwork?: boolean;
    /**
     * Path to file with cloud-init user data (string)
     *
     * > **Note**: You need to install the Hetzner Docker Machine Driver first as shown as in the examples section.
     */
    userdata?: string;
    /**
     * Comma-separated list of volume IDs or names which should be attached to the server (string)
     */
    volumes?: string;
}

export interface NodeTemplateLinodeConfig {
    /**
     * Linode user accounts (seperated by commas) whose Linode SSH keys will be permitted root access to the created node. (string)
     */
    authorizedUsers?: string;
    /**
     * Create private IP for the instance. Default `false` (bool)
     */
    createPrivateIp?: boolean;
    /**
     * Port number for Docker engine. Default `2376` (string)
     */
    dockerPort?: string;
    /**
     * Azure virtual machine OS image. Default `canonical:UbuntuServer:18.04-LTS:latest` (string)
     */
    image?: string;
    /**
     * AWS instance type. Default `t2.micro` (string)
     */
    instanceType?: string;
    /**
     * Linode Instance Label. (string)
     */
    label?: string;
    /**
     * AWS region. (string)
     */
    region?: string;
    /**
     * Root Password (string)
     */
    rootPass?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * Specifies the Linode StackScript to use to create the instance. (string)
     */
    stackscript?: string;
    /**
     * A JSON string specifying data for the selected StackScript. (string)
     */
    stackscriptData?: string;
    /**
     * Linode Instance Swap Size (MB). Default `512` (string)
     */
    swapSize?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string;
    /**
     * Linode API token. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    token?: string;
    /**
     * Prefix the User-Agent in Linode API calls with some 'product/version' (string)
     */
    uaPrefix?: string;
}

export interface NodeTemplateNodeTaint {
    /**
     * Taint effect. Supported values : `"NoExecute" | "NoSchedule" | "PreferNoSchedule"` (string)
     */
    effect?: string;
    /**
     * Taint key (string)
     */
    key: string;
    /**
     * Taint time added (string)
     */
    timeAdded: string;
    /**
     * Taint value (string)
     */
    value: string;
}

export interface NodeTemplateOpennebulaConfig {
    /**
     * Size of the Volatile disk in MB - only for b2d (string)
     */
    b2dSize?: string;
    /**
     * CPU value for the VM (string)
     */
    cpu?: string;
    /**
     * Dev prefix to use for the images. E.g.: 'vd', 'sd', 'hd' (string)
     */
    devPrefix?: string;
    /**
     * VNC is enabled by default. Disable it with this flag (bool)
     */
    disableVnc?: boolean;
    /**
     * Size of the disk for the VM in MB (string)
     */
    diskResize?: string;
    /**
     * Image ID to use as the VM OS. Conflicts with `imageName` (string)
     */
    imageId?: string;
    /**
     * Use `diskInfo` instead
     */
    imageName?: string;
    /**
     * Owner of the image to use as the VM OS (string)
     */
    imageOwner?: string;
    /**
     * Size of the memory for the VM in MB (string)
     */
    memory?: string;
    /**
     * Opennebula network ID to connect the machine to. Conflicts with `networkName` (string)
     */
    networkId?: string;
    /**
     * Use `networkInfo` instead
     */
    networkName?: string;
    /**
     * Opennebula user ID of the Network to connect the machine to (string)
     */
    networkOwner?: string;
    /**
     * Set the password for the XML-RPC API authentication (string)
     */
    password: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * Opennebula template ID to use. Conflicts with `templateName` (string)
     */
    templateId?: string;
    /**
     * Name of the Opennbula template to use. Conflicts with `templateId` (string)
     */
    templateName?: string;
    /**
     * Set the user for the XML-RPC API authentication (string)
     */
    user: string;
    /**
     * VCPUs for the VM (string)
     *
     * > **Note**: `Required*` denotes that one of imageName / imageId or templateName / templateId is required but you cannot combine them.
     */
    vcpu?: string;
    /**
     * Set the url for the Opennebula XML-RPC API (string)
     */
    xmlRpcUrl: string;
}

export interface NodeTemplateOpenstackConfig {
    /**
     * OpenStack active timeout Default `200` (string)
     */
    activeTimeout?: string;
    /**
     * OpenStack application credential id. Conflicts with `applicationCredentialName` (string)
     */
    applicationCredentialId?: string;
    /**
     * OpenStack application credential name. Conflicts with `applicationCredentialId` (string)
     */
    applicationCredentialName?: string;
    /**
     * OpenStack application credential secret (string)
     */
    applicationCredentialSecret?: string;
    /**
     * OpenStack authentication URL (string)
     */
    authUrl: string;
    /**
     * OpenStack availability zone (string)
     */
    availabilityZone: string;
    /**
     * Enable booting from volume. Default is `false` (bool)
     */
    bootFromVolume?: boolean;
    /**
     * CA certificate bundle to verify against (string)
     */
    cacert?: string;
    /**
     * Enables the OpenStack config drive for the instance. Default `false` (bool)
     */
    configDrive?: boolean;
    /**
     * OpenStack domain ID. Identity v3 only. Conflicts with `domainName` (string)
     */
    domainId?: string;
    /**
     * OpenStack domain name. Identity v3 only. Conflicts with `domainId` (string)
     */
    domainName?: string;
    /**
     * OpenStack endpoint type. adminURL, internalURL or publicURL (string)
     */
    endpointType?: string;
    /**
     * OpenStack flavor id to use for the instance. Conflicts with `flavorName` (string)
     */
    flavorId?: string;
    /**
     * OpenStack flavor name to use for the instance. Conflicts with `flavorId` (string)
     */
    flavorName?: string;
    /**
     * OpenStack floating IP pool to get an IP from to assign to the instance (string)
     */
    floatingIpPool?: string;
    /**
     * Image ID to use as the VM OS. Conflicts with `imageName` (string)
     */
    imageId?: string;
    /**
     * Use `diskInfo` instead
     */
    imageName?: string;
    /**
     * Disable TLS credential checking. Default `false` (bool)
     */
    insecure?: boolean;
    /**
     * OpenStack version of IP address assigned for the machine Default `4` (string)
     */
    ipVersion?: string;
    /**
     * OpenStack keypair to use to SSH to the instance (string)
     */
    keypairName?: string;
    /**
     * OpenStack network id the machine will be connected on. Conflicts with `netName` (string)
     */
    netId?: string;
    /**
     * OpenStack network name the machine will be connected on. Conflicts with `netId` (string)
     */
    netName?: string;
    /**
     * Use the nova networking services instead of neutron (string)
     */
    novaNetwork?: boolean;
    /**
     * Set the password for the XML-RPC API authentication (string)
     */
    password?: string;
    /**
     * Private key content to use for SSH (string)
     */
    privateKeyFile?: string;
    /**
     * AWS region. (string)
     */
    region: string;
    /**
     * OpenStack comma separated security groups for the machine (string)
     */
    secGroups?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * OpenStack tenant id. Conflicts with `tenantName` (string)
     */
    tenantId?: string;
    /**
     * OpenStack tenant name. Conflicts with `tenantId` (string)
     */
    tenantName?: string;
    /**
     * File containing an openstack userdata script (string)
     */
    userDataFile?: string;
    /**
     * OpenStack username (string)
     */
    username?: string;
    /**
     * OpenStack volume device path (attaching). Applicable only when `bootFromVolume` is `true`. Omit for auto `/dev/vdb`. (string)
     *
     * > **Note**: `Required*` denotes that either the _name or _id is required but you cannot use both.
     *
     * > **Note**: `Required**` denotes that either the _name or _id is required unless `applicationCredentialId` is defined.
     */
    volumeDevicePath?: string;
    /**
     * OpenStack volume id of existing volume. Applicable only when `bootFromVolume` is `true` (string)
     */
    volumeId?: string;
    /**
     * OpenStack volume name of existing volume. Applicable only when `bootFromVolume` is `true` (string)
     */
    volumeName?: string;
    /**
     * OpenStack volume size (GiB). Required when `bootFromVolume` is `true` (string)
     */
    volumeSize?: string;
    /**
     * Amazon EBS volume type. Default `gp2` (string)
     */
    volumeType?: string;
}

export interface NodeTemplateOutscaleConfig {
    /**
     * AWS access key. Required on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    accessKey: string;
    /**
     * Extra tags for all created resources (e.g. key1=value1,key2=value2) (list)
     */
    extraTagsAlls?: string[];
    /**
     * Extra tags only for instances (e.g. key1=value1,key2=value2) (list)
     */
    extraTagsInstances?: string[];
    /**
     * AWS instance type. Default `t2.micro` (string)
     */
    instanceType?: string;
    /**
     * AWS region. (string)
     */
    region?: string;
    /**
     * Iops for io1 Root Disk. From 1 to 13000.
     */
    rootDiskIops?: number;
    /**
     * Size of the Root Disk (in GB). From 1 to 14901.
     */
    rootDiskSize?: number;
    /**
     * Type of the Root Disk. Possible values are :'standard', 'gp2' or 'io1'.
     */
    rootDiskType?: string;
    /**
     * AWS secret key. Required on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    secretKey: string;
    /**
     * Ids of user defined Security Groups to add to the machine. (list)
     */
    securityGroupIds?: string[];
    /**
     * Outscale Machine Image to use as bootstrap for the VM. Default `ami-2cf1fa3e` (string)
     */
    sourceOmi?: string;
}

export interface NodeTemplateVsphereConfig {
    /**
     * vSphere URL for boot2docker iso image. Default `https://releases.rancher.com/os/latest/rancheros-vmware.iso` (string)
     */
    boot2dockerUrl?: string;
    /**
     * vSphere vm configuration parameters (used for guestinfo) (list)
     */
    cfgparams?: string[];
    /**
     * If you choose creation type vm (clone vm) a name of what vm you want to clone is required. From Rancher v2.3.3 (string)
     */
    cloneFrom?: string;
    /**
     * Cloud Config YAML content to inject as user-data. From Rancher v2.3.3 (string)
     */
    cloudConfig?: string;
    /**
     * vSphere cloud-init file or url to set in the guestinfo (string)
     */
    cloudinit?: string;
    /**
     * If you choose to clone from a content library template specify the name of the library. From Rancher v2.3.3 (string)
     */
    contentLibrary?: string;
    /**
     * CPU count, Default `2` (string)
     */
    cpuCount?: string;
    /**
     * Creation type when creating a new virtual machine. Supported values: vm, template, library, legacy. Default `legacy`. From Rancher v2.3.3 (string)
     */
    creationType?: string;
    /**
     * vSphere custom attributes, format key/value e.g. `200=my custom value`. From Rancher v2.3.3 (List)
     */
    customAttributes?: string[];
    /**
     * vSphere datacenter for docker VM (string)
     */
    datacenter?: string;
    /**
     * vSphere datastore for docker VM (string)
     */
    datastore?: string;
    /**
     * vSphere datastore cluster for virtual machine. From Rancher v2.3.3 (string)
     */
    datastoreCluster?: string;
    /**
     * Disk size if using managed disk. Just for Rancher v2.3.x and above. Default `30` (string)
     */
    diskSize?: string;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter (string)
     */
    folder?: string;
    /**
     * vSphere compute resource where the docker VM will be instantiated. This can be omitted if using a cluster with DRS (string)
     */
    hostsystem?: string;
    /**
     * Memory size (in GiB), Default `4` (string)
     */
    memorySize?: string;
    /**
     * vSphere network where the docker VM will be attached (list)
     */
    networks?: string[];
    /**
     * Set the password for the XML-RPC API authentication (string)
     */
    password?: string;
    /**
     * vSphere resource pool for docker VM (string)
     */
    pool?: string;
    /**
     * SSH password (string)
     */
    sshPassword?: string;
    /**
     * SSH port. Default `22` (string)
     */
    sshPort?: string;
    /**
     * Set the name of the ssh user (string)
     */
    sshUser?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown'ed. Default `staff`. From Rancher v2.3.3 (string)
     */
    sshUserGroup?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2) (string)
     */
    tags?: string[];
    /**
     * OpenStack username (string)
     */
    username?: string;
    /**
     * vSphere vApp IP allocation policy. Supported values are: `dhcp`, `fixed`, `transient` and `fixedAllocated` (string)
     */
    vappIpAllocationPolicy?: string;
    /**
     * vSphere vApp IP protocol for this deployment. Supported values are: `IPv4` and `IPv6` (string)
     */
    vappIpProtocol?: string;
    /**
     * vSphere vApp properties (list)
     */
    vappProperties?: string[];
    /**
     * vSphere OVF environment transports to use for properties. Supported values are: `iso` and `com.vmware.guestInfo` (string)
     */
    vappTransport?: string;
    /**
     * vSphere IP/hostname for vCenter. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x (string)
     */
    vcenter?: string;
    /**
     * vSphere Port for vCenter. Mandatory on Rancher v2.0.x and v2.1.x. Use `rancher2.CloudCredential` from Rancher v2.2.x. Default `443` (string)
     */
    vcenterPort?: string;
}

export interface NotifierDingtalkConfig {
    /**
     * Dingtalk proxy url (string)
     */
    proxyUrl?: string;
    /**
     * Secret for url sign enable (string)
     */
    secret?: string;
    /**
     * Dingtalk url (string)
     */
    url: string;
}

export interface NotifierMsteamsConfig {
    /**
     * Dingtalk proxy url (string)
     */
    proxyUrl?: string;
    /**
     * Dingtalk url (string)
     */
    url: string;
}

export interface NotifierPagerdutyConfig {
    /**
     * Dingtalk proxy url (string)
     */
    proxyUrl?: string;
    /**
     * Pagerduty service key (string)
     */
    serviceKey: string;
}

export interface NotifierSlackConfig {
    /**
     * Slack default recipient (string)
     */
    defaultRecipient: string;
    /**
     * Dingtalk proxy url (string)
     */
    proxyUrl?: string;
    /**
     * Dingtalk url (string)
     */
    url: string;
}

export interface NotifierSmtpConfig {
    /**
     * SMTP default recipient (string)
     */
    defaultRecipient: string;
    /**
     * SMTP host (string)
     */
    host: string;
    /**
     * SMTP password (string)
     */
    password?: string;
    /**
     * SMTP port (int)
     */
    port: number;
    /**
     * SMTP sender (string)
     */
    sender: string;
    /**
     * SMTP tls. Default `true` (bool)
     */
    tls?: boolean;
    /**
     * SMTP username (string)
     */
    username?: string;
}

export interface NotifierWebhookConfig {
    /**
     * Webhook proxy url (string)
     */
    proxyUrl?: string;
    /**
     * Webhook url (string)
     */
    url: string;
}

export interface NotifierWechatConfig {
    /**
     * Wechat agent ID (string)
     */
    agent: string;
    /**
     * Wechat corporation ID (string)
     */
    corp: string;
    /**
     * Slack default recipient (string)
     */
    defaultRecipient: string;
    /**
     * Dingtalk proxy url (string)
     */
    proxyUrl?: string;
    /**
     * Wechat recipient type. Allowed values: `party` | `tag` | `user` (string)
     */
    recipientType?: string;
    /**
     * Secret for url sign enable (string)
     */
    secret: string;
}

export interface PodSecurityPolicyTemplateAllowedCsiDriver {
    /**
     * The name of the PodSecurityPolicyTemplate (string)
     */
    name: string;
}

export interface PodSecurityPolicyTemplateAllowedFlexVolume {
    driver: string;
}

export interface PodSecurityPolicyTemplateAllowedHostPath {
    /**
     * (string)
     */
    pathPrefix: string;
    /**
     * (string)
     */
    readOnly?: boolean;
}

export interface PodSecurityPolicyTemplateFsGroup {
    /**
     * (list)
     */
    ranges: outputs.PodSecurityPolicyTemplateFsGroupRange[];
    /**
     * (string)
     */
    rule?: string;
}

export interface PodSecurityPolicyTemplateFsGroupRange {
    /**
     * (int)
     */
    max: number;
    /**
     * (int)
     */
    min: number;
}

export interface PodSecurityPolicyTemplateHostPort {
    /**
     * (int)
     */
    max: number;
    /**
     * (int)
     */
    min: number;
}

export interface PodSecurityPolicyTemplateRunAsGroup {
    /**
     * (list)
     */
    ranges?: outputs.PodSecurityPolicyTemplateRunAsGroupRange[];
    /**
     * (string)
     */
    rule: string;
}

export interface PodSecurityPolicyTemplateRunAsGroupRange {
    /**
     * (int)
     */
    max: number;
    /**
     * (int)
     */
    min: number;
}

export interface PodSecurityPolicyTemplateRunAsUser {
    /**
     * (list)
     */
    ranges?: outputs.PodSecurityPolicyTemplateRunAsUserRange[];
    /**
     * (string)
     */
    rule: string;
}

export interface PodSecurityPolicyTemplateRunAsUserRange {
    /**
     * (int)
     */
    max: number;
    /**
     * (int)
     */
    min: number;
}

export interface PodSecurityPolicyTemplateRuntimeClass {
    /**
     * (list)
     */
    allowedRuntimeClassNames: string[];
    /**
     * (string)
     */
    defaultRuntimeClassName?: string;
}

export interface PodSecurityPolicyTemplateSeLinux {
    /**
     * (string)
     */
    rule: string;
    /**
     * (list maxitems:1)
     */
    seLinuxOption?: outputs.PodSecurityPolicyTemplateSeLinuxSeLinuxOption;
}

export interface PodSecurityPolicyTemplateSeLinuxSeLinuxOption {
    /**
     * (string)
     */
    level?: string;
    /**
     * (string)
     */
    role?: string;
    /**
     * (string)
     */
    type?: string;
    /**
     * (string)
     */
    user?: string;
}

export interface PodSecurityPolicyTemplateSupplementalGroup {
    /**
     * (list)
     */
    ranges: outputs.PodSecurityPolicyTemplateSupplementalGroupRange[];
    /**
     * (string)
     */
    rule?: string;
}

export interface PodSecurityPolicyTemplateSupplementalGroupRange {
    /**
     * (int)
     */
    max: number;
    /**
     * (int)
     */
    min: number;
}

export interface ProjectAlertGroupRecipient {
    defaultRecipient?: boolean;
    /**
     * Recipient notifier ID (string)
     */
    notifierId: string;
    /**
     * Recipient notifier ID. Supported values : `"pagerduty" | "slack" | "email" | "webhook" | "wechat"` (string)
     */
    notifierType: string;
    /**
     * Recipient (string)
     */
    recipient: string;
}

export interface ProjectAlertRuleMetricRule {
    /**
     * Metric rule comparison. Supported values : `"equal" | "greater-or-equal" | "greater-than" | "less-or-equal" | "less-than" | "not-equal" | "has-value"`. Default: `equal`  (string)
     */
    comparison?: string;
    /**
     * Metric rule description (string)
     */
    description?: string;
    /**
     * Metric rule duration (string)
     */
    duration: string;
    /**
     * Metric rule expression (string)
     */
    expression: string;
    /**
     * Metric rule threshold value (float64)
     */
    thresholdValue: number;
}

export interface ProjectAlertRulePodRule {
    /**
     * Pod rule condition. Supported values : `"notrunning" | "notscheduled" | "restarts"`. Default: `notrunning` (string)
     */
    condition?: string;
    /**
     * Pod ID (string)
     */
    podId: string;
    /**
     * Pod rule restart interval seconds. Default: `300` (int)
     */
    restartIntervalSeconds?: number;
    /**
     * Pod rule restart times. Default: `3`  (int)
     */
    restartTimes?: number;
}

export interface ProjectAlertRuleWorkloadRule {
    /**
     * Workload rule available percentage. Default: `70` (int)
     */
    availablePercentage?: number;
    /**
     * Workload rule selector (map)
     */
    selector?: {[key: string]: any};
    /**
     * Workload ID (string)
     */
    workloadId?: string;
}

export interface ProjectContainerResourceLimit {
    /**
     * CPU limit for containers (string)
     */
    limitsCpu?: string;
    /**
     * Memory limit for containers (string)
     */
    limitsMemory?: string;
    /**
     * CPU reservation for containers (string)
     */
    requestsCpu?: string;
    /**
     * Memory reservation for containers (string)
     */
    requestsMemory?: string;
}

export interface ProjectProjectMonitoringInput {
    /**
     * Key/value answers for monitor input (map)
     */
    answers?: {[key: string]: any};
    /**
     * rancher-monitoring chart version (string)
     */
    version?: string;
}

export interface ProjectResourceQuota {
    /**
     * Default resource quota limit for  namespaces in project (list maxitems:1)
     */
    namespaceDefaultLimit: outputs.ProjectResourceQuotaNamespaceDefaultLimit;
    /**
     * Resource quota limit for project (list maxitems:1)
     */
    projectLimit: outputs.ProjectResourceQuotaProjectLimit;
}

export interface ProjectResourceQuotaNamespaceDefaultLimit {
    /**
     * Limit for config maps in project (string)
     */
    configMaps?: string;
    /**
     * CPU limit for containers (string)
     */
    limitsCpu?: string;
    /**
     * Memory limit for containers (string)
     */
    limitsMemory?: string;
    /**
     * Limit for persistent volume claims in project (string)
     */
    persistentVolumeClaims?: string;
    /**
     * Limit for pods in project (string)
     */
    pods?: string;
    /**
     * Limit for replication controllers in project (string)
     */
    replicationControllers?: string;
    /**
     * CPU reservation for containers (string)
     */
    requestsCpu?: string;
    /**
     * Memory reservation for containers (string)
     */
    requestsMemory?: string;
    /**
     * Limit for requests storage in project (string)
     */
    requestsStorage?: string;
    /**
     * Limit for secrets in project (string)
     */
    secrets?: string;
    services?: string;
    /**
     * Limit for services load balancers in project (string)
     */
    servicesLoadBalancers?: string;
    /**
     * Limit for services node ports in project (string)
     *
     * More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
     */
    servicesNodePorts?: string;
}

export interface ProjectResourceQuotaProjectLimit {
    /**
     * Limit for config maps in project (string)
     */
    configMaps?: string;
    /**
     * CPU limit for containers (string)
     */
    limitsCpu?: string;
    /**
     * Memory limit for containers (string)
     */
    limitsMemory?: string;
    /**
     * Limit for persistent volume claims in project (string)
     */
    persistentVolumeClaims?: string;
    /**
     * Limit for pods in project (string)
     */
    pods?: string;
    /**
     * Limit for replication controllers in project (string)
     */
    replicationControllers?: string;
    /**
     * CPU reservation for containers (string)
     */
    requestsCpu?: string;
    /**
     * Memory reservation for containers (string)
     */
    requestsMemory?: string;
    /**
     * Limit for requests storage in project (string)
     */
    requestsStorage?: string;
    /**
     * Limit for secrets in project (string)
     */
    secrets?: string;
    services?: string;
    /**
     * Limit for services load balancers in project (string)
     */
    servicesLoadBalancers?: string;
    /**
     * Limit for services node ports in project (string)
     *
     * More info at [resource-quotas](https://rancher.com/docs/rancher/v2.x/en/k8s-in-rancher/projects-and-namespaces/resource-quotas/)
     */
    servicesNodePorts?: string;
}

export interface RegistryRegistry {
    /**
     * Address for registry.
     */
    address: string;
    /**
     * Password for the registry (string)
     */
    password?: string;
    /**
     * Username for the registry (string)
     */
    username?: string;
}

export interface RoleTempalteRule {
    /**
     * Policy rule api groups (list)
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls (list)
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names (list)
     */
    resourceNames?: string[];
    /**
     * Policy rule resources (list)
     */
    resources?: string[];
    /**
     * Policy rule verbs. `bind`, `create`, `delete`, `deletecollection`, `escalate`, `get`, `impersonate`, `list`, `patch`, `update`, `use`, `view`, `watch`, `own` and `*` values are supported (list)
     */
    verbs?: string[];
}

export interface RoleTemplateRule {
    /**
     * Policy rule api groups (list)
     */
    apiGroups?: string[];
    /**
     * Policy rule non resource urls (list)
     */
    nonResourceUrls?: string[];
    /**
     * Policy rule resource names (list)
     */
    resourceNames?: string[];
    /**
     * Policy rule resources (list)
     */
    resources?: string[];
    /**
     * Policy rule verbs. `bind`, `create`, `delete`, `deletecollection`, `escalate`, `get`, `impersonate`, `list`, `patch`, `update`, `use`, `view`, `watch`, `own` and `*` values are supported (list)
     */
    verbs?: string[];
}

