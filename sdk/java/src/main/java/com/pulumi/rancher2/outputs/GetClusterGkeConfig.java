// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.rancher2.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetClusterGkeConfig {
    /**
     * @return The IP address range of the container pods
     * 
     */
    private String clusterIpv4Cidr;
    /**
     * @return The contents of the GC credential file
     * 
     */
    private String credential;
    /**
     * @return (Computed) The description for Cluster (string)
     * 
     */
    private @Nullable String description;
    /**
     * @return Size of the disk attached to each node
     * 
     */
    private @Nullable Integer diskSizeGb;
    /**
     * @return Type of the disk attached to each node
     * 
     */
    private String diskType;
    /**
     * @return To enable kubernetes alpha feature
     * 
     */
    private @Nullable Boolean enableAlphaFeature;
    /**
     * @return Specifies whether the node auto-repair is enabled for the node pool
     * 
     */
    private @Nullable Boolean enableAutoRepair;
    /**
     * @return Specifies whether node auto-upgrade is enabled for the node pool
     * 
     */
    private @Nullable Boolean enableAutoUpgrade;
    /**
     * @return Enable horizontal pod autoscaling for the cluster
     * 
     */
    private @Nullable Boolean enableHorizontalPodAutoscaling;
    /**
     * @return Enable http load balancing for the cluster
     * 
     */
    private @Nullable Boolean enableHttpLoadBalancing;
    /**
     * @return Whether to enable the kubernetes dashboard
     * 
     */
    private @Nullable Boolean enableKubernetesDashboard;
    /**
     * @return Whether to enable legacy abac on the cluster
     * 
     */
    private @Nullable Boolean enableLegacyAbac;
    /**
     * @return Whether or not master authorized network is enabled
     * 
     */
    private @Nullable Boolean enableMasterAuthorizedNetwork;
    /**
     * @return Enable network policy config for the cluster
     * 
     */
    private @Nullable Boolean enableNetworkPolicyConfig;
    /**
     * @return Enable nodepool autoscaling
     * 
     */
    private @Nullable Boolean enableNodepoolAutoscaling;
    /**
     * @return Whether the master&#39;s internal IP address is used as the cluster endpoint
     * 
     */
    private @Nullable Boolean enablePrivateEndpoint;
    /**
     * @return Whether nodes have internal IP address only
     * 
     */
    private @Nullable Boolean enablePrivateNodes;
    /**
     * @return Enable stackdriver logging
     * 
     */
    private @Nullable Boolean enableStackdriverLogging;
    /**
     * @return Enable stackdriver monitoring
     * 
     */
    private @Nullable Boolean enableStackdriverMonitoring;
    /**
     * @return The image to use for the worker nodes
     * 
     */
    private String imageType;
    /**
     * @return The IP address range for the cluster pod IPs
     * 
     */
    private String ipPolicyClusterIpv4CidrBlock;
    /**
     * @return The name of the secondary range to be used for the cluster CIDR block
     * 
     */
    private String ipPolicyClusterSecondaryRangeName;
    /**
     * @return Whether a new subnetwork will be created automatically for the cluster
     * 
     */
    private @Nullable Boolean ipPolicyCreateSubnetwork;
    /**
     * @return The IP address range of the instance IPs in this cluster
     * 
     */
    private String ipPolicyNodeIpv4CidrBlock;
    /**
     * @return The IP address range of the services IPs in this cluster
     * 
     */
    private String ipPolicyServicesIpv4CidrBlock;
    /**
     * @return The name of the secondary range to be used for the services CIDR block
     * 
     */
    private String ipPolicyServicesSecondaryRangeName;
    /**
     * @return A custom subnetwork name to be used if createSubnetwork is true
     * 
     */
    private String ipPolicySubnetworkName;
    /**
     * @return Issue a client certificate
     * 
     */
    private @Nullable Boolean issueClientCertificate;
    /**
     * @return Enable the kubernetes dashboard
     * 
     */
    private @Nullable Boolean kubernetesDashboard;
    /**
     * @return (Computed) Labels for Node Pool object (map)
     * 
     */
    private Map<String,String> labels;
    /**
     * @return The number of local SSD disks to be attached to the node
     * 
     */
    private @Nullable Integer localSsdCount;
    /**
     * @return Locations to use for the cluster
     * 
     */
    private List<String> locations;
    /**
     * @return The machine type to use for the worker nodes
     * 
     */
    private String machineType;
    /**
     * @return When to performance updates on the nodes, in 24-hour time
     * 
     */
    private String maintenanceWindow;
    /**
     * @return Define up to 10 external networks that could access Kubernetes master through HTTPS
     * 
     */
    private @Nullable List<String> masterAuthorizedNetworkCidrBlocks;
    /**
     * @return The IP range in CIDR notation to use for the hosted master network
     * 
     */
    private String masterIpv4CidrBlock;
    /**
     * @return The kubernetes master version
     * 
     */
    private String masterVersion;
    /**
     * @return Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
     * 
     */
    private @Nullable Integer maxNodeCount;
    /**
     * @return Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
     * 
     */
    private @Nullable Integer minNodeCount;
    /**
     * @return The network to use for the cluster
     * 
     */
    private String network;
    /**
     * @return The number of nodes to create in this cluster
     * 
     */
    private @Nullable Integer nodeCount;
    /**
     * @return The ID of the cluster node pool
     * 
     */
    private String nodePool;
    /**
     * @return The version of kubernetes to use on the nodes
     * 
     */
    private String nodeVersion;
    /**
     * @return The set of Google API scopes to be made available on all of the node VMs under the default service account
     * 
     */
    private List<String> oauthScopes;
    /**
     * @return Whether the nodes are created as preemptible VM instances
     * 
     */
    private @Nullable Boolean preemptible;
    /**
     * @return The ID of your project to use when creating a cluster
     * 
     */
    private String projectId;
    /**
     * @return The region to launch the cluster. Region or zone should be used
     * 
     */
    private @Nullable String region;
    /**
     * @return The map of Kubernetes labels (key/value pairs) to be applied to each cluster
     * 
     */
    private Map<String,String> resourceLabels;
    /**
     * @return The Google Cloud Platform Service Account to be used by the node VMs
     * 
     */
    private String serviceAccount;
    /**
     * @return The sub-network to use for the cluster
     * 
     */
    private String subNetwork;
    /**
     * @return List of kubernetes taints to be applied to each node
     * 
     */
    private @Nullable List<String> taints;
    /**
     * @return Whether alias IPs will be used for pod IPs in the cluster
     * 
     */
    private @Nullable Boolean useIpAliases;
    /**
     * @return The zone to launch the cluster. Zone or region should be used
     * 
     */
    private @Nullable String zone;

    private GetClusterGkeConfig() {}
    /**
     * @return The IP address range of the container pods
     * 
     */
    public String clusterIpv4Cidr() {
        return this.clusterIpv4Cidr;
    }
    /**
     * @return The contents of the GC credential file
     * 
     */
    public String credential() {
        return this.credential;
    }
    /**
     * @return (Computed) The description for Cluster (string)
     * 
     */
    public Optional<String> description() {
        return Optional.ofNullable(this.description);
    }
    /**
     * @return Size of the disk attached to each node
     * 
     */
    public Optional<Integer> diskSizeGb() {
        return Optional.ofNullable(this.diskSizeGb);
    }
    /**
     * @return Type of the disk attached to each node
     * 
     */
    public String diskType() {
        return this.diskType;
    }
    /**
     * @return To enable kubernetes alpha feature
     * 
     */
    public Optional<Boolean> enableAlphaFeature() {
        return Optional.ofNullable(this.enableAlphaFeature);
    }
    /**
     * @return Specifies whether the node auto-repair is enabled for the node pool
     * 
     */
    public Optional<Boolean> enableAutoRepair() {
        return Optional.ofNullable(this.enableAutoRepair);
    }
    /**
     * @return Specifies whether node auto-upgrade is enabled for the node pool
     * 
     */
    public Optional<Boolean> enableAutoUpgrade() {
        return Optional.ofNullable(this.enableAutoUpgrade);
    }
    /**
     * @return Enable horizontal pod autoscaling for the cluster
     * 
     */
    public Optional<Boolean> enableHorizontalPodAutoscaling() {
        return Optional.ofNullable(this.enableHorizontalPodAutoscaling);
    }
    /**
     * @return Enable http load balancing for the cluster
     * 
     */
    public Optional<Boolean> enableHttpLoadBalancing() {
        return Optional.ofNullable(this.enableHttpLoadBalancing);
    }
    /**
     * @return Whether to enable the kubernetes dashboard
     * 
     */
    public Optional<Boolean> enableKubernetesDashboard() {
        return Optional.ofNullable(this.enableKubernetesDashboard);
    }
    /**
     * @return Whether to enable legacy abac on the cluster
     * 
     */
    public Optional<Boolean> enableLegacyAbac() {
        return Optional.ofNullable(this.enableLegacyAbac);
    }
    /**
     * @return Whether or not master authorized network is enabled
     * 
     */
    public Optional<Boolean> enableMasterAuthorizedNetwork() {
        return Optional.ofNullable(this.enableMasterAuthorizedNetwork);
    }
    /**
     * @return Enable network policy config for the cluster
     * 
     */
    public Optional<Boolean> enableNetworkPolicyConfig() {
        return Optional.ofNullable(this.enableNetworkPolicyConfig);
    }
    /**
     * @return Enable nodepool autoscaling
     * 
     */
    public Optional<Boolean> enableNodepoolAutoscaling() {
        return Optional.ofNullable(this.enableNodepoolAutoscaling);
    }
    /**
     * @return Whether the master&#39;s internal IP address is used as the cluster endpoint
     * 
     */
    public Optional<Boolean> enablePrivateEndpoint() {
        return Optional.ofNullable(this.enablePrivateEndpoint);
    }
    /**
     * @return Whether nodes have internal IP address only
     * 
     */
    public Optional<Boolean> enablePrivateNodes() {
        return Optional.ofNullable(this.enablePrivateNodes);
    }
    /**
     * @return Enable stackdriver logging
     * 
     */
    public Optional<Boolean> enableStackdriverLogging() {
        return Optional.ofNullable(this.enableStackdriverLogging);
    }
    /**
     * @return Enable stackdriver monitoring
     * 
     */
    public Optional<Boolean> enableStackdriverMonitoring() {
        return Optional.ofNullable(this.enableStackdriverMonitoring);
    }
    /**
     * @return The image to use for the worker nodes
     * 
     */
    public String imageType() {
        return this.imageType;
    }
    /**
     * @return The IP address range for the cluster pod IPs
     * 
     */
    public String ipPolicyClusterIpv4CidrBlock() {
        return this.ipPolicyClusterIpv4CidrBlock;
    }
    /**
     * @return The name of the secondary range to be used for the cluster CIDR block
     * 
     */
    public String ipPolicyClusterSecondaryRangeName() {
        return this.ipPolicyClusterSecondaryRangeName;
    }
    /**
     * @return Whether a new subnetwork will be created automatically for the cluster
     * 
     */
    public Optional<Boolean> ipPolicyCreateSubnetwork() {
        return Optional.ofNullable(this.ipPolicyCreateSubnetwork);
    }
    /**
     * @return The IP address range of the instance IPs in this cluster
     * 
     */
    public String ipPolicyNodeIpv4CidrBlock() {
        return this.ipPolicyNodeIpv4CidrBlock;
    }
    /**
     * @return The IP address range of the services IPs in this cluster
     * 
     */
    public String ipPolicyServicesIpv4CidrBlock() {
        return this.ipPolicyServicesIpv4CidrBlock;
    }
    /**
     * @return The name of the secondary range to be used for the services CIDR block
     * 
     */
    public String ipPolicyServicesSecondaryRangeName() {
        return this.ipPolicyServicesSecondaryRangeName;
    }
    /**
     * @return A custom subnetwork name to be used if createSubnetwork is true
     * 
     */
    public String ipPolicySubnetworkName() {
        return this.ipPolicySubnetworkName;
    }
    /**
     * @return Issue a client certificate
     * 
     */
    public Optional<Boolean> issueClientCertificate() {
        return Optional.ofNullable(this.issueClientCertificate);
    }
    /**
     * @return Enable the kubernetes dashboard
     * 
     */
    public Optional<Boolean> kubernetesDashboard() {
        return Optional.ofNullable(this.kubernetesDashboard);
    }
    /**
     * @return (Computed) Labels for Node Pool object (map)
     * 
     */
    public Map<String,String> labels() {
        return this.labels;
    }
    /**
     * @return The number of local SSD disks to be attached to the node
     * 
     */
    public Optional<Integer> localSsdCount() {
        return Optional.ofNullable(this.localSsdCount);
    }
    /**
     * @return Locations to use for the cluster
     * 
     */
    public List<String> locations() {
        return this.locations;
    }
    /**
     * @return The machine type to use for the worker nodes
     * 
     */
    public String machineType() {
        return this.machineType;
    }
    /**
     * @return When to performance updates on the nodes, in 24-hour time
     * 
     */
    public String maintenanceWindow() {
        return this.maintenanceWindow;
    }
    /**
     * @return Define up to 10 external networks that could access Kubernetes master through HTTPS
     * 
     */
    public List<String> masterAuthorizedNetworkCidrBlocks() {
        return this.masterAuthorizedNetworkCidrBlocks == null ? List.of() : this.masterAuthorizedNetworkCidrBlocks;
    }
    /**
     * @return The IP range in CIDR notation to use for the hosted master network
     * 
     */
    public String masterIpv4CidrBlock() {
        return this.masterIpv4CidrBlock;
    }
    /**
     * @return The kubernetes master version
     * 
     */
    public String masterVersion() {
        return this.masterVersion;
    }
    /**
     * @return Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
     * 
     */
    public Optional<Integer> maxNodeCount() {
        return Optional.ofNullable(this.maxNodeCount);
    }
    /**
     * @return Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
     * 
     */
    public Optional<Integer> minNodeCount() {
        return Optional.ofNullable(this.minNodeCount);
    }
    /**
     * @return The network to use for the cluster
     * 
     */
    public String network() {
        return this.network;
    }
    /**
     * @return The number of nodes to create in this cluster
     * 
     */
    public Optional<Integer> nodeCount() {
        return Optional.ofNullable(this.nodeCount);
    }
    /**
     * @return The ID of the cluster node pool
     * 
     */
    public String nodePool() {
        return this.nodePool;
    }
    /**
     * @return The version of kubernetes to use on the nodes
     * 
     */
    public String nodeVersion() {
        return this.nodeVersion;
    }
    /**
     * @return The set of Google API scopes to be made available on all of the node VMs under the default service account
     * 
     */
    public List<String> oauthScopes() {
        return this.oauthScopes;
    }
    /**
     * @return Whether the nodes are created as preemptible VM instances
     * 
     */
    public Optional<Boolean> preemptible() {
        return Optional.ofNullable(this.preemptible);
    }
    /**
     * @return The ID of your project to use when creating a cluster
     * 
     */
    public String projectId() {
        return this.projectId;
    }
    /**
     * @return The region to launch the cluster. Region or zone should be used
     * 
     */
    public Optional<String> region() {
        return Optional.ofNullable(this.region);
    }
    /**
     * @return The map of Kubernetes labels (key/value pairs) to be applied to each cluster
     * 
     */
    public Map<String,String> resourceLabels() {
        return this.resourceLabels;
    }
    /**
     * @return The Google Cloud Platform Service Account to be used by the node VMs
     * 
     */
    public String serviceAccount() {
        return this.serviceAccount;
    }
    /**
     * @return The sub-network to use for the cluster
     * 
     */
    public String subNetwork() {
        return this.subNetwork;
    }
    /**
     * @return List of kubernetes taints to be applied to each node
     * 
     */
    public List<String> taints() {
        return this.taints == null ? List.of() : this.taints;
    }
    /**
     * @return Whether alias IPs will be used for pod IPs in the cluster
     * 
     */
    public Optional<Boolean> useIpAliases() {
        return Optional.ofNullable(this.useIpAliases);
    }
    /**
     * @return The zone to launch the cluster. Zone or region should be used
     * 
     */
    public Optional<String> zone() {
        return Optional.ofNullable(this.zone);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetClusterGkeConfig defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private String clusterIpv4Cidr;
        private String credential;
        private @Nullable String description;
        private @Nullable Integer diskSizeGb;
        private String diskType;
        private @Nullable Boolean enableAlphaFeature;
        private @Nullable Boolean enableAutoRepair;
        private @Nullable Boolean enableAutoUpgrade;
        private @Nullable Boolean enableHorizontalPodAutoscaling;
        private @Nullable Boolean enableHttpLoadBalancing;
        private @Nullable Boolean enableKubernetesDashboard;
        private @Nullable Boolean enableLegacyAbac;
        private @Nullable Boolean enableMasterAuthorizedNetwork;
        private @Nullable Boolean enableNetworkPolicyConfig;
        private @Nullable Boolean enableNodepoolAutoscaling;
        private @Nullable Boolean enablePrivateEndpoint;
        private @Nullable Boolean enablePrivateNodes;
        private @Nullable Boolean enableStackdriverLogging;
        private @Nullable Boolean enableStackdriverMonitoring;
        private String imageType;
        private String ipPolicyClusterIpv4CidrBlock;
        private String ipPolicyClusterSecondaryRangeName;
        private @Nullable Boolean ipPolicyCreateSubnetwork;
        private String ipPolicyNodeIpv4CidrBlock;
        private String ipPolicyServicesIpv4CidrBlock;
        private String ipPolicyServicesSecondaryRangeName;
        private String ipPolicySubnetworkName;
        private @Nullable Boolean issueClientCertificate;
        private @Nullable Boolean kubernetesDashboard;
        private Map<String,String> labels;
        private @Nullable Integer localSsdCount;
        private List<String> locations;
        private String machineType;
        private String maintenanceWindow;
        private @Nullable List<String> masterAuthorizedNetworkCidrBlocks;
        private String masterIpv4CidrBlock;
        private String masterVersion;
        private @Nullable Integer maxNodeCount;
        private @Nullable Integer minNodeCount;
        private String network;
        private @Nullable Integer nodeCount;
        private String nodePool;
        private String nodeVersion;
        private List<String> oauthScopes;
        private @Nullable Boolean preemptible;
        private String projectId;
        private @Nullable String region;
        private Map<String,String> resourceLabels;
        private String serviceAccount;
        private String subNetwork;
        private @Nullable List<String> taints;
        private @Nullable Boolean useIpAliases;
        private @Nullable String zone;
        public Builder() {}
        public Builder(GetClusterGkeConfig defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.clusterIpv4Cidr = defaults.clusterIpv4Cidr;
    	      this.credential = defaults.credential;
    	      this.description = defaults.description;
    	      this.diskSizeGb = defaults.diskSizeGb;
    	      this.diskType = defaults.diskType;
    	      this.enableAlphaFeature = defaults.enableAlphaFeature;
    	      this.enableAutoRepair = defaults.enableAutoRepair;
    	      this.enableAutoUpgrade = defaults.enableAutoUpgrade;
    	      this.enableHorizontalPodAutoscaling = defaults.enableHorizontalPodAutoscaling;
    	      this.enableHttpLoadBalancing = defaults.enableHttpLoadBalancing;
    	      this.enableKubernetesDashboard = defaults.enableKubernetesDashboard;
    	      this.enableLegacyAbac = defaults.enableLegacyAbac;
    	      this.enableMasterAuthorizedNetwork = defaults.enableMasterAuthorizedNetwork;
    	      this.enableNetworkPolicyConfig = defaults.enableNetworkPolicyConfig;
    	      this.enableNodepoolAutoscaling = defaults.enableNodepoolAutoscaling;
    	      this.enablePrivateEndpoint = defaults.enablePrivateEndpoint;
    	      this.enablePrivateNodes = defaults.enablePrivateNodes;
    	      this.enableStackdriverLogging = defaults.enableStackdriverLogging;
    	      this.enableStackdriverMonitoring = defaults.enableStackdriverMonitoring;
    	      this.imageType = defaults.imageType;
    	      this.ipPolicyClusterIpv4CidrBlock = defaults.ipPolicyClusterIpv4CidrBlock;
    	      this.ipPolicyClusterSecondaryRangeName = defaults.ipPolicyClusterSecondaryRangeName;
    	      this.ipPolicyCreateSubnetwork = defaults.ipPolicyCreateSubnetwork;
    	      this.ipPolicyNodeIpv4CidrBlock = defaults.ipPolicyNodeIpv4CidrBlock;
    	      this.ipPolicyServicesIpv4CidrBlock = defaults.ipPolicyServicesIpv4CidrBlock;
    	      this.ipPolicyServicesSecondaryRangeName = defaults.ipPolicyServicesSecondaryRangeName;
    	      this.ipPolicySubnetworkName = defaults.ipPolicySubnetworkName;
    	      this.issueClientCertificate = defaults.issueClientCertificate;
    	      this.kubernetesDashboard = defaults.kubernetesDashboard;
    	      this.labels = defaults.labels;
    	      this.localSsdCount = defaults.localSsdCount;
    	      this.locations = defaults.locations;
    	      this.machineType = defaults.machineType;
    	      this.maintenanceWindow = defaults.maintenanceWindow;
    	      this.masterAuthorizedNetworkCidrBlocks = defaults.masterAuthorizedNetworkCidrBlocks;
    	      this.masterIpv4CidrBlock = defaults.masterIpv4CidrBlock;
    	      this.masterVersion = defaults.masterVersion;
    	      this.maxNodeCount = defaults.maxNodeCount;
    	      this.minNodeCount = defaults.minNodeCount;
    	      this.network = defaults.network;
    	      this.nodeCount = defaults.nodeCount;
    	      this.nodePool = defaults.nodePool;
    	      this.nodeVersion = defaults.nodeVersion;
    	      this.oauthScopes = defaults.oauthScopes;
    	      this.preemptible = defaults.preemptible;
    	      this.projectId = defaults.projectId;
    	      this.region = defaults.region;
    	      this.resourceLabels = defaults.resourceLabels;
    	      this.serviceAccount = defaults.serviceAccount;
    	      this.subNetwork = defaults.subNetwork;
    	      this.taints = defaults.taints;
    	      this.useIpAliases = defaults.useIpAliases;
    	      this.zone = defaults.zone;
        }

        @CustomType.Setter
        public Builder clusterIpv4Cidr(String clusterIpv4Cidr) {
            if (clusterIpv4Cidr == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "clusterIpv4Cidr");
            }
            this.clusterIpv4Cidr = clusterIpv4Cidr;
            return this;
        }
        @CustomType.Setter
        public Builder credential(String credential) {
            if (credential == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "credential");
            }
            this.credential = credential;
            return this;
        }
        @CustomType.Setter
        public Builder description(@Nullable String description) {

            this.description = description;
            return this;
        }
        @CustomType.Setter
        public Builder diskSizeGb(@Nullable Integer diskSizeGb) {

            this.diskSizeGb = diskSizeGb;
            return this;
        }
        @CustomType.Setter
        public Builder diskType(String diskType) {
            if (diskType == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "diskType");
            }
            this.diskType = diskType;
            return this;
        }
        @CustomType.Setter
        public Builder enableAlphaFeature(@Nullable Boolean enableAlphaFeature) {

            this.enableAlphaFeature = enableAlphaFeature;
            return this;
        }
        @CustomType.Setter
        public Builder enableAutoRepair(@Nullable Boolean enableAutoRepair) {

            this.enableAutoRepair = enableAutoRepair;
            return this;
        }
        @CustomType.Setter
        public Builder enableAutoUpgrade(@Nullable Boolean enableAutoUpgrade) {

            this.enableAutoUpgrade = enableAutoUpgrade;
            return this;
        }
        @CustomType.Setter
        public Builder enableHorizontalPodAutoscaling(@Nullable Boolean enableHorizontalPodAutoscaling) {

            this.enableHorizontalPodAutoscaling = enableHorizontalPodAutoscaling;
            return this;
        }
        @CustomType.Setter
        public Builder enableHttpLoadBalancing(@Nullable Boolean enableHttpLoadBalancing) {

            this.enableHttpLoadBalancing = enableHttpLoadBalancing;
            return this;
        }
        @CustomType.Setter
        public Builder enableKubernetesDashboard(@Nullable Boolean enableKubernetesDashboard) {

            this.enableKubernetesDashboard = enableKubernetesDashboard;
            return this;
        }
        @CustomType.Setter
        public Builder enableLegacyAbac(@Nullable Boolean enableLegacyAbac) {

            this.enableLegacyAbac = enableLegacyAbac;
            return this;
        }
        @CustomType.Setter
        public Builder enableMasterAuthorizedNetwork(@Nullable Boolean enableMasterAuthorizedNetwork) {

            this.enableMasterAuthorizedNetwork = enableMasterAuthorizedNetwork;
            return this;
        }
        @CustomType.Setter
        public Builder enableNetworkPolicyConfig(@Nullable Boolean enableNetworkPolicyConfig) {

            this.enableNetworkPolicyConfig = enableNetworkPolicyConfig;
            return this;
        }
        @CustomType.Setter
        public Builder enableNodepoolAutoscaling(@Nullable Boolean enableNodepoolAutoscaling) {

            this.enableNodepoolAutoscaling = enableNodepoolAutoscaling;
            return this;
        }
        @CustomType.Setter
        public Builder enablePrivateEndpoint(@Nullable Boolean enablePrivateEndpoint) {

            this.enablePrivateEndpoint = enablePrivateEndpoint;
            return this;
        }
        @CustomType.Setter
        public Builder enablePrivateNodes(@Nullable Boolean enablePrivateNodes) {

            this.enablePrivateNodes = enablePrivateNodes;
            return this;
        }
        @CustomType.Setter
        public Builder enableStackdriverLogging(@Nullable Boolean enableStackdriverLogging) {

            this.enableStackdriverLogging = enableStackdriverLogging;
            return this;
        }
        @CustomType.Setter
        public Builder enableStackdriverMonitoring(@Nullable Boolean enableStackdriverMonitoring) {

            this.enableStackdriverMonitoring = enableStackdriverMonitoring;
            return this;
        }
        @CustomType.Setter
        public Builder imageType(String imageType) {
            if (imageType == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "imageType");
            }
            this.imageType = imageType;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicyClusterIpv4CidrBlock(String ipPolicyClusterIpv4CidrBlock) {
            if (ipPolicyClusterIpv4CidrBlock == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "ipPolicyClusterIpv4CidrBlock");
            }
            this.ipPolicyClusterIpv4CidrBlock = ipPolicyClusterIpv4CidrBlock;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicyClusterSecondaryRangeName(String ipPolicyClusterSecondaryRangeName) {
            if (ipPolicyClusterSecondaryRangeName == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "ipPolicyClusterSecondaryRangeName");
            }
            this.ipPolicyClusterSecondaryRangeName = ipPolicyClusterSecondaryRangeName;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicyCreateSubnetwork(@Nullable Boolean ipPolicyCreateSubnetwork) {

            this.ipPolicyCreateSubnetwork = ipPolicyCreateSubnetwork;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicyNodeIpv4CidrBlock(String ipPolicyNodeIpv4CidrBlock) {
            if (ipPolicyNodeIpv4CidrBlock == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "ipPolicyNodeIpv4CidrBlock");
            }
            this.ipPolicyNodeIpv4CidrBlock = ipPolicyNodeIpv4CidrBlock;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicyServicesIpv4CidrBlock(String ipPolicyServicesIpv4CidrBlock) {
            if (ipPolicyServicesIpv4CidrBlock == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "ipPolicyServicesIpv4CidrBlock");
            }
            this.ipPolicyServicesIpv4CidrBlock = ipPolicyServicesIpv4CidrBlock;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicyServicesSecondaryRangeName(String ipPolicyServicesSecondaryRangeName) {
            if (ipPolicyServicesSecondaryRangeName == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "ipPolicyServicesSecondaryRangeName");
            }
            this.ipPolicyServicesSecondaryRangeName = ipPolicyServicesSecondaryRangeName;
            return this;
        }
        @CustomType.Setter
        public Builder ipPolicySubnetworkName(String ipPolicySubnetworkName) {
            if (ipPolicySubnetworkName == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "ipPolicySubnetworkName");
            }
            this.ipPolicySubnetworkName = ipPolicySubnetworkName;
            return this;
        }
        @CustomType.Setter
        public Builder issueClientCertificate(@Nullable Boolean issueClientCertificate) {

            this.issueClientCertificate = issueClientCertificate;
            return this;
        }
        @CustomType.Setter
        public Builder kubernetesDashboard(@Nullable Boolean kubernetesDashboard) {

            this.kubernetesDashboard = kubernetesDashboard;
            return this;
        }
        @CustomType.Setter
        public Builder labels(Map<String,String> labels) {
            if (labels == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "labels");
            }
            this.labels = labels;
            return this;
        }
        @CustomType.Setter
        public Builder localSsdCount(@Nullable Integer localSsdCount) {

            this.localSsdCount = localSsdCount;
            return this;
        }
        @CustomType.Setter
        public Builder locations(List<String> locations) {
            if (locations == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "locations");
            }
            this.locations = locations;
            return this;
        }
        public Builder locations(String... locations) {
            return locations(List.of(locations));
        }
        @CustomType.Setter
        public Builder machineType(String machineType) {
            if (machineType == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "machineType");
            }
            this.machineType = machineType;
            return this;
        }
        @CustomType.Setter
        public Builder maintenanceWindow(String maintenanceWindow) {
            if (maintenanceWindow == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "maintenanceWindow");
            }
            this.maintenanceWindow = maintenanceWindow;
            return this;
        }
        @CustomType.Setter
        public Builder masterAuthorizedNetworkCidrBlocks(@Nullable List<String> masterAuthorizedNetworkCidrBlocks) {

            this.masterAuthorizedNetworkCidrBlocks = masterAuthorizedNetworkCidrBlocks;
            return this;
        }
        public Builder masterAuthorizedNetworkCidrBlocks(String... masterAuthorizedNetworkCidrBlocks) {
            return masterAuthorizedNetworkCidrBlocks(List.of(masterAuthorizedNetworkCidrBlocks));
        }
        @CustomType.Setter
        public Builder masterIpv4CidrBlock(String masterIpv4CidrBlock) {
            if (masterIpv4CidrBlock == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "masterIpv4CidrBlock");
            }
            this.masterIpv4CidrBlock = masterIpv4CidrBlock;
            return this;
        }
        @CustomType.Setter
        public Builder masterVersion(String masterVersion) {
            if (masterVersion == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "masterVersion");
            }
            this.masterVersion = masterVersion;
            return this;
        }
        @CustomType.Setter
        public Builder maxNodeCount(@Nullable Integer maxNodeCount) {

            this.maxNodeCount = maxNodeCount;
            return this;
        }
        @CustomType.Setter
        public Builder minNodeCount(@Nullable Integer minNodeCount) {

            this.minNodeCount = minNodeCount;
            return this;
        }
        @CustomType.Setter
        public Builder network(String network) {
            if (network == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "network");
            }
            this.network = network;
            return this;
        }
        @CustomType.Setter
        public Builder nodeCount(@Nullable Integer nodeCount) {

            this.nodeCount = nodeCount;
            return this;
        }
        @CustomType.Setter
        public Builder nodePool(String nodePool) {
            if (nodePool == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "nodePool");
            }
            this.nodePool = nodePool;
            return this;
        }
        @CustomType.Setter
        public Builder nodeVersion(String nodeVersion) {
            if (nodeVersion == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "nodeVersion");
            }
            this.nodeVersion = nodeVersion;
            return this;
        }
        @CustomType.Setter
        public Builder oauthScopes(List<String> oauthScopes) {
            if (oauthScopes == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "oauthScopes");
            }
            this.oauthScopes = oauthScopes;
            return this;
        }
        public Builder oauthScopes(String... oauthScopes) {
            return oauthScopes(List.of(oauthScopes));
        }
        @CustomType.Setter
        public Builder preemptible(@Nullable Boolean preemptible) {

            this.preemptible = preemptible;
            return this;
        }
        @CustomType.Setter
        public Builder projectId(String projectId) {
            if (projectId == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "projectId");
            }
            this.projectId = projectId;
            return this;
        }
        @CustomType.Setter
        public Builder region(@Nullable String region) {

            this.region = region;
            return this;
        }
        @CustomType.Setter
        public Builder resourceLabels(Map<String,String> resourceLabels) {
            if (resourceLabels == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "resourceLabels");
            }
            this.resourceLabels = resourceLabels;
            return this;
        }
        @CustomType.Setter
        public Builder serviceAccount(String serviceAccount) {
            if (serviceAccount == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "serviceAccount");
            }
            this.serviceAccount = serviceAccount;
            return this;
        }
        @CustomType.Setter
        public Builder subNetwork(String subNetwork) {
            if (subNetwork == null) {
              throw new MissingRequiredPropertyException("GetClusterGkeConfig", "subNetwork");
            }
            this.subNetwork = subNetwork;
            return this;
        }
        @CustomType.Setter
        public Builder taints(@Nullable List<String> taints) {

            this.taints = taints;
            return this;
        }
        public Builder taints(String... taints) {
            return taints(List.of(taints));
        }
        @CustomType.Setter
        public Builder useIpAliases(@Nullable Boolean useIpAliases) {

            this.useIpAliases = useIpAliases;
            return this;
        }
        @CustomType.Setter
        public Builder zone(@Nullable String zone) {

            this.zone = zone;
            return this;
        }
        public GetClusterGkeConfig build() {
            final var _resultValue = new GetClusterGkeConfig();
            _resultValue.clusterIpv4Cidr = clusterIpv4Cidr;
            _resultValue.credential = credential;
            _resultValue.description = description;
            _resultValue.diskSizeGb = diskSizeGb;
            _resultValue.diskType = diskType;
            _resultValue.enableAlphaFeature = enableAlphaFeature;
            _resultValue.enableAutoRepair = enableAutoRepair;
            _resultValue.enableAutoUpgrade = enableAutoUpgrade;
            _resultValue.enableHorizontalPodAutoscaling = enableHorizontalPodAutoscaling;
            _resultValue.enableHttpLoadBalancing = enableHttpLoadBalancing;
            _resultValue.enableKubernetesDashboard = enableKubernetesDashboard;
            _resultValue.enableLegacyAbac = enableLegacyAbac;
            _resultValue.enableMasterAuthorizedNetwork = enableMasterAuthorizedNetwork;
            _resultValue.enableNetworkPolicyConfig = enableNetworkPolicyConfig;
            _resultValue.enableNodepoolAutoscaling = enableNodepoolAutoscaling;
            _resultValue.enablePrivateEndpoint = enablePrivateEndpoint;
            _resultValue.enablePrivateNodes = enablePrivateNodes;
            _resultValue.enableStackdriverLogging = enableStackdriverLogging;
            _resultValue.enableStackdriverMonitoring = enableStackdriverMonitoring;
            _resultValue.imageType = imageType;
            _resultValue.ipPolicyClusterIpv4CidrBlock = ipPolicyClusterIpv4CidrBlock;
            _resultValue.ipPolicyClusterSecondaryRangeName = ipPolicyClusterSecondaryRangeName;
            _resultValue.ipPolicyCreateSubnetwork = ipPolicyCreateSubnetwork;
            _resultValue.ipPolicyNodeIpv4CidrBlock = ipPolicyNodeIpv4CidrBlock;
            _resultValue.ipPolicyServicesIpv4CidrBlock = ipPolicyServicesIpv4CidrBlock;
            _resultValue.ipPolicyServicesSecondaryRangeName = ipPolicyServicesSecondaryRangeName;
            _resultValue.ipPolicySubnetworkName = ipPolicySubnetworkName;
            _resultValue.issueClientCertificate = issueClientCertificate;
            _resultValue.kubernetesDashboard = kubernetesDashboard;
            _resultValue.labels = labels;
            _resultValue.localSsdCount = localSsdCount;
            _resultValue.locations = locations;
            _resultValue.machineType = machineType;
            _resultValue.maintenanceWindow = maintenanceWindow;
            _resultValue.masterAuthorizedNetworkCidrBlocks = masterAuthorizedNetworkCidrBlocks;
            _resultValue.masterIpv4CidrBlock = masterIpv4CidrBlock;
            _resultValue.masterVersion = masterVersion;
            _resultValue.maxNodeCount = maxNodeCount;
            _resultValue.minNodeCount = minNodeCount;
            _resultValue.network = network;
            _resultValue.nodeCount = nodeCount;
            _resultValue.nodePool = nodePool;
            _resultValue.nodeVersion = nodeVersion;
            _resultValue.oauthScopes = oauthScopes;
            _resultValue.preemptible = preemptible;
            _resultValue.projectId = projectId;
            _resultValue.region = region;
            _resultValue.resourceLabels = resourceLabels;
            _resultValue.serviceAccount = serviceAccount;
            _resultValue.subNetwork = subNetwork;
            _resultValue.taints = taints;
            _resultValue.useIpAliases = useIpAliases;
            _resultValue.zone = zone;
            return _resultValue;
        }
    }
}
