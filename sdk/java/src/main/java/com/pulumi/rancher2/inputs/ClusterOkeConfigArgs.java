// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.rancher2.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterOkeConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterOkeConfigArgs Empty = new ClusterOkeConfigArgs();

    /**
     * Optionally specify a cluster type of basic or enhanced
     * 
     */
    @Import(name="clusterType")
    private @Nullable Output<String> clusterType;

    /**
     * @return Optionally specify a cluster type of basic or enhanced
     * 
     */
    public Optional<Output<String>> clusterType() {
        return Optional.ofNullable(this.clusterType);
    }

    /**
     * The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
     * 
     */
    @Import(name="compartmentId", required=true)
    private Output<String> compartmentId;

    /**
     * @return The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
     * 
     */
    public Output<String> compartmentId() {
        return this.compartmentId;
    }

    /**
     * The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
     * 
     */
    @Import(name="controlPlaneSubnetName")
    private @Nullable Output<String> controlPlaneSubnetName;

    /**
     * @return The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
     * 
     */
    public Optional<Output<String>> controlPlaneSubnetName() {
        return Optional.ofNullable(this.controlPlaneSubnetName);
    }

    /**
     * An optional custom boot volume size (in GB) for the nodes
     * 
     */
    @Import(name="customBootVolumeSize")
    private @Nullable Output<Integer> customBootVolumeSize;

    /**
     * @return An optional custom boot volume size (in GB) for the nodes
     * 
     */
    public Optional<Output<Integer>> customBootVolumeSize() {
        return Optional.ofNullable(this.customBootVolumeSize);
    }

    /**
     * The description for Cluster (string)
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description for Cluster (string)
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Enable the kubernetes dashboard
     * 
     */
    @Import(name="enableKubernetesDashboard")
    private @Nullable Output<Boolean> enableKubernetesDashboard;

    /**
     * @return Enable the kubernetes dashboard
     * 
     */
    public Optional<Output<Boolean>> enableKubernetesDashboard() {
        return Optional.ofNullable(this.enableKubernetesDashboard);
    }

    /**
     * Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
     * 
     */
    @Import(name="enablePrivateControlPlane")
    private @Nullable Output<Boolean> enablePrivateControlPlane;

    /**
     * @return Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
     * 
     */
    public Optional<Output<Boolean>> enablePrivateControlPlane() {
        return Optional.ofNullable(this.enablePrivateControlPlane);
    }

    /**
     * Whether worker nodes are deployed into a new private subnet
     * 
     */
    @Import(name="enablePrivateNodes")
    private @Nullable Output<Boolean> enablePrivateNodes;

    /**
     * @return Whether worker nodes are deployed into a new private subnet
     * 
     */
    public Optional<Output<Boolean>> enablePrivateNodes() {
        return Optional.ofNullable(this.enablePrivateNodes);
    }

    /**
     * The optional grace period in minutes to allow cordon and drain to complete successfuly
     * 
     */
    @Import(name="evictionGraceDuration")
    private @Nullable Output<String> evictionGraceDuration;

    /**
     * @return The optional grace period in minutes to allow cordon and drain to complete successfuly
     * 
     */
    public Optional<Output<String>> evictionGraceDuration() {
        return Optional.ofNullable(this.evictionGraceDuration);
    }

    /**
     * The fingerprint corresponding to the specified user&#39;s private API Key
     * 
     */
    @Import(name="fingerprint")
    private @Nullable Output<String> fingerprint;

    /**
     * @return The fingerprint corresponding to the specified user&#39;s private API Key
     * 
     */
    public Optional<Output<String>> fingerprint() {
        return Optional.ofNullable(this.fingerprint);
    }

    /**
     * Optional amount of memory in GB for nodes (requires flexible node_shape)
     * 
     */
    @Import(name="flexMemoryInGbs")
    private @Nullable Output<Integer> flexMemoryInGbs;

    /**
     * @return Optional amount of memory in GB for nodes (requires flexible node_shape)
     * 
     */
    public Optional<Output<Integer>> flexMemoryInGbs() {
        return Optional.ofNullable(this.flexMemoryInGbs);
    }

    /**
     * Optional number of OCPUs for nodes (requires flexible node_shape)
     * 
     */
    @Import(name="flexOcpus")
    private @Nullable Output<Integer> flexOcpus;

    /**
     * @return Optional number of OCPUs for nodes (requires flexible node_shape)
     * 
     */
    public Optional<Output<Integer>> flexOcpus() {
        return Optional.ofNullable(this.flexOcpus);
    }

    /**
     * Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
     * 
     */
    @Import(name="forceDeleteAfterGraceDuration")
    private @Nullable Output<Boolean> forceDeleteAfterGraceDuration;

    /**
     * @return Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
     * 
     */
    public Optional<Output<Boolean>> forceDeleteAfterGraceDuration() {
        return Optional.ofNullable(this.forceDeleteAfterGraceDuration);
    }

    /**
     * Optional specify a comma separated list of master encryption key OCID(s) to verify images
     * 
     */
    @Import(name="imageVerificationKmsKeyId")
    private @Nullable Output<String> imageVerificationKmsKeyId;

    /**
     * @return Optional specify a comma separated list of master encryption key OCID(s) to verify images
     * 
     */
    public Optional<Output<String>> imageVerificationKmsKeyId() {
        return Optional.ofNullable(this.imageVerificationKmsKeyId);
    }

    /**
     * Optional specify the OCID of the KMS Vault master key
     * 
     */
    @Import(name="kmsKeyId")
    private @Nullable Output<String> kmsKeyId;

    /**
     * @return Optional specify the OCID of the KMS Vault master key
     * 
     */
    public Optional<Output<String>> kmsKeyId() {
        return Optional.ofNullable(this.kmsKeyId);
    }

    /**
     * The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
     * 
     */
    @Import(name="kubernetesVersion", required=true)
    private Output<String> kubernetesVersion;

    /**
     * @return The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
     * 
     */
    public Output<String> kubernetesVersion() {
        return this.kubernetesVersion;
    }

    /**
     * Optional limit on the total number of nodes in the pool
     * 
     */
    @Import(name="limitNodeCount")
    private @Nullable Output<Integer> limitNodeCount;

    /**
     * @return Optional limit on the total number of nodes in the pool
     * 
     */
    public Optional<Output<Integer>> limitNodeCount() {
        return Optional.ofNullable(this.limitNodeCount);
    }

    /**
     * The name of the first existing subnet to use for Kubernetes services / LB
     * 
     */
    @Import(name="loadBalancerSubnetName1")
    private @Nullable Output<String> loadBalancerSubnetName1;

    /**
     * @return The name of the first existing subnet to use for Kubernetes services / LB
     * 
     */
    public Optional<Output<String>> loadBalancerSubnetName1() {
        return Optional.ofNullable(this.loadBalancerSubnetName1);
    }

    /**
     * The (optional) name of a second existing subnet to use for Kubernetes services / LB
     * 
     */
    @Import(name="loadBalancerSubnetName2")
    private @Nullable Output<String> loadBalancerSubnetName2;

    /**
     * @return The (optional) name of a second existing subnet to use for Kubernetes services / LB
     * 
     */
    public Optional<Output<String>> loadBalancerSubnetName2() {
        return Optional.ofNullable(this.loadBalancerSubnetName2);
    }

    /**
     * The OS for the node image
     * 
     */
    @Import(name="nodeImage", required=true)
    private Output<String> nodeImage;

    /**
     * @return The OS for the node image
     * 
     */
    public Output<String> nodeImage() {
        return this.nodeImage;
    }

    /**
     * Optional name for DNS domain of node pool subnet
     * 
     */
    @Import(name="nodePoolDnsDomainName")
    private @Nullable Output<String> nodePoolDnsDomainName;

    /**
     * @return Optional name for DNS domain of node pool subnet
     * 
     */
    public Optional<Output<String>> nodePoolDnsDomainName() {
        return Optional.ofNullable(this.nodePoolDnsDomainName);
    }

    /**
     * Optional pre-existing subnet (public or private) for nodes
     * 
     */
    @Import(name="nodePoolSubnetName")
    private @Nullable Output<String> nodePoolSubnetName;

    /**
     * @return Optional pre-existing subnet (public or private) for nodes
     * 
     */
    public Optional<Output<String>> nodePoolSubnetName() {
        return Optional.ofNullable(this.nodePoolSubnetName);
    }

    /**
     * The contents of the SSH public key file to use for the nodes
     * 
     */
    @Import(name="nodePublicKeyContents")
    private @Nullable Output<String> nodePublicKeyContents;

    /**
     * @return The contents of the SSH public key file to use for the nodes
     * 
     */
    public Optional<Output<String>> nodePublicKeyContents() {
        return Optional.ofNullable(this.nodePublicKeyContents);
    }

    /**
     * The shape of the node (determines number of CPUs and  amount of memory on each node)
     * 
     */
    @Import(name="nodeShape", required=true)
    private Output<String> nodeShape;

    /**
     * @return The shape of the node (determines number of CPUs and  amount of memory on each node)
     * 
     */
    public Output<String> nodeShape() {
        return this.nodeShape;
    }

    /**
     * The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
     * 
     */
    @Import(name="nodeUserDataContents")
    private @Nullable Output<String> nodeUserDataContents;

    /**
     * @return The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
     * 
     */
    public Optional<Output<String>> nodeUserDataContents() {
        return Optional.ofNullable(this.nodeUserDataContents);
    }

    /**
     * Optional specify the pod CIDR, defaults to 10.244.0.0/16
     * 
     */
    @Import(name="podCidr")
    private @Nullable Output<String> podCidr;

    /**
     * @return Optional specify the pod CIDR, defaults to 10.244.0.0/16
     * 
     */
    public Optional<Output<String>> podCidr() {
        return Optional.ofNullable(this.podCidr);
    }

    /**
     * Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
     * 
     */
    @Import(name="podNetwork")
    private @Nullable Output<String> podNetwork;

    /**
     * @return Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
     * 
     */
    public Optional<Output<String>> podNetwork() {
        return Optional.ofNullable(this.podNetwork);
    }

    /**
     * The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
     * 
     */
    @Import(name="podSubnetName")
    private @Nullable Output<String> podSubnetName;

    /**
     * @return The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
     * 
     */
    public Optional<Output<String>> podSubnetName() {
        return Optional.ofNullable(this.podSubnetName);
    }

    /**
     * The private API key file contents for the specified user, in PEM format
     * 
     */
    @Import(name="privateKeyContents")
    private @Nullable Output<String> privateKeyContents;

    /**
     * @return The private API key file contents for the specified user, in PEM format
     * 
     */
    public Optional<Output<String>> privateKeyContents() {
        return Optional.ofNullable(this.privateKeyContents);
    }

    /**
     * The passphrase of the private key for the OKE cluster
     * 
     */
    @Import(name="privateKeyPassphrase")
    private @Nullable Output<String> privateKeyPassphrase;

    /**
     * @return The passphrase of the private key for the OKE cluster
     * 
     */
    public Optional<Output<String>> privateKeyPassphrase() {
        return Optional.ofNullable(this.privateKeyPassphrase);
    }

    /**
     * Number of node subnets (defaults to creating 1 regional subnet)
     * 
     */
    @Import(name="quantityOfNodeSubnets")
    private @Nullable Output<Integer> quantityOfNodeSubnets;

    /**
     * @return Number of node subnets (defaults to creating 1 regional subnet)
     * 
     */
    public Optional<Output<Integer>> quantityOfNodeSubnets() {
        return Optional.ofNullable(this.quantityOfNodeSubnets);
    }

    /**
     * Number of worker nodes in each subnet / availability domain
     * 
     */
    @Import(name="quantityPerSubnet")
    private @Nullable Output<Integer> quantityPerSubnet;

    /**
     * @return Number of worker nodes in each subnet / availability domain
     * 
     */
    public Optional<Output<Integer>> quantityPerSubnet() {
        return Optional.ofNullable(this.quantityPerSubnet);
    }

    /**
     * The availability domain within the region to host the OKE cluster
     * 
     */
    @Import(name="region", required=true)
    private Output<String> region;

    /**
     * @return The availability domain within the region to host the OKE cluster
     * 
     */
    public Output<String> region() {
        return this.region;
    }

    /**
     * Optional specify the service CIDR, defaults to 10.96.0.0/16
     * 
     */
    @Import(name="serviceCidr")
    private @Nullable Output<String> serviceCidr;

    /**
     * @return Optional specify the service CIDR, defaults to 10.96.0.0/16
     * 
     */
    public Optional<Output<String>> serviceCidr() {
        return Optional.ofNullable(this.serviceCidr);
    }

    /**
     * Optional name for DNS domain of service subnet
     * 
     */
    @Import(name="serviceDnsDomainName")
    private @Nullable Output<String> serviceDnsDomainName;

    /**
     * @return Optional name for DNS domain of service subnet
     * 
     */
    public Optional<Output<String>> serviceDnsDomainName() {
        return Optional.ofNullable(this.serviceDnsDomainName);
    }

    /**
     * Whether to skip deleting VCN
     * 
     */
    @Import(name="skipVcnDelete")
    private @Nullable Output<Boolean> skipVcnDelete;

    /**
     * @return Whether to skip deleting VCN
     * 
     */
    public Optional<Output<Boolean>> skipVcnDelete() {
        return Optional.ofNullable(this.skipVcnDelete);
    }

    /**
     * The OCID of the tenancy in which to create resources
     * 
     */
    @Import(name="tenancyId", required=true)
    private Output<String> tenancyId;

    /**
     * @return The OCID of the tenancy in which to create resources
     * 
     */
    public Output<String> tenancyId() {
        return this.tenancyId;
    }

    /**
     * The OCID of a user who has access to the tenancy/compartment
     * 
     */
    @Import(name="userOcid")
    private @Nullable Output<String> userOcid;

    /**
     * @return The OCID of a user who has access to the tenancy/compartment
     * 
     */
    public Optional<Output<String>> userOcid() {
        return Optional.ofNullable(this.userOcid);
    }

    /**
     * The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
     * 
     */
    @Import(name="vcnCompartmentId")
    private @Nullable Output<String> vcnCompartmentId;

    /**
     * @return The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
     * 
     */
    public Optional<Output<String>> vcnCompartmentId() {
        return Optional.ofNullable(this.vcnCompartmentId);
    }

    /**
     * The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
     * 
     */
    @Import(name="vcnName")
    private @Nullable Output<String> vcnName;

    /**
     * @return The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
     * 
     */
    public Optional<Output<String>> vcnName() {
        return Optional.ofNullable(this.vcnName);
    }

    /**
     * Additional CIDR from which to allow ingress to worker nodes
     * 
     */
    @Import(name="workerNodeIngressCidr")
    private @Nullable Output<String> workerNodeIngressCidr;

    /**
     * @return Additional CIDR from which to allow ingress to worker nodes
     * 
     */
    public Optional<Output<String>> workerNodeIngressCidr() {
        return Optional.ofNullable(this.workerNodeIngressCidr);
    }

    private ClusterOkeConfigArgs() {}

    private ClusterOkeConfigArgs(ClusterOkeConfigArgs $) {
        this.clusterType = $.clusterType;
        this.compartmentId = $.compartmentId;
        this.controlPlaneSubnetName = $.controlPlaneSubnetName;
        this.customBootVolumeSize = $.customBootVolumeSize;
        this.description = $.description;
        this.enableKubernetesDashboard = $.enableKubernetesDashboard;
        this.enablePrivateControlPlane = $.enablePrivateControlPlane;
        this.enablePrivateNodes = $.enablePrivateNodes;
        this.evictionGraceDuration = $.evictionGraceDuration;
        this.fingerprint = $.fingerprint;
        this.flexMemoryInGbs = $.flexMemoryInGbs;
        this.flexOcpus = $.flexOcpus;
        this.forceDeleteAfterGraceDuration = $.forceDeleteAfterGraceDuration;
        this.imageVerificationKmsKeyId = $.imageVerificationKmsKeyId;
        this.kmsKeyId = $.kmsKeyId;
        this.kubernetesVersion = $.kubernetesVersion;
        this.limitNodeCount = $.limitNodeCount;
        this.loadBalancerSubnetName1 = $.loadBalancerSubnetName1;
        this.loadBalancerSubnetName2 = $.loadBalancerSubnetName2;
        this.nodeImage = $.nodeImage;
        this.nodePoolDnsDomainName = $.nodePoolDnsDomainName;
        this.nodePoolSubnetName = $.nodePoolSubnetName;
        this.nodePublicKeyContents = $.nodePublicKeyContents;
        this.nodeShape = $.nodeShape;
        this.nodeUserDataContents = $.nodeUserDataContents;
        this.podCidr = $.podCidr;
        this.podNetwork = $.podNetwork;
        this.podSubnetName = $.podSubnetName;
        this.privateKeyContents = $.privateKeyContents;
        this.privateKeyPassphrase = $.privateKeyPassphrase;
        this.quantityOfNodeSubnets = $.quantityOfNodeSubnets;
        this.quantityPerSubnet = $.quantityPerSubnet;
        this.region = $.region;
        this.serviceCidr = $.serviceCidr;
        this.serviceDnsDomainName = $.serviceDnsDomainName;
        this.skipVcnDelete = $.skipVcnDelete;
        this.tenancyId = $.tenancyId;
        this.userOcid = $.userOcid;
        this.vcnCompartmentId = $.vcnCompartmentId;
        this.vcnName = $.vcnName;
        this.workerNodeIngressCidr = $.workerNodeIngressCidr;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterOkeConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterOkeConfigArgs $;

        public Builder() {
            $ = new ClusterOkeConfigArgs();
        }

        public Builder(ClusterOkeConfigArgs defaults) {
            $ = new ClusterOkeConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param clusterType Optionally specify a cluster type of basic or enhanced
         * 
         * @return builder
         * 
         */
        public Builder clusterType(@Nullable Output<String> clusterType) {
            $.clusterType = clusterType;
            return this;
        }

        /**
         * @param clusterType Optionally specify a cluster type of basic or enhanced
         * 
         * @return builder
         * 
         */
        public Builder clusterType(String clusterType) {
            return clusterType(Output.of(clusterType));
        }

        /**
         * @param compartmentId The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
         * 
         * @return builder
         * 
         */
        public Builder compartmentId(Output<String> compartmentId) {
            $.compartmentId = compartmentId;
            return this;
        }

        /**
         * @param compartmentId The OCID of the compartment in which to create resources (VCN, worker nodes, etc.)
         * 
         * @return builder
         * 
         */
        public Builder compartmentId(String compartmentId) {
            return compartmentId(Output.of(compartmentId));
        }

        /**
         * @param controlPlaneSubnetName The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
         * 
         * @return builder
         * 
         */
        public Builder controlPlaneSubnetName(@Nullable Output<String> controlPlaneSubnetName) {
            $.controlPlaneSubnetName = controlPlaneSubnetName;
            return this;
        }

        /**
         * @param controlPlaneSubnetName The (optional) name of a pre-existing subnet (public or private) for the Kubernetes API endpoint
         * 
         * @return builder
         * 
         */
        public Builder controlPlaneSubnetName(String controlPlaneSubnetName) {
            return controlPlaneSubnetName(Output.of(controlPlaneSubnetName));
        }

        /**
         * @param customBootVolumeSize An optional custom boot volume size (in GB) for the nodes
         * 
         * @return builder
         * 
         */
        public Builder customBootVolumeSize(@Nullable Output<Integer> customBootVolumeSize) {
            $.customBootVolumeSize = customBootVolumeSize;
            return this;
        }

        /**
         * @param customBootVolumeSize An optional custom boot volume size (in GB) for the nodes
         * 
         * @return builder
         * 
         */
        public Builder customBootVolumeSize(Integer customBootVolumeSize) {
            return customBootVolumeSize(Output.of(customBootVolumeSize));
        }

        /**
         * @param description The description for Cluster (string)
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description for Cluster (string)
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param enableKubernetesDashboard Enable the kubernetes dashboard
         * 
         * @return builder
         * 
         */
        public Builder enableKubernetesDashboard(@Nullable Output<Boolean> enableKubernetesDashboard) {
            $.enableKubernetesDashboard = enableKubernetesDashboard;
            return this;
        }

        /**
         * @param enableKubernetesDashboard Enable the kubernetes dashboard
         * 
         * @return builder
         * 
         */
        public Builder enableKubernetesDashboard(Boolean enableKubernetesDashboard) {
            return enableKubernetesDashboard(Output.of(enableKubernetesDashboard));
        }

        /**
         * @param enablePrivateControlPlane Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateControlPlane(@Nullable Output<Boolean> enablePrivateControlPlane) {
            $.enablePrivateControlPlane = enablePrivateControlPlane;
            return this;
        }

        /**
         * @param enablePrivateControlPlane Whether Kubernetes API endpoint is a private IP only accessible from within the VCN
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateControlPlane(Boolean enablePrivateControlPlane) {
            return enablePrivateControlPlane(Output.of(enablePrivateControlPlane));
        }

        /**
         * @param enablePrivateNodes Whether worker nodes are deployed into a new private subnet
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateNodes(@Nullable Output<Boolean> enablePrivateNodes) {
            $.enablePrivateNodes = enablePrivateNodes;
            return this;
        }

        /**
         * @param enablePrivateNodes Whether worker nodes are deployed into a new private subnet
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateNodes(Boolean enablePrivateNodes) {
            return enablePrivateNodes(Output.of(enablePrivateNodes));
        }

        /**
         * @param evictionGraceDuration The optional grace period in minutes to allow cordon and drain to complete successfuly
         * 
         * @return builder
         * 
         */
        public Builder evictionGraceDuration(@Nullable Output<String> evictionGraceDuration) {
            $.evictionGraceDuration = evictionGraceDuration;
            return this;
        }

        /**
         * @param evictionGraceDuration The optional grace period in minutes to allow cordon and drain to complete successfuly
         * 
         * @return builder
         * 
         */
        public Builder evictionGraceDuration(String evictionGraceDuration) {
            return evictionGraceDuration(Output.of(evictionGraceDuration));
        }

        /**
         * @param fingerprint The fingerprint corresponding to the specified user&#39;s private API Key
         * 
         * @return builder
         * 
         */
        public Builder fingerprint(@Nullable Output<String> fingerprint) {
            $.fingerprint = fingerprint;
            return this;
        }

        /**
         * @param fingerprint The fingerprint corresponding to the specified user&#39;s private API Key
         * 
         * @return builder
         * 
         */
        public Builder fingerprint(String fingerprint) {
            return fingerprint(Output.of(fingerprint));
        }

        /**
         * @param flexMemoryInGbs Optional amount of memory in GB for nodes (requires flexible node_shape)
         * 
         * @return builder
         * 
         */
        public Builder flexMemoryInGbs(@Nullable Output<Integer> flexMemoryInGbs) {
            $.flexMemoryInGbs = flexMemoryInGbs;
            return this;
        }

        /**
         * @param flexMemoryInGbs Optional amount of memory in GB for nodes (requires flexible node_shape)
         * 
         * @return builder
         * 
         */
        public Builder flexMemoryInGbs(Integer flexMemoryInGbs) {
            return flexMemoryInGbs(Output.of(flexMemoryInGbs));
        }

        /**
         * @param flexOcpus Optional number of OCPUs for nodes (requires flexible node_shape)
         * 
         * @return builder
         * 
         */
        public Builder flexOcpus(@Nullable Output<Integer> flexOcpus) {
            $.flexOcpus = flexOcpus;
            return this;
        }

        /**
         * @param flexOcpus Optional number of OCPUs for nodes (requires flexible node_shape)
         * 
         * @return builder
         * 
         */
        public Builder flexOcpus(Integer flexOcpus) {
            return flexOcpus(Output.of(flexOcpus));
        }

        /**
         * @param forceDeleteAfterGraceDuration Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
         * 
         * @return builder
         * 
         */
        public Builder forceDeleteAfterGraceDuration(@Nullable Output<Boolean> forceDeleteAfterGraceDuration) {
            $.forceDeleteAfterGraceDuration = forceDeleteAfterGraceDuration;
            return this;
        }

        /**
         * @param forceDeleteAfterGraceDuration Whether to send a SIGKILL signal if a pod does not terminate within the specified grace period
         * 
         * @return builder
         * 
         */
        public Builder forceDeleteAfterGraceDuration(Boolean forceDeleteAfterGraceDuration) {
            return forceDeleteAfterGraceDuration(Output.of(forceDeleteAfterGraceDuration));
        }

        /**
         * @param imageVerificationKmsKeyId Optional specify a comma separated list of master encryption key OCID(s) to verify images
         * 
         * @return builder
         * 
         */
        public Builder imageVerificationKmsKeyId(@Nullable Output<String> imageVerificationKmsKeyId) {
            $.imageVerificationKmsKeyId = imageVerificationKmsKeyId;
            return this;
        }

        /**
         * @param imageVerificationKmsKeyId Optional specify a comma separated list of master encryption key OCID(s) to verify images
         * 
         * @return builder
         * 
         */
        public Builder imageVerificationKmsKeyId(String imageVerificationKmsKeyId) {
            return imageVerificationKmsKeyId(Output.of(imageVerificationKmsKeyId));
        }

        /**
         * @param kmsKeyId Optional specify the OCID of the KMS Vault master key
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyId(@Nullable Output<String> kmsKeyId) {
            $.kmsKeyId = kmsKeyId;
            return this;
        }

        /**
         * @param kmsKeyId Optional specify the OCID of the KMS Vault master key
         * 
         * @return builder
         * 
         */
        public Builder kmsKeyId(String kmsKeyId) {
            return kmsKeyId(Output.of(kmsKeyId));
        }

        /**
         * @param kubernetesVersion The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
         * 
         * @return builder
         * 
         */
        public Builder kubernetesVersion(Output<String> kubernetesVersion) {
            $.kubernetesVersion = kubernetesVersion;
            return this;
        }

        /**
         * @param kubernetesVersion The Kubernetes version that will be used for your master *and* worker nodes e.g. v1.33.1
         * 
         * @return builder
         * 
         */
        public Builder kubernetesVersion(String kubernetesVersion) {
            return kubernetesVersion(Output.of(kubernetesVersion));
        }

        /**
         * @param limitNodeCount Optional limit on the total number of nodes in the pool
         * 
         * @return builder
         * 
         */
        public Builder limitNodeCount(@Nullable Output<Integer> limitNodeCount) {
            $.limitNodeCount = limitNodeCount;
            return this;
        }

        /**
         * @param limitNodeCount Optional limit on the total number of nodes in the pool
         * 
         * @return builder
         * 
         */
        public Builder limitNodeCount(Integer limitNodeCount) {
            return limitNodeCount(Output.of(limitNodeCount));
        }

        /**
         * @param loadBalancerSubnetName1 The name of the first existing subnet to use for Kubernetes services / LB
         * 
         * @return builder
         * 
         */
        public Builder loadBalancerSubnetName1(@Nullable Output<String> loadBalancerSubnetName1) {
            $.loadBalancerSubnetName1 = loadBalancerSubnetName1;
            return this;
        }

        /**
         * @param loadBalancerSubnetName1 The name of the first existing subnet to use for Kubernetes services / LB
         * 
         * @return builder
         * 
         */
        public Builder loadBalancerSubnetName1(String loadBalancerSubnetName1) {
            return loadBalancerSubnetName1(Output.of(loadBalancerSubnetName1));
        }

        /**
         * @param loadBalancerSubnetName2 The (optional) name of a second existing subnet to use for Kubernetes services / LB
         * 
         * @return builder
         * 
         */
        public Builder loadBalancerSubnetName2(@Nullable Output<String> loadBalancerSubnetName2) {
            $.loadBalancerSubnetName2 = loadBalancerSubnetName2;
            return this;
        }

        /**
         * @param loadBalancerSubnetName2 The (optional) name of a second existing subnet to use for Kubernetes services / LB
         * 
         * @return builder
         * 
         */
        public Builder loadBalancerSubnetName2(String loadBalancerSubnetName2) {
            return loadBalancerSubnetName2(Output.of(loadBalancerSubnetName2));
        }

        /**
         * @param nodeImage The OS for the node image
         * 
         * @return builder
         * 
         */
        public Builder nodeImage(Output<String> nodeImage) {
            $.nodeImage = nodeImage;
            return this;
        }

        /**
         * @param nodeImage The OS for the node image
         * 
         * @return builder
         * 
         */
        public Builder nodeImage(String nodeImage) {
            return nodeImage(Output.of(nodeImage));
        }

        /**
         * @param nodePoolDnsDomainName Optional name for DNS domain of node pool subnet
         * 
         * @return builder
         * 
         */
        public Builder nodePoolDnsDomainName(@Nullable Output<String> nodePoolDnsDomainName) {
            $.nodePoolDnsDomainName = nodePoolDnsDomainName;
            return this;
        }

        /**
         * @param nodePoolDnsDomainName Optional name for DNS domain of node pool subnet
         * 
         * @return builder
         * 
         */
        public Builder nodePoolDnsDomainName(String nodePoolDnsDomainName) {
            return nodePoolDnsDomainName(Output.of(nodePoolDnsDomainName));
        }

        /**
         * @param nodePoolSubnetName Optional pre-existing subnet (public or private) for nodes
         * 
         * @return builder
         * 
         */
        public Builder nodePoolSubnetName(@Nullable Output<String> nodePoolSubnetName) {
            $.nodePoolSubnetName = nodePoolSubnetName;
            return this;
        }

        /**
         * @param nodePoolSubnetName Optional pre-existing subnet (public or private) for nodes
         * 
         * @return builder
         * 
         */
        public Builder nodePoolSubnetName(String nodePoolSubnetName) {
            return nodePoolSubnetName(Output.of(nodePoolSubnetName));
        }

        /**
         * @param nodePublicKeyContents The contents of the SSH public key file to use for the nodes
         * 
         * @return builder
         * 
         */
        public Builder nodePublicKeyContents(@Nullable Output<String> nodePublicKeyContents) {
            $.nodePublicKeyContents = nodePublicKeyContents;
            return this;
        }

        /**
         * @param nodePublicKeyContents The contents of the SSH public key file to use for the nodes
         * 
         * @return builder
         * 
         */
        public Builder nodePublicKeyContents(String nodePublicKeyContents) {
            return nodePublicKeyContents(Output.of(nodePublicKeyContents));
        }

        /**
         * @param nodeShape The shape of the node (determines number of CPUs and  amount of memory on each node)
         * 
         * @return builder
         * 
         */
        public Builder nodeShape(Output<String> nodeShape) {
            $.nodeShape = nodeShape;
            return this;
        }

        /**
         * @param nodeShape The shape of the node (determines number of CPUs and  amount of memory on each node)
         * 
         * @return builder
         * 
         */
        public Builder nodeShape(String nodeShape) {
            return nodeShape(Output.of(nodeShape));
        }

        /**
         * @param nodeUserDataContents The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
         * 
         * @return builder
         * 
         */
        public Builder nodeUserDataContents(@Nullable Output<String> nodeUserDataContents) {
            $.nodeUserDataContents = nodeUserDataContents;
            return this;
        }

        /**
         * @param nodeUserDataContents The contents of custom cloud-init / user_data for the nodes - will be base64 encoded internally if it is not already
         * 
         * @return builder
         * 
         */
        public Builder nodeUserDataContents(String nodeUserDataContents) {
            return nodeUserDataContents(Output.of(nodeUserDataContents));
        }

        /**
         * @param podCidr Optional specify the pod CIDR, defaults to 10.244.0.0/16
         * 
         * @return builder
         * 
         */
        public Builder podCidr(@Nullable Output<String> podCidr) {
            $.podCidr = podCidr;
            return this;
        }

        /**
         * @param podCidr Optional specify the pod CIDR, defaults to 10.244.0.0/16
         * 
         * @return builder
         * 
         */
        public Builder podCidr(String podCidr) {
            return podCidr(Output.of(podCidr));
        }

        /**
         * @param podNetwork Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
         * 
         * @return builder
         * 
         */
        public Builder podNetwork(@Nullable Output<String> podNetwork) {
            $.podNetwork = podNetwork;
            return this;
        }

        /**
         * @param podNetwork Optional Pod Network plugin. Choose flannel or native. Defaults to flannel
         * 
         * @return builder
         * 
         */
        public Builder podNetwork(String podNetwork) {
            return podNetwork(Output.of(podNetwork));
        }

        /**
         * @param podSubnetName The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
         * 
         * @return builder
         * 
         */
        public Builder podSubnetName(@Nullable Output<String> podSubnetName) {
            $.podSubnetName = podSubnetName;
            return this;
        }

        /**
         * @param podSubnetName The (optional) name of a pre-existing subnet that pods will be assigned IPs from when using native pod networking
         * 
         * @return builder
         * 
         */
        public Builder podSubnetName(String podSubnetName) {
            return podSubnetName(Output.of(podSubnetName));
        }

        /**
         * @param privateKeyContents The private API key file contents for the specified user, in PEM format
         * 
         * @return builder
         * 
         */
        public Builder privateKeyContents(@Nullable Output<String> privateKeyContents) {
            $.privateKeyContents = privateKeyContents;
            return this;
        }

        /**
         * @param privateKeyContents The private API key file contents for the specified user, in PEM format
         * 
         * @return builder
         * 
         */
        public Builder privateKeyContents(String privateKeyContents) {
            return privateKeyContents(Output.of(privateKeyContents));
        }

        /**
         * @param privateKeyPassphrase The passphrase of the private key for the OKE cluster
         * 
         * @return builder
         * 
         */
        public Builder privateKeyPassphrase(@Nullable Output<String> privateKeyPassphrase) {
            $.privateKeyPassphrase = privateKeyPassphrase;
            return this;
        }

        /**
         * @param privateKeyPassphrase The passphrase of the private key for the OKE cluster
         * 
         * @return builder
         * 
         */
        public Builder privateKeyPassphrase(String privateKeyPassphrase) {
            return privateKeyPassphrase(Output.of(privateKeyPassphrase));
        }

        /**
         * @param quantityOfNodeSubnets Number of node subnets (defaults to creating 1 regional subnet)
         * 
         * @return builder
         * 
         */
        public Builder quantityOfNodeSubnets(@Nullable Output<Integer> quantityOfNodeSubnets) {
            $.quantityOfNodeSubnets = quantityOfNodeSubnets;
            return this;
        }

        /**
         * @param quantityOfNodeSubnets Number of node subnets (defaults to creating 1 regional subnet)
         * 
         * @return builder
         * 
         */
        public Builder quantityOfNodeSubnets(Integer quantityOfNodeSubnets) {
            return quantityOfNodeSubnets(Output.of(quantityOfNodeSubnets));
        }

        /**
         * @param quantityPerSubnet Number of worker nodes in each subnet / availability domain
         * 
         * @return builder
         * 
         */
        public Builder quantityPerSubnet(@Nullable Output<Integer> quantityPerSubnet) {
            $.quantityPerSubnet = quantityPerSubnet;
            return this;
        }

        /**
         * @param quantityPerSubnet Number of worker nodes in each subnet / availability domain
         * 
         * @return builder
         * 
         */
        public Builder quantityPerSubnet(Integer quantityPerSubnet) {
            return quantityPerSubnet(Output.of(quantityPerSubnet));
        }

        /**
         * @param region The availability domain within the region to host the OKE cluster
         * 
         * @return builder
         * 
         */
        public Builder region(Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The availability domain within the region to host the OKE cluster
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param serviceCidr Optional specify the service CIDR, defaults to 10.96.0.0/16
         * 
         * @return builder
         * 
         */
        public Builder serviceCidr(@Nullable Output<String> serviceCidr) {
            $.serviceCidr = serviceCidr;
            return this;
        }

        /**
         * @param serviceCidr Optional specify the service CIDR, defaults to 10.96.0.0/16
         * 
         * @return builder
         * 
         */
        public Builder serviceCidr(String serviceCidr) {
            return serviceCidr(Output.of(serviceCidr));
        }

        /**
         * @param serviceDnsDomainName Optional name for DNS domain of service subnet
         * 
         * @return builder
         * 
         */
        public Builder serviceDnsDomainName(@Nullable Output<String> serviceDnsDomainName) {
            $.serviceDnsDomainName = serviceDnsDomainName;
            return this;
        }

        /**
         * @param serviceDnsDomainName Optional name for DNS domain of service subnet
         * 
         * @return builder
         * 
         */
        public Builder serviceDnsDomainName(String serviceDnsDomainName) {
            return serviceDnsDomainName(Output.of(serviceDnsDomainName));
        }

        /**
         * @param skipVcnDelete Whether to skip deleting VCN
         * 
         * @return builder
         * 
         */
        public Builder skipVcnDelete(@Nullable Output<Boolean> skipVcnDelete) {
            $.skipVcnDelete = skipVcnDelete;
            return this;
        }

        /**
         * @param skipVcnDelete Whether to skip deleting VCN
         * 
         * @return builder
         * 
         */
        public Builder skipVcnDelete(Boolean skipVcnDelete) {
            return skipVcnDelete(Output.of(skipVcnDelete));
        }

        /**
         * @param tenancyId The OCID of the tenancy in which to create resources
         * 
         * @return builder
         * 
         */
        public Builder tenancyId(Output<String> tenancyId) {
            $.tenancyId = tenancyId;
            return this;
        }

        /**
         * @param tenancyId The OCID of the tenancy in which to create resources
         * 
         * @return builder
         * 
         */
        public Builder tenancyId(String tenancyId) {
            return tenancyId(Output.of(tenancyId));
        }

        /**
         * @param userOcid The OCID of a user who has access to the tenancy/compartment
         * 
         * @return builder
         * 
         */
        public Builder userOcid(@Nullable Output<String> userOcid) {
            $.userOcid = userOcid;
            return this;
        }

        /**
         * @param userOcid The OCID of a user who has access to the tenancy/compartment
         * 
         * @return builder
         * 
         */
        public Builder userOcid(String userOcid) {
            return userOcid(Output.of(userOcid));
        }

        /**
         * @param vcnCompartmentId The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
         * 
         * @return builder
         * 
         */
        public Builder vcnCompartmentId(@Nullable Output<String> vcnCompartmentId) {
            $.vcnCompartmentId = vcnCompartmentId;
            return this;
        }

        /**
         * @param vcnCompartmentId The OCID of the compartment (if different from compartment_id) in which to find the pre-existing virtual network set with vcn_name.
         * 
         * @return builder
         * 
         */
        public Builder vcnCompartmentId(String vcnCompartmentId) {
            return vcnCompartmentId(Output.of(vcnCompartmentId));
        }

        /**
         * @param vcnName The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
         * 
         * @return builder
         * 
         */
        public Builder vcnName(@Nullable Output<String> vcnName) {
            $.vcnName = vcnName;
            return this;
        }

        /**
         * @param vcnName The optional name of an existing virtual network to use for the cluster creation. A new VCN will be created if not specified.
         * 
         * @return builder
         * 
         */
        public Builder vcnName(String vcnName) {
            return vcnName(Output.of(vcnName));
        }

        /**
         * @param workerNodeIngressCidr Additional CIDR from which to allow ingress to worker nodes
         * 
         * @return builder
         * 
         */
        public Builder workerNodeIngressCidr(@Nullable Output<String> workerNodeIngressCidr) {
            $.workerNodeIngressCidr = workerNodeIngressCidr;
            return this;
        }

        /**
         * @param workerNodeIngressCidr Additional CIDR from which to allow ingress to worker nodes
         * 
         * @return builder
         * 
         */
        public Builder workerNodeIngressCidr(String workerNodeIngressCidr) {
            return workerNodeIngressCidr(Output.of(workerNodeIngressCidr));
        }

        public ClusterOkeConfigArgs build() {
            if ($.compartmentId == null) {
                throw new MissingRequiredPropertyException("ClusterOkeConfigArgs", "compartmentId");
            }
            if ($.kubernetesVersion == null) {
                throw new MissingRequiredPropertyException("ClusterOkeConfigArgs", "kubernetesVersion");
            }
            if ($.nodeImage == null) {
                throw new MissingRequiredPropertyException("ClusterOkeConfigArgs", "nodeImage");
            }
            if ($.nodeShape == null) {
                throw new MissingRequiredPropertyException("ClusterOkeConfigArgs", "nodeShape");
            }
            if ($.region == null) {
                throw new MissingRequiredPropertyException("ClusterOkeConfigArgs", "region");
            }
            if ($.tenancyId == null) {
                throw new MissingRequiredPropertyException("ClusterOkeConfigArgs", "tenancyId");
            }
            return $;
        }
    }

}
