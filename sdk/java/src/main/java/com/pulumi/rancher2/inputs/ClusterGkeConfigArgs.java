// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.rancher2.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ClusterGkeConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final ClusterGkeConfigArgs Empty = new ClusterGkeConfigArgs();

    /**
     * The IP address range of the container pods
     * 
     */
    @Import(name="clusterIpv4Cidr", required=true)
    private Output<String> clusterIpv4Cidr;

    /**
     * @return The IP address range of the container pods
     * 
     */
    public Output<String> clusterIpv4Cidr() {
        return this.clusterIpv4Cidr;
    }

    /**
     * The contents of the GC credential file
     * 
     */
    @Import(name="credential", required=true)
    private Output<String> credential;

    /**
     * @return The contents of the GC credential file
     * 
     */
    public Output<String> credential() {
        return this.credential;
    }

    /**
     * The description for Cluster (string)
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description for Cluster (string)
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Size of the disk attached to each node
     * 
     */
    @Import(name="diskSizeGb")
    private @Nullable Output<Integer> diskSizeGb;

    /**
     * @return Size of the disk attached to each node
     * 
     */
    public Optional<Output<Integer>> diskSizeGb() {
        return Optional.ofNullable(this.diskSizeGb);
    }

    /**
     * Type of the disk attached to each node
     * 
     */
    @Import(name="diskType", required=true)
    private Output<String> diskType;

    /**
     * @return Type of the disk attached to each node
     * 
     */
    public Output<String> diskType() {
        return this.diskType;
    }

    /**
     * To enable kubernetes alpha feature
     * 
     */
    @Import(name="enableAlphaFeature")
    private @Nullable Output<Boolean> enableAlphaFeature;

    /**
     * @return To enable kubernetes alpha feature
     * 
     */
    public Optional<Output<Boolean>> enableAlphaFeature() {
        return Optional.ofNullable(this.enableAlphaFeature);
    }

    /**
     * Specifies whether the node auto-repair is enabled for the node pool
     * 
     */
    @Import(name="enableAutoRepair")
    private @Nullable Output<Boolean> enableAutoRepair;

    /**
     * @return Specifies whether the node auto-repair is enabled for the node pool
     * 
     */
    public Optional<Output<Boolean>> enableAutoRepair() {
        return Optional.ofNullable(this.enableAutoRepair);
    }

    /**
     * Specifies whether node auto-upgrade is enabled for the node pool
     * 
     */
    @Import(name="enableAutoUpgrade")
    private @Nullable Output<Boolean> enableAutoUpgrade;

    /**
     * @return Specifies whether node auto-upgrade is enabled for the node pool
     * 
     */
    public Optional<Output<Boolean>> enableAutoUpgrade() {
        return Optional.ofNullable(this.enableAutoUpgrade);
    }

    /**
     * Enable horizontal pod autoscaling for the cluster
     * 
     */
    @Import(name="enableHorizontalPodAutoscaling")
    private @Nullable Output<Boolean> enableHorizontalPodAutoscaling;

    /**
     * @return Enable horizontal pod autoscaling for the cluster
     * 
     */
    public Optional<Output<Boolean>> enableHorizontalPodAutoscaling() {
        return Optional.ofNullable(this.enableHorizontalPodAutoscaling);
    }

    /**
     * Enable http load balancing for the cluster
     * 
     */
    @Import(name="enableHttpLoadBalancing")
    private @Nullable Output<Boolean> enableHttpLoadBalancing;

    /**
     * @return Enable http load balancing for the cluster
     * 
     */
    public Optional<Output<Boolean>> enableHttpLoadBalancing() {
        return Optional.ofNullable(this.enableHttpLoadBalancing);
    }

    /**
     * Whether to enable the kubernetes dashboard
     * 
     */
    @Import(name="enableKubernetesDashboard")
    private @Nullable Output<Boolean> enableKubernetesDashboard;

    /**
     * @return Whether to enable the kubernetes dashboard
     * 
     */
    public Optional<Output<Boolean>> enableKubernetesDashboard() {
        return Optional.ofNullable(this.enableKubernetesDashboard);
    }

    /**
     * Whether to enable legacy abac on the cluster
     * 
     */
    @Import(name="enableLegacyAbac")
    private @Nullable Output<Boolean> enableLegacyAbac;

    /**
     * @return Whether to enable legacy abac on the cluster
     * 
     */
    public Optional<Output<Boolean>> enableLegacyAbac() {
        return Optional.ofNullable(this.enableLegacyAbac);
    }

    /**
     * Whether or not master authorized network is enabled
     * 
     */
    @Import(name="enableMasterAuthorizedNetwork")
    private @Nullable Output<Boolean> enableMasterAuthorizedNetwork;

    /**
     * @return Whether or not master authorized network is enabled
     * 
     */
    public Optional<Output<Boolean>> enableMasterAuthorizedNetwork() {
        return Optional.ofNullable(this.enableMasterAuthorizedNetwork);
    }

    /**
     * Enable network policy config for the cluster
     * 
     */
    @Import(name="enableNetworkPolicyConfig")
    private @Nullable Output<Boolean> enableNetworkPolicyConfig;

    /**
     * @return Enable network policy config for the cluster
     * 
     */
    public Optional<Output<Boolean>> enableNetworkPolicyConfig() {
        return Optional.ofNullable(this.enableNetworkPolicyConfig);
    }

    /**
     * Enable nodepool autoscaling
     * 
     */
    @Import(name="enableNodepoolAutoscaling")
    private @Nullable Output<Boolean> enableNodepoolAutoscaling;

    /**
     * @return Enable nodepool autoscaling
     * 
     */
    public Optional<Output<Boolean>> enableNodepoolAutoscaling() {
        return Optional.ofNullable(this.enableNodepoolAutoscaling);
    }

    /**
     * Whether the master&#39;s internal IP address is used as the cluster endpoint
     * 
     */
    @Import(name="enablePrivateEndpoint")
    private @Nullable Output<Boolean> enablePrivateEndpoint;

    /**
     * @return Whether the master&#39;s internal IP address is used as the cluster endpoint
     * 
     */
    public Optional<Output<Boolean>> enablePrivateEndpoint() {
        return Optional.ofNullable(this.enablePrivateEndpoint);
    }

    /**
     * Whether nodes have internal IP address only
     * 
     */
    @Import(name="enablePrivateNodes")
    private @Nullable Output<Boolean> enablePrivateNodes;

    /**
     * @return Whether nodes have internal IP address only
     * 
     */
    public Optional<Output<Boolean>> enablePrivateNodes() {
        return Optional.ofNullable(this.enablePrivateNodes);
    }

    /**
     * Enable stackdriver logging
     * 
     */
    @Import(name="enableStackdriverLogging")
    private @Nullable Output<Boolean> enableStackdriverLogging;

    /**
     * @return Enable stackdriver logging
     * 
     */
    public Optional<Output<Boolean>> enableStackdriverLogging() {
        return Optional.ofNullable(this.enableStackdriverLogging);
    }

    /**
     * Enable stackdriver monitoring
     * 
     */
    @Import(name="enableStackdriverMonitoring")
    private @Nullable Output<Boolean> enableStackdriverMonitoring;

    /**
     * @return Enable stackdriver monitoring
     * 
     */
    public Optional<Output<Boolean>> enableStackdriverMonitoring() {
        return Optional.ofNullable(this.enableStackdriverMonitoring);
    }

    /**
     * The image to use for the worker nodes
     * 
     */
    @Import(name="imageType", required=true)
    private Output<String> imageType;

    /**
     * @return The image to use for the worker nodes
     * 
     */
    public Output<String> imageType() {
        return this.imageType;
    }

    /**
     * The IP address range for the cluster pod IPs
     * 
     */
    @Import(name="ipPolicyClusterIpv4CidrBlock", required=true)
    private Output<String> ipPolicyClusterIpv4CidrBlock;

    /**
     * @return The IP address range for the cluster pod IPs
     * 
     */
    public Output<String> ipPolicyClusterIpv4CidrBlock() {
        return this.ipPolicyClusterIpv4CidrBlock;
    }

    /**
     * The name of the secondary range to be used for the cluster CIDR block
     * 
     */
    @Import(name="ipPolicyClusterSecondaryRangeName", required=true)
    private Output<String> ipPolicyClusterSecondaryRangeName;

    /**
     * @return The name of the secondary range to be used for the cluster CIDR block
     * 
     */
    public Output<String> ipPolicyClusterSecondaryRangeName() {
        return this.ipPolicyClusterSecondaryRangeName;
    }

    /**
     * Whether a new subnetwork will be created automatically for the cluster
     * 
     */
    @Import(name="ipPolicyCreateSubnetwork")
    private @Nullable Output<Boolean> ipPolicyCreateSubnetwork;

    /**
     * @return Whether a new subnetwork will be created automatically for the cluster
     * 
     */
    public Optional<Output<Boolean>> ipPolicyCreateSubnetwork() {
        return Optional.ofNullable(this.ipPolicyCreateSubnetwork);
    }

    /**
     * The IP address range of the instance IPs in this cluster
     * 
     */
    @Import(name="ipPolicyNodeIpv4CidrBlock", required=true)
    private Output<String> ipPolicyNodeIpv4CidrBlock;

    /**
     * @return The IP address range of the instance IPs in this cluster
     * 
     */
    public Output<String> ipPolicyNodeIpv4CidrBlock() {
        return this.ipPolicyNodeIpv4CidrBlock;
    }

    /**
     * The IP address range of the services IPs in this cluster
     * 
     */
    @Import(name="ipPolicyServicesIpv4CidrBlock", required=true)
    private Output<String> ipPolicyServicesIpv4CidrBlock;

    /**
     * @return The IP address range of the services IPs in this cluster
     * 
     */
    public Output<String> ipPolicyServicesIpv4CidrBlock() {
        return this.ipPolicyServicesIpv4CidrBlock;
    }

    /**
     * The name of the secondary range to be used for the services CIDR block
     * 
     */
    @Import(name="ipPolicyServicesSecondaryRangeName", required=true)
    private Output<String> ipPolicyServicesSecondaryRangeName;

    /**
     * @return The name of the secondary range to be used for the services CIDR block
     * 
     */
    public Output<String> ipPolicyServicesSecondaryRangeName() {
        return this.ipPolicyServicesSecondaryRangeName;
    }

    /**
     * A custom subnetwork name to be used if createSubnetwork is true
     * 
     */
    @Import(name="ipPolicySubnetworkName", required=true)
    private Output<String> ipPolicySubnetworkName;

    /**
     * @return A custom subnetwork name to be used if createSubnetwork is true
     * 
     */
    public Output<String> ipPolicySubnetworkName() {
        return this.ipPolicySubnetworkName;
    }

    /**
     * Issue a client certificate
     * 
     */
    @Import(name="issueClientCertificate")
    private @Nullable Output<Boolean> issueClientCertificate;

    /**
     * @return Issue a client certificate
     * 
     */
    public Optional<Output<Boolean>> issueClientCertificate() {
        return Optional.ofNullable(this.issueClientCertificate);
    }

    /**
     * Enable the kubernetes dashboard
     * 
     */
    @Import(name="kubernetesDashboard")
    private @Nullable Output<Boolean> kubernetesDashboard;

    /**
     * @return Enable the kubernetes dashboard
     * 
     */
    public Optional<Output<Boolean>> kubernetesDashboard() {
        return Optional.ofNullable(this.kubernetesDashboard);
    }

    /**
     * Labels for the Cluster (map)
     * 
     */
    @Import(name="labels")
    private @Nullable Output<Map<String,String>> labels;

    /**
     * @return Labels for the Cluster (map)
     * 
     */
    public Optional<Output<Map<String,String>>> labels() {
        return Optional.ofNullable(this.labels);
    }

    /**
     * The number of local SSD disks to be attached to the node
     * 
     */
    @Import(name="localSsdCount")
    private @Nullable Output<Integer> localSsdCount;

    /**
     * @return The number of local SSD disks to be attached to the node
     * 
     */
    public Optional<Output<Integer>> localSsdCount() {
        return Optional.ofNullable(this.localSsdCount);
    }

    /**
     * Locations to use for the cluster
     * 
     */
    @Import(name="locations", required=true)
    private Output<List<String>> locations;

    /**
     * @return Locations to use for the cluster
     * 
     */
    public Output<List<String>> locations() {
        return this.locations;
    }

    /**
     * The machine type to use for the worker nodes
     * 
     */
    @Import(name="machineType", required=true)
    private Output<String> machineType;

    /**
     * @return The machine type to use for the worker nodes
     * 
     */
    public Output<String> machineType() {
        return this.machineType;
    }

    /**
     * When to performance updates on the nodes, in 24-hour time
     * 
     */
    @Import(name="maintenanceWindow", required=true)
    private Output<String> maintenanceWindow;

    /**
     * @return When to performance updates on the nodes, in 24-hour time
     * 
     */
    public Output<String> maintenanceWindow() {
        return this.maintenanceWindow;
    }

    /**
     * Define up to 10 external networks that could access Kubernetes master through HTTPS
     * 
     */
    @Import(name="masterAuthorizedNetworkCidrBlocks")
    private @Nullable Output<List<String>> masterAuthorizedNetworkCidrBlocks;

    /**
     * @return Define up to 10 external networks that could access Kubernetes master through HTTPS
     * 
     */
    public Optional<Output<List<String>>> masterAuthorizedNetworkCidrBlocks() {
        return Optional.ofNullable(this.masterAuthorizedNetworkCidrBlocks);
    }

    /**
     * The IP range in CIDR notation to use for the hosted master network
     * 
     */
    @Import(name="masterIpv4CidrBlock", required=true)
    private Output<String> masterIpv4CidrBlock;

    /**
     * @return The IP range in CIDR notation to use for the hosted master network
     * 
     */
    public Output<String> masterIpv4CidrBlock() {
        return this.masterIpv4CidrBlock;
    }

    /**
     * The kubernetes master version
     * 
     */
    @Import(name="masterVersion", required=true)
    private Output<String> masterVersion;

    /**
     * @return The kubernetes master version
     * 
     */
    public Output<String> masterVersion() {
        return this.masterVersion;
    }

    /**
     * Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
     * 
     */
    @Import(name="maxNodeCount")
    private @Nullable Output<Integer> maxNodeCount;

    /**
     * @return Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
     * 
     */
    public Optional<Output<Integer>> maxNodeCount() {
        return Optional.ofNullable(this.maxNodeCount);
    }

    /**
     * Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
     * 
     */
    @Import(name="minNodeCount")
    private @Nullable Output<Integer> minNodeCount;

    /**
     * @return Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
     * 
     */
    public Optional<Output<Integer>> minNodeCount() {
        return Optional.ofNullable(this.minNodeCount);
    }

    /**
     * The network to use for the cluster
     * 
     */
    @Import(name="network", required=true)
    private Output<String> network;

    /**
     * @return The network to use for the cluster
     * 
     */
    public Output<String> network() {
        return this.network;
    }

    /**
     * The number of nodes to create in this cluster
     * 
     */
    @Import(name="nodeCount")
    private @Nullable Output<Integer> nodeCount;

    /**
     * @return The number of nodes to create in this cluster
     * 
     */
    public Optional<Output<Integer>> nodeCount() {
        return Optional.ofNullable(this.nodeCount);
    }

    /**
     * The ID of the cluster node pool
     * 
     */
    @Import(name="nodePool", required=true)
    private Output<String> nodePool;

    /**
     * @return The ID of the cluster node pool
     * 
     */
    public Output<String> nodePool() {
        return this.nodePool;
    }

    /**
     * The version of kubernetes to use on the nodes
     * 
     */
    @Import(name="nodeVersion", required=true)
    private Output<String> nodeVersion;

    /**
     * @return The version of kubernetes to use on the nodes
     * 
     */
    public Output<String> nodeVersion() {
        return this.nodeVersion;
    }

    /**
     * The set of Google API scopes to be made available on all of the node VMs under the default service account
     * 
     */
    @Import(name="oauthScopes", required=true)
    private Output<List<String>> oauthScopes;

    /**
     * @return The set of Google API scopes to be made available on all of the node VMs under the default service account
     * 
     */
    public Output<List<String>> oauthScopes() {
        return this.oauthScopes;
    }

    /**
     * Whether the nodes are created as preemptible VM instances
     * 
     */
    @Import(name="preemptible")
    private @Nullable Output<Boolean> preemptible;

    /**
     * @return Whether the nodes are created as preemptible VM instances
     * 
     */
    public Optional<Output<Boolean>> preemptible() {
        return Optional.ofNullable(this.preemptible);
    }

    /**
     * The ID of your project to use when creating a cluster
     * 
     */
    @Import(name="projectId", required=true)
    private Output<String> projectId;

    /**
     * @return The ID of your project to use when creating a cluster
     * 
     */
    public Output<String> projectId() {
        return this.projectId;
    }

    /**
     * The region to launch the cluster. Region or zone should be used
     * 
     */
    @Import(name="region")
    private @Nullable Output<String> region;

    /**
     * @return The region to launch the cluster. Region or zone should be used
     * 
     */
    public Optional<Output<String>> region() {
        return Optional.ofNullable(this.region);
    }

    /**
     * The map of Kubernetes labels (key/value pairs) to be applied to each cluster
     * 
     */
    @Import(name="resourceLabels")
    private @Nullable Output<Map<String,String>> resourceLabels;

    /**
     * @return The map of Kubernetes labels (key/value pairs) to be applied to each cluster
     * 
     */
    public Optional<Output<Map<String,String>>> resourceLabels() {
        return Optional.ofNullable(this.resourceLabels);
    }

    /**
     * The Google Cloud Platform Service Account to be used by the node VMs
     * 
     */
    @Import(name="serviceAccount", required=true)
    private Output<String> serviceAccount;

    /**
     * @return The Google Cloud Platform Service Account to be used by the node VMs
     * 
     */
    public Output<String> serviceAccount() {
        return this.serviceAccount;
    }

    /**
     * The sub-network to use for the cluster
     * 
     */
    @Import(name="subNetwork", required=true)
    private Output<String> subNetwork;

    /**
     * @return The sub-network to use for the cluster
     * 
     */
    public Output<String> subNetwork() {
        return this.subNetwork;
    }

    /**
     * List of kubernetes taints to be applied to each node
     * 
     */
    @Import(name="taints")
    private @Nullable Output<List<String>> taints;

    /**
     * @return List of kubernetes taints to be applied to each node
     * 
     */
    public Optional<Output<List<String>>> taints() {
        return Optional.ofNullable(this.taints);
    }

    /**
     * Whether alias IPs will be used for pod IPs in the cluster
     * 
     */
    @Import(name="useIpAliases")
    private @Nullable Output<Boolean> useIpAliases;

    /**
     * @return Whether alias IPs will be used for pod IPs in the cluster
     * 
     */
    public Optional<Output<Boolean>> useIpAliases() {
        return Optional.ofNullable(this.useIpAliases);
    }

    /**
     * The zone to launch the cluster. Zone or region should be used
     * 
     */
    @Import(name="zone")
    private @Nullable Output<String> zone;

    /**
     * @return The zone to launch the cluster. Zone or region should be used
     * 
     */
    public Optional<Output<String>> zone() {
        return Optional.ofNullable(this.zone);
    }

    private ClusterGkeConfigArgs() {}

    private ClusterGkeConfigArgs(ClusterGkeConfigArgs $) {
        this.clusterIpv4Cidr = $.clusterIpv4Cidr;
        this.credential = $.credential;
        this.description = $.description;
        this.diskSizeGb = $.diskSizeGb;
        this.diskType = $.diskType;
        this.enableAlphaFeature = $.enableAlphaFeature;
        this.enableAutoRepair = $.enableAutoRepair;
        this.enableAutoUpgrade = $.enableAutoUpgrade;
        this.enableHorizontalPodAutoscaling = $.enableHorizontalPodAutoscaling;
        this.enableHttpLoadBalancing = $.enableHttpLoadBalancing;
        this.enableKubernetesDashboard = $.enableKubernetesDashboard;
        this.enableLegacyAbac = $.enableLegacyAbac;
        this.enableMasterAuthorizedNetwork = $.enableMasterAuthorizedNetwork;
        this.enableNetworkPolicyConfig = $.enableNetworkPolicyConfig;
        this.enableNodepoolAutoscaling = $.enableNodepoolAutoscaling;
        this.enablePrivateEndpoint = $.enablePrivateEndpoint;
        this.enablePrivateNodes = $.enablePrivateNodes;
        this.enableStackdriverLogging = $.enableStackdriverLogging;
        this.enableStackdriverMonitoring = $.enableStackdriverMonitoring;
        this.imageType = $.imageType;
        this.ipPolicyClusterIpv4CidrBlock = $.ipPolicyClusterIpv4CidrBlock;
        this.ipPolicyClusterSecondaryRangeName = $.ipPolicyClusterSecondaryRangeName;
        this.ipPolicyCreateSubnetwork = $.ipPolicyCreateSubnetwork;
        this.ipPolicyNodeIpv4CidrBlock = $.ipPolicyNodeIpv4CidrBlock;
        this.ipPolicyServicesIpv4CidrBlock = $.ipPolicyServicesIpv4CidrBlock;
        this.ipPolicyServicesSecondaryRangeName = $.ipPolicyServicesSecondaryRangeName;
        this.ipPolicySubnetworkName = $.ipPolicySubnetworkName;
        this.issueClientCertificate = $.issueClientCertificate;
        this.kubernetesDashboard = $.kubernetesDashboard;
        this.labels = $.labels;
        this.localSsdCount = $.localSsdCount;
        this.locations = $.locations;
        this.machineType = $.machineType;
        this.maintenanceWindow = $.maintenanceWindow;
        this.masterAuthorizedNetworkCidrBlocks = $.masterAuthorizedNetworkCidrBlocks;
        this.masterIpv4CidrBlock = $.masterIpv4CidrBlock;
        this.masterVersion = $.masterVersion;
        this.maxNodeCount = $.maxNodeCount;
        this.minNodeCount = $.minNodeCount;
        this.network = $.network;
        this.nodeCount = $.nodeCount;
        this.nodePool = $.nodePool;
        this.nodeVersion = $.nodeVersion;
        this.oauthScopes = $.oauthScopes;
        this.preemptible = $.preemptible;
        this.projectId = $.projectId;
        this.region = $.region;
        this.resourceLabels = $.resourceLabels;
        this.serviceAccount = $.serviceAccount;
        this.subNetwork = $.subNetwork;
        this.taints = $.taints;
        this.useIpAliases = $.useIpAliases;
        this.zone = $.zone;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ClusterGkeConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ClusterGkeConfigArgs $;

        public Builder() {
            $ = new ClusterGkeConfigArgs();
        }

        public Builder(ClusterGkeConfigArgs defaults) {
            $ = new ClusterGkeConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param clusterIpv4Cidr The IP address range of the container pods
         * 
         * @return builder
         * 
         */
        public Builder clusterIpv4Cidr(Output<String> clusterIpv4Cidr) {
            $.clusterIpv4Cidr = clusterIpv4Cidr;
            return this;
        }

        /**
         * @param clusterIpv4Cidr The IP address range of the container pods
         * 
         * @return builder
         * 
         */
        public Builder clusterIpv4Cidr(String clusterIpv4Cidr) {
            return clusterIpv4Cidr(Output.of(clusterIpv4Cidr));
        }

        /**
         * @param credential The contents of the GC credential file
         * 
         * @return builder
         * 
         */
        public Builder credential(Output<String> credential) {
            $.credential = credential;
            return this;
        }

        /**
         * @param credential The contents of the GC credential file
         * 
         * @return builder
         * 
         */
        public Builder credential(String credential) {
            return credential(Output.of(credential));
        }

        /**
         * @param description The description for Cluster (string)
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description for Cluster (string)
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param diskSizeGb Size of the disk attached to each node
         * 
         * @return builder
         * 
         */
        public Builder diskSizeGb(@Nullable Output<Integer> diskSizeGb) {
            $.diskSizeGb = diskSizeGb;
            return this;
        }

        /**
         * @param diskSizeGb Size of the disk attached to each node
         * 
         * @return builder
         * 
         */
        public Builder diskSizeGb(Integer diskSizeGb) {
            return diskSizeGb(Output.of(diskSizeGb));
        }

        /**
         * @param diskType Type of the disk attached to each node
         * 
         * @return builder
         * 
         */
        public Builder diskType(Output<String> diskType) {
            $.diskType = diskType;
            return this;
        }

        /**
         * @param diskType Type of the disk attached to each node
         * 
         * @return builder
         * 
         */
        public Builder diskType(String diskType) {
            return diskType(Output.of(diskType));
        }

        /**
         * @param enableAlphaFeature To enable kubernetes alpha feature
         * 
         * @return builder
         * 
         */
        public Builder enableAlphaFeature(@Nullable Output<Boolean> enableAlphaFeature) {
            $.enableAlphaFeature = enableAlphaFeature;
            return this;
        }

        /**
         * @param enableAlphaFeature To enable kubernetes alpha feature
         * 
         * @return builder
         * 
         */
        public Builder enableAlphaFeature(Boolean enableAlphaFeature) {
            return enableAlphaFeature(Output.of(enableAlphaFeature));
        }

        /**
         * @param enableAutoRepair Specifies whether the node auto-repair is enabled for the node pool
         * 
         * @return builder
         * 
         */
        public Builder enableAutoRepair(@Nullable Output<Boolean> enableAutoRepair) {
            $.enableAutoRepair = enableAutoRepair;
            return this;
        }

        /**
         * @param enableAutoRepair Specifies whether the node auto-repair is enabled for the node pool
         * 
         * @return builder
         * 
         */
        public Builder enableAutoRepair(Boolean enableAutoRepair) {
            return enableAutoRepair(Output.of(enableAutoRepair));
        }

        /**
         * @param enableAutoUpgrade Specifies whether node auto-upgrade is enabled for the node pool
         * 
         * @return builder
         * 
         */
        public Builder enableAutoUpgrade(@Nullable Output<Boolean> enableAutoUpgrade) {
            $.enableAutoUpgrade = enableAutoUpgrade;
            return this;
        }

        /**
         * @param enableAutoUpgrade Specifies whether node auto-upgrade is enabled for the node pool
         * 
         * @return builder
         * 
         */
        public Builder enableAutoUpgrade(Boolean enableAutoUpgrade) {
            return enableAutoUpgrade(Output.of(enableAutoUpgrade));
        }

        /**
         * @param enableHorizontalPodAutoscaling Enable horizontal pod autoscaling for the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableHorizontalPodAutoscaling(@Nullable Output<Boolean> enableHorizontalPodAutoscaling) {
            $.enableHorizontalPodAutoscaling = enableHorizontalPodAutoscaling;
            return this;
        }

        /**
         * @param enableHorizontalPodAutoscaling Enable horizontal pod autoscaling for the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableHorizontalPodAutoscaling(Boolean enableHorizontalPodAutoscaling) {
            return enableHorizontalPodAutoscaling(Output.of(enableHorizontalPodAutoscaling));
        }

        /**
         * @param enableHttpLoadBalancing Enable http load balancing for the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableHttpLoadBalancing(@Nullable Output<Boolean> enableHttpLoadBalancing) {
            $.enableHttpLoadBalancing = enableHttpLoadBalancing;
            return this;
        }

        /**
         * @param enableHttpLoadBalancing Enable http load balancing for the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableHttpLoadBalancing(Boolean enableHttpLoadBalancing) {
            return enableHttpLoadBalancing(Output.of(enableHttpLoadBalancing));
        }

        /**
         * @param enableKubernetesDashboard Whether to enable the kubernetes dashboard
         * 
         * @return builder
         * 
         */
        public Builder enableKubernetesDashboard(@Nullable Output<Boolean> enableKubernetesDashboard) {
            $.enableKubernetesDashboard = enableKubernetesDashboard;
            return this;
        }

        /**
         * @param enableKubernetesDashboard Whether to enable the kubernetes dashboard
         * 
         * @return builder
         * 
         */
        public Builder enableKubernetesDashboard(Boolean enableKubernetesDashboard) {
            return enableKubernetesDashboard(Output.of(enableKubernetesDashboard));
        }

        /**
         * @param enableLegacyAbac Whether to enable legacy abac on the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableLegacyAbac(@Nullable Output<Boolean> enableLegacyAbac) {
            $.enableLegacyAbac = enableLegacyAbac;
            return this;
        }

        /**
         * @param enableLegacyAbac Whether to enable legacy abac on the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableLegacyAbac(Boolean enableLegacyAbac) {
            return enableLegacyAbac(Output.of(enableLegacyAbac));
        }

        /**
         * @param enableMasterAuthorizedNetwork Whether or not master authorized network is enabled
         * 
         * @return builder
         * 
         */
        public Builder enableMasterAuthorizedNetwork(@Nullable Output<Boolean> enableMasterAuthorizedNetwork) {
            $.enableMasterAuthorizedNetwork = enableMasterAuthorizedNetwork;
            return this;
        }

        /**
         * @param enableMasterAuthorizedNetwork Whether or not master authorized network is enabled
         * 
         * @return builder
         * 
         */
        public Builder enableMasterAuthorizedNetwork(Boolean enableMasterAuthorizedNetwork) {
            return enableMasterAuthorizedNetwork(Output.of(enableMasterAuthorizedNetwork));
        }

        /**
         * @param enableNetworkPolicyConfig Enable network policy config for the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableNetworkPolicyConfig(@Nullable Output<Boolean> enableNetworkPolicyConfig) {
            $.enableNetworkPolicyConfig = enableNetworkPolicyConfig;
            return this;
        }

        /**
         * @param enableNetworkPolicyConfig Enable network policy config for the cluster
         * 
         * @return builder
         * 
         */
        public Builder enableNetworkPolicyConfig(Boolean enableNetworkPolicyConfig) {
            return enableNetworkPolicyConfig(Output.of(enableNetworkPolicyConfig));
        }

        /**
         * @param enableNodepoolAutoscaling Enable nodepool autoscaling
         * 
         * @return builder
         * 
         */
        public Builder enableNodepoolAutoscaling(@Nullable Output<Boolean> enableNodepoolAutoscaling) {
            $.enableNodepoolAutoscaling = enableNodepoolAutoscaling;
            return this;
        }

        /**
         * @param enableNodepoolAutoscaling Enable nodepool autoscaling
         * 
         * @return builder
         * 
         */
        public Builder enableNodepoolAutoscaling(Boolean enableNodepoolAutoscaling) {
            return enableNodepoolAutoscaling(Output.of(enableNodepoolAutoscaling));
        }

        /**
         * @param enablePrivateEndpoint Whether the master&#39;s internal IP address is used as the cluster endpoint
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateEndpoint(@Nullable Output<Boolean> enablePrivateEndpoint) {
            $.enablePrivateEndpoint = enablePrivateEndpoint;
            return this;
        }

        /**
         * @param enablePrivateEndpoint Whether the master&#39;s internal IP address is used as the cluster endpoint
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateEndpoint(Boolean enablePrivateEndpoint) {
            return enablePrivateEndpoint(Output.of(enablePrivateEndpoint));
        }

        /**
         * @param enablePrivateNodes Whether nodes have internal IP address only
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateNodes(@Nullable Output<Boolean> enablePrivateNodes) {
            $.enablePrivateNodes = enablePrivateNodes;
            return this;
        }

        /**
         * @param enablePrivateNodes Whether nodes have internal IP address only
         * 
         * @return builder
         * 
         */
        public Builder enablePrivateNodes(Boolean enablePrivateNodes) {
            return enablePrivateNodes(Output.of(enablePrivateNodes));
        }

        /**
         * @param enableStackdriverLogging Enable stackdriver logging
         * 
         * @return builder
         * 
         */
        public Builder enableStackdriverLogging(@Nullable Output<Boolean> enableStackdriverLogging) {
            $.enableStackdriverLogging = enableStackdriverLogging;
            return this;
        }

        /**
         * @param enableStackdriverLogging Enable stackdriver logging
         * 
         * @return builder
         * 
         */
        public Builder enableStackdriverLogging(Boolean enableStackdriverLogging) {
            return enableStackdriverLogging(Output.of(enableStackdriverLogging));
        }

        /**
         * @param enableStackdriverMonitoring Enable stackdriver monitoring
         * 
         * @return builder
         * 
         */
        public Builder enableStackdriverMonitoring(@Nullable Output<Boolean> enableStackdriverMonitoring) {
            $.enableStackdriverMonitoring = enableStackdriverMonitoring;
            return this;
        }

        /**
         * @param enableStackdriverMonitoring Enable stackdriver monitoring
         * 
         * @return builder
         * 
         */
        public Builder enableStackdriverMonitoring(Boolean enableStackdriverMonitoring) {
            return enableStackdriverMonitoring(Output.of(enableStackdriverMonitoring));
        }

        /**
         * @param imageType The image to use for the worker nodes
         * 
         * @return builder
         * 
         */
        public Builder imageType(Output<String> imageType) {
            $.imageType = imageType;
            return this;
        }

        /**
         * @param imageType The image to use for the worker nodes
         * 
         * @return builder
         * 
         */
        public Builder imageType(String imageType) {
            return imageType(Output.of(imageType));
        }

        /**
         * @param ipPolicyClusterIpv4CidrBlock The IP address range for the cluster pod IPs
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyClusterIpv4CidrBlock(Output<String> ipPolicyClusterIpv4CidrBlock) {
            $.ipPolicyClusterIpv4CidrBlock = ipPolicyClusterIpv4CidrBlock;
            return this;
        }

        /**
         * @param ipPolicyClusterIpv4CidrBlock The IP address range for the cluster pod IPs
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyClusterIpv4CidrBlock(String ipPolicyClusterIpv4CidrBlock) {
            return ipPolicyClusterIpv4CidrBlock(Output.of(ipPolicyClusterIpv4CidrBlock));
        }

        /**
         * @param ipPolicyClusterSecondaryRangeName The name of the secondary range to be used for the cluster CIDR block
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyClusterSecondaryRangeName(Output<String> ipPolicyClusterSecondaryRangeName) {
            $.ipPolicyClusterSecondaryRangeName = ipPolicyClusterSecondaryRangeName;
            return this;
        }

        /**
         * @param ipPolicyClusterSecondaryRangeName The name of the secondary range to be used for the cluster CIDR block
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyClusterSecondaryRangeName(String ipPolicyClusterSecondaryRangeName) {
            return ipPolicyClusterSecondaryRangeName(Output.of(ipPolicyClusterSecondaryRangeName));
        }

        /**
         * @param ipPolicyCreateSubnetwork Whether a new subnetwork will be created automatically for the cluster
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyCreateSubnetwork(@Nullable Output<Boolean> ipPolicyCreateSubnetwork) {
            $.ipPolicyCreateSubnetwork = ipPolicyCreateSubnetwork;
            return this;
        }

        /**
         * @param ipPolicyCreateSubnetwork Whether a new subnetwork will be created automatically for the cluster
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyCreateSubnetwork(Boolean ipPolicyCreateSubnetwork) {
            return ipPolicyCreateSubnetwork(Output.of(ipPolicyCreateSubnetwork));
        }

        /**
         * @param ipPolicyNodeIpv4CidrBlock The IP address range of the instance IPs in this cluster
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyNodeIpv4CidrBlock(Output<String> ipPolicyNodeIpv4CidrBlock) {
            $.ipPolicyNodeIpv4CidrBlock = ipPolicyNodeIpv4CidrBlock;
            return this;
        }

        /**
         * @param ipPolicyNodeIpv4CidrBlock The IP address range of the instance IPs in this cluster
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyNodeIpv4CidrBlock(String ipPolicyNodeIpv4CidrBlock) {
            return ipPolicyNodeIpv4CidrBlock(Output.of(ipPolicyNodeIpv4CidrBlock));
        }

        /**
         * @param ipPolicyServicesIpv4CidrBlock The IP address range of the services IPs in this cluster
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyServicesIpv4CidrBlock(Output<String> ipPolicyServicesIpv4CidrBlock) {
            $.ipPolicyServicesIpv4CidrBlock = ipPolicyServicesIpv4CidrBlock;
            return this;
        }

        /**
         * @param ipPolicyServicesIpv4CidrBlock The IP address range of the services IPs in this cluster
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyServicesIpv4CidrBlock(String ipPolicyServicesIpv4CidrBlock) {
            return ipPolicyServicesIpv4CidrBlock(Output.of(ipPolicyServicesIpv4CidrBlock));
        }

        /**
         * @param ipPolicyServicesSecondaryRangeName The name of the secondary range to be used for the services CIDR block
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyServicesSecondaryRangeName(Output<String> ipPolicyServicesSecondaryRangeName) {
            $.ipPolicyServicesSecondaryRangeName = ipPolicyServicesSecondaryRangeName;
            return this;
        }

        /**
         * @param ipPolicyServicesSecondaryRangeName The name of the secondary range to be used for the services CIDR block
         * 
         * @return builder
         * 
         */
        public Builder ipPolicyServicesSecondaryRangeName(String ipPolicyServicesSecondaryRangeName) {
            return ipPolicyServicesSecondaryRangeName(Output.of(ipPolicyServicesSecondaryRangeName));
        }

        /**
         * @param ipPolicySubnetworkName A custom subnetwork name to be used if createSubnetwork is true
         * 
         * @return builder
         * 
         */
        public Builder ipPolicySubnetworkName(Output<String> ipPolicySubnetworkName) {
            $.ipPolicySubnetworkName = ipPolicySubnetworkName;
            return this;
        }

        /**
         * @param ipPolicySubnetworkName A custom subnetwork name to be used if createSubnetwork is true
         * 
         * @return builder
         * 
         */
        public Builder ipPolicySubnetworkName(String ipPolicySubnetworkName) {
            return ipPolicySubnetworkName(Output.of(ipPolicySubnetworkName));
        }

        /**
         * @param issueClientCertificate Issue a client certificate
         * 
         * @return builder
         * 
         */
        public Builder issueClientCertificate(@Nullable Output<Boolean> issueClientCertificate) {
            $.issueClientCertificate = issueClientCertificate;
            return this;
        }

        /**
         * @param issueClientCertificate Issue a client certificate
         * 
         * @return builder
         * 
         */
        public Builder issueClientCertificate(Boolean issueClientCertificate) {
            return issueClientCertificate(Output.of(issueClientCertificate));
        }

        /**
         * @param kubernetesDashboard Enable the kubernetes dashboard
         * 
         * @return builder
         * 
         */
        public Builder kubernetesDashboard(@Nullable Output<Boolean> kubernetesDashboard) {
            $.kubernetesDashboard = kubernetesDashboard;
            return this;
        }

        /**
         * @param kubernetesDashboard Enable the kubernetes dashboard
         * 
         * @return builder
         * 
         */
        public Builder kubernetesDashboard(Boolean kubernetesDashboard) {
            return kubernetesDashboard(Output.of(kubernetesDashboard));
        }

        /**
         * @param labels Labels for the Cluster (map)
         * 
         * @return builder
         * 
         */
        public Builder labels(@Nullable Output<Map<String,String>> labels) {
            $.labels = labels;
            return this;
        }

        /**
         * @param labels Labels for the Cluster (map)
         * 
         * @return builder
         * 
         */
        public Builder labels(Map<String,String> labels) {
            return labels(Output.of(labels));
        }

        /**
         * @param localSsdCount The number of local SSD disks to be attached to the node
         * 
         * @return builder
         * 
         */
        public Builder localSsdCount(@Nullable Output<Integer> localSsdCount) {
            $.localSsdCount = localSsdCount;
            return this;
        }

        /**
         * @param localSsdCount The number of local SSD disks to be attached to the node
         * 
         * @return builder
         * 
         */
        public Builder localSsdCount(Integer localSsdCount) {
            return localSsdCount(Output.of(localSsdCount));
        }

        /**
         * @param locations Locations to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder locations(Output<List<String>> locations) {
            $.locations = locations;
            return this;
        }

        /**
         * @param locations Locations to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder locations(List<String> locations) {
            return locations(Output.of(locations));
        }

        /**
         * @param locations Locations to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder locations(String... locations) {
            return locations(List.of(locations));
        }

        /**
         * @param machineType The machine type to use for the worker nodes
         * 
         * @return builder
         * 
         */
        public Builder machineType(Output<String> machineType) {
            $.machineType = machineType;
            return this;
        }

        /**
         * @param machineType The machine type to use for the worker nodes
         * 
         * @return builder
         * 
         */
        public Builder machineType(String machineType) {
            return machineType(Output.of(machineType));
        }

        /**
         * @param maintenanceWindow When to performance updates on the nodes, in 24-hour time
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindow(Output<String> maintenanceWindow) {
            $.maintenanceWindow = maintenanceWindow;
            return this;
        }

        /**
         * @param maintenanceWindow When to performance updates on the nodes, in 24-hour time
         * 
         * @return builder
         * 
         */
        public Builder maintenanceWindow(String maintenanceWindow) {
            return maintenanceWindow(Output.of(maintenanceWindow));
        }

        /**
         * @param masterAuthorizedNetworkCidrBlocks Define up to 10 external networks that could access Kubernetes master through HTTPS
         * 
         * @return builder
         * 
         */
        public Builder masterAuthorizedNetworkCidrBlocks(@Nullable Output<List<String>> masterAuthorizedNetworkCidrBlocks) {
            $.masterAuthorizedNetworkCidrBlocks = masterAuthorizedNetworkCidrBlocks;
            return this;
        }

        /**
         * @param masterAuthorizedNetworkCidrBlocks Define up to 10 external networks that could access Kubernetes master through HTTPS
         * 
         * @return builder
         * 
         */
        public Builder masterAuthorizedNetworkCidrBlocks(List<String> masterAuthorizedNetworkCidrBlocks) {
            return masterAuthorizedNetworkCidrBlocks(Output.of(masterAuthorizedNetworkCidrBlocks));
        }

        /**
         * @param masterAuthorizedNetworkCidrBlocks Define up to 10 external networks that could access Kubernetes master through HTTPS
         * 
         * @return builder
         * 
         */
        public Builder masterAuthorizedNetworkCidrBlocks(String... masterAuthorizedNetworkCidrBlocks) {
            return masterAuthorizedNetworkCidrBlocks(List.of(masterAuthorizedNetworkCidrBlocks));
        }

        /**
         * @param masterIpv4CidrBlock The IP range in CIDR notation to use for the hosted master network
         * 
         * @return builder
         * 
         */
        public Builder masterIpv4CidrBlock(Output<String> masterIpv4CidrBlock) {
            $.masterIpv4CidrBlock = masterIpv4CidrBlock;
            return this;
        }

        /**
         * @param masterIpv4CidrBlock The IP range in CIDR notation to use for the hosted master network
         * 
         * @return builder
         * 
         */
        public Builder masterIpv4CidrBlock(String masterIpv4CidrBlock) {
            return masterIpv4CidrBlock(Output.of(masterIpv4CidrBlock));
        }

        /**
         * @param masterVersion The kubernetes master version
         * 
         * @return builder
         * 
         */
        public Builder masterVersion(Output<String> masterVersion) {
            $.masterVersion = masterVersion;
            return this;
        }

        /**
         * @param masterVersion The kubernetes master version
         * 
         * @return builder
         * 
         */
        public Builder masterVersion(String masterVersion) {
            return masterVersion(Output.of(masterVersion));
        }

        /**
         * @param maxNodeCount Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
         * 
         * @return builder
         * 
         */
        public Builder maxNodeCount(@Nullable Output<Integer> maxNodeCount) {
            $.maxNodeCount = maxNodeCount;
            return this;
        }

        /**
         * @param maxNodeCount Maximum number of nodes in the NodePool. Must be &gt;= minNodeCount. There has to enough quota to scale up the cluster
         * 
         * @return builder
         * 
         */
        public Builder maxNodeCount(Integer maxNodeCount) {
            return maxNodeCount(Output.of(maxNodeCount));
        }

        /**
         * @param minNodeCount Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
         * 
         * @return builder
         * 
         */
        public Builder minNodeCount(@Nullable Output<Integer> minNodeCount) {
            $.minNodeCount = minNodeCount;
            return this;
        }

        /**
         * @param minNodeCount Minimmum number of nodes in the NodePool. Must be &gt;= 1 and &lt;= maxNodeCount
         * 
         * @return builder
         * 
         */
        public Builder minNodeCount(Integer minNodeCount) {
            return minNodeCount(Output.of(minNodeCount));
        }

        /**
         * @param network The network to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder network(Output<String> network) {
            $.network = network;
            return this;
        }

        /**
         * @param network The network to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder network(String network) {
            return network(Output.of(network));
        }

        /**
         * @param nodeCount The number of nodes to create in this cluster
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(@Nullable Output<Integer> nodeCount) {
            $.nodeCount = nodeCount;
            return this;
        }

        /**
         * @param nodeCount The number of nodes to create in this cluster
         * 
         * @return builder
         * 
         */
        public Builder nodeCount(Integer nodeCount) {
            return nodeCount(Output.of(nodeCount));
        }

        /**
         * @param nodePool The ID of the cluster node pool
         * 
         * @return builder
         * 
         */
        public Builder nodePool(Output<String> nodePool) {
            $.nodePool = nodePool;
            return this;
        }

        /**
         * @param nodePool The ID of the cluster node pool
         * 
         * @return builder
         * 
         */
        public Builder nodePool(String nodePool) {
            return nodePool(Output.of(nodePool));
        }

        /**
         * @param nodeVersion The version of kubernetes to use on the nodes
         * 
         * @return builder
         * 
         */
        public Builder nodeVersion(Output<String> nodeVersion) {
            $.nodeVersion = nodeVersion;
            return this;
        }

        /**
         * @param nodeVersion The version of kubernetes to use on the nodes
         * 
         * @return builder
         * 
         */
        public Builder nodeVersion(String nodeVersion) {
            return nodeVersion(Output.of(nodeVersion));
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available on all of the node VMs under the default service account
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(Output<List<String>> oauthScopes) {
            $.oauthScopes = oauthScopes;
            return this;
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available on all of the node VMs under the default service account
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(List<String> oauthScopes) {
            return oauthScopes(Output.of(oauthScopes));
        }

        /**
         * @param oauthScopes The set of Google API scopes to be made available on all of the node VMs under the default service account
         * 
         * @return builder
         * 
         */
        public Builder oauthScopes(String... oauthScopes) {
            return oauthScopes(List.of(oauthScopes));
        }

        /**
         * @param preemptible Whether the nodes are created as preemptible VM instances
         * 
         * @return builder
         * 
         */
        public Builder preemptible(@Nullable Output<Boolean> preemptible) {
            $.preemptible = preemptible;
            return this;
        }

        /**
         * @param preemptible Whether the nodes are created as preemptible VM instances
         * 
         * @return builder
         * 
         */
        public Builder preemptible(Boolean preemptible) {
            return preemptible(Output.of(preemptible));
        }

        /**
         * @param projectId The ID of your project to use when creating a cluster
         * 
         * @return builder
         * 
         */
        public Builder projectId(Output<String> projectId) {
            $.projectId = projectId;
            return this;
        }

        /**
         * @param projectId The ID of your project to use when creating a cluster
         * 
         * @return builder
         * 
         */
        public Builder projectId(String projectId) {
            return projectId(Output.of(projectId));
        }

        /**
         * @param region The region to launch the cluster. Region or zone should be used
         * 
         * @return builder
         * 
         */
        public Builder region(@Nullable Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region The region to launch the cluster. Region or zone should be used
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param resourceLabels The map of Kubernetes labels (key/value pairs) to be applied to each cluster
         * 
         * @return builder
         * 
         */
        public Builder resourceLabels(@Nullable Output<Map<String,String>> resourceLabels) {
            $.resourceLabels = resourceLabels;
            return this;
        }

        /**
         * @param resourceLabels The map of Kubernetes labels (key/value pairs) to be applied to each cluster
         * 
         * @return builder
         * 
         */
        public Builder resourceLabels(Map<String,String> resourceLabels) {
            return resourceLabels(Output.of(resourceLabels));
        }

        /**
         * @param serviceAccount The Google Cloud Platform Service Account to be used by the node VMs
         * 
         * @return builder
         * 
         */
        public Builder serviceAccount(Output<String> serviceAccount) {
            $.serviceAccount = serviceAccount;
            return this;
        }

        /**
         * @param serviceAccount The Google Cloud Platform Service Account to be used by the node VMs
         * 
         * @return builder
         * 
         */
        public Builder serviceAccount(String serviceAccount) {
            return serviceAccount(Output.of(serviceAccount));
        }

        /**
         * @param subNetwork The sub-network to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder subNetwork(Output<String> subNetwork) {
            $.subNetwork = subNetwork;
            return this;
        }

        /**
         * @param subNetwork The sub-network to use for the cluster
         * 
         * @return builder
         * 
         */
        public Builder subNetwork(String subNetwork) {
            return subNetwork(Output.of(subNetwork));
        }

        /**
         * @param taints List of kubernetes taints to be applied to each node
         * 
         * @return builder
         * 
         */
        public Builder taints(@Nullable Output<List<String>> taints) {
            $.taints = taints;
            return this;
        }

        /**
         * @param taints List of kubernetes taints to be applied to each node
         * 
         * @return builder
         * 
         */
        public Builder taints(List<String> taints) {
            return taints(Output.of(taints));
        }

        /**
         * @param taints List of kubernetes taints to be applied to each node
         * 
         * @return builder
         * 
         */
        public Builder taints(String... taints) {
            return taints(List.of(taints));
        }

        /**
         * @param useIpAliases Whether alias IPs will be used for pod IPs in the cluster
         * 
         * @return builder
         * 
         */
        public Builder useIpAliases(@Nullable Output<Boolean> useIpAliases) {
            $.useIpAliases = useIpAliases;
            return this;
        }

        /**
         * @param useIpAliases Whether alias IPs will be used for pod IPs in the cluster
         * 
         * @return builder
         * 
         */
        public Builder useIpAliases(Boolean useIpAliases) {
            return useIpAliases(Output.of(useIpAliases));
        }

        /**
         * @param zone The zone to launch the cluster. Zone or region should be used
         * 
         * @return builder
         * 
         */
        public Builder zone(@Nullable Output<String> zone) {
            $.zone = zone;
            return this;
        }

        /**
         * @param zone The zone to launch the cluster. Zone or region should be used
         * 
         * @return builder
         * 
         */
        public Builder zone(String zone) {
            return zone(Output.of(zone));
        }

        public ClusterGkeConfigArgs build() {
            if ($.clusterIpv4Cidr == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "clusterIpv4Cidr");
            }
            if ($.credential == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "credential");
            }
            if ($.diskType == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "diskType");
            }
            if ($.imageType == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "imageType");
            }
            if ($.ipPolicyClusterIpv4CidrBlock == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "ipPolicyClusterIpv4CidrBlock");
            }
            if ($.ipPolicyClusterSecondaryRangeName == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "ipPolicyClusterSecondaryRangeName");
            }
            if ($.ipPolicyNodeIpv4CidrBlock == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "ipPolicyNodeIpv4CidrBlock");
            }
            if ($.ipPolicyServicesIpv4CidrBlock == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "ipPolicyServicesIpv4CidrBlock");
            }
            if ($.ipPolicyServicesSecondaryRangeName == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "ipPolicyServicesSecondaryRangeName");
            }
            if ($.ipPolicySubnetworkName == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "ipPolicySubnetworkName");
            }
            if ($.locations == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "locations");
            }
            if ($.machineType == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "machineType");
            }
            if ($.maintenanceWindow == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "maintenanceWindow");
            }
            if ($.masterIpv4CidrBlock == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "masterIpv4CidrBlock");
            }
            if ($.masterVersion == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "masterVersion");
            }
            if ($.network == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "network");
            }
            if ($.nodePool == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "nodePool");
            }
            if ($.nodeVersion == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "nodeVersion");
            }
            if ($.oauthScopes == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "oauthScopes");
            }
            if ($.projectId == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "projectId");
            }
            if ($.serviceAccount == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "serviceAccount");
            }
            if ($.subNetwork == null) {
                throw new MissingRequiredPropertyException("ClusterGkeConfigArgs", "subNetwork");
            }
            return $;
        }
    }

}
